const __vite__mapDeps = (
    i,
    m = __vite__mapDeps,
    d = m.f ||
        (m.f = [
            "./browserAll-CSnNg6po.js",
            "./webworkerAll-Dusud6Lz.js",
            "./colorToUniform-BXaCBwVl.js",
            "./WebGPURenderer-dpsYrxgD.js",
            "./SharedSystems-DsUedaMB.js",
            "./WebGLRenderer-B4qgeFrM.js",
        ])
) => i.map((i) => d[i]);
var xS = Object.defineProperty;
var i0 = (s) => {
    throw TypeError(s);
};
var CS = (s, e, t) =>
    e in s
        ? xS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
        : (s[e] = t);
var x = (s, e, t) => CS(s, typeof e != "symbol" ? e + "" : e, t),
    Qd = (s, e, t) => e.has(s) || i0("Cannot " + t);
var ze = (s, e, t) => (
        Qd(s, e, "read from private field"), t ? t.call(s) : e.get(s)
    ),
    Bn = (s, e, t) =>
        e.has(s)
            ? i0("Cannot add the same private member more than once")
            : e instanceof WeakSet
            ? e.add(s)
            : e.set(s, t),
    ms = (s, e, t, n) => (
        Qd(s, e, "write to private field"), n ? n.call(s, t) : e.set(s, t), t
    ),
    Qr = (s, e, t) => (Qd(s, e, "access private method"), t);
(function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        n(i);
    new MutationObserver((i) => {
        for (const r of i)
            if (r.type === "childList")
                for (const a of r.addedNodes)
                    a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
    }).observe(document, { childList: !0, subtree: !0 });
    function t(i) {
        const r = {};
        return (
            i.integrity && (r.integrity = i.integrity),
            i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy),
            i.crossOrigin === "use-credentials"
                ? (r.credentials = "include")
                : i.crossOrigin === "anonymous"
                ? (r.credentials = "omit")
                : (r.credentials = "same-origin"),
            r
        );
    }
    function n(i) {
        if (i.ep) return;
        i.ep = !0;
        const r = t(i);
        fetch(i.href, r);
    }
})();
const Vy = !1;
var zm = Array.isArray,
    AS = Array.prototype.indexOf,
    Ym = Array.from,
    du = Object.defineProperty,
    ih = Object.getOwnPropertyDescriptor,
    Uy = Object.getOwnPropertyDescriptors,
    SS = Object.prototype,
    ES = Array.prototype,
    Gm = Object.getPrototypeOf,
    r0 = Object.isExtensible;
function PS(s) {
    return typeof s == "function";
}
const ts = () => {};
function jm(s) {
    for (var e = 0; e < s.length; e++) s[e]();
}
function kS() {
    var s,
        e,
        t = new Promise((n, i) => {
            (s = n), (e = i);
        });
    return { promise: t, resolve: s, reject: e };
}
const rs = 2,
    Wm = 4,
    ld = 8,
    ja = 16,
    lr = 32,
    Wa = 64,
    zy = 128,
    Ts = 256,
    fu = 512,
    pn = 1024,
    as = 2048,
    hr = 4096,
    js = 8192,
    ul = 16384,
    hd = 32768,
    cd = 65536,
    a0 = 1 << 17,
    TS = 1 << 18,
    ac = 1 << 19,
    Yy = 1 << 20,
    Ep = 1 << 21,
    Xm = 1 << 22,
    _a = 1 << 23,
    Eo = Symbol("$state"),
    qm = new (class extends Error {
        constructor() {
            super(...arguments);
            x(this, "name", "StaleReactionError");
            x(
                this,
                "message",
                "The reaction that called `getAbortSignal()` was re-run or destroyed"
            );
        }
    })();
function MS() {
    throw new Error("https://svelte.dev/e/await_outside_boundary");
}
function Gy(s) {
    throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function IS() {
    throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function RS(s) {
    throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function LS() {
    throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function OS(s) {
    throw new Error("https://svelte.dev/e/effect_orphan");
}
function BS() {
    throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function FS() {
    throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function $S() {
    throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function DS() {
    throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
const ud = 1,
    dd = 2,
    jy = 4,
    NS = 8,
    VS = 16,
    US = 1,
    zS = 2,
    YS = 4,
    GS = 1,
    jS = 2,
    nn = Symbol(),
    WS = "http://www.w3.org/1999/xhtml";
function XS(s) {
    console.warn("https://svelte.dev/e/legacy_recursive_reactive_block");
}
let qS = !1;
function Wy(s) {
    return s === this.v;
}
function Hm(s, e) {
    return s != s
        ? e == e
        : s !== e ||
              (s !== null && typeof s == "object") ||
              typeof s == "function";
}
function Xy(s) {
    return !Hm(s, this.v);
}
let HS = !1,
    os = null;
function pu(s) {
    os = s;
}
function Ne(s, e = !1, t) {
    os = { p: os, c: null, e: null, s, x: null, l: null };
}
function Ve(s) {
    var e = os,
        t = e.e;
    if (t !== null) {
        e.e = null;
        for (var n of t) cw(n);
    }
    return (os = e.p), {};
}
function qy() {
    return !0;
}
const KS = new WeakMap();
function ZS(s) {
    var e = Ie;
    if (e === null) return (Pe.f |= _a), s;
    if ((e.f & hd) === 0) {
        if ((e.f & zy) === 0)
            throw (!e.parent && s instanceof Error && Hy(s), s);
        e.b.error(s);
    } else Km(s, e);
}
function Km(s, e) {
    for (; e !== null; ) {
        if ((e.f & zy) !== 0)
            try {
                e.b.error(s);
                return;
            } catch (t) {
                s = t;
            }
        e = e.parent;
    }
    throw (s instanceof Error && Hy(s), s);
}
function Hy(s) {
    const e = KS.get(s);
    e &&
        (du(s, "message", { value: e.message }),
        du(s, "stack", { value: e.stack }));
}
let Sr = [],
    mu = [];
function Ky() {
    var s = Sr;
    (Sr = []), jm(s);
}
function QS() {
    var s = mu;
    (mu = []), jm(s);
}
function JS() {
    return Sr.length > 0 || mu.length > 0;
}
function oc(s) {
    if (Sr.length === 0 && !rh) {
        var e = Sr;
        queueMicrotask(() => {
            e === Sr && Ky();
        });
    }
    Sr.push(s);
}
function eE() {
    Sr.length > 0 && Ky(), mu.length > 0 && QS();
}
function tE() {
    const s = Ie.b;
    return s === null && MS(), s;
}
function Zm(s) {
    var e = rs | as,
        t = Pe !== null && (Pe.f & rs) !== 0 ? Pe : null;
    return (
        Ie === null || (t !== null && (t.f & Ts) !== 0)
            ? (e |= Ts)
            : (Ie.f |= ac),
        {
            ctx: os,
            deps: null,
            effects: null,
            equals: Wy,
            f: e,
            fn: s,
            reactions: null,
            rv: 0,
            v: nn,
            wv: 0,
            parent: t ?? Ie,
            ac: null,
        }
    );
}
function nE(s, e) {
    let t = Ie;
    t === null && IS();
    var n = t.b,
        i = void 0,
        r = bh(nn),
        a = null,
        o = !Pe;
    return (
        gE(() => {
            try {
                var h = s();
                a && Promise.resolve(h).catch(() => {});
            } catch (f) {
                h = Promise.reject(f);
            }
            var l = () => h;
            (i = (a == null ? void 0 : a.then(l, l)) ?? Promise.resolve(h)),
                (a = i);
            var u = ht,
                c = n.is_pending();
            o && (n.update_pending_count(1), c || u.increment());
            const d = (f, p = void 0) => {
                (a = null),
                    c || u.activate(),
                    p
                        ? p !== qm && ((r.f |= _a), yh(r, p))
                        : ((r.f & _a) !== 0 && (r.f ^= _a), yh(r, f)),
                    o && (n.update_pending_count(-1), c || u.decrement()),
                    Jy();
            };
            if ((i.then(d, (f) => d(null, f || "unknown")), u))
                return () => {
                    queueMicrotask(() => u.neuter());
                };
        }),
        new Promise((h) => {
            function l(u) {
                function c() {
                    u === i ? h(r) : l(i);
                }
                u.then(c, c);
            }
            l(i);
        })
    );
}
function Me(s) {
    const e = Zm(s);
    return _w(e), e;
}
function sE(s) {
    const e = Zm(s);
    return (e.equals = Xy), e;
}
function Zy(s) {
    var e = s.effects;
    if (e !== null) {
        s.effects = null;
        for (var t = 0; t < e.length; t += 1) tr(e[t]);
    }
}
function iE(s) {
    for (var e = s.parent; e !== null; ) {
        if ((e.f & rs) === 0) return e;
        e = e.parent;
    }
    return null;
}
function Qm(s) {
    var e,
        t = Ie;
    Ur(iE(s));
    try {
        Zy(s), (e = ww(s));
    } finally {
        Ur(t);
    }
    return e;
}
function Qy(s) {
    var e = Qm(s);
    if ((s.equals(e) || ((s.v = e), (s.wv = bw())), !pl)) {
        var t = (Er || (s.f & Ts) !== 0) && s.deps !== null ? hr : pn;
        Pn(s, t);
    }
}
function rE(s, e, t) {
    const n = Zm;
    if (e.length === 0) {
        t(s.map(n));
        return;
    }
    var i = ht,
        r = Ie,
        a = aE(),
        o = tE();
    Promise.all(e.map((h) => nE(h)))
        .then((h) => {
            i == null || i.activate(), a();
            try {
                t([...s.map(n), ...h]);
            } catch (l) {
                (r.f & ul) === 0 && Km(l, r);
            }
            i == null || i.deactivate(), Jy();
        })
        .catch((h) => {
            o.error(h);
        });
}
function aE() {
    var s = Ie,
        e = Pe,
        t = os,
        n = ht;
    return function () {
        Ur(s), Ai(e), pu(t), n == null || n.activate();
    };
}
function Jy() {
    Ur(null), Ai(null), pu(null);
}
const Jd = new Set();
let ht = null,
    Hc = null,
    o0 = new Set(),
    Ma = [],
    fd = null,
    Pp = !1,
    rh = !1;
var tc, Yo, Cr, nc, sc, ma, Go, ga, Ar, jo, ic, rc, qs, ew, Kc, kp, Ta;
let Jm =
    ((Ta = class {
        constructor() {
            Bn(this, qs);
            x(this, "current", new Map());
            Bn(this, tc, new Map());
            Bn(this, Yo, new Set());
            Bn(this, Cr, 0);
            Bn(this, nc, null);
            Bn(this, sc, !1);
            Bn(this, ma, []);
            Bn(this, Go, []);
            Bn(this, ga, []);
            Bn(this, Ar, []);
            Bn(this, jo, []);
            Bn(this, ic, []);
            Bn(this, rc, []);
            x(this, "skipped_effects", new Set());
        }
        process(e) {
            var i;
            (Ma = []), (Hc = null);
            for (const r of e) Qr(this, qs, ew).call(this, r);
            if (ze(this, ma).length === 0 && ze(this, Cr) === 0) {
                Qr(this, qs, kp).call(this);
                var t = ze(this, ga),
                    n = ze(this, Ar);
                ms(this, ga, []),
                    ms(this, Ar, []),
                    ms(this, jo, []),
                    (Hc = ht),
                    (ht = null),
                    l0(t),
                    l0(n),
                    ht === null ? (ht = this) : Jd.delete(this),
                    (i = ze(this, nc)) == null || i.resolve();
            } else
                Qr(this, qs, Kc).call(this, ze(this, ga)),
                    Qr(this, qs, Kc).call(this, ze(this, Ar)),
                    Qr(this, qs, Kc).call(this, ze(this, jo));
            for (const r of ze(this, ma)) ko(r);
            for (const r of ze(this, Go)) ko(r);
            ms(this, ma, []), ms(this, Go, []);
        }
        capture(e, t) {
            ze(this, tc).has(e) || ze(this, tc).set(e, t),
                this.current.set(e, e.v);
        }
        activate() {
            ht = this;
        }
        deactivate() {
            (ht = null), (Hc = null);
            for (const e of o0) if ((o0.delete(e), e(), ht !== null)) break;
        }
        neuter() {
            ms(this, sc, !0);
        }
        flush() {
            Ma.length > 0 ? tw() : Qr(this, qs, kp).call(this),
                ht === this &&
                    (ze(this, Cr) === 0 && Jd.delete(this), this.deactivate());
        }
        increment() {
            ms(this, Cr, ze(this, Cr) + 1);
        }
        decrement() {
            if ((ms(this, Cr, ze(this, Cr) - 1), ze(this, Cr) === 0)) {
                for (const e of ze(this, ic)) Pn(e, as), Wo(e);
                for (const e of ze(this, rc)) Pn(e, hr), Wo(e);
                ms(this, ga, []), ms(this, Ar, []), this.flush();
            } else this.deactivate();
        }
        add_callback(e) {
            ze(this, Yo).add(e);
        }
        settled() {
            return (ze(this, nc) ?? ms(this, nc, kS())).promise;
        }
        static ensure() {
            if (ht === null) {
                const e = (ht = new Ta());
                Jd.add(ht),
                    rh ||
                        Ta.enqueue(() => {
                            ht === e && e.flush();
                        });
            }
            return ht;
        }
        static enqueue(e) {
            oc(e);
        }
    }),
    (tc = new WeakMap()),
    (Yo = new WeakMap()),
    (Cr = new WeakMap()),
    (nc = new WeakMap()),
    (sc = new WeakMap()),
    (ma = new WeakMap()),
    (Go = new WeakMap()),
    (ga = new WeakMap()),
    (Ar = new WeakMap()),
    (jo = new WeakMap()),
    (ic = new WeakMap()),
    (rc = new WeakMap()),
    (qs = new WeakSet()),
    (ew = function (e) {
        var u;
        e.f ^= pn;
        for (var t = e.first; t !== null; ) {
            var n = t.f,
                i = (n & (lr | Wa)) !== 0,
                r = i && (n & pn) !== 0,
                a = r || (n & js) !== 0 || this.skipped_effects.has(t);
            if (!a && t.fn !== null) {
                if (i) t.f ^= pn;
                else if ((n & Wm) !== 0) ze(this, Ar).push(t);
                else if ((n & pn) === 0)
                    if ((n & Xm) !== 0) {
                        var o =
                            (u = t.b) != null && u.is_pending()
                                ? ze(this, Go)
                                : ze(this, ma);
                        o.push(t);
                    } else
                        md(t) &&
                            ((t.f & ja) !== 0 && ze(this, jo).push(t), ko(t));
                var h = t.first;
                if (h !== null) {
                    t = h;
                    continue;
                }
            }
            var l = t.parent;
            for (t = t.next; t === null && l !== null; )
                (t = l.next), (l = l.parent);
        }
    }),
    (Kc = function (e) {
        for (const t of e)
            ((t.f & as) !== 0 ? ze(this, ic) : ze(this, rc)).push(t), Pn(t, pn);
        e.length = 0;
    }),
    (kp = function () {
        if (!ze(this, sc)) for (const e of ze(this, Yo)) e();
        ze(this, Yo).clear();
    }),
    Ta);
function oE(s) {
    var e = rh;
    rh = !0;
    try {
        for (var t; ; ) {
            if (
                (eE(),
                Ma.length === 0 &&
                    !JS() &&
                    (ht == null || ht.flush(), Ma.length === 0))
            )
                return (fd = null), t;
            tw();
        }
    } finally {
        rh = e;
    }
}
function tw() {
    var s = Po;
    Pp = !0;
    try {
        var e = 0;
        for (c0(!0); Ma.length > 0; ) {
            var t = Jm.ensure();
            if (e++ > 1e3) {
                var n, i;
                lE();
            }
            t.process(Ma), Fr.clear();
        }
    } finally {
        (Pp = !1), c0(s), (fd = null);
    }
}
function lE() {
    try {
        BS();
    } catch (s) {
        Km(s, fd);
    }
}
let zi = null;
function l0(s) {
    var e = s.length;
    if (e !== 0) {
        for (var t = 0; t < e; ) {
            var n = s[t++];
            if (
                (n.f & (ul | js)) === 0 &&
                md(n) &&
                ((zi = []),
                ko(n),
                n.deps === null &&
                    n.first === null &&
                    n.nodes_start === null &&
                    (n.teardown === null && n.ac === null
                        ? pw(n)
                        : (n.fn = null)),
                (zi == null ? void 0 : zi.length) > 0)
            ) {
                Fr.clear();
                for (const i of zi) ko(i);
                zi = [];
            }
        }
        zi = null;
    }
}
function Wo(s) {
    for (var e = (fd = s); e.parent !== null; ) {
        e = e.parent;
        var t = e.f;
        if (Pp && e === Ie && (t & ja) !== 0) return;
        if ((t & (Wa | lr)) !== 0) {
            if ((t & pn) === 0) return;
            e.f ^= pn;
        }
    }
    Ma.push(e);
}
const Fr = new Map();
function bh(s, e) {
    var t = { f: 0, v: s, reactions: null, equals: Wy, rv: 0, wv: 0 };
    return t;
}
function gt(s, e) {
    const t = bh(s);
    return _w(t), t;
}
function nw(s, e = !1, t = !0) {
    const n = bh(s);
    return e || (n.equals = Xy), n;
}
function Re(s, e, t = !1) {
    Pe !== null &&
        (!pi || (Pe.f & a0) !== 0) &&
        qy() &&
        (Pe.f & (rs | ja | Xm | a0)) !== 0 &&
        !(En != null && En.includes(s)) &&
        DS();
    let n = t ? rn(e) : e;
    return yh(s, n);
}
function yh(s, e) {
    if (!s.equals(e)) {
        var t = s.v;
        pl ? Fr.set(s, e) : Fr.set(s, t), (s.v = e);
        var n = Jm.ensure();
        n.capture(s, t),
            (s.f & rs) !== 0 &&
                ((s.f & as) !== 0 && Qm(s), Pn(s, (s.f & Ts) === 0 ? pn : hr)),
            (s.wv = bw()),
            sw(s, as),
            Ie !== null &&
                (Ie.f & pn) !== 0 &&
                (Ie.f & (lr | Wa)) === 0 &&
                (ws === null ? bE([s]) : ws.push(s));
    }
    return e;
}
function ef(s) {
    Re(s, s.v + 1);
}
function sw(s, e) {
    var t = s.reactions;
    if (t !== null)
        for (var n = t.length, i = 0; i < n; i++) {
            var r = t[i],
                a = r.f,
                o = (a & as) === 0;
            o && Pn(r, e),
                (a & rs) !== 0
                    ? sw(r, hr)
                    : o && ((a & ja) !== 0 && zi !== null && zi.push(r), Wo(r));
        }
}
function rn(s) {
    if (typeof s != "object" || s === null || Eo in s) return s;
    const e = Gm(s);
    if (e !== SS && e !== ES) return s;
    var t = new Map(),
        n = zm(s),
        i = gt(0),
        r = va,
        a = (o) => {
            if (va === r) return o();
            var h = Pe,
                l = va;
            Ai(null), d0(r);
            var u = o();
            return Ai(h), d0(l), u;
        };
    return (
        n && t.set("length", gt(s.length)),
        new Proxy(s, {
            defineProperty(o, h, l) {
                (!("value" in l) ||
                    l.configurable === !1 ||
                    l.enumerable === !1 ||
                    l.writable === !1) &&
                    FS();
                var u = t.get(h);
                return (
                    u === void 0
                        ? (u = a(() => {
                              var c = gt(l.value);
                              return t.set(h, c), c;
                          }))
                        : Re(u, l.value, !0),
                    !0
                );
            },
            deleteProperty(o, h) {
                var l = t.get(h);
                if (l === void 0) {
                    if (h in o) {
                        const u = a(() => gt(nn));
                        t.set(h, u), ef(i);
                    }
                } else Re(l, nn), ef(i);
                return !0;
            },
            get(o, h, l) {
                var f;
                if (h === Eo) return s;
                var u = t.get(h),
                    c = h in o;
                if (
                    (u === void 0 &&
                        (!c || ((f = ih(o, h)) != null && f.writable)) &&
                        ((u = a(() => {
                            var p = rn(c ? o[h] : nn),
                                m = gt(p);
                            return m;
                        })),
                        t.set(h, u)),
                    u !== void 0)
                ) {
                    var d = $(u);
                    return d === nn ? void 0 : d;
                }
                return Reflect.get(o, h, l);
            },
            getOwnPropertyDescriptor(o, h) {
                var l = Reflect.getOwnPropertyDescriptor(o, h);
                if (l && "value" in l) {
                    var u = t.get(h);
                    u && (l.value = $(u));
                } else if (l === void 0) {
                    var c = t.get(h),
                        d = c == null ? void 0 : c.v;
                    if (c !== void 0 && d !== nn)
                        return {
                            enumerable: !0,
                            configurable: !0,
                            value: d,
                            writable: !0,
                        };
                }
                return l;
            },
            has(o, h) {
                var d;
                if (h === Eo) return !0;
                var l = t.get(h),
                    u = (l !== void 0 && l.v !== nn) || Reflect.has(o, h);
                if (
                    l !== void 0 ||
                    (Ie !== null &&
                        (!u || ((d = ih(o, h)) != null && d.writable)))
                ) {
                    l === void 0 &&
                        ((l = a(() => {
                            var f = u ? rn(o[h]) : nn,
                                p = gt(f);
                            return p;
                        })),
                        t.set(h, l));
                    var c = $(l);
                    if (c === nn) return !1;
                }
                return u;
            },
            set(o, h, l, u) {
                var b;
                var c = t.get(h),
                    d = h in o;
                if (n && h === "length")
                    for (var f = l; f < c.v; f += 1) {
                        var p = t.get(f + "");
                        p !== void 0
                            ? Re(p, nn)
                            : f in o &&
                              ((p = a(() => gt(nn))), t.set(f + "", p));
                    }
                if (c === void 0)
                    (!d || ((b = ih(o, h)) != null && b.writable)) &&
                        ((c = a(() => gt(void 0))), Re(c, rn(l)), t.set(h, c));
                else {
                    d = c.v !== nn;
                    var m = a(() => rn(l));
                    Re(c, m);
                }
                var g = Reflect.getOwnPropertyDescriptor(o, h);
                if ((g != null && g.set && g.set.call(u, l), !d)) {
                    if (n && typeof h == "string") {
                        var _ = t.get("length"),
                            v = Number(h);
                        Number.isInteger(v) && v >= _.v && Re(_, v + 1);
                    }
                    ef(i);
                }
                return !0;
            },
            ownKeys(o) {
                $(i);
                var h = Reflect.ownKeys(o).filter((c) => {
                    var d = t.get(c);
                    return d === void 0 || d.v !== nn;
                });
                for (var [l, u] of t) u.v !== nn && !(l in o) && h.push(l);
                return h;
            },
            setPrototypeOf() {
                $S();
            },
        })
    );
}
var wh, iw, rw, aw;
function hE() {
    if (wh === void 0) {
        (wh = window), (iw = /Firefox/.test(navigator.userAgent));
        var s = Element.prototype,
            e = Node.prototype,
            t = Text.prototype;
        (rw = ih(e, "firstChild").get),
            (aw = ih(e, "nextSibling").get),
            r0(s) &&
                ((s.__click = void 0),
                (s.__className = void 0),
                (s.__attributes = null),
                (s.__style = void 0),
                (s.__e = void 0)),
            r0(t) && (t.__t = void 0);
    }
}
function dl(s = "") {
    return document.createTextNode(s);
}
function Xo(s) {
    return rw.call(s);
}
function pd(s) {
    return aw.call(s);
}
function I(s, e) {
    return Xo(s);
}
function me(s, e) {
    {
        var t = Xo(s);
        return t instanceof Comment && t.data === "" ? pd(t) : t;
    }
}
function N(s, e = 1, t = !1) {
    let n = s;
    for (; e--; ) n = pd(n);
    return n;
}
function cE(s) {
    s.textContent = "";
}
function ow() {
    return !1;
}
let h0 = !1;
function uE() {
    h0 ||
        ((h0 = !0),
        document.addEventListener(
            "reset",
            (s) => {
                Promise.resolve().then(() => {
                    var e;
                    if (!s.defaultPrevented)
                        for (const t of s.target.elements)
                            (e = t.__on_r) == null || e.call(t);
                });
            },
            { capture: !0 }
        ));
}
function fl(s) {
    var e = Pe,
        t = Ie;
    Ai(null), Ur(null);
    try {
        return s();
    } finally {
        Ai(e), Ur(t);
    }
}
function dE(s, e, t, n = t) {
    s.addEventListener(e, () => fl(t));
    const i = s.__on_r;
    i
        ? (s.__on_r = () => {
              i(), n(!0);
          })
        : (s.__on_r = () => n(!0)),
        uE();
}
function lw(s) {
    Ie === null && Pe === null && OS(),
        Pe !== null && (Pe.f & Ts) !== 0 && Ie === null && LS(),
        pl && RS();
}
function fE(s, e) {
    var t = e.last;
    t === null
        ? (e.last = e.first = s)
        : ((t.next = s), (s.prev = t), (e.last = s));
}
function Ti(s, e, t, n = !0) {
    var i = Ie;
    i !== null && (i.f & js) !== 0 && (s |= js);
    var r = {
        ctx: os,
        deps: null,
        nodes_start: null,
        nodes_end: null,
        f: s | as,
        first: null,
        fn: e,
        last: null,
        next: null,
        parent: i,
        b: i && i.b,
        prev: null,
        teardown: null,
        transitions: null,
        wv: 0,
        ac: null,
    };
    if (t)
        try {
            ko(r), (r.f |= hd);
        } catch (h) {
            throw (tr(r), h);
        }
    else e !== null && Wo(r);
    if (n) {
        var a = r;
        if (
            (t &&
                a.deps === null &&
                a.teardown === null &&
                a.nodes_start === null &&
                a.first === a.last &&
                (a.f & ac) === 0 &&
                (a = a.first),
            a !== null &&
                ((a.parent = i),
                i !== null && fE(a, i),
                Pe !== null && (Pe.f & rs) !== 0 && (s & Wa) === 0))
        ) {
            var o = Pe;
            (o.effects ?? (o.effects = [])).push(a);
        }
    }
    return r;
}
function hw(s) {
    const e = Ti(ld, null, !1);
    return Pn(e, pn), (e.teardown = s), e;
}
function _n(s) {
    lw();
    var e = Ie.f,
        t = !Pe && (e & lr) !== 0 && (e & hd) === 0;
    if (t) {
        var n = os;
        (n.e ?? (n.e = [])).push(s);
    } else return cw(s);
}
function cw(s) {
    return Ti(Wm | Yy, s, !1);
}
function pE(s) {
    return lw(), Ti(ld | Yy, s, !0);
}
function mE(s) {
    Jm.ensure();
    const e = Ti(Wa | ac, s, !0);
    return (t = {}) =>
        new Promise((n) => {
            t.outro
                ? ng(e, () => {
                      tr(e), n(void 0);
                  })
                : (tr(e), n(void 0));
        });
}
function eg(s) {
    return Ti(Wm, s, !1);
}
function gE(s) {
    return Ti(Xm | ac, s, !0);
}
function tg(s, e = 0) {
    return Ti(ld | e, s, !0);
}
function ie(s, e = [], t = []) {
    rE(e, t, (n) => {
        Ti(ld, () => s(...n.map($)), !0);
    });
}
function uw(s, e = 0) {
    var t = Ti(ja | e, s, !0);
    return t;
}
function xh(s, e = !0) {
    return Ti(lr | ac, s, !0, e);
}
function dw(s) {
    var e = s.teardown;
    if (e !== null) {
        const t = pl,
            n = Pe;
        u0(!0), Ai(null);
        try {
            e.call(null);
        } finally {
            u0(t), Ai(n);
        }
    }
}
function fw(s, e = !1) {
    var t = s.first;
    for (s.first = s.last = null; t !== null; ) {
        const i = t.ac;
        i !== null &&
            fl(() => {
                i.abort(qm);
            });
        var n = t.next;
        (t.f & Wa) !== 0 ? (t.parent = null) : tr(t, e), (t = n);
    }
}
function _E(s) {
    for (var e = s.first; e !== null; ) {
        var t = e.next;
        (e.f & lr) === 0 && tr(e), (e = t);
    }
}
function tr(s, e = !0) {
    var t = !1;
    (e || (s.f & TS) !== 0) &&
        s.nodes_start !== null &&
        s.nodes_end !== null &&
        (vE(s.nodes_start, s.nodes_end), (t = !0)),
        fw(s, e && !t),
        gu(s, 0),
        Pn(s, ul);
    var n = s.transitions;
    if (n !== null) for (const r of n) r.stop();
    dw(s);
    var i = s.parent;
    i !== null && i.first !== null && pw(s),
        (s.next =
            s.prev =
            s.teardown =
            s.ctx =
            s.deps =
            s.fn =
            s.nodes_start =
            s.nodes_end =
            s.ac =
                null);
}
function vE(s, e) {
    for (; s !== null; ) {
        var t = s === e ? null : pd(s);
        s.remove(), (s = t);
    }
}
function pw(s) {
    var e = s.parent,
        t = s.prev,
        n = s.next;
    t !== null && (t.next = n),
        n !== null && (n.prev = t),
        e !== null &&
            (e.first === s && (e.first = n), e.last === s && (e.last = t));
}
function ng(s, e) {
    var t = [];
    sg(s, t, !0),
        mw(t, () => {
            tr(s), e && e();
        });
}
function mw(s, e) {
    var t = s.length;
    if (t > 0) {
        var n = () => --t || e();
        for (var i of s) i.out(n);
    } else e();
}
function sg(s, e, t) {
    if ((s.f & js) === 0) {
        if (((s.f ^= js), s.transitions !== null))
            for (const a of s.transitions) (a.is_global || t) && e.push(a);
        for (var n = s.first; n !== null; ) {
            var i = n.next,
                r = (n.f & cd) !== 0 || (n.f & lr) !== 0;
            sg(n, e, r ? t : !1), (n = i);
        }
    }
}
function ig(s) {
    gw(s, !0);
}
function gw(s, e) {
    if ((s.f & js) !== 0) {
        (s.f ^= js), (s.f & pn) === 0 && (Pn(s, as), Wo(s));
        for (var t = s.first; t !== null; ) {
            var n = t.next,
                i = (t.f & cd) !== 0 || (t.f & lr) !== 0;
            gw(t, i ? e : !1), (t = n);
        }
        if (s.transitions !== null)
            for (const r of s.transitions) (r.is_global || e) && r.in();
    }
}
let Po = !1;
function c0(s) {
    Po = s;
}
let pl = !1;
function u0(s) {
    pl = s;
}
let Pe = null,
    pi = !1;
function Ai(s) {
    Pe = s;
}
let Ie = null;
function Ur(s) {
    Ie = s;
}
let En = null;
function _w(s) {
    Pe !== null && (En === null ? (En = [s]) : En.push(s));
}
let xn = null,
    Hn = 0,
    ws = null;
function bE(s) {
    ws = s;
}
let vw = 1,
    Ch = 0,
    va = Ch;
function d0(s) {
    va = s;
}
let Er = !1;
function bw() {
    return ++vw;
}
function md(s) {
    var c;
    var e = s.f;
    if ((e & as) !== 0) return !0;
    if ((e & hr) !== 0) {
        var t = s.deps,
            n = (e & Ts) !== 0;
        if (t !== null) {
            var i,
                r,
                a = (e & fu) !== 0,
                o = n && Ie !== null && !Er,
                h = t.length;
            if ((a || o) && (Ie === null || (Ie.f & ul) === 0)) {
                var l = s,
                    u = l.parent;
                for (i = 0; i < h; i++)
                    (r = t[i]),
                        (a ||
                            !(
                                (c = r == null ? void 0 : r.reactions) !=
                                    null && c.includes(l)
                            )) &&
                            (r.reactions ?? (r.reactions = [])).push(l);
                a && (l.f ^= fu),
                    o && u !== null && (u.f & Ts) === 0 && (l.f ^= Ts);
            }
            for (i = 0; i < h; i++)
                if (((r = t[i]), md(r) && Qy(r), r.wv > s.wv)) return !0;
        }
        (!n || (Ie !== null && !Er)) && Pn(s, pn);
    }
    return !1;
}
function yw(s, e, t = !0) {
    var n = s.reactions;
    if (n !== null && !(En != null && En.includes(s)))
        for (var i = 0; i < n.length; i++) {
            var r = n[i];
            (r.f & rs) !== 0
                ? yw(r, e, !1)
                : e === r &&
                  (t ? Pn(r, as) : (r.f & pn) !== 0 && Pn(r, hr), Wo(r));
        }
}
function ww(s) {
    var m;
    var e = xn,
        t = Hn,
        n = ws,
        i = Pe,
        r = Er,
        a = En,
        o = os,
        h = pi,
        l = va,
        u = s.f;
    (xn = null),
        (Hn = 0),
        (ws = null),
        (Er = (u & Ts) !== 0 && (pi || !Po || Pe === null)),
        (Pe = (u & (lr | Wa)) === 0 ? s : null),
        (En = null),
        pu(s.ctx),
        (pi = !1),
        (va = ++Ch),
        s.ac !== null &&
            (fl(() => {
                s.ac.abort(qm);
            }),
            (s.ac = null));
    try {
        s.f |= Ep;
        var c = s.fn,
            d = c(),
            f = s.deps;
        if (xn !== null) {
            var p;
            if ((gu(s, Hn), f !== null && Hn > 0))
                for (f.length = Hn + xn.length, p = 0; p < xn.length; p++)
                    f[Hn + p] = xn[p];
            else s.deps = f = xn;
            if (!Er || ((u & rs) !== 0 && s.reactions !== null))
                for (p = Hn; p < f.length; p++)
                    ((m = f[p]).reactions ?? (m.reactions = [])).push(s);
        } else f !== null && Hn < f.length && (gu(s, Hn), (f.length = Hn));
        if (
            qy() &&
            ws !== null &&
            !pi &&
            f !== null &&
            (s.f & (rs | hr | as)) === 0
        )
            for (p = 0; p < ws.length; p++) yw(ws[p], s);
        return (
            i !== null &&
                i !== s &&
                (Ch++, ws !== null && (n === null ? (n = ws) : n.push(...ws))),
            (s.f & _a) !== 0 && (s.f ^= _a),
            d
        );
    } catch (g) {
        return ZS(g);
    } finally {
        (s.f ^= Ep),
            (xn = e),
            (Hn = t),
            (ws = n),
            (Pe = i),
            (Er = r),
            (En = a),
            pu(o),
            (pi = h),
            (va = l);
    }
}
function yE(s, e) {
    let t = e.reactions;
    if (t !== null) {
        var n = AS.call(t, s);
        if (n !== -1) {
            var i = t.length - 1;
            i === 0 ? (t = e.reactions = null) : ((t[n] = t[i]), t.pop());
        }
    }
    t === null &&
        (e.f & rs) !== 0 &&
        (xn === null || !xn.includes(e)) &&
        (Pn(e, hr), (e.f & (Ts | fu)) === 0 && (e.f ^= fu), Zy(e), gu(e, 0));
}
function gu(s, e) {
    var t = s.deps;
    if (t !== null) for (var n = e; n < t.length; n++) yE(s, t[n]);
}
function ko(s) {
    var e = s.f;
    if ((e & ul) === 0) {
        Pn(s, pn);
        var t = Ie,
            n = Po;
        (Ie = s), (Po = !0);
        try {
            (e & ja) !== 0 ? _E(s) : fw(s), dw(s);
            var i = ww(s);
            (s.teardown = typeof i == "function" ? i : null), (s.wv = vw);
            var r;
            Vy && HS && (s.f & as) !== 0 && s.deps;
        } finally {
            (Po = n), (Ie = t);
        }
    }
}
async function wE() {
    await Promise.resolve(), oE();
}
function $(s) {
    var e = s.f,
        t = (e & rs) !== 0;
    if (Pe !== null && !pi) {
        var n = Ie !== null && (Ie.f & ul) !== 0;
        if (!n && !(En != null && En.includes(s))) {
            var i = Pe.deps;
            if ((Pe.f & Ep) !== 0)
                s.rv < Ch &&
                    ((s.rv = Ch),
                    xn === null && i !== null && i[Hn] === s
                        ? Hn++
                        : xn === null
                        ? (xn = [s])
                        : (!Er || !xn.includes(s)) && xn.push(s));
            else {
                (Pe.deps ?? (Pe.deps = [])).push(s);
                var r = s.reactions;
                r === null
                    ? (s.reactions = [Pe])
                    : r.includes(Pe) || r.push(Pe);
            }
        }
    } else if (t && s.deps === null && s.effects === null) {
        var a = s,
            o = a.parent;
        o !== null && (o.f & Ts) === 0 && (a.f ^= Ts);
    }
    if (pl) {
        if (Fr.has(s)) return Fr.get(s);
        if (t) {
            a = s;
            var h = a.v;
            return (
                (((a.f & pn) === 0 && a.reactions !== null) || xw(a)) &&
                    (h = Qm(a)),
                Fr.set(a, h),
                h
            );
        }
    } else t && ((a = s), md(a) && Qy(a));
    if ((s.f & _a) !== 0) throw s.v;
    return s.v;
}
function xw(s) {
    if (s.v === nn) return !0;
    if (s.deps === null) return !1;
    for (const e of s.deps)
        if (Fr.has(e) || ((e.f & rs) !== 0 && xw(e))) return !0;
    return !1;
}
function Xa(s) {
    var e = pi;
    try {
        return (pi = !0), s();
    } finally {
        pi = e;
    }
}
const xE = -7169;
function Pn(s, e) {
    s.f = (s.f & xE) | e;
}
function CE(s) {
    if (!(typeof s != "object" || !s || s instanceof EventTarget)) {
        if (Eo in s) Tp(s);
        else if (!Array.isArray(s))
            for (let e in s) {
                const t = s[e];
                typeof t == "object" && t && Eo in t && Tp(t);
            }
    }
}
function Tp(s, e = new Set()) {
    if (
        typeof s == "object" &&
        s !== null &&
        !(s instanceof EventTarget) &&
        !e.has(s)
    ) {
        e.add(s), s instanceof Date && s.getTime();
        for (let n in s)
            try {
                Tp(s[n], e);
            } catch {}
        const t = Gm(s);
        if (
            t !== Object.prototype &&
            t !== Array.prototype &&
            t !== Map.prototype &&
            t !== Set.prototype &&
            t !== Date.prototype
        ) {
            const n = Uy(t);
            for (let i in n) {
                const r = n[i].get;
                if (r)
                    try {
                        r.call(s);
                    } catch {}
            }
        }
    }
}
const AE = ["touchstart", "touchmove"];
function SE(s) {
    return AE.includes(s);
}
const Cw = new Set(),
    Mp = new Set();
function EE(s, e, t, n = {}) {
    function i(r) {
        if ((n.capture || Kl.call(e, r), !r.cancelBubble))
            return fl(() => (t == null ? void 0 : t.call(this, r)));
    }
    return (
        s.startsWith("pointer") || s.startsWith("touch") || s === "wheel"
            ? oc(() => {
                  e.addEventListener(s, i, n);
              })
            : e.addEventListener(s, i, n),
        i
    );
}
function Ip(s, e, t, n, i) {
    var r = { capture: n, passive: i },
        a = EE(s, e, t, r);
    (e === document.body ||
        e === window ||
        e === document ||
        e instanceof HTMLMediaElement) &&
        hw(() => {
            e.removeEventListener(s, a, r);
        });
}
function Jt(s) {
    for (var e = 0; e < s.length; e++) Cw.add(s[e]);
    for (var t of Mp) t(s);
}
let f0 = null;
function Kl(s) {
    var v;
    var e = this,
        t = e.ownerDocument,
        n = s.type,
        i = ((v = s.composedPath) == null ? void 0 : v.call(s)) || [],
        r = i[0] || s.target;
    f0 = s;
    var a = 0,
        o = f0 === s && s.__root;
    if (o) {
        var h = i.indexOf(o);
        if (h !== -1 && (e === document || e === window)) {
            s.__root = e;
            return;
        }
        var l = i.indexOf(e);
        if (l === -1) return;
        h <= l && (a = h);
    }
    if (((r = i[a] || s.target), r !== e)) {
        du(s, "currentTarget", {
            configurable: !0,
            get() {
                return r || t;
            },
        });
        var u = Pe,
            c = Ie;
        Ai(null), Ur(null);
        try {
            for (var d, f = []; r !== null; ) {
                var p = r.assignedSlot || r.parentNode || r.host || null;
                try {
                    var m = r["__" + n];
                    if (m != null && (!r.disabled || s.target === r))
                        if (zm(m)) {
                            var [g, ..._] = m;
                            g.apply(r, [s, ..._]);
                        } else m.call(r, s);
                } catch (b) {
                    d ? f.push(b) : (d = b);
                }
                if (s.cancelBubble || p === e || p === null) break;
                r = p;
            }
            if (d) {
                for (let b of f)
                    queueMicrotask(() => {
                        throw b;
                    });
                throw d;
            }
        } finally {
            (s.__root = e), delete s.currentTarget, Ai(u), Ur(c);
        }
    }
}
function Aw(s) {
    var e = document.createElement("template");
    return (e.innerHTML = s.replaceAll("<!>", "<!---->")), e.content;
}
function Ah(s, e) {
    var t = Ie;
    t.nodes_start === null && ((t.nodes_start = s), (t.nodes_end = e));
}
function X(s, e) {
    var t = (e & GS) !== 0,
        n = (e & jS) !== 0,
        i,
        r = !s.startsWith("<!>");
    return () => {
        i === void 0 && ((i = Aw(r ? s : "<!>" + s)), t || (i = Xo(i)));
        var a = n || iw ? document.importNode(i, !0) : i.cloneNode(!0);
        if (t) {
            var o = Xo(a),
                h = a.lastChild;
            Ah(o, h);
        } else Ah(a, a);
        return a;
    };
}
function PE(s, e, t = "svg") {
    var n = !s.startsWith("<!>"),
        i = `<${t}>${n ? s : "<!>" + s}</${t}>`,
        r;
    return () => {
        if (!r) {
            var a = Aw(i),
                o = Xo(a);
            r = Xo(o);
        }
        var h = r.cloneNode(!0);
        return Ah(h, h), h;
    };
}
function bn(s, e) {
    return PE(s, e, "svg");
}
function kE(s = "") {
    {
        var e = dl(s + "");
        return Ah(e, e), e;
    }
}
function Oe() {
    var s = document.createDocumentFragment(),
        e = document.createComment(""),
        t = dl();
    return s.append(e, t), Ah(e, t), s;
}
function D(s, e) {
    s !== null && s.before(e);
}
let Rp = !0;
function se(s, e) {
    var t = e == null ? "" : typeof e == "object" ? e + "" : e;
    t !== (s.__t ?? (s.__t = s.nodeValue)) &&
        ((s.__t = t), (s.nodeValue = t + ""));
}
function TE(s, e) {
    return ME(s, e);
}
const no = new Map();
function ME(
    s,
    {
        target: e,
        anchor: t,
        props: n = {},
        events: i,
        context: r,
        intro: a = !0,
    }
) {
    hE();
    var o = new Set(),
        h = (c) => {
            for (var d = 0; d < c.length; d++) {
                var f = c[d];
                if (!o.has(f)) {
                    o.add(f);
                    var p = SE(f);
                    e.addEventListener(f, Kl, { passive: p });
                    var m = no.get(f);
                    m === void 0
                        ? (document.addEventListener(f, Kl, { passive: p }),
                          no.set(f, 1))
                        : no.set(f, m + 1);
                }
            }
        };
    h(Ym(Cw)), Mp.add(h);
    var l = void 0,
        u = mE(() => {
            var c = t ?? e.appendChild(dl());
            return (
                xh(() => {
                    if (r) {
                        Ne({});
                        var d = os;
                        d.c = r;
                    }
                    i && (n.$$events = i),
                        (Rp = a),
                        (l = s(c, n) || {}),
                        (Rp = !0),
                        r && Ve();
                }),
                () => {
                    var p;
                    for (var d of o) {
                        e.removeEventListener(d, Kl);
                        var f = no.get(d);
                        --f === 0
                            ? (document.removeEventListener(d, Kl),
                              no.delete(d))
                            : no.set(d, f);
                    }
                    Mp.delete(h),
                        c !== t &&
                            ((p = c.parentNode) == null || p.removeChild(c));
                }
            );
        });
    return IE.set(l, u), l;
}
let IE = new WeakMap();
function ne(s, e, t = !1) {
    var n = s,
        i = null,
        r = null,
        a = nn,
        o = t ? cd : 0,
        h = !1;
    const l = (f, p = !0) => {
        (h = !0), d(p, f);
    };
    var u = null;
    function c() {
        u !== null && (u.lastChild.remove(), n.before(u), (u = null));
        var f = a ? i : r,
            p = a ? r : i;
        f && ig(f),
            p &&
                ng(p, () => {
                    a ? (r = null) : (i = null);
                });
    }
    const d = (f, p) => {
        if (a !== (a = f)) {
            var m = ow(),
                g = n;
            if (
                (m &&
                    ((u = document.createDocumentFragment()),
                    u.append((g = dl()))),
                a
                    ? i ?? (i = p && xh(() => p(g)))
                    : r ?? (r = p && xh(() => p(g))),
                m)
            ) {
                var _ = ht,
                    v = a ? i : r,
                    b = a ? r : i;
                v && _.skipped_effects.delete(v),
                    b && _.skipped_effects.add(b),
                    _.add_callback(c);
            } else c();
        }
    };
    uw(() => {
        (h = !1), e(l), h || d(null, null);
    }, o);
}
function ot(s, e) {
    return e;
}
function RE(s, e, t) {
    for (var n = s.items, i = [], r = e.length, a = 0; a < r; a++)
        sg(e[a].e, i, !0);
    var o = r > 0 && i.length === 0 && t !== null;
    if (o) {
        var h = t.parentNode;
        cE(h), h.append(t), n.clear(), ci(s, e[0].prev, e[r - 1].next);
    }
    mw(i, () => {
        for (var l = 0; l < r; l++) {
            var u = e[l];
            o || (n.delete(u.k), ci(s, u.prev, u.next)), tr(u.e, !o);
        }
    });
}
function lt(s, e, t, n, i, r = null) {
    var a = s,
        o = { flags: e, items: new Map(), first: null },
        h = (e & jy) !== 0;
    if (h) {
        var l = s;
        a = l.appendChild(dl());
    }
    var u = null,
        c = !1,
        d = new Map(),
        f = sE(() => {
            var _ = t();
            return zm(_) ? _ : _ == null ? [] : Ym(_);
        }),
        p,
        m;
    function g() {
        LE(m, p, o, d, a, i, e, n, t),
            r !== null &&
                (p.length === 0
                    ? u
                        ? ig(u)
                        : (u = xh(() => r(a)))
                    : u !== null &&
                      ng(u, () => {
                          u = null;
                      }));
    }
    uw(() => {
        m ?? (m = Ie), (p = $(f));
        var _ = p.length;
        if (!(c && _ === 0)) {
            c = _ === 0;
            var v, b, y, C;
            if (ow()) {
                var w = new Set(),
                    A = ht;
                for (b = 0; b < _; b += 1) {
                    (y = p[b]), (C = n(y, b));
                    var E = o.items.get(C) ?? d.get(C);
                    E
                        ? (e & (ud | dd)) !== 0 && Sw(E, y, b, e)
                        : ((v = Ew(null, o, null, null, y, C, b, i, e, t, !0)),
                          d.set(C, v)),
                        w.add(C);
                }
                for (const [S, P] of o.items)
                    w.has(S) || A.skipped_effects.add(P.e);
                A.add_callback(g);
            } else g();
            $(f);
        }
    });
}
function LE(s, e, t, n, i, r, a, o, h) {
    var V, W, Z, J;
    var l = (a & NS) !== 0,
        u = (a & (ud | dd)) !== 0,
        c = e.length,
        d = t.items,
        f = t.first,
        p = f,
        m,
        g = null,
        _,
        v = [],
        b = [],
        y,
        C,
        w,
        A;
    if (l)
        for (A = 0; A < c; A += 1)
            (y = e[A]),
                (C = o(y, A)),
                (w = d.get(C)),
                w !== void 0 &&
                    ((V = w.a) == null || V.measure(),
                    (_ ?? (_ = new Set())).add(w));
    for (A = 0; A < c; A += 1) {
        if (((y = e[A]), (C = o(y, A)), (w = d.get(C)), w === void 0)) {
            var E = n.get(C);
            if (E !== void 0) {
                n.delete(C), d.set(C, E);
                var S = g ? g.next : p;
                ci(t, g, E), ci(t, E, S), tf(E, S, i), (g = E);
            } else {
                var P = p ? p.e.nodes_start : i;
                g = Ew(
                    P,
                    t,
                    g,
                    g === null ? t.first : g.next,
                    y,
                    C,
                    A,
                    r,
                    a,
                    h
                );
            }
            d.set(C, g), (v = []), (b = []), (p = g.next);
            continue;
        }
        if (
            (u && Sw(w, y, A, a),
            (w.e.f & js) !== 0 &&
                (ig(w.e),
                l &&
                    ((W = w.a) == null || W.unfix(),
                    (_ ?? (_ = new Set())).delete(w))),
            w !== p)
        ) {
            if (m !== void 0 && m.has(w)) {
                if (v.length < b.length) {
                    var k = b[0],
                        R;
                    g = k.prev;
                    var M = v[0],
                        T = v[v.length - 1];
                    for (R = 0; R < v.length; R += 1) tf(v[R], k, i);
                    for (R = 0; R < b.length; R += 1) m.delete(b[R]);
                    ci(t, M.prev, T.next),
                        ci(t, g, M),
                        ci(t, T, k),
                        (p = k),
                        (g = T),
                        (A -= 1),
                        (v = []),
                        (b = []);
                } else
                    m.delete(w),
                        tf(w, p, i),
                        ci(t, w.prev, w.next),
                        ci(t, w, g === null ? t.first : g.next),
                        ci(t, g, w),
                        (g = w);
                continue;
            }
            for (v = [], b = []; p !== null && p.k !== C; )
                (p.e.f & js) === 0 && (m ?? (m = new Set())).add(p),
                    b.push(p),
                    (p = p.next);
            if (p === null) continue;
            w = p;
        }
        v.push(w), (g = w), (p = w.next);
    }
    if (p !== null || m !== void 0) {
        for (var O = m === void 0 ? [] : Ym(m); p !== null; )
            (p.e.f & js) === 0 && O.push(p), (p = p.next);
        var L = O.length;
        if (L > 0) {
            var F = (a & jy) !== 0 && c === 0 ? i : null;
            if (l) {
                for (A = 0; A < L; A += 1) (Z = O[A].a) == null || Z.measure();
                for (A = 0; A < L; A += 1) (J = O[A].a) == null || J.fix();
            }
            RE(t, O, F);
        }
    }
    l &&
        oc(() => {
            var G;
            if (_ !== void 0) for (w of _) (G = w.a) == null || G.apply();
        }),
        (s.first = t.first && t.first.e),
        (s.last = g && g.e);
    for (var Y of n.values()) tr(Y.e);
    n.clear();
}
function Sw(s, e, t, n) {
    (n & ud) !== 0 && yh(s.v, e), (n & dd) !== 0 ? yh(s.i, t) : (s.i = t);
}
function Ew(s, e, t, n, i, r, a, o, h, l, u) {
    var c = (h & ud) !== 0,
        d = (h & VS) === 0,
        f = c ? (d ? nw(i, !1, !1) : bh(i)) : i,
        p = (h & dd) === 0 ? a : bh(a),
        m = { i: p, v: f, k: r, a: null, e: null, prev: t, next: n };
    try {
        if (s === null) {
            var g = document.createDocumentFragment();
            g.append((s = dl()));
        }
        return (
            (m.e = xh(() => o(s, f, p, l), qS)),
            (m.e.prev = t && t.e),
            (m.e.next = n && n.e),
            t === null ? u || (e.first = m) : ((t.next = m), (t.e.next = m.e)),
            n !== null && ((n.prev = m), (n.e.prev = m.e)),
            m
        );
    } finally {
    }
}
function tf(s, e, t) {
    for (
        var n = s.next ? s.next.e.nodes_start : t,
            i = e ? e.e.nodes_start : t,
            r = s.e.nodes_start;
        r !== null && r !== n;

    ) {
        var a = pd(r);
        i.before(r), (r = a);
    }
}
function ci(s, e, t) {
    e === null ? (s.first = t) : ((e.next = t), (e.e.next = t && t.e)),
        t !== null && ((t.prev = e), (t.e.prev = e && e.e));
}
function OE(s, e, t) {
    eg(() => {
        var n = Xa(() => e(s, t == null ? void 0 : t()) || {});
        if (t && n != null && n.update) {
            var i = !1,
                r = {};
            tg(() => {
                var a = t();
                CE(a), i && Hm(r, a) && ((r = a), n.update(a));
            }),
                (i = !0);
        }
        if (n != null && n.destroy) return () => n.destroy();
    });
}
const p0 = [
    ...`
\r\f\v\uFEFF`,
];
function BE(s, e, t) {
    var n = s == null ? "" : "" + s;
    if ((e && (n = n ? n + " " + e : e), t)) {
        for (var i in t)
            if (t[i]) n = n ? n + " " + i : i;
            else if (n.length)
                for (var r = i.length, a = 0; (a = n.indexOf(i, a)) >= 0; ) {
                    var o = a + r;
                    (a === 0 || p0.includes(n[a - 1])) &&
                    (o === n.length || p0.includes(n[o]))
                        ? (n =
                              (a === 0 ? "" : n.substring(0, a)) +
                              n.substring(o + 1))
                        : (a = o);
                }
    }
    return n === "" ? null : n;
}
function FE(s, e) {
    return s == null ? null : String(s);
}
function qe(s, e, t, n, i, r) {
    var a = s.__className;
    if (a !== t || a === void 0) {
        var o = BE(t, n, r);
        o == null ? s.removeAttribute("class") : (s.className = o),
            (s.__className = t);
    } else if (r && i !== r)
        for (var h in r) {
            var l = !!r[h];
            (i == null || l !== !!i[h]) && s.classList.toggle(h, l);
        }
    return r;
}
function an(s, e, t, n) {
    var i = s.__style;
    if (i !== e) {
        var r = FE(e);
        r == null ? s.removeAttribute("style") : (s.style.cssText = r),
            (s.__style = e);
    }
    return n;
}
const $E = Symbol("is custom element"),
    DE = Symbol("is html");
function wr(s, e, t, n) {
    var i = NE(s);
    i[e] !== (i[e] = t) &&
        (t == null
            ? s.removeAttribute(e)
            : typeof t != "string" && VE(s).includes(e)
            ? (s[e] = t)
            : s.setAttribute(e, t));
}
function NE(s) {
    return (
        s.__attributes ??
        (s.__attributes = {
            [$E]: s.nodeName.includes("-"),
            [DE]: s.namespaceURI === WS,
        })
    );
}
var m0 = new Map();
function VE(s) {
    var e = s.getAttribute("is") || s.nodeName,
        t = m0.get(e);
    if (t) return t;
    m0.set(e, (t = []));
    for (var n, i = s, r = Element.prototype; r !== i; ) {
        n = Uy(i);
        for (var a in n) n[a].set && t.push(a);
        i = Gm(i);
    }
    return t;
}
const UE = () => performance.now(),
    mi = {
        tick: (s) => requestAnimationFrame(s),
        now: () => UE(),
        tasks: new Set(),
    };
function Pw() {
    const s = mi.now();
    mi.tasks.forEach((e) => {
        e.c(s) || (mi.tasks.delete(e), e.f());
    }),
        mi.tasks.size !== 0 && mi.tick(Pw);
}
function kw(s) {
    let e;
    return (
        mi.tasks.size === 0 && mi.tick(Pw),
        {
            promise: new Promise((t) => {
                mi.tasks.add((e = { c: s, f: t }));
            }),
            abort() {
                mi.tasks.delete(e);
            },
        }
    );
}
function xc(s, e) {
    fl(() => {
        s.dispatchEvent(new CustomEvent(e));
    });
}
function zE(s) {
    if (s === "float") return "cssFloat";
    if (s === "offset") return "cssOffset";
    if (s.startsWith("--")) return s;
    const e = s.split("-");
    return e.length === 1
        ? e[0]
        : e[0] +
              e
                  .slice(1)
                  .map((t) => t[0].toUpperCase() + t.slice(1))
                  .join("");
}
function g0(s) {
    const e = {},
        t = s.split(";");
    for (const n of t) {
        const [i, r] = n.split(":");
        if (!i || r === void 0) break;
        const a = zE(i.trim());
        e[a] = r.trim();
    }
    return e;
}
const YE = (s) => s;
function Vn(s, e, t, n) {
    var i = (s & US) !== 0,
        r = (s & zS) !== 0,
        a = i && r,
        o = (s & YS) !== 0,
        h = a ? "both" : i ? "in" : "out",
        l,
        u = e.inert,
        c = e.style.overflow,
        d,
        f;
    function p() {
        return fl(
            () =>
                l ??
                (l = t()(e, (n == null ? void 0 : n()) ?? {}, { direction: h }))
        );
    }
    var m = {
            is_global: o,
            in() {
                var b;
                if (((e.inert = u), !i)) {
                    f == null || f.abort(),
                        (b = f == null ? void 0 : f.reset) == null || b.call(f);
                    return;
                }
                r || d == null || d.abort(),
                    xc(e, "introstart"),
                    (d = Lp(e, p(), f, 1, () => {
                        xc(e, "introend"),
                            d == null || d.abort(),
                            (d = l = void 0),
                            (e.style.overflow = c);
                    }));
            },
            out(b) {
                if (!r) {
                    b == null || b(), (l = void 0);
                    return;
                }
                (e.inert = !0),
                    xc(e, "outrostart"),
                    (f = Lp(e, p(), d, 0, () => {
                        xc(e, "outroend"), b == null || b();
                    }));
            },
            stop: () => {
                d == null || d.abort(), f == null || f.abort();
            },
        },
        g = Ie;
    if (((g.transitions ?? (g.transitions = [])).push(m), i && Rp)) {
        var _ = o;
        if (!_) {
            for (var v = g.parent; v && (v.f & cd) !== 0; )
                for (; (v = v.parent) && (v.f & ja) === 0; );
            _ = !v || (v.f & hd) !== 0;
        }
        _ &&
            eg(() => {
                Xa(() => m.in());
            });
    }
}
function Lp(s, e, t, n, i) {
    var r = n === 1;
    if (PS(e)) {
        var a,
            o = !1;
        return (
            oc(() => {
                if (!o) {
                    var g = e({ direction: r ? "in" : "out" });
                    a = Lp(s, g, t, n, i);
                }
            }),
            {
                abort: () => {
                    (o = !0), a == null || a.abort();
                },
                deactivate: () => a.deactivate(),
                reset: () => a.reset(),
                t: () => a.t(),
            }
        );
    }
    if ((t == null || t.deactivate(), !(e != null && e.duration)))
        return i(), { abort: ts, deactivate: ts, reset: ts, t: () => n };
    const { delay: h = 0, css: l, tick: u, easing: c = YE } = e;
    var d = [];
    if (r && t === void 0 && (u && u(0, 1), l)) {
        var f = g0(l(0, 1));
        d.push(f, f);
    }
    var p = () => 1 - n,
        m = s.animate(d, { duration: h, fill: "forwards" });
    return (
        (m.onfinish = () => {
            m.cancel();
            var g = (t == null ? void 0 : t.t()) ?? 1 - n;
            t == null || t.abort();
            var _ = n - g,
                v = e.duration * Math.abs(_),
                b = [];
            if (v > 0) {
                var y = !1;
                if (l)
                    for (
                        var C = Math.ceil(v / 16.666666666666668), w = 0;
                        w <= C;
                        w += 1
                    ) {
                        var A = g + _ * c(w / C),
                            E = g0(l(A, 1 - A));
                        b.push(E), y || (y = E.overflow === "hidden");
                    }
                y && (s.style.overflow = "hidden"),
                    (p = () => {
                        var S = m.currentTime;
                        return g + _ * c(S / v);
                    }),
                    u &&
                        kw(() => {
                            if (m.playState !== "running") return !1;
                            var S = p();
                            return u(S, 1 - S), !0;
                        });
            }
            (m = s.animate(b, { duration: v, fill: "forwards" })),
                (m.onfinish = () => {
                    (p = () => n), u == null || u(n, 1 - n), i();
                });
        }),
        {
            abort: () => {
                m && (m.cancel(), (m.effect = null), (m.onfinish = ts));
            },
            deactivate: () => {
                i = ts;
            },
            reset: () => {
                n === 0 && (u == null || u(1, 0));
            },
            t: () => p(),
        }
    );
}
function _0(s, e, t = e) {
    var n = new WeakSet();
    dE(s, "input", async (i) => {
        var r = i ? s.defaultValue : s.value;
        if (
            ((r = nf(s) ? sf(r) : r),
            t(r),
            ht !== null && n.add(ht),
            await wE(),
            r !== (r = e()))
        ) {
            var a = s.selectionStart,
                o = s.selectionEnd;
            (s.value = r ?? ""),
                o !== null &&
                    ((s.selectionStart = a),
                    (s.selectionEnd = Math.min(o, s.value.length)));
        }
    }),
        Xa(e) == null &&
            s.value &&
            (t(nf(s) ? sf(s.value) : s.value), ht !== null && n.add(ht)),
        tg(() => {
            var i = e();
            if (s === document.activeElement) {
                var r = Hc ?? ht;
                if (n.has(r)) return;
            }
            (nf(s) && i === sf(s.value)) ||
                (s.type === "date" && !i && !s.value) ||
                (i !== s.value && (s.value = i ?? ""));
        });
}
function nf(s) {
    var e = s.type;
    return e === "number" || e === "range";
}
function sf(s) {
    return s === "" ? null : +s;
}
function v0(s, e) {
    return s === e || (s == null ? void 0 : s[Eo]) === e;
}
function b0(s = {}, e, t, n) {
    return (
        eg(() => {
            var i, r;
            return (
                tg(() => {
                    (i = r),
                        (r = []),
                        Xa(() => {
                            s !== t(...r) &&
                                (e(s, ...r),
                                i && v0(t(...i), s) && e(null, ...i));
                        });
                }),
                () => {
                    oc(() => {
                        r && v0(t(...r), s) && e(null, ...r);
                    });
                }
            );
        }),
        s
    );
}
function rg(s, e, t) {
    if (s == null) return e(void 0), t && t(void 0), ts;
    const n = Xa(() => s.subscribe(e, t));
    return n.unsubscribe ? () => n.unsubscribe() : n;
}
const so = [];
function Tw(s, e) {
    return { subscribe: fe(s, e).subscribe };
}
function fe(s, e = ts) {
    let t = null;
    const n = new Set();
    function i(o) {
        if (Hm(s, o) && ((s = o), t)) {
            const h = !so.length;
            for (const l of n) l[1](), so.push(l, s);
            if (h) {
                for (let l = 0; l < so.length; l += 2) so[l][0](so[l + 1]);
                so.length = 0;
            }
        }
    }
    function r(o) {
        i(o(s));
    }
    function a(o, h = ts) {
        const l = [o, h];
        return (
            n.add(l),
            n.size === 1 && (t = e(i, r) || ts),
            o(s),
            () => {
                n.delete(l), n.size === 0 && t && (t(), (t = null));
            }
        );
    }
    return { set: i, update: r, subscribe: a };
}
function Mi(s, e, t) {
    const n = !Array.isArray(s),
        i = n ? [s] : s;
    if (!i.every(Boolean))
        throw new Error("derived() expects stores as input, got a falsy value");
    const r = e.length < 2;
    return Tw(t, (a, o) => {
        let h = !1;
        const l = [];
        let u = 0,
            c = ts;
        const d = () => {
                if (u) return;
                c();
                const p = e(n ? l[0] : l, a, o);
                r ? a(p) : (c = typeof p == "function" ? p : ts);
            },
            f = i.map((p, m) =>
                rg(
                    p,
                    (g) => {
                        (l[m] = g), (u &= ~(1 << m)), h && d();
                    },
                    () => {
                        u |= 1 << m;
                    }
                )
            );
        return (
            (h = !0),
            d(),
            function () {
                jm(f), c(), (h = !1);
            }
        );
    });
}
function Q(s) {
    let e;
    return rg(s, (t) => (e = t))(), e;
}
let Op = Symbol();
function U(s, e, t) {
    const n =
        t[e] ?? (t[e] = { store: null, source: nw(void 0), unsubscribe: ts });
    if (n.store !== s && !(Op in t))
        if ((n.unsubscribe(), (n.store = s ?? null), s == null))
            (n.source.v = void 0), (n.unsubscribe = ts);
        else {
            var i = !0;
            (n.unsubscribe = rg(s, (r) => {
                i ? (n.source.v = r) : Re(n.source, r);
            })),
                (i = !1);
        }
    return s && Op in t ? Q(s) : $(n.source);
}
function Ia(s, e) {
    return s.set(e), e;
}
function tt() {
    const s = {};
    function e() {
        hw(() => {
            for (var t in s) s[t].unsubscribe();
            du(s, Op, { enumerable: !1, value: !0 });
        });
    }
    return [s, e];
}
function y0(s, e, t, n) {
    var i = n,
        r = !0,
        a = () => (r && ((r = !1), (i = n)), i),
        o;
    (o = s[e]), o === void 0 && n !== void 0 && (o = a());
    var h;
    return (
        (h = () => {
            var l = s[e];
            return l === void 0 ? a() : ((r = !0), l);
        }),
        h
    );
}
function _u(s) {
    pE(() => {
        s();
        var e = Ie;
        (e.f & as) !== 0 && (XS(), Pn(e, hr));
    });
}
function Fs(s) {
    os === null && Gy(),
        _n(() => {
            const e = Xa(s);
            if (typeof e == "function") return e;
        });
}
function gd(s) {
    os === null && Gy(), Fs(() => () => Xa(s));
}
const GE = "5";
var Ny;
typeof window < "u" &&
    (
        (Ny = window.__svelte ?? (window.__svelte = {})).v ?? (Ny.v = new Set())
    ).add(GE);
function w0(s) {
    return Object.prototype.toString.call(s) === "[object Date]";
}
function jE(s) {
    return s;
}
function ag(s) {
    const e = s - 1;
    return e * e * e + 1;
}
function Bp(s, e) {
    if (s === e || s !== s) return () => s;
    const t = typeof s;
    if (t !== typeof e || Array.isArray(s) !== Array.isArray(e))
        throw new Error("Cannot interpolate values of different type");
    if (Array.isArray(s)) {
        const n = e.map((i, r) => Bp(s[r], i));
        return (i) => n.map((r) => r(i));
    }
    if (t === "object") {
        if (!s || !e) throw new Error("Object cannot be null");
        if (w0(s) && w0(e)) {
            const r = s.getTime(),
                o = e.getTime() - r;
            return (h) => new Date(r + h * o);
        }
        const n = Object.keys(e),
            i = {};
        return (
            n.forEach((r) => {
                i[r] = Bp(s[r], e[r]);
            }),
            (r) => {
                const a = {};
                return (
                    n.forEach((o) => {
                        a[o] = i[o](r);
                    }),
                    a
                );
            }
        );
    }
    if (t === "number") {
        const n = e - s;
        return (i) => s + i * n;
    }
    return () => e;
}
function _d(s, e = {}) {
    const t = fe(s);
    let n,
        i = s;
    function r(a, o) {
        if (((i = a), s == null)) return t.set((s = a)), Promise.resolve();
        let h = n,
            l = !1,
            {
                delay: u = 0,
                duration: c = 400,
                easing: d = jE,
                interpolate: f = Bp,
            } = { ...e, ...o };
        if (c === 0)
            return (
                h && (h.abort(), (h = null)), t.set((s = i)), Promise.resolve()
            );
        const p = mi.now() + u;
        let m;
        return (
            (n = kw((g) => {
                if (g < p) return !0;
                l ||
                    ((m = f(s, a)),
                    typeof c == "function" && (c = c(s, a)),
                    (l = !0)),
                    h && (h.abort(), (h = null));
                const _ = g - p;
                return _ > c
                    ? (t.set((s = a)), !1)
                    : (t.set((s = m(d(_ / c)))), !0);
            })),
            n.promise
        );
    }
    return { set: r, update: (a, o) => r(a(i, s), o), subscribe: t.subscribe };
}
const rf = { mobile: 661, mobileHeight: 449 },
    Ye = fe({ width: 0, height: 0 });
Mi(Ye, ({ width: s, height: e }) => s / e);
const us = Mi(Ye, (s) => {
        const { width: e, height: t } = s;
        return e === 0 && t === 0
            ? "desktop"
            : (t < rf.mobileHeight || (e < rf.mobile && e > t)) && e > t
            ? "landscape"
            : e < rf.mobile
            ? "portrait"
            : "desktop";
    }),
    Wi = fe(!1);
let WE = rn({ paused: !1 });
const Mw = rn({ authenticated: !1 }),
    Qe = rn({
        replay: !1,
        event: 0,
        version: 0,
        mode: "BASE",
        game: "",
        currency: "USD",
        lang: "en",
        amount: 1e6,
    });
function XE(s) {
    WE.paused = s;
}
let Ke = rn({
    forceUpdateBalanceFromServer: !1,
    instantBalance: 0,
    displayBalance: _d(0),
    update: ({ duration: s = 500, delay: e = 0 } = {}) =>
        Ke.displayBalance.set(Ke.instantBalance, { duration: s, delay: e }),
});
const Os = fe("BASE"),
    Nt = fe(0),
    vu = Mi([Nt, Os], ([s, e]) => s * Q(lc)[e].costMultiplier),
    Ra = fe(0),
    ml = fe([1, 5, 25, 50, 75, 100, 200, 500, 800, 1e3]),
    wi = fe(!1),
    xi = fe(!1),
    Fp = fe(1 / 0),
    da = fe(0),
    og = Mi(da, (s) => s > 0),
    br = fe(!1),
    qo = fe(!1),
    Iw = fe(!0),
    Us = fe("default"),
    ah = fe(!1),
    Ki = fe(!1),
    Sh = _d(0, { easing: ag, duration: 500 }),
    af = (s) => Mi(Ra, (e) => e * s),
    Zc = _d(0, { easing: ag, duration: 500 }),
    lg = fe(0),
    aa = fe(!1),
    Te = rn({
        turbo: !1,
        baseTurbo: !1,
        toggleBaseTurbo: () => {
            (Te.baseTurbo = !Te.baseTurbo), (Te.turbo = Te.baseTurbo);
        },
        resetBaseTurbo: () => {
            Te.turbo = Te.baseTurbo;
        },
        toggleBonusTurbo: () => {
            Te.turbo = !Te.turbo;
        },
    });
let bu = rn({ disabled: !1 });
Mi(aa, (s) => (s ? 2 : 1));
const Eh = fe(1),
    qE = Mi(Eh, (s) => s > 0),
    Ph = fe(1),
    HE = Mi(Ph, (s) => s > 0),
    Ws = fe("idle"),
    Ys = fe("base"),
    Cc = rn({
        mode: "base",
        bonusType: void 0,
        setMode: (s) => {
            s === "bonus" || s === "super" || s === "epic"
                ? ((Cc.mode = "bonus"), (Cc.bonusType = s), Ys.set("bonus"))
                : (s === "base" || !s) &&
                  ((Cc.mode = "base"), (Cc.bonusType = void 0), Ys.set("base"));
        },
    }),
    vd = _d(0);
Mi(vd, (s) => (s === 1 ? "100" : String((s * 100).toFixed(2))));
const gl = Mi(vd, (s) => s === 1),
    hg = fe(!1),
    cg = fe(!1),
    _l = fe(!1),
    lc = fe(),
    Rw = fe(),
    KE = fe(),
    Lw = fe(),
    Js = fe(),
    To = fe(),
    Qc = fe("en"),
    Mo = fe(""),
    ba = fe(),
    x0 = fe(!1),
    ya = fe(),
    ei = fe(),
    Ow = fe(),
    ZE = fe(),
    gi = rn({ loading: !1, data: null, error: null });
function QE() {
    const s = new Set();
    return {
        getSubscriptions: () => s,
        next: (e) => {
            s.forEach((t) => {
                t(e);
            });
        },
        subscribe: (e) => (
            s.add(e),
            function () {
                s.delete(e);
            }
        ),
    };
}
function JE() {
    const s = QE(),
        e = (i) => {
            const r = s.getSubscriptions();
            return Promise.all(Array.from(r).map((a) => a(i)) || []);
        },
        t = (i) =>
            s.subscribe((r) => {
                const a = r.type in i ? i[r.type] : void 0;
                if (a) return a(r);
            });
    return {
        register: (i) => {
            t(i);
        },
        registerEvent: t,
        asyncNext: e,
        next: s.next,
    };
}
function eP() {
    return { emitter: JE() };
}
const De = eP().emitter,
    ye = rn({ skip: !1 });
async function C0(s, e = 2e3) {
    return new Promise((t, n) => {
        let i = null,
            r = null;
        const a = () => {
            i && (clearTimeout(i), (i = null)),
                r && (cancelAnimationFrame(r), (r = null));
        };
        i = setTimeout(() => {
            a(), t();
        }, e);
        const o = () => {
            if (ye.skip) {
                De.next({ type: "skipInvoked" }), a();
                try {
                    s(), t();
                } catch (h) {
                    n(h);
                }
                return;
            }
            r = requestAnimationFrame(o);
        };
        o();
    });
}
const bd = typeof window < "u" && typeof document < "u",
    of =
        bd && typeof window.requestAnimationFrame == "function"
            ? window.requestAnimationFrame.bind(window)
            : (s) => setTimeout(() => s(Date.now()), 16);
let Jc = bd ? !document.hidden : !0;
if (bd) {
    const s = () => {
            Jc = !document.hidden;
        },
        e = () => {
            Jc = !0;
        },
        t = () => {
            Jc = !document.hidden;
        };
    document.addEventListener("visibilitychange", s),
        window.addEventListener("focus", e),
        window.addEventListener("blur", t);
}
const tP = (s, e) =>
        new Promise((t) => {
            if (!bd) {
                if (e()) {
                    t();
                    return;
                }
                setTimeout(t, s);
                return;
            }
            if (s <= 0 || e()) {
                t();
                return;
            }
            let n = 0,
                i = null;
            const r = (a) => {
                if (e()) {
                    t();
                    return;
                }
                if (!Jc) {
                    (i = null), of(r);
                    return;
                }
                if ((i === null && (i = a), (n += a - i), (i = a), n >= s)) {
                    t();
                    return;
                }
                of(r);
            };
            of(r);
        }),
    Le = (s) => tP(s, () => !1),
    kh = (s, e) => {
        let t = !1;
        return (
            (async () => (await Le(e), t || s()))(),
            {
                cancel: () => {
                    t = !0;
                },
            }
        );
    },
    A0 = (s, e, t = 200, n) =>
        new Promise((i) => {
            s.forEach((r, a) => {
                (async () => (
                    await Le(a * t), e(r, a), a === s.length - 1 && i()
                ))();
            });
        }),
    nr = (s, e = "USD", t = "en-US") =>
        e === "XGC"
            ? `GC ${new Intl.NumberFormat(t, {
                  style: "decimal",
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
              }).format(s)}`
            : e === "XSC"
            ? `SC ${new Intl.NumberFormat(t, {
                  style: "decimal",
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
              }).format(s)}`
            : new Intl.NumberFormat(t, {
                  style: "currency",
                  currency: e,
              }).format(s),
    nP = (s) => {
        const e = {
                value: s,
                isDown: !1,
                isUp: !1,
                press: void 0,
                release: void 0,
                downHandler: (i) => {
                    i.key === e.value &&
                        (e.isUp && e.press && e.press(),
                        (e.isDown = !0),
                        (e.isUp = !1),
                        i.preventDefault());
                },
                upHandler: (i) => {
                    i.key === e.value &&
                        (e.isDown && e.release && e.release(),
                        (e.isDown = !1),
                        (e.isUp = !0),
                        i.preventDefault());
                },
                unsubscribe: () => {
                    window.removeEventListener("keydown", t),
                        window.removeEventListener("keyup", n);
                },
            },
            t = e.downHandler.bind(e),
            n = e.upHandler.bind(e);
        return (
            window.addEventListener("keydown", t, !1),
            window.addEventListener("keyup", n, !1),
            e
        );
    },
    es = 1e6,
    sP = (s) => ({ reel: s[0], row: s[1] }),
    lf = (s) => s.map((e) => sP(e)),
    iP = 16777215,
    rP = 0;
function hf(s) {
    return s && typeof s == "object" && !Array.isArray(s);
}
function $p(s, ...e) {
    if (!e.length) return s;
    const t = e.shift();
    if (hf(s) && hf(t))
        for (const n in t)
            hf(t[n])
                ? (s[n] || Object.assign(s, { [n]: {} }), $p(s[n], t[n]))
                : Object.assign(s, { [n]: t[n] });
    return $p(s, ...e);
}
const Bw = typeof window < "u" && typeof document < "u",
    aP = () => (Bw ? !document.hidden : !0);
Tw(aP(), (s) => {
    if (!Bw) return () => {};
    const e = () => s(!document.hidden);
    return (
        document.addEventListener("visibilitychange", e),
        window.addEventListener("blur", e),
        window.addEventListener("focus", e),
        () => {
            document.removeEventListener("visibilitychange", e),
                window.removeEventListener("blur", e),
                window.removeEventListener("focus", e);
        }
    );
});
const ug = fe(),
    oP = (s) => Q(ug).stage.getChildByLabel(s, !0),
    go = (s) => {
        Q(ug).stage.addChild(s);
    },
    Fw = (s, e, t) => {
        const n = oP(s);
        if (!n) {
            console.warn(`No Spine found with label: ${s}`);
            return;
        }
        n.addSlotObject(e, t);
    },
    lP = (s, e = 0, t = 0) => {
        (s.x = Q(Ye).width / 2 + e), (s.y = Q(Ye).height / 2 + t);
    },
    S0 = ({ container: s, maxDimensions: e, originalDimensions: t }) => {
        const n = e.width / t.width,
            i = e.height / t.height,
            r = Math.min(Q(Ye).width / e.width, 1) * n,
            a = Math.min(Q(Ye).height / e.height, 1) * i;
        s.scale = Math.min(r, a, n, i);
    };
function Yi(s) {
    if (s === void 0)
        throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
        );
    return s;
}
function $w(s, e) {
    (s.prototype = Object.create(e.prototype)),
        (s.prototype.constructor = s),
        (s.__proto__ = e);
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var is = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: { lineHeight: "" },
    },
    Ho = { duration: 0.5, overwrite: !1, delay: 0 },
    dg,
    ln,
    _t,
    Cs = 1e8,
    st = 1 / Cs,
    Dp = Math.PI * 2,
    hP = Dp / 4,
    cP = 0,
    Dw = Math.sqrt,
    uP = Math.cos,
    dP = Math.sin,
    Zt = function (e) {
        return typeof e == "string";
    },
    Et = function (e) {
        return typeof e == "function";
    },
    sr = function (e) {
        return typeof e == "number";
    },
    fg = function (e) {
        return typeof e > "u";
    },
    Si = function (e) {
        return typeof e == "object";
    },
    Un = function (e) {
        return e !== !1;
    },
    pg = function () {
        return typeof window < "u";
    },
    Ac = function (e) {
        return Et(e) || Zt(e);
    },
    Nw =
        (typeof ArrayBuffer == "function" && ArrayBuffer.isView) ||
        function () {},
    vn = Array.isArray,
    Np = /(?:-?\.?\d|\.)+/gi,
    Vw = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    bo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    cf = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    Uw = /[+-]=-?[.\d]+/,
    zw = /[^,'"\[\]\s]+/gi,
    fP = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    yt,
    fi,
    Vp,
    mg,
    ls = {},
    yu = {},
    Yw,
    Gw = function (e) {
        return (yu = Ko(e, ls)) && jn;
    },
    gg = function (e, t) {
        return console.warn(
            "Invalid property",
            e,
            "set to",
            t,
            "Missing plugin? gsap.registerPlugin()"
        );
    },
    Th = function (e, t) {
        return !t && console.warn(e);
    },
    jw = function (e, t) {
        return (e && (ls[e] = t) && yu && (yu[e] = t)) || ls;
    },
    Mh = function () {
        return 0;
    },
    pP = { suppressEvents: !0, isStart: !0, kill: !1 },
    eu = { suppressEvents: !0, kill: !1 },
    mP = { suppressEvents: !0 },
    _g = {},
    $r = [],
    Up = {},
    Ww,
    Jn = {},
    uf = {},
    E0 = 30,
    tu = [],
    vg = "",
    bg = function (e) {
        var t = e[0],
            n,
            i;
        if ((Si(t) || Et(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
            for (i = tu.length; i-- && !tu[i].targetTest(t); );
            n = tu[i];
        }
        for (i = e.length; i--; )
            (e[i] && (e[i]._gsap || (e[i]._gsap = new g1(e[i], n)))) ||
                e.splice(i, 1);
        return e;
    },
    wa = function (e) {
        return e._gsap || bg(As(e))[0]._gsap;
    },
    Xw = function (e, t, n) {
        return (n = e[t]) && Et(n)
            ? e[t]()
            : (fg(n) && e.getAttribute && e.getAttribute(t)) || n;
    },
    zn = function (e, t) {
        return (e = e.split(",")).forEach(t) || e;
    },
    Rt = function (e) {
        return Math.round(e * 1e5) / 1e5 || 0;
    },
    Dt = function (e) {
        return Math.round(e * 1e7) / 1e7 || 0;
    },
    Io = function (e, t) {
        var n = t.charAt(0),
            i = parseFloat(t.substr(2));
        return (
            (e = parseFloat(e)),
            n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
        );
    },
    gP = function (e, t) {
        for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
        return i < n;
    },
    wu = function () {
        var e = $r.length,
            t = $r.slice(0),
            n,
            i;
        for (Up = {}, $r.length = 0, n = 0; n < e; n++)
            (i = t[n]),
                i &&
                    i._lazy &&
                    (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
    },
    yg = function (e) {
        return !!(e._initted || e._startAt || e.add);
    },
    qw = function (e, t, n, i) {
        $r.length && !ln && wu(),
            e.render(t, n, !!(ln && t < 0 && yg(e))),
            $r.length && !ln && wu();
    },
    Hw = function (e) {
        var t = parseFloat(e);
        return (t || t === 0) && (e + "").match(zw).length < 2
            ? t
            : Zt(e)
            ? e.trim()
            : e;
    },
    Kw = function (e) {
        return e;
    },
    hs = function (e, t) {
        for (var n in t) n in e || (e[n] = t[n]);
        return e;
    },
    _P = function (e) {
        return function (t, n) {
            for (var i in n)
                i in t ||
                    (i === "duration" && e) ||
                    i === "ease" ||
                    (t[i] = n[i]);
        };
    },
    Ko = function (e, t) {
        for (var n in t) e[n] = t[n];
        return e;
    },
    P0 = function s(e, t) {
        for (var n in t)
            n !== "__proto__" &&
                n !== "constructor" &&
                n !== "prototype" &&
                (e[n] = Si(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
        return e;
    },
    xu = function (e, t) {
        var n = {},
            i;
        for (i in e) i in t || (n[i] = e[i]);
        return n;
    },
    oh = function (e) {
        var t = e.parent || yt,
            n = e.keyframes ? _P(vn(e.keyframes)) : hs;
        if (Un(e.inherit))
            for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
        return e;
    },
    vP = function (e, t) {
        for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; );
        return n < 0;
    },
    Zw = function (e, t, n, i, r) {
        var a = e[i],
            o;
        if (r) for (o = t[r]; a && a[r] > o; ) a = a._prev;
        return (
            a
                ? ((t._next = a._next), (a._next = t))
                : ((t._next = e[n]), (e[n] = t)),
            t._next ? (t._next._prev = t) : (e[i] = t),
            (t._prev = a),
            (t.parent = t._dp = e),
            t
        );
    },
    yd = function (e, t, n, i) {
        n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
        var r = t._prev,
            a = t._next;
        r ? (r._next = a) : e[n] === t && (e[n] = a),
            a ? (a._prev = r) : e[i] === t && (e[i] = r),
            (t._next = t._prev = t.parent = null);
    },
    zr = function (e, t) {
        e.parent &&
            (!t || e.parent.autoRemoveChildren) &&
            e.parent.remove &&
            e.parent.remove(e),
            (e._act = 0);
    },
    xa = function (e, t) {
        if (e && (!t || t._end > e._dur || t._start < 0))
            for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
        return e;
    },
    bP = function (e) {
        for (var t = e.parent; t && t.parent; )
            (t._dirty = 1), t.totalDuration(), (t = t.parent);
        return e;
    },
    zp = function (e, t, n, i) {
        return (
            e._startAt &&
            (ln
                ? e._startAt.revert(eu)
                : (e.vars.immediateRender && !e.vars.autoRevert) ||
                  e._startAt.render(t, !0, i))
        );
    },
    yP = function s(e) {
        return !e || (e._ts && s(e.parent));
    },
    k0 = function (e) {
        return e._repeat ? Zo(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
    },
    Zo = function (e, t) {
        var n = Math.floor((e = Dt(e / t)));
        return e && n === e ? n - 1 : n;
    },
    Cu = function (e, t) {
        return (
            (e - t._start) * t._ts +
            (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        );
    },
    wd = function (e) {
        return (e._end = Dt(
            e._start + (e._tDur / Math.abs(e._ts || e._rts || st) || 0)
        ));
    },
    xd = function (e, t) {
        var n = e._dp;
        return (
            n &&
                n.smoothChildTiming &&
                e._ts &&
                ((e._start = Dt(
                    n._time -
                        (e._ts > 0
                            ? t / e._ts
                            : ((e._dirty ? e.totalDuration() : e._tDur) - t) /
                              -e._ts)
                )),
                wd(e),
                n._dirty || xa(n, e)),
            e
        );
    },
    Qw = function (e, t) {
        var n;
        if (
            ((t._time ||
                (!t._dur && t._initted) ||
                (t._start < e._time && (t._dur || !t.add))) &&
                ((n = Cu(e.rawTime(), t)),
                (!t._dur || hc(0, t.totalDuration(), n) - t._tTime > st) &&
                    t.render(n, !0)),
            xa(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
        ) {
            if (e._dur < e.duration())
                for (n = e; n._dp; )
                    n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
            e._zTime = -st;
        }
    },
    _i = function (e, t, n, i) {
        return (
            t.parent && zr(t),
            (t._start = Dt(
                (sr(n) ? n : n || e !== yt ? bs(e, n, t) : e._time) + t._delay
            )),
            (t._end = Dt(
                t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
            )),
            Zw(e, t, "_first", "_last", e._sort ? "_start" : 0),
            Yp(t) || (e._recent = t),
            i || Qw(e, t),
            e._ts < 0 && xd(e, e._tTime),
            e
        );
    },
    Jw = function (e, t) {
        return (
            (ls.ScrollTrigger || gg("scrollTrigger", t)) &&
            ls.ScrollTrigger.create(t, e)
        );
    },
    e1 = function (e, t, n, i, r) {
        if ((xg(e, t, r), !e._initted)) return 1;
        if (
            !n &&
            e._pt &&
            !ln &&
            ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
            Ww !== ns.frame
        )
            return $r.push(e), (e._lazy = [r, i]), 1;
    },
    wP = function s(e) {
        var t = e.parent;
        return (
            t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t))
        );
    },
    Yp = function (e) {
        var t = e.data;
        return t === "isFromStart" || t === "isStart";
    },
    xP = function (e, t, n, i) {
        var r = e.ratio,
            a =
                t < 0 ||
                (!t &&
                    ((!e._start && wP(e) && !(!e._initted && Yp(e))) ||
                        ((e._ts < 0 || e._dp._ts < 0) && !Yp(e))))
                    ? 0
                    : 1,
            o = e._rDelay,
            h = 0,
            l,
            u,
            c;
        if (
            (o &&
                e._repeat &&
                ((h = hc(0, e._tDur, t)),
                (u = Zo(h, o)),
                e._yoyo && u & 1 && (a = 1 - a),
                u !== Zo(e._tTime, o) &&
                    ((r = 1 - a),
                    e.vars.repeatRefresh && e._initted && e.invalidate())),
            a !== r || ln || i || e._zTime === st || (!t && e._zTime))
        ) {
            if (!e._initted && e1(e, t, i, n, h)) return;
            for (
                c = e._zTime,
                    e._zTime = t || (n ? st : 0),
                    n || (n = t && !c),
                    e.ratio = a,
                    e._from && (a = 1 - a),
                    e._time = 0,
                    e._tTime = h,
                    l = e._pt;
                l;

            )
                l.r(a, l.d), (l = l._next);
            t < 0 && zp(e, t, n, !0),
                e._onUpdate && !n && ss(e, "onUpdate"),
                h && e._repeat && !n && e.parent && ss(e, "onRepeat"),
                (t >= e._tDur || t < 0) &&
                    e.ratio === a &&
                    (a && zr(e, 1),
                    !n &&
                        !ln &&
                        (ss(e, a ? "onComplete" : "onReverseComplete", !0),
                        e._prom && e._prom()));
        } else e._zTime || (e._zTime = t);
    },
    CP = function (e, t, n) {
        var i;
        if (n > t)
            for (i = e._first; i && i._start <= n; ) {
                if (i.data === "isPause" && i._start > t) return i;
                i = i._next;
            }
        else
            for (i = e._last; i && i._start >= n; ) {
                if (i.data === "isPause" && i._start < t) return i;
                i = i._prev;
            }
    },
    Qo = function (e, t, n, i) {
        var r = e._repeat,
            a = Dt(t) || 0,
            o = e._tTime / e._tDur;
        return (
            o && !i && (e._time *= a / e._dur),
            (e._dur = a),
            (e._tDur = r
                ? r < 0
                    ? 1e10
                    : Dt(a * (r + 1) + e._rDelay * r)
                : a),
            o > 0 && !i && xd(e, (e._tTime = e._tDur * o)),
            e.parent && wd(e),
            n || xa(e.parent, e),
            e
        );
    },
    T0 = function (e) {
        return e instanceof Cn ? xa(e) : Qo(e, e._dur);
    },
    AP = { _start: 0, endTime: Mh, totalDuration: Mh },
    bs = function s(e, t, n) {
        var i = e.labels,
            r = e._recent || AP,
            a = e.duration() >= Cs ? r.endTime(!1) : e._dur,
            o,
            h,
            l;
        return Zt(t) && (isNaN(t) || t in i)
            ? ((h = t.charAt(0)),
              (l = t.substr(-1) === "%"),
              (o = t.indexOf("=")),
              h === "<" || h === ">"
                  ? (o >= 0 && (t = t.replace(/=/, "")),
                    (h === "<" ? r._start : r.endTime(r._repeat >= 0)) +
                        (parseFloat(t.substr(1)) || 0) *
                            (l ? (o < 0 ? r : n).totalDuration() / 100 : 1))
                  : o < 0
                  ? (t in i || (i[t] = a), i[t])
                  : ((h = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
                    l &&
                        n &&
                        (h = (h / 100) * (vn(n) ? n[0] : n).totalDuration()),
                    o > 1 ? s(e, t.substr(0, o - 1), n) + h : a + h))
            : t == null
            ? a
            : +t;
    },
    lh = function (e, t, n) {
        var i = sr(t[1]),
            r = (i ? 2 : 1) + (e < 2 ? 0 : 1),
            a = t[r],
            o,
            h;
        if ((i && (a.duration = t[1]), (a.parent = n), e)) {
            for (o = a, h = n; h && !("immediateRender" in o); )
                (o = h.vars.defaults || {}),
                    (h = Un(h.vars.inherit) && h.parent);
            (a.immediateRender = Un(o.immediateRender)),
                e < 2 ? (a.runBackwards = 1) : (a.startAt = t[r - 1]);
        }
        return new $t(t[0], a, t[r + 1]);
    },
    qr = function (e, t) {
        return e || e === 0 ? t(e) : t;
    },
    hc = function (e, t, n) {
        return n < e ? e : n > t ? t : n;
    },
    mn = function (e, t) {
        return !Zt(e) || !(t = fP.exec(e)) ? "" : t[1];
    },
    SP = function (e, t, n) {
        return qr(n, function (i) {
            return hc(e, t, i);
        });
    },
    Gp = [].slice,
    t1 = function (e, t) {
        return (
            e &&
            Si(e) &&
            "length" in e &&
            ((!t && !e.length) || (e.length - 1 in e && Si(e[0]))) &&
            !e.nodeType &&
            e !== fi
        );
    },
    EP = function (e, t, n) {
        return (
            n === void 0 && (n = []),
            e.forEach(function (i) {
                var r;
                return (Zt(i) && !t) || t1(i, 1)
                    ? (r = n).push.apply(r, As(i))
                    : n.push(i);
            }) || n
        );
    },
    As = function (e, t, n) {
        return _t && !t && _t.selector
            ? _t.selector(e)
            : Zt(e) && !n && (Vp || !Jo())
            ? Gp.call((t || mg).querySelectorAll(e), 0)
            : vn(e)
            ? EP(e, n)
            : t1(e)
            ? Gp.call(e, 0)
            : e
            ? [e]
            : [];
    },
    jp = function (e) {
        return (
            (e = As(e)[0] || Th("Invalid scope") || {}),
            function (t) {
                var n = e.current || e.nativeElement || e;
                return As(
                    t,
                    n.querySelectorAll
                        ? n
                        : n === e
                        ? Th("Invalid scope") || mg.createElement("div")
                        : e
                );
            }
        );
    },
    n1 = function (e) {
        return e.sort(function () {
            return 0.5 - Math.random();
        });
    },
    s1 = function (e) {
        if (Et(e)) return e;
        var t = Si(e) ? e : { each: e },
            n = Ca(t.ease),
            i = t.from || 0,
            r = parseFloat(t.base) || 0,
            a = {},
            o = i > 0 && i < 1,
            h = isNaN(i) || o,
            l = t.axis,
            u = i,
            c = i;
        return (
            Zt(i)
                ? (u = c = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
                : !o && h && ((u = i[0]), (c = i[1])),
            function (d, f, p) {
                var m = (p || t).length,
                    g = a[m],
                    _,
                    v,
                    b,
                    y,
                    C,
                    w,
                    A,
                    E,
                    S;
                if (!g) {
                    if (
                        ((S = t.grid === "auto" ? 0 : (t.grid || [1, Cs])[1]),
                        !S)
                    ) {
                        for (
                            A = -Cs;
                            A < (A = p[S++].getBoundingClientRect().left) &&
                            S < m;

                        );
                        S < m && S--;
                    }
                    for (
                        g = a[m] = [],
                            _ = h ? Math.min(S, m) * u - 0.5 : i % S,
                            v =
                                S === Cs
                                    ? 0
                                    : h
                                    ? (m * c) / S - 0.5
                                    : (i / S) | 0,
                            A = 0,
                            E = Cs,
                            w = 0;
                        w < m;
                        w++
                    )
                        (b = (w % S) - _),
                            (y = v - ((w / S) | 0)),
                            (g[w] = C =
                                l
                                    ? Math.abs(l === "y" ? y : b)
                                    : Dw(b * b + y * y)),
                            C > A && (A = C),
                            C < E && (E = C);
                    i === "random" && n1(g),
                        (g.max = A - E),
                        (g.min = E),
                        (g.v = m =
                            (parseFloat(t.amount) ||
                                parseFloat(t.each) *
                                    (S > m
                                        ? m - 1
                                        : l
                                        ? l === "y"
                                            ? m / S
                                            : S
                                        : Math.max(S, m / S)) ||
                                0) * (i === "edges" ? -1 : 1)),
                        (g.b = m < 0 ? r - m : r),
                        (g.u = mn(t.amount || t.each) || 0),
                        (n = n && m < 0 ? f1(n) : n);
                }
                return (
                    (m = (g[d] - g.min) / g.max || 0),
                    Dt(g.b + (n ? n(m) : m) * g.v) + g.u
                );
            }
        );
    },
    Wp = function (e) {
        var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
        return function (n) {
            var i = Dt(Math.round(parseFloat(n) / e) * e * t);
            return (i - (i % 1)) / t + (sr(n) ? 0 : mn(n));
        };
    },
    i1 = function (e, t) {
        var n = vn(e),
            i,
            r;
        return (
            !n &&
                Si(e) &&
                ((i = n = e.radius || Cs),
                e.values
                    ? ((e = As(e.values)), (r = !sr(e[0])) && (i *= i))
                    : (e = Wp(e.increment))),
            qr(
                t,
                n
                    ? Et(e)
                        ? function (a) {
                              return (r = e(a)), Math.abs(r - a) <= i ? r : a;
                          }
                        : function (a) {
                              for (
                                  var o = parseFloat(r ? a.x : a),
                                      h = parseFloat(r ? a.y : 0),
                                      l = Cs,
                                      u = 0,
                                      c = e.length,
                                      d,
                                      f;
                                  c--;

                              )
                                  r
                                      ? ((d = e[c].x - o),
                                        (f = e[c].y - h),
                                        (d = d * d + f * f))
                                      : (d = Math.abs(e[c] - o)),
                                      d < l && ((l = d), (u = c));
                              return (
                                  (u = !i || l <= i ? e[u] : a),
                                  r || u === a || sr(a) ? u : u + mn(a)
                              );
                          }
                    : Wp(e)
            )
        );
    },
    r1 = function (e, t, n, i) {
        return qr(vn(e) ? !t : n === !0 ? !!(n = 0) : !i, function () {
            return vn(e)
                ? e[~~(Math.random() * e.length)]
                : (n = n || 1e-5) &&
                      (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                      Math.floor(
                          Math.round(
                              (e - n / 2 + Math.random() * (t - e + n * 0.99)) /
                                  n
                          ) *
                              n *
                              i
                      ) / i;
        });
    },
    PP = function () {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return function (i) {
            return t.reduce(function (r, a) {
                return a(r);
            }, i);
        };
    },
    kP = function (e, t) {
        return function (n) {
            return e(parseFloat(n)) + (t || mn(n));
        };
    },
    TP = function (e, t, n) {
        return o1(e, t, 0, 1, n);
    },
    a1 = function (e, t, n) {
        return qr(n, function (i) {
            return e[~~t(i)];
        });
    },
    MP = function s(e, t, n) {
        var i = t - e;
        return vn(e)
            ? a1(e, s(0, e.length), t)
            : qr(n, function (r) {
                  return ((i + ((r - e) % i)) % i) + e;
              });
    },
    IP = function s(e, t, n) {
        var i = t - e,
            r = i * 2;
        return vn(e)
            ? a1(e, s(0, e.length - 1), t)
            : qr(n, function (a) {
                  return (
                      (a = (r + ((a - e) % r)) % r || 0),
                      e + (a > i ? r - a : a)
                  );
              });
    },
    Ih = function (e) {
        for (var t = 0, n = "", i, r, a, o; ~(i = e.indexOf("random(", t)); )
            (a = e.indexOf(")", i)),
                (o = e.charAt(i + 7) === "["),
                (r = e.substr(i + 7, a - i - 7).match(o ? zw : Np)),
                (n +=
                    e.substr(t, i - t) +
                    r1(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5)),
                (t = a + 1);
        return n + e.substr(t, e.length - t);
    },
    o1 = function (e, t, n, i, r) {
        var a = t - e,
            o = i - n;
        return qr(r, function (h) {
            return n + (((h - e) / a) * o || 0);
        });
    },
    RP = function s(e, t, n, i) {
        var r = isNaN(e + t)
            ? 0
            : function (f) {
                  return (1 - f) * e + f * t;
              };
        if (!r) {
            var a = Zt(e),
                o = {},
                h,
                l,
                u,
                c,
                d;
            if ((n === !0 && (i = 1) && (n = null), a))
                (e = { p: e }), (t = { p: t });
            else if (vn(e) && !vn(t)) {
                for (u = [], c = e.length, d = c - 2, l = 1; l < c; l++)
                    u.push(s(e[l - 1], e[l]));
                c--,
                    (r = function (p) {
                        p *= c;
                        var m = Math.min(d, ~~p);
                        return u[m](p - m);
                    }),
                    (n = t);
            } else i || (e = Ko(vn(e) ? [] : {}, e));
            if (!u) {
                for (h in t) wg.call(o, e, h, "get", t[h]);
                r = function (p) {
                    return Sg(p, o) || (a ? e.p : e);
                };
            }
        }
        return qr(n, r);
    },
    M0 = function (e, t, n) {
        var i = e.labels,
            r = Cs,
            a,
            o,
            h;
        for (a in i)
            (o = i[a] - t),
                o < 0 == !!n &&
                    o &&
                    r > (o = Math.abs(o)) &&
                    ((h = a), (r = o));
        return h;
    },
    ss = function (e, t, n) {
        var i = e.vars,
            r = i[t],
            a = _t,
            o = e._ctx,
            h,
            l,
            u;
        if (r)
            return (
                (h = i[t + "Params"]),
                (l = i.callbackScope || e),
                n && $r.length && wu(),
                o && (_t = o),
                (u = h ? r.apply(l, h) : r.call(l)),
                (_t = a),
                u
            );
    },
    Zl = function (e) {
        return (
            zr(e),
            e.scrollTrigger && e.scrollTrigger.kill(!!ln),
            e.progress() < 1 && ss(e, "onInterrupt"),
            e
        );
    },
    yo,
    l1 = [],
    h1 = function (e) {
        if (e)
            if (((e = (!e.name && e.default) || e), pg() || e.headless)) {
                var t = e.name,
                    n = Et(e),
                    i =
                        t && !n && e.init
                            ? function () {
                                  this._props = [];
                              }
                            : e,
                    r = {
                        init: Mh,
                        render: Sg,
                        add: wg,
                        kill: qP,
                        modifier: XP,
                        rawVars: 0,
                    },
                    a = {
                        targetTest: 0,
                        get: 0,
                        getSetter: Ag,
                        aliases: {},
                        register: 0,
                    };
                if ((Jo(), e !== i)) {
                    if (Jn[t]) return;
                    hs(i, hs(xu(e, r), a)),
                        Ko(i.prototype, Ko(r, xu(e, a))),
                        (Jn[(i.prop = t)] = i),
                        e.targetTest && (tu.push(i), (_g[t] = 1)),
                        (t =
                            (t === "css"
                                ? "CSS"
                                : t.charAt(0).toUpperCase() + t.substr(1)) +
                            "Plugin");
                }
                jw(t, i), e.register && e.register(jn, i, Yn);
            } else l1.push(e);
    },
    nt = 255,
    Ql = {
        aqua: [0, nt, nt],
        lime: [0, nt, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, nt],
        navy: [0, 0, 128],
        white: [nt, nt, nt],
        olive: [128, 128, 0],
        yellow: [nt, nt, 0],
        orange: [nt, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [nt, 0, 0],
        pink: [nt, 192, 203],
        cyan: [0, nt, nt],
        transparent: [nt, nt, nt, 0],
    },
    df = function (e, t, n) {
        return (
            (e += e < 0 ? 1 : e > 1 ? -1 : 0),
            ((e * 6 < 1
                ? t + (n - t) * e * 6
                : e < 0.5
                ? n
                : e * 3 < 2
                ? t + (n - t) * (2 / 3 - e) * 6
                : t) *
                nt +
                0.5) |
                0
        );
    },
    c1 = function (e, t, n) {
        var i = e ? (sr(e) ? [e >> 16, (e >> 8) & nt, e & nt] : 0) : Ql.black,
            r,
            a,
            o,
            h,
            l,
            u,
            c,
            d,
            f,
            p;
        if (!i) {
            if (
                (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Ql[e])
            )
                i = Ql[e];
            else if (e.charAt(0) === "#") {
                if (
                    (e.length < 6 &&
                        ((r = e.charAt(1)),
                        (a = e.charAt(2)),
                        (o = e.charAt(3)),
                        (e =
                            "#" +
                            r +
                            r +
                            a +
                            a +
                            o +
                            o +
                            (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
                    e.length === 9)
                )
                    return (
                        (i = parseInt(e.substr(1, 6), 16)),
                        [
                            i >> 16,
                            (i >> 8) & nt,
                            i & nt,
                            parseInt(e.substr(7), 16) / 255,
                        ]
                    );
                (e = parseInt(e.substr(1), 16)),
                    (i = [e >> 16, (e >> 8) & nt, e & nt]);
            } else if (e.substr(0, 3) === "hsl") {
                if (((i = p = e.match(Np)), !t))
                    (h = (+i[0] % 360) / 360),
                        (l = +i[1] / 100),
                        (u = +i[2] / 100),
                        (a = u <= 0.5 ? u * (l + 1) : u + l - u * l),
                        (r = u * 2 - a),
                        i.length > 3 && (i[3] *= 1),
                        (i[0] = df(h + 1 / 3, r, a)),
                        (i[1] = df(h, r, a)),
                        (i[2] = df(h - 1 / 3, r, a));
                else if (~e.indexOf("="))
                    return (
                        (i = e.match(Vw)), n && i.length < 4 && (i[3] = 1), i
                    );
            } else i = e.match(Np) || Ql.transparent;
            i = i.map(Number);
        }
        return (
            t &&
                !p &&
                ((r = i[0] / nt),
                (a = i[1] / nt),
                (o = i[2] / nt),
                (c = Math.max(r, a, o)),
                (d = Math.min(r, a, o)),
                (u = (c + d) / 2),
                c === d
                    ? (h = l = 0)
                    : ((f = c - d),
                      (l = u > 0.5 ? f / (2 - c - d) : f / (c + d)),
                      (h =
                          c === r
                              ? (a - o) / f + (a < o ? 6 : 0)
                              : c === a
                              ? (o - r) / f + 2
                              : (r - a) / f + 4),
                      (h *= 60)),
                (i[0] = ~~(h + 0.5)),
                (i[1] = ~~(l * 100 + 0.5)),
                (i[2] = ~~(u * 100 + 0.5))),
            n && i.length < 4 && (i[3] = 1),
            i
        );
    },
    u1 = function (e) {
        var t = [],
            n = [],
            i = -1;
        return (
            e.split(Dr).forEach(function (r) {
                var a = r.match(bo) || [];
                t.push.apply(t, a), n.push((i += a.length + 1));
            }),
            (t.c = n),
            t
        );
    },
    I0 = function (e, t, n) {
        var i = "",
            r = (e + i).match(Dr),
            a = t ? "hsla(" : "rgba(",
            o = 0,
            h,
            l,
            u,
            c;
        if (!r) return e;
        if (
            ((r = r.map(function (d) {
                return (
                    (d = c1(d, t, 1)) &&
                    a +
                        (t
                            ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3]
                            : d.join(",")) +
                        ")"
                );
            })),
            n && ((u = u1(e)), (h = n.c), h.join(i) !== u.c.join(i)))
        )
            for (l = e.replace(Dr, "1").split(bo), c = l.length - 1; o < c; o++)
                i +=
                    l[o] +
                    (~h.indexOf(o)
                        ? r.shift() || a + "0,0,0,0)"
                        : (u.length ? u : r.length ? r : n).shift());
        if (!l)
            for (l = e.split(Dr), c = l.length - 1; o < c; o++)
                i += l[o] + r[o];
        return i + l[c];
    },
    Dr = (function () {
        var s =
                "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            e;
        for (e in Ql) s += "|" + e + "\\b";
        return new RegExp(s + ")", "gi");
    })(),
    LP = /hsl[a]?\(/,
    d1 = function (e) {
        var t = e.join(" "),
            n;
        if (((Dr.lastIndex = 0), Dr.test(t)))
            return (
                (n = LP.test(t)),
                (e[1] = I0(e[1], n)),
                (e[0] = I0(e[0], n, u1(e[1]))),
                !0
            );
    },
    Rh,
    ns = (function () {
        var s = Date.now,
            e = 500,
            t = 33,
            n = s(),
            i = n,
            r = 1e3 / 240,
            a = r,
            o = [],
            h,
            l,
            u,
            c,
            d,
            f,
            p = function m(g) {
                var _ = s() - i,
                    v = g === !0,
                    b,
                    y,
                    C,
                    w;
                if (
                    ((_ > e || _ < 0) && (n += _ - t),
                    (i += _),
                    (C = i - n),
                    (b = C - a),
                    (b > 0 || v) &&
                        ((w = ++c.frame),
                        (d = C - c.time * 1e3),
                        (c.time = C = C / 1e3),
                        (a += b + (b >= r ? 4 : r - b)),
                        (y = 1)),
                    v || (h = l(m)),
                    y)
                )
                    for (f = 0; f < o.length; f++) o[f](C, d, w, g);
            };
        return (
            (c = {
                time: 0,
                frame: 0,
                tick: function () {
                    p(!0);
                },
                deltaRatio: function (g) {
                    return d / (1e3 / (g || 60));
                },
                wake: function () {
                    Yw &&
                        (!Vp &&
                            pg() &&
                            ((fi = Vp = window),
                            (mg = fi.document || {}),
                            (ls.gsap = jn),
                            (fi.gsapVersions || (fi.gsapVersions = [])).push(
                                jn.version
                            ),
                            Gw(
                                yu ||
                                    fi.GreenSockGlobals ||
                                    (!fi.gsap && fi) ||
                                    {}
                            ),
                            l1.forEach(h1)),
                        (u =
                            typeof requestAnimationFrame < "u" &&
                            requestAnimationFrame),
                        h && c.sleep(),
                        (l =
                            u ||
                            function (g) {
                                return setTimeout(
                                    g,
                                    (a - c.time * 1e3 + 1) | 0
                                );
                            }),
                        (Rh = 1),
                        p(2));
                },
                sleep: function () {
                    (u ? cancelAnimationFrame : clearTimeout)(h),
                        (Rh = 0),
                        (l = Mh);
                },
                lagSmoothing: function (g, _) {
                    (e = g || 1 / 0), (t = Math.min(_ || 33, e));
                },
                fps: function (g) {
                    (r = 1e3 / (g || 240)), (a = c.time * 1e3 + r);
                },
                add: function (g, _, v) {
                    var b = _
                        ? function (y, C, w, A) {
                              g(y, C, w, A), c.remove(b);
                          }
                        : g;
                    return c.remove(g), o[v ? "unshift" : "push"](b), Jo(), b;
                },
                remove: function (g, _) {
                    ~(_ = o.indexOf(g)) && o.splice(_, 1) && f >= _ && f--;
                },
                _listeners: o,
            }),
            c
        );
    })(),
    Jo = function () {
        return !Rh && ns.wake();
    },
    ke = {},
    OP = /^[\d.\-M][\d.\-,\s]/,
    BP = /["']/g,
    FP = function (e) {
        for (
            var t = {},
                n = e.substr(1, e.length - 3).split(":"),
                i = n[0],
                r = 1,
                a = n.length,
                o,
                h,
                l;
            r < a;
            r++
        )
            (h = n[r]),
                (o = r !== a - 1 ? h.lastIndexOf(",") : h.length),
                (l = h.substr(0, o)),
                (t[i] = isNaN(l) ? l.replace(BP, "").trim() : +l),
                (i = h.substr(o + 1).trim());
        return t;
    },
    $P = function (e) {
        var t = e.indexOf("(") + 1,
            n = e.indexOf(")"),
            i = e.indexOf("(", t);
        return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
    },
    DP = function (e) {
        var t = (e + "").split("("),
            n = ke[t[0]];
        return n && t.length > 1 && n.config
            ? n.config.apply(
                  null,
                  ~e.indexOf("{") ? [FP(t[1])] : $P(e).split(",").map(Hw)
              )
            : ke._CE && OP.test(e)
            ? ke._CE("", e)
            : n;
    },
    f1 = function (e) {
        return function (t) {
            return 1 - e(1 - t);
        };
    },
    p1 = function s(e, t) {
        for (var n = e._first, i; n; )
            n instanceof Cn
                ? s(n, t)
                : n.vars.yoyoEase &&
                  (!n._yoyo || !n._repeat) &&
                  n._yoyo !== t &&
                  (n.timeline
                      ? s(n.timeline, t)
                      : ((i = n._ease),
                        (n._ease = n._yEase),
                        (n._yEase = i),
                        (n._yoyo = t))),
                (n = n._next);
    },
    Ca = function (e, t) {
        return (e && (Et(e) ? e : ke[e] || DP(e))) || t;
    },
    qa = function (e, t, n, i) {
        n === void 0 &&
            (n = function (h) {
                return 1 - t(1 - h);
            }),
            i === void 0 &&
                (i = function (h) {
                    return h < 0.5 ? t(h * 2) / 2 : 1 - t((1 - h) * 2) / 2;
                });
        var r = { easeIn: t, easeOut: n, easeInOut: i },
            a;
        return (
            zn(e, function (o) {
                (ke[o] = ls[o] = r), (ke[(a = o.toLowerCase())] = n);
                for (var h in r)
                    ke[
                        a +
                            (h === "easeIn"
                                ? ".in"
                                : h === "easeOut"
                                ? ".out"
                                : ".inOut")
                    ] = ke[o + "." + h] = r[h];
            }),
            r
        );
    },
    m1 = function (e) {
        return function (t) {
            return t < 0.5
                ? (1 - e(1 - t * 2)) / 2
                : 0.5 + e((t - 0.5) * 2) / 2;
        };
    },
    ff = function s(e, t, n) {
        var i = t >= 1 ? t : 1,
            r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
            a = (r / Dp) * (Math.asin(1 / i) || 0),
            o = function (u) {
                return u === 1
                    ? 1
                    : i * Math.pow(2, -10 * u) * dP((u - a) * r) + 1;
            },
            h =
                e === "out"
                    ? o
                    : e === "in"
                    ? function (l) {
                          return 1 - o(1 - l);
                      }
                    : m1(o);
        return (
            (r = Dp / r),
            (h.config = function (l, u) {
                return s(e, l, u);
            }),
            h
        );
    },
    pf = function s(e, t) {
        t === void 0 && (t = 1.70158);
        var n = function (a) {
                return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
            },
            i =
                e === "out"
                    ? n
                    : e === "in"
                    ? function (r) {
                          return 1 - n(1 - r);
                      }
                    : m1(n);
        return (
            (i.config = function (r) {
                return s(e, r);
            }),
            i
        );
    };
zn("Linear,Quad,Cubic,Quart,Quint,Strong", function (s, e) {
    var t = e < 5 ? e + 1 : e;
    qa(
        s + ",Power" + (t - 1),
        e
            ? function (n) {
                  return Math.pow(n, t);
              }
            : function (n) {
                  return n;
              },
        function (n) {
            return 1 - Math.pow(1 - n, t);
        },
        function (n) {
            return n < 0.5
                ? Math.pow(n * 2, t) / 2
                : 1 - Math.pow((1 - n) * 2, t) / 2;
        }
    );
});
ke.Linear.easeNone = ke.none = ke.Linear.easeIn;
qa("Elastic", ff("in"), ff("out"), ff());
(function (s, e) {
    var t = 1 / e,
        n = 2 * t,
        i = 2.5 * t,
        r = function (o) {
            return o < t
                ? s * o * o
                : o < n
                ? s * Math.pow(o - 1.5 / e, 2) + 0.75
                : o < i
                ? s * (o -= 2.25 / e) * o + 0.9375
                : s * Math.pow(o - 2.625 / e, 2) + 0.984375;
        };
    qa(
        "Bounce",
        function (a) {
            return 1 - r(1 - a);
        },
        r
    );
})(7.5625, 2.75);
qa("Expo", function (s) {
    return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s);
});
qa("Circ", function (s) {
    return -(Dw(1 - s * s) - 1);
});
qa("Sine", function (s) {
    return s === 1 ? 1 : -uP(s * hP) + 1;
});
qa("Back", pf("in"), pf("out"), pf());
ke.SteppedEase =
    ke.steps =
    ls.SteppedEase =
        {
            config: function (e, t) {
                e === void 0 && (e = 1);
                var n = 1 / e,
                    i = e + (t ? 0 : 1),
                    r = t ? 1 : 0,
                    a = 1 - st;
                return function (o) {
                    return (((i * hc(0, a, o)) | 0) + r) * n;
                };
            },
        };
Ho.ease = ke["quad.out"];
zn(
    "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
    function (s) {
        return (vg += s + "," + s + "Params,");
    }
);
var g1 = function (e, t) {
        (this.id = cP++),
            (e._gsap = this),
            (this.target = e),
            (this.harness = t),
            (this.get = t ? t.get : Xw),
            (this.set = t ? t.getSetter : Ag);
    },
    Lh = (function () {
        function s(t) {
            (this.vars = t),
                (this._delay = +t.delay || 0),
                (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
                    ((this._rDelay = t.repeatDelay || 0),
                    (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
                (this._ts = 1),
                Qo(this, +t.duration, 1, 1),
                (this.data = t.data),
                _t && ((this._ctx = _t), _t.data.push(this)),
                Rh || ns.wake();
        }
        var e = s.prototype;
        return (
            (e.delay = function (n) {
                return n || n === 0
                    ? (this.parent &&
                          this.parent.smoothChildTiming &&
                          this.startTime(this._start + n - this._delay),
                      (this._delay = n),
                      this)
                    : this._delay;
            }),
            (e.duration = function (n) {
                return arguments.length
                    ? this.totalDuration(
                          this._repeat > 0
                              ? n + (n + this._rDelay) * this._repeat
                              : n
                      )
                    : this.totalDuration() && this._dur;
            }),
            (e.totalDuration = function (n) {
                return arguments.length
                    ? ((this._dirty = 0),
                      Qo(
                          this,
                          this._repeat < 0
                              ? n
                              : (n - this._repeat * this._rDelay) /
                                    (this._repeat + 1)
                      ))
                    : this._tDur;
            }),
            (e.totalTime = function (n, i) {
                if ((Jo(), !arguments.length)) return this._tTime;
                var r = this._dp;
                if (r && r.smoothChildTiming && this._ts) {
                    for (
                        xd(this, n), !r._dp || r.parent || Qw(r, this);
                        r && r.parent;

                    )
                        r.parent._time !==
                            r._start +
                                (r._ts >= 0
                                    ? r._tTime / r._ts
                                    : (r.totalDuration() - r._tTime) /
                                      -r._ts) && r.totalTime(r._tTime, !0),
                            (r = r.parent);
                    !this.parent &&
                        this._dp.autoRemoveChildren &&
                        ((this._ts > 0 && n < this._tDur) ||
                            (this._ts < 0 && n > 0) ||
                            (!this._tDur && !n)) &&
                        _i(this._dp, this, this._start - this._delay);
                }
                return (
                    (this._tTime !== n ||
                        (!this._dur && !i) ||
                        (this._initted && Math.abs(this._zTime) === st) ||
                        (!n &&
                            !this._initted &&
                            (this.add || this._ptLookup))) &&
                        (this._ts || (this._pTime = n), qw(this, n, i)),
                    this
                );
            }),
            (e.time = function (n, i) {
                return arguments.length
                    ? this.totalTime(
                          Math.min(this.totalDuration(), n + k0(this)) %
                              (this._dur + this._rDelay) || (n ? this._dur : 0),
                          i
                      )
                    : this._time;
            }),
            (e.totalProgress = function (n, i) {
                return arguments.length
                    ? this.totalTime(this.totalDuration() * n, i)
                    : this.totalDuration()
                    ? Math.min(1, this._tTime / this._tDur)
                    : this.rawTime() >= 0 && this._initted
                    ? 1
                    : 0;
            }),
            (e.progress = function (n, i) {
                return arguments.length
                    ? this.totalTime(
                          this.duration() *
                              (this._yoyo && !(this.iteration() & 1)
                                  ? 1 - n
                                  : n) +
                              k0(this),
                          i
                      )
                    : this.duration()
                    ? Math.min(1, this._time / this._dur)
                    : this.rawTime() > 0
                    ? 1
                    : 0;
            }),
            (e.iteration = function (n, i) {
                var r = this.duration() + this._rDelay;
                return arguments.length
                    ? this.totalTime(this._time + (n - 1) * r, i)
                    : this._repeat
                    ? Zo(this._tTime, r) + 1
                    : 1;
            }),
            (e.timeScale = function (n, i) {
                if (!arguments.length) return this._rts === -st ? 0 : this._rts;
                if (this._rts === n) return this;
                var r =
                    this.parent && this._ts
                        ? Cu(this.parent._time, this)
                        : this._tTime;
                return (
                    (this._rts = +n || 0),
                    (this._ts = this._ps || n === -st ? 0 : this._rts),
                    this.totalTime(
                        hc(-Math.abs(this._delay), this.totalDuration(), r),
                        i !== !1
                    ),
                    wd(this),
                    bP(this)
                );
            }),
            (e.paused = function (n) {
                return arguments.length
                    ? (this._ps !== n &&
                          ((this._ps = n),
                          n
                              ? ((this._pTime =
                                    this._tTime ||
                                    Math.max(-this._delay, this.rawTime())),
                                (this._ts = this._act = 0))
                              : (Jo(),
                                (this._ts = this._rts),
                                this.totalTime(
                                    this.parent &&
                                        !this.parent.smoothChildTiming
                                        ? this.rawTime()
                                        : this._tTime || this._pTime,
                                    this.progress() === 1 &&
                                        Math.abs(this._zTime) !== st &&
                                        (this._tTime -= st)
                                ))),
                      this)
                    : this._ps;
            }),
            (e.startTime = function (n) {
                if (arguments.length) {
                    this._start = n;
                    var i = this.parent || this._dp;
                    return (
                        i &&
                            (i._sort || !this.parent) &&
                            _i(i, this, n - this._delay),
                        this
                    );
                }
                return this._start;
            }),
            (e.endTime = function (n) {
                return (
                    this._start +
                    (Un(n) ? this.totalDuration() : this.duration()) /
                        Math.abs(this._ts || 1)
                );
            }),
            (e.rawTime = function (n) {
                var i = this.parent || this._dp;
                return i
                    ? n &&
                      (!this._ts ||
                          (this._repeat &&
                              this._time &&
                              this.totalProgress() < 1))
                        ? this._tTime % (this._dur + this._rDelay)
                        : this._ts
                        ? Cu(i.rawTime(n), this)
                        : this._tTime
                    : this._tTime;
            }),
            (e.revert = function (n) {
                n === void 0 && (n = mP);
                var i = ln;
                return (
                    (ln = n),
                    yg(this) &&
                        (this.timeline && this.timeline.revert(n),
                        this.totalTime(-0.01, n.suppressEvents)),
                    this.data !== "nested" && n.kill !== !1 && this.kill(),
                    (ln = i),
                    this
                );
            }),
            (e.globalTime = function (n) {
                for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
                    (r = i._start + r / (Math.abs(i._ts) || 1)), (i = i._dp);
                return !this.parent && this._sat ? this._sat.globalTime(n) : r;
            }),
            (e.repeat = function (n) {
                return arguments.length
                    ? ((this._repeat = n === 1 / 0 ? -2 : n), T0(this))
                    : this._repeat === -2
                    ? 1 / 0
                    : this._repeat;
            }),
            (e.repeatDelay = function (n) {
                if (arguments.length) {
                    var i = this._time;
                    return (
                        (this._rDelay = n), T0(this), i ? this.time(i) : this
                    );
                }
                return this._rDelay;
            }),
            (e.yoyo = function (n) {
                return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
            }),
            (e.seek = function (n, i) {
                return this.totalTime(bs(this, n), Un(i));
            }),
            (e.restart = function (n, i) {
                return (
                    this.play().totalTime(n ? -this._delay : 0, Un(i)),
                    this._dur || (this._zTime = -st),
                    this
                );
            }),
            (e.play = function (n, i) {
                return (
                    n != null && this.seek(n, i), this.reversed(!1).paused(!1)
                );
            }),
            (e.reverse = function (n, i) {
                return (
                    n != null && this.seek(n || this.totalDuration(), i),
                    this.reversed(!0).paused(!1)
                );
            }),
            (e.pause = function (n, i) {
                return n != null && this.seek(n, i), this.paused(!0);
            }),
            (e.resume = function () {
                return this.paused(!1);
            }),
            (e.reversed = function (n) {
                return arguments.length
                    ? (!!n !== this.reversed() &&
                          this.timeScale(-this._rts || (n ? -st : 0)),
                      this)
                    : this._rts < 0;
            }),
            (e.invalidate = function () {
                return (
                    (this._initted = this._act = 0), (this._zTime = -st), this
                );
            }),
            (e.isActive = function () {
                var n = this.parent || this._dp,
                    i = this._start,
                    r;
                return !!(
                    !n ||
                    (this._ts &&
                        this._initted &&
                        n.isActive() &&
                        (r = n.rawTime(!0)) >= i &&
                        r < this.endTime(!0) - st)
                );
            }),
            (e.eventCallback = function (n, i, r) {
                var a = this.vars;
                return arguments.length > 1
                    ? (i
                          ? ((a[n] = i),
                            r && (a[n + "Params"] = r),
                            n === "onUpdate" && (this._onUpdate = i))
                          : delete a[n],
                      this)
                    : a[n];
            }),
            (e.then = function (n) {
                var i = this;
                return new Promise(function (r) {
                    var a = Et(n) ? n : Kw,
                        o = function () {
                            var l = i.then;
                            (i.then = null),
                                Et(a) &&
                                    (a = a(i)) &&
                                    (a.then || a === i) &&
                                    (i.then = l),
                                r(a),
                                (i.then = l);
                        };
                    (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
                    (!i._tTime && i._ts < 0)
                        ? o()
                        : (i._prom = o);
                });
            }),
            (e.kill = function () {
                Zl(this);
            }),
            s
        );
    })();
hs(Lh.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -st,
    _prom: 0,
    _ps: !1,
    _rts: 1,
});
var Cn = (function (s) {
    $w(e, s);
    function e(n, i) {
        var r;
        return (
            n === void 0 && (n = {}),
            (r = s.call(this, n) || this),
            (r.labels = {}),
            (r.smoothChildTiming = !!n.smoothChildTiming),
            (r.autoRemoveChildren = !!n.autoRemoveChildren),
            (r._sort = Un(n.sortChildren)),
            yt && _i(n.parent || yt, Yi(r), i),
            n.reversed && r.reverse(),
            n.paused && r.paused(!0),
            n.scrollTrigger && Jw(Yi(r), n.scrollTrigger),
            r
        );
    }
    var t = e.prototype;
    return (
        (t.to = function (i, r, a) {
            return lh(0, arguments, this), this;
        }),
        (t.from = function (i, r, a) {
            return lh(1, arguments, this), this;
        }),
        (t.fromTo = function (i, r, a, o) {
            return lh(2, arguments, this), this;
        }),
        (t.set = function (i, r, a) {
            return (
                (r.duration = 0),
                (r.parent = this),
                oh(r).repeatDelay || (r.repeat = 0),
                (r.immediateRender = !!r.immediateRender),
                new $t(i, r, bs(this, a), 1),
                this
            );
        }),
        (t.call = function (i, r, a) {
            return _i(this, $t.delayedCall(0, i, r), a);
        }),
        (t.staggerTo = function (i, r, a, o, h, l, u) {
            return (
                (a.duration = r),
                (a.stagger = a.stagger || o),
                (a.onComplete = l),
                (a.onCompleteParams = u),
                (a.parent = this),
                new $t(i, a, bs(this, h)),
                this
            );
        }),
        (t.staggerFrom = function (i, r, a, o, h, l, u) {
            return (
                (a.runBackwards = 1),
                (oh(a).immediateRender = Un(a.immediateRender)),
                this.staggerTo(i, r, a, o, h, l, u)
            );
        }),
        (t.staggerFromTo = function (i, r, a, o, h, l, u, c) {
            return (
                (o.startAt = a),
                (oh(o).immediateRender = Un(o.immediateRender)),
                this.staggerTo(i, r, o, h, l, u, c)
            );
        }),
        (t.render = function (i, r, a) {
            var o = this._time,
                h = this._dirty ? this.totalDuration() : this._tDur,
                l = this._dur,
                u = i <= 0 ? 0 : Dt(i),
                c = this._zTime < 0 != i < 0 && (this._initted || !l),
                d,
                f,
                p,
                m,
                g,
                _,
                v,
                b,
                y,
                C,
                w,
                A;
            if (
                (this !== yt && u > h && i >= 0 && (u = h),
                u !== this._tTime || a || c)
            ) {
                if (
                    (o !== this._time &&
                        l &&
                        ((u += this._time - o), (i += this._time - o)),
                    (d = u),
                    (y = this._start),
                    (b = this._ts),
                    (_ = !b),
                    c &&
                        (l || (o = this._zTime),
                        (i || !r) && (this._zTime = i)),
                    this._repeat)
                ) {
                    if (
                        ((w = this._yoyo),
                        (g = l + this._rDelay),
                        this._repeat < -1 && i < 0)
                    )
                        return this.totalTime(g * 100 + i, r, a);
                    if (
                        ((d = Dt(u % g)),
                        u === h
                            ? ((m = this._repeat), (d = l))
                            : ((C = Dt(u / g)),
                              (m = ~~C),
                              m && m === C && ((d = l), m--),
                              d > l && (d = l)),
                        (C = Zo(this._tTime, g)),
                        !o &&
                            this._tTime &&
                            C !== m &&
                            this._tTime - C * g - this._dur <= 0 &&
                            (C = m),
                        w && m & 1 && ((d = l - d), (A = 1)),
                        m !== C && !this._lock)
                    ) {
                        var E = w && C & 1,
                            S = E === (w && m & 1);
                        if (
                            (m < C && (E = !E),
                            (o = E ? 0 : u % l ? l : u),
                            (this._lock = 1),
                            (this.render(
                                o || (A ? 0 : Dt(m * g)),
                                r,
                                !l
                            )._lock = 0),
                            (this._tTime = u),
                            !r && this.parent && ss(this, "onRepeat"),
                            this.vars.repeatRefresh &&
                                !A &&
                                (this.invalidate()._lock = 1),
                            (o && o !== this._time) ||
                                _ !== !this._ts ||
                                (this.vars.onRepeat &&
                                    !this.parent &&
                                    !this._act))
                        )
                            return this;
                        if (
                            ((l = this._dur),
                            (h = this._tDur),
                            S &&
                                ((this._lock = 2),
                                (o = E ? l : -1e-4),
                                this.render(o, !0),
                                this.vars.repeatRefresh &&
                                    !A &&
                                    this.invalidate()),
                            (this._lock = 0),
                            !this._ts && !_)
                        )
                            return this;
                        p1(this, A);
                    }
                }
                if (
                    (this._hasPause &&
                        !this._forcing &&
                        this._lock < 2 &&
                        ((v = CP(this, Dt(o), Dt(d))),
                        v && (u -= d - (d = v._start))),
                    (this._tTime = u),
                    (this._time = d),
                    (this._act = !b),
                    this._initted ||
                        ((this._onUpdate = this.vars.onUpdate),
                        (this._initted = 1),
                        (this._zTime = i),
                        (o = 0)),
                    !o &&
                        u &&
                        !r &&
                        !C &&
                        (ss(this, "onStart"), this._tTime !== u))
                )
                    return this;
                if (d >= o && i >= 0)
                    for (f = this._first; f; ) {
                        if (
                            ((p = f._next),
                            (f._act || d >= f._start) && f._ts && v !== f)
                        ) {
                            if (f.parent !== this) return this.render(i, r, a);
                            if (
                                (f.render(
                                    f._ts > 0
                                        ? (d - f._start) * f._ts
                                        : (f._dirty
                                              ? f.totalDuration()
                                              : f._tDur) +
                                              (d - f._start) * f._ts,
                                    r,
                                    a
                                ),
                                d !== this._time || (!this._ts && !_))
                            ) {
                                (v = 0), p && (u += this._zTime = -st);
                                break;
                            }
                        }
                        f = p;
                    }
                else {
                    f = this._last;
                    for (var P = i < 0 ? i : d; f; ) {
                        if (
                            ((p = f._prev),
                            (f._act || P <= f._end) && f._ts && v !== f)
                        ) {
                            if (f.parent !== this) return this.render(i, r, a);
                            if (
                                (f.render(
                                    f._ts > 0
                                        ? (P - f._start) * f._ts
                                        : (f._dirty
                                              ? f.totalDuration()
                                              : f._tDur) +
                                              (P - f._start) * f._ts,
                                    r,
                                    a || (ln && yg(f))
                                ),
                                d !== this._time || (!this._ts && !_))
                            ) {
                                (v = 0), p && (u += this._zTime = P ? -st : st);
                                break;
                            }
                        }
                        f = p;
                    }
                }
                if (
                    v &&
                    !r &&
                    (this.pause(),
                    (v.render(d >= o ? 0 : -st)._zTime = d >= o ? 1 : -1),
                    this._ts)
                )
                    return (this._start = y), wd(this), this.render(i, r, a);
                this._onUpdate && !r && ss(this, "onUpdate", !0),
                    ((u === h && this._tTime >= this.totalDuration()) ||
                        (!u && o)) &&
                        (y === this._start ||
                            Math.abs(b) !== Math.abs(this._ts)) &&
                        (this._lock ||
                            ((i || !l) &&
                                ((u === h && this._ts > 0) ||
                                    (!u && this._ts < 0)) &&
                                zr(this, 1),
                            !r &&
                                !(i < 0 && !o) &&
                                (u || o || !h) &&
                                (ss(
                                    this,
                                    u === h && i >= 0
                                        ? "onComplete"
                                        : "onReverseComplete",
                                    !0
                                ),
                                this._prom &&
                                    !(u < h && this.timeScale() > 0) &&
                                    this._prom())));
            }
            return this;
        }),
        (t.add = function (i, r) {
            var a = this;
            if ((sr(r) || (r = bs(this, r, i)), !(i instanceof Lh))) {
                if (vn(i))
                    return (
                        i.forEach(function (o) {
                            return a.add(o, r);
                        }),
                        this
                    );
                if (Zt(i)) return this.addLabel(i, r);
                if (Et(i)) i = $t.delayedCall(0, i);
                else return this;
            }
            return this !== i ? _i(this, i, r) : this;
        }),
        (t.getChildren = function (i, r, a, o) {
            i === void 0 && (i = !0),
                r === void 0 && (r = !0),
                a === void 0 && (a = !0),
                o === void 0 && (o = -Cs);
            for (var h = [], l = this._first; l; )
                l._start >= o &&
                    (l instanceof $t
                        ? r && h.push(l)
                        : (a && h.push(l),
                          i && h.push.apply(h, l.getChildren(!0, r, a)))),
                    (l = l._next);
            return h;
        }),
        (t.getById = function (i) {
            for (var r = this.getChildren(1, 1, 1), a = r.length; a--; )
                if (r[a].vars.id === i) return r[a];
        }),
        (t.remove = function (i) {
            return Zt(i)
                ? this.removeLabel(i)
                : Et(i)
                ? this.killTweensOf(i)
                : (i.parent === this && yd(this, i),
                  i === this._recent && (this._recent = this._last),
                  xa(this));
        }),
        (t.totalTime = function (i, r) {
            return arguments.length
                ? ((this._forcing = 1),
                  !this._dp &&
                      this._ts &&
                      (this._start = Dt(
                          ns.time -
                              (this._ts > 0
                                  ? i / this._ts
                                  : (this.totalDuration() - i) / -this._ts)
                      )),
                  s.prototype.totalTime.call(this, i, r),
                  (this._forcing = 0),
                  this)
                : this._tTime;
        }),
        (t.addLabel = function (i, r) {
            return (this.labels[i] = bs(this, r)), this;
        }),
        (t.removeLabel = function (i) {
            return delete this.labels[i], this;
        }),
        (t.addPause = function (i, r, a) {
            var o = $t.delayedCall(0, r || Mh, a);
            return (
                (o.data = "isPause"),
                (this._hasPause = 1),
                _i(this, o, bs(this, i))
            );
        }),
        (t.removePause = function (i) {
            var r = this._first;
            for (i = bs(this, i); r; )
                r._start === i && r.data === "isPause" && zr(r), (r = r._next);
        }),
        (t.killTweensOf = function (i, r, a) {
            for (var o = this.getTweensOf(i, a), h = o.length; h--; )
                Pr !== o[h] && o[h].kill(i, r);
            return this;
        }),
        (t.getTweensOf = function (i, r) {
            for (var a = [], o = As(i), h = this._first, l = sr(r), u; h; )
                h instanceof $t
                    ? gP(h._targets, o) &&
                      (l
                          ? (!Pr || (h._initted && h._ts)) &&
                            h.globalTime(0) <= r &&
                            h.globalTime(h.totalDuration()) > r
                          : !r || h.isActive()) &&
                      a.push(h)
                    : (u = h.getTweensOf(o, r)).length && a.push.apply(a, u),
                    (h = h._next);
            return a;
        }),
        (t.tweenTo = function (i, r) {
            r = r || {};
            var a = this,
                o = bs(a, i),
                h = r,
                l = h.startAt,
                u = h.onStart,
                c = h.onStartParams,
                d = h.immediateRender,
                f,
                p = $t.to(
                    a,
                    hs(
                        {
                            ease: r.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: o,
                            overwrite: "auto",
                            duration:
                                r.duration ||
                                Math.abs(
                                    (o -
                                        (l && "time" in l ? l.time : a._time)) /
                                        a.timeScale()
                                ) ||
                                st,
                            onStart: function () {
                                if ((a.pause(), !f)) {
                                    var g =
                                        r.duration ||
                                        Math.abs(
                                            (o -
                                                (l && "time" in l
                                                    ? l.time
                                                    : a._time)) /
                                                a.timeScale()
                                        );
                                    p._dur !== g &&
                                        Qo(p, g, 0, 1).render(p._time, !0, !0),
                                        (f = 1);
                                }
                                u && u.apply(p, c || []);
                            },
                        },
                        r
                    )
                );
            return d ? p.render(0) : p;
        }),
        (t.tweenFromTo = function (i, r, a) {
            return this.tweenTo(r, hs({ startAt: { time: bs(this, i) } }, a));
        }),
        (t.recent = function () {
            return this._recent;
        }),
        (t.nextLabel = function (i) {
            return i === void 0 && (i = this._time), M0(this, bs(this, i));
        }),
        (t.previousLabel = function (i) {
            return i === void 0 && (i = this._time), M0(this, bs(this, i), 1);
        }),
        (t.currentLabel = function (i) {
            return arguments.length
                ? this.seek(i, !0)
                : this.previousLabel(this._time + st);
        }),
        (t.shiftChildren = function (i, r, a) {
            a === void 0 && (a = 0);
            for (var o = this._first, h = this.labels, l; o; )
                o._start >= a && ((o._start += i), (o._end += i)),
                    (o = o._next);
            if (r) for (l in h) h[l] >= a && (h[l] += i);
            return xa(this);
        }),
        (t.invalidate = function (i) {
            var r = this._first;
            for (this._lock = 0; r; ) r.invalidate(i), (r = r._next);
            return s.prototype.invalidate.call(this, i);
        }),
        (t.clear = function (i) {
            i === void 0 && (i = !0);
            for (var r = this._first, a; r; )
                (a = r._next), this.remove(r), (r = a);
            return (
                this._dp && (this._time = this._tTime = this._pTime = 0),
                i && (this.labels = {}),
                xa(this)
            );
        }),
        (t.totalDuration = function (i) {
            var r = 0,
                a = this,
                o = a._last,
                h = Cs,
                l,
                u,
                c;
            if (arguments.length)
                return a.timeScale(
                    (a._repeat < 0 ? a.duration() : a.totalDuration()) /
                        (a.reversed() ? -i : i)
                );
            if (a._dirty) {
                for (c = a.parent; o; )
                    (l = o._prev),
                        o._dirty && o.totalDuration(),
                        (u = o._start),
                        u > h && a._sort && o._ts && !a._lock
                            ? ((a._lock = 1),
                              (_i(a, o, u - o._delay, 1)._lock = 0))
                            : (h = u),
                        u < 0 &&
                            o._ts &&
                            ((r -= u),
                            ((!c && !a._dp) || (c && c.smoothChildTiming)) &&
                                ((a._start += u / a._ts),
                                (a._time -= u),
                                (a._tTime -= u)),
                            a.shiftChildren(-u, !1, -1 / 0),
                            (h = 0)),
                        o._end > r && o._ts && (r = o._end),
                        (o = l);
                Qo(a, a === yt && a._time > r ? a._time : r, 1, 1),
                    (a._dirty = 0);
            }
            return a._tDur;
        }),
        (e.updateRoot = function (i) {
            if (
                (yt._ts && (qw(yt, Cu(i, yt)), (Ww = ns.frame)), ns.frame >= E0)
            ) {
                E0 += is.autoSleep || 120;
                var r = yt._first;
                if (
                    (!r || !r._ts) &&
                    is.autoSleep &&
                    ns._listeners.length < 2
                ) {
                    for (; r && !r._ts; ) r = r._next;
                    r || ns.sleep();
                }
            }
        }),
        e
    );
})(Lh);
hs(Cn.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var NP = function (e, t, n, i, r, a, o) {
        var h = new Yn(this._pt, e, t, 0, 1, x1, null, r),
            l = 0,
            u = 0,
            c,
            d,
            f,
            p,
            m,
            g,
            _,
            v;
        for (
            h.b = n,
                h.e = i,
                n += "",
                i += "",
                (_ = ~i.indexOf("random(")) && (i = Ih(i)),
                a && ((v = [n, i]), a(v, e, t), (n = v[0]), (i = v[1])),
                d = n.match(cf) || [];
            (c = cf.exec(i));

        )
            (p = c[0]),
                (m = i.substring(l, c.index)),
                f ? (f = (f + 1) % 5) : m.substr(-5) === "rgba(" && (f = 1),
                p !== d[u++] &&
                    ((g = parseFloat(d[u - 1]) || 0),
                    (h._pt = {
                        _next: h._pt,
                        p: m || u === 1 ? m : ",",
                        s: g,
                        c:
                            p.charAt(1) === "="
                                ? Io(g, p) - g
                                : parseFloat(p) - g,
                        m: f && f < 4 ? Math.round : 0,
                    }),
                    (l = cf.lastIndex));
        return (
            (h.c = l < i.length ? i.substring(l, i.length) : ""),
            (h.fp = o),
            (Uw.test(i) || _) && (h.e = 0),
            (this._pt = h),
            h
        );
    },
    wg = function (e, t, n, i, r, a, o, h, l, u) {
        Et(i) && (i = i(r || 0, e, a));
        var c = e[t],
            d =
                n !== "get"
                    ? n
                    : Et(c)
                    ? l
                        ? e[
                              t.indexOf("set") || !Et(e["get" + t.substr(3)])
                                  ? t
                                  : "get" + t.substr(3)
                          ](l)
                        : e[t]()
                    : c,
            f = Et(c) ? (l ? GP : y1) : Cg,
            p;
        if (
            (Zt(i) &&
                (~i.indexOf("random(") && (i = Ih(i)),
                i.charAt(1) === "=" &&
                    ((p = Io(d, i) + (mn(d) || 0)), (p || p === 0) && (i = p))),
            !u || d !== i || Xp)
        )
            return !isNaN(d * i) && i !== ""
                ? ((p = new Yn(
                      this._pt,
                      e,
                      t,
                      +d || 0,
                      i - (d || 0),
                      typeof c == "boolean" ? WP : w1,
                      0,
                      f
                  )),
                  l && (p.fp = l),
                  o && p.modifier(o, this, e),
                  (this._pt = p))
                : (!c && !(t in e) && gg(t, i),
                  NP.call(this, e, t, d, i, f, h || is.stringFilter, l));
    },
    VP = function (e, t, n, i, r) {
        if (
            (Et(e) && (e = hh(e, r, t, n, i)),
            !Si(e) || (e.style && e.nodeType) || vn(e) || Nw(e))
        )
            return Zt(e) ? hh(e, r, t, n, i) : e;
        var a = {},
            o;
        for (o in e) a[o] = hh(e[o], r, t, n, i);
        return a;
    },
    _1 = function (e, t, n, i, r, a) {
        var o, h, l, u;
        if (
            Jn[e] &&
            (o = new Jn[e]()).init(
                r,
                o.rawVars ? t[e] : VP(t[e], i, r, a, n),
                n,
                i,
                a
            ) !== !1 &&
            ((n._pt = h =
                new Yn(n._pt, r, e, 0, 1, o.render, o, 0, o.priority)),
            n !== yo)
        )
            for (
                l = n._ptLookup[n._targets.indexOf(r)], u = o._props.length;
                u--;

            )
                l[o._props[u]] = h;
        return o;
    },
    Pr,
    Xp,
    xg = function s(e, t, n) {
        var i = e.vars,
            r = i.ease,
            a = i.startAt,
            o = i.immediateRender,
            h = i.lazy,
            l = i.onUpdate,
            u = i.runBackwards,
            c = i.yoyoEase,
            d = i.keyframes,
            f = i.autoRevert,
            p = e._dur,
            m = e._startAt,
            g = e._targets,
            _ = e.parent,
            v = _ && _.data === "nested" ? _.vars.targets : g,
            b = e._overwrite === "auto" && !dg,
            y = e.timeline,
            C,
            w,
            A,
            E,
            S,
            P,
            k,
            R,
            M,
            T,
            O,
            L,
            F;
        if (
            (y && (!d || !r) && (r = "none"),
            (e._ease = Ca(r, Ho.ease)),
            (e._yEase = c ? f1(Ca(c === !0 ? r : c, Ho.ease)) : 0),
            c &&
                e._yoyo &&
                !e._repeat &&
                ((c = e._yEase), (e._yEase = e._ease), (e._ease = c)),
            (e._from = !y && !!i.runBackwards),
            !y || (d && !i.stagger))
        ) {
            if (
                ((R = g[0] ? wa(g[0]).harness : 0),
                (L = R && i[R.prop]),
                (C = xu(i, _g)),
                m &&
                    (m._zTime < 0 && m.progress(1),
                    t < 0 && u && o && !f
                        ? m.render(-1, !0)
                        : m.revert(u && p ? eu : pP),
                    (m._lazy = 0)),
                a)
            ) {
                if (
                    (zr(
                        (e._startAt = $t.set(
                            g,
                            hs(
                                {
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: _,
                                    immediateRender: !0,
                                    lazy: !m && Un(h),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate:
                                        l &&
                                        function () {
                                            return ss(e, "onUpdate");
                                        },
                                    stagger: 0,
                                },
                                a
                            )
                        ))
                    ),
                    (e._startAt._dp = 0),
                    (e._startAt._sat = e),
                    t < 0 && (ln || (!o && !f)) && e._startAt.revert(eu),
                    o && p && t <= 0 && n <= 0)
                ) {
                    t && (e._zTime = t);
                    return;
                }
            } else if (u && p && !m) {
                if (
                    (t && (o = !1),
                    (A = hs(
                        {
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: o && !m && Un(h),
                            immediateRender: o,
                            stagger: 0,
                            parent: _,
                        },
                        C
                    )),
                    L && (A[R.prop] = L),
                    zr((e._startAt = $t.set(g, A))),
                    (e._startAt._dp = 0),
                    (e._startAt._sat = e),
                    t < 0 &&
                        (ln
                            ? e._startAt.revert(eu)
                            : e._startAt.render(-1, !0)),
                    (e._zTime = t),
                    !o)
                )
                    s(e._startAt, st, st);
                else if (!t) return;
            }
            for (
                e._pt = e._ptCache = 0, h = (p && Un(h)) || (h && !p), w = 0;
                w < g.length;
                w++
            ) {
                if (
                    ((S = g[w]),
                    (k = S._gsap || bg(g)[w]._gsap),
                    (e._ptLookup[w] = T = {}),
                    Up[k.id] && $r.length && wu(),
                    (O = v === g ? w : v.indexOf(S)),
                    R &&
                        (M = new R()).init(S, L || C, e, O, v) !== !1 &&
                        ((e._pt = E =
                            new Yn(
                                e._pt,
                                S,
                                M.name,
                                0,
                                1,
                                M.render,
                                M,
                                0,
                                M.priority
                            )),
                        M._props.forEach(function (Y) {
                            T[Y] = E;
                        }),
                        M.priority && (P = 1)),
                    !R || L)
                )
                    for (A in C)
                        Jn[A] && (M = _1(A, C, e, O, S, v))
                            ? M.priority && (P = 1)
                            : (T[A] = E =
                                  wg.call(
                                      e,
                                      S,
                                      A,
                                      "get",
                                      C[A],
                                      O,
                                      v,
                                      0,
                                      i.stringFilter
                                  ));
                e._op && e._op[w] && e.kill(S, e._op[w]),
                    b &&
                        e._pt &&
                        ((Pr = e),
                        yt.killTweensOf(S, T, e.globalTime(t)),
                        (F = !e.parent),
                        (Pr = 0)),
                    e._pt && h && (Up[k.id] = 1);
            }
            P && C1(e), e._onInit && e._onInit(e);
        }
        (e._onUpdate = l),
            (e._initted = (!e._op || e._pt) && !F),
            d && t <= 0 && y.render(Cs, !0, !0);
    },
    UP = function (e, t, n, i, r, a, o, h) {
        var l = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
            u,
            c,
            d,
            f;
        if (!l)
            for (
                l = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length;
                f--;

            ) {
                if (((u = d[f][t]), u && u.d && u.d._pt))
                    for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
                        u = u._next;
                if (!u)
                    return (
                        (Xp = 1),
                        (e.vars[t] = "+=0"),
                        xg(e, o),
                        (Xp = 0),
                        h ? Th(t + " not eligible for reset") : 1
                    );
                l.push(u);
            }
        for (f = l.length; f--; )
            (c = l[f]),
                (u = c._pt || c),
                (u.s = (i || i === 0) && !r ? i : u.s + (i || 0) + a * u.c),
                (u.c = n - u.s),
                c.e && (c.e = Rt(n) + mn(c.e)),
                c.b && (c.b = u.s + mn(c.b));
    },
    zP = function (e, t) {
        var n = e[0] ? wa(e[0]).harness : 0,
            i = n && n.aliases,
            r,
            a,
            o,
            h;
        if (!i) return t;
        r = Ko({}, t);
        for (a in i)
            if (a in r)
                for (h = i[a].split(","), o = h.length; o--; ) r[h[o]] = r[a];
        return r;
    },
    YP = function (e, t, n, i) {
        var r = t.ease || i || "power1.inOut",
            a,
            o;
        if (vn(t))
            (o = n[e] || (n[e] = [])),
                t.forEach(function (h, l) {
                    return o.push({
                        t: (l / (t.length - 1)) * 100,
                        v: h,
                        e: r,
                    });
                });
        else
            for (a in t)
                (o = n[a] || (n[a] = [])),
                    a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: r });
    },
    hh = function (e, t, n, i, r) {
        return Et(e)
            ? e.call(t, n, i, r)
            : Zt(e) && ~e.indexOf("random(")
            ? Ih(e)
            : e;
    },
    v1 = vg + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    b1 = {};
zn(v1 + ",id,stagger,delay,duration,paused,scrollTrigger", function (s) {
    return (b1[s] = 1);
});
var $t = (function (s) {
    $w(e, s);
    function e(n, i, r, a) {
        var o;
        typeof i == "number" && ((r.duration = i), (i = r), (r = null)),
            (o = s.call(this, a ? i : oh(i)) || this);
        var h = o.vars,
            l = h.duration,
            u = h.delay,
            c = h.immediateRender,
            d = h.stagger,
            f = h.overwrite,
            p = h.keyframes,
            m = h.defaults,
            g = h.scrollTrigger,
            _ = h.yoyoEase,
            v = i.parent || yt,
            b = (vn(n) || Nw(n) ? sr(n[0]) : "length" in i) ? [n] : As(n),
            y,
            C,
            w,
            A,
            E,
            S,
            P,
            k;
        if (
            ((o._targets = b.length
                ? bg(b)
                : Th(
                      "GSAP target " + n + " not found. https://gsap.com",
                      !is.nullTargetWarn
                  ) || []),
            (o._ptLookup = []),
            (o._overwrite = f),
            p || d || Ac(l) || Ac(u))
        ) {
            if (
                ((i = o.vars),
                (y = o.timeline =
                    new Cn({
                        data: "nested",
                        defaults: m || {},
                        targets: v && v.data === "nested" ? v.vars.targets : b,
                    })),
                y.kill(),
                (y.parent = y._dp = Yi(o)),
                (y._start = 0),
                d || Ac(l) || Ac(u))
            ) {
                if (((A = b.length), (P = d && s1(d)), Si(d)))
                    for (E in d)
                        ~v1.indexOf(E) && (k || (k = {}), (k[E] = d[E]));
                for (C = 0; C < A; C++)
                    (w = xu(i, b1)),
                        (w.stagger = 0),
                        _ && (w.yoyoEase = _),
                        k && Ko(w, k),
                        (S = b[C]),
                        (w.duration = +hh(l, Yi(o), C, S, b)),
                        (w.delay = (+hh(u, Yi(o), C, S, b) || 0) - o._delay),
                        !d &&
                            A === 1 &&
                            w.delay &&
                            ((o._delay = u = w.delay),
                            (o._start += u),
                            (w.delay = 0)),
                        y.to(S, w, P ? P(C, S, b) : 0),
                        (y._ease = ke.none);
                y.duration() ? (l = u = 0) : (o.timeline = 0);
            } else if (p) {
                oh(hs(y.vars.defaults, { ease: "none" })),
                    (y._ease = Ca(p.ease || i.ease || "none"));
                var R = 0,
                    M,
                    T,
                    O;
                if (vn(p))
                    p.forEach(function (L) {
                        return y.to(b, L, ">");
                    }),
                        y.duration();
                else {
                    w = {};
                    for (E in p)
                        E === "ease" ||
                            E === "easeEach" ||
                            YP(E, p[E], w, p.easeEach);
                    for (E in w)
                        for (
                            M = w[E].sort(function (L, F) {
                                return L.t - F.t;
                            }),
                                R = 0,
                                C = 0;
                            C < M.length;
                            C++
                        )
                            (T = M[C]),
                                (O = {
                                    ease: T.e,
                                    duration:
                                        ((T.t - (C ? M[C - 1].t : 0)) / 100) *
                                        l,
                                }),
                                (O[E] = T.v),
                                y.to(b, O, R),
                                (R += O.duration);
                    y.duration() < l &&
                        y.to({}, { duration: l - y.duration() });
                }
            }
            l || o.duration((l = y.duration()));
        } else o.timeline = 0;
        return (
            f === !0 && !dg && ((Pr = Yi(o)), yt.killTweensOf(b), (Pr = 0)),
            _i(v, Yi(o), r),
            i.reversed && o.reverse(),
            i.paused && o.paused(!0),
            (c ||
                (!l &&
                    !p &&
                    o._start === Dt(v._time) &&
                    Un(c) &&
                    yP(Yi(o)) &&
                    v.data !== "nested")) &&
                ((o._tTime = -st), o.render(Math.max(0, -u) || 0)),
            g && Jw(Yi(o), g),
            o
        );
    }
    var t = e.prototype;
    return (
        (t.render = function (i, r, a) {
            var o = this._time,
                h = this._tDur,
                l = this._dur,
                u = i < 0,
                c = i > h - st && !u ? h : i < st ? 0 : i,
                d,
                f,
                p,
                m,
                g,
                _,
                v,
                b,
                y;
            if (!l) xP(this, i, r, a);
            else if (
                c !== this._tTime ||
                !i ||
                a ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 !== u) ||
                this._lazy
            ) {
                if (((d = c), (b = this.timeline), this._repeat)) {
                    if (((m = l + this._rDelay), this._repeat < -1 && u))
                        return this.totalTime(m * 100 + i, r, a);
                    if (
                        ((d = Dt(c % m)),
                        c === h
                            ? ((p = this._repeat), (d = l))
                            : ((g = Dt(c / m)),
                              (p = ~~g),
                              p && p === g ? ((d = l), p--) : d > l && (d = l)),
                        (_ = this._yoyo && p & 1),
                        _ && ((y = this._yEase), (d = l - d)),
                        (g = Zo(this._tTime, m)),
                        d === o && !a && this._initted && p === g)
                    )
                        return (this._tTime = c), this;
                    p !== g &&
                        (b && this._yEase && p1(b, _),
                        this.vars.repeatRefresh &&
                            !_ &&
                            !this._lock &&
                            d !== m &&
                            this._initted &&
                            ((this._lock = a = 1),
                            (this.render(
                                Dt(m * p),
                                !0
                            ).invalidate()._lock = 0)));
                }
                if (!this._initted) {
                    if (e1(this, u ? i : d, a, r, c))
                        return (this._tTime = 0), this;
                    if (
                        o !== this._time &&
                        !(a && this.vars.repeatRefresh && p !== g)
                    )
                        return this;
                    if (l !== this._dur) return this.render(i, r, a);
                }
                if (
                    ((this._tTime = c),
                    (this._time = d),
                    !this._act &&
                        this._ts &&
                        ((this._act = 1), (this._lazy = 0)),
                    (this.ratio = v = (y || this._ease)(d / l)),
                    this._from && (this.ratio = v = 1 - v),
                    !o &&
                        c &&
                        !r &&
                        !g &&
                        (ss(this, "onStart"), this._tTime !== c))
                )
                    return this;
                for (f = this._pt; f; ) f.r(v, f.d), (f = f._next);
                (b &&
                    b.render(
                        i < 0 ? i : b._dur * b._ease(d / this._dur),
                        r,
                        a
                    )) ||
                    (this._startAt && (this._zTime = i)),
                    this._onUpdate &&
                        !r &&
                        (u && zp(this, i, r, a), ss(this, "onUpdate")),
                    this._repeat &&
                        p !== g &&
                        this.vars.onRepeat &&
                        !r &&
                        this.parent &&
                        ss(this, "onRepeat"),
                    (c === this._tDur || !c) &&
                        this._tTime === c &&
                        (u && !this._onUpdate && zp(this, i, !0, !0),
                        (i || !l) &&
                            ((c === this._tDur && this._ts > 0) ||
                                (!c && this._ts < 0)) &&
                            zr(this, 1),
                        !r &&
                            !(u && !o) &&
                            (c || o || _) &&
                            (ss(
                                this,
                                c === h ? "onComplete" : "onReverseComplete",
                                !0
                            ),
                            this._prom &&
                                !(c < h && this.timeScale() > 0) &&
                                this._prom()));
            }
            return this;
        }),
        (t.targets = function () {
            return this._targets;
        }),
        (t.invalidate = function (i) {
            return (
                (!i || !this.vars.runBackwards) && (this._startAt = 0),
                (this._pt =
                    this._op =
                    this._onUpdate =
                    this._lazy =
                    this.ratio =
                        0),
                (this._ptLookup = []),
                this.timeline && this.timeline.invalidate(i),
                s.prototype.invalidate.call(this, i)
            );
        }),
        (t.resetTo = function (i, r, a, o, h) {
            Rh || ns.wake(), this._ts || this.play();
            var l = Math.min(
                    this._dur,
                    (this._dp._time - this._start) * this._ts
                ),
                u;
            return (
                this._initted || xg(this, l),
                (u = this._ease(l / this._dur)),
                UP(this, i, r, a, o, u, l, h)
                    ? this.resetTo(i, r, a, o, 1)
                    : (xd(this, 0),
                      this.parent ||
                          Zw(
                              this._dp,
                              this,
                              "_first",
                              "_last",
                              this._dp._sort ? "_start" : 0
                          ),
                      this.render(0))
            );
        }),
        (t.kill = function (i, r) {
            if ((r === void 0 && (r = "all"), !i && (!r || r === "all")))
                return (
                    (this._lazy = this._pt = 0),
                    this.parent
                        ? Zl(this)
                        : this.scrollTrigger && this.scrollTrigger.kill(!!ln),
                    this
                );
            if (this.timeline) {
                var a = this.timeline.totalDuration();
                return (
                    this.timeline.killTweensOf(
                        i,
                        r,
                        Pr && Pr.vars.overwrite !== !0
                    )._first || Zl(this),
                    this.parent &&
                        a !== this.timeline.totalDuration() &&
                        Qo(this, (this._dur * this.timeline._tDur) / a, 0, 1),
                    this
                );
            }
            var o = this._targets,
                h = i ? As(i) : o,
                l = this._ptLookup,
                u = this._pt,
                c,
                d,
                f,
                p,
                m,
                g,
                _;
            if ((!r || r === "all") && vP(o, h))
                return r === "all" && (this._pt = 0), Zl(this);
            for (
                c = this._op = this._op || [],
                    r !== "all" &&
                        (Zt(r) &&
                            ((m = {}),
                            zn(r, function (v) {
                                return (m[v] = 1);
                            }),
                            (r = m)),
                        (r = zP(o, r))),
                    _ = o.length;
                _--;

            )
                if (~h.indexOf(o[_])) {
                    (d = l[_]),
                        r === "all"
                            ? ((c[_] = r), (p = d), (f = {}))
                            : ((f = c[_] = c[_] || {}), (p = r));
                    for (m in p)
                        (g = d && d[m]),
                            g &&
                                ((!("kill" in g.d) || g.d.kill(m) === !0) &&
                                    yd(this, g, "_pt"),
                                delete d[m]),
                            f !== "all" && (f[m] = 1);
                }
            return this._initted && !this._pt && u && Zl(this), this;
        }),
        (e.to = function (i, r) {
            return new e(i, r, arguments[2]);
        }),
        (e.from = function (i, r) {
            return lh(1, arguments);
        }),
        (e.delayedCall = function (i, r, a, o) {
            return new e(r, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: i,
                onComplete: r,
                onReverseComplete: r,
                onCompleteParams: a,
                onReverseCompleteParams: a,
                callbackScope: o,
            });
        }),
        (e.fromTo = function (i, r, a) {
            return lh(2, arguments);
        }),
        (e.set = function (i, r) {
            return (
                (r.duration = 0), r.repeatDelay || (r.repeat = 0), new e(i, r)
            );
        }),
        (e.killTweensOf = function (i, r, a) {
            return yt.killTweensOf(i, r, a);
        }),
        e
    );
})(Lh);
hs($t.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
zn("staggerTo,staggerFrom,staggerFromTo", function (s) {
    $t[s] = function () {
        var e = new Cn(),
            t = Gp.call(arguments, 0);
        return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
    };
});
var Cg = function (e, t, n) {
        return (e[t] = n);
    },
    y1 = function (e, t, n) {
        return e[t](n);
    },
    GP = function (e, t, n, i) {
        return e[t](i.fp, n);
    },
    jP = function (e, t, n) {
        return e.setAttribute(t, n);
    },
    Ag = function (e, t) {
        return Et(e[t]) ? y1 : fg(e[t]) && e.setAttribute ? jP : Cg;
    },
    w1 = function (e, t) {
        return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
    },
    WP = function (e, t) {
        return t.set(t.t, t.p, !!(t.s + t.c * e), t);
    },
    x1 = function (e, t) {
        var n = t._pt,
            i = "";
        if (!e && t.b) i = t.b;
        else if (e === 1 && t.e) i = t.e;
        else {
            for (; n; )
                (i =
                    n.p +
                    (n.m
                        ? n.m(n.s + n.c * e)
                        : Math.round((n.s + n.c * e) * 1e4) / 1e4) +
                    i),
                    (n = n._next);
            i += t.c;
        }
        t.set(t.t, t.p, i, t);
    },
    Sg = function (e, t) {
        for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
    },
    XP = function (e, t, n, i) {
        for (var r = this._pt, a; r; )
            (a = r._next), r.p === i && r.modifier(e, t, n), (r = a);
    },
    qP = function (e) {
        for (var t = this._pt, n, i; t; )
            (i = t._next),
                (t.p === e && !t.op) || t.op === e
                    ? yd(this, t, "_pt")
                    : t.dep || (n = 1),
                (t = i);
        return !n;
    },
    HP = function (e, t, n, i) {
        i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
    },
    C1 = function (e) {
        for (var t = e._pt, n, i, r, a; t; ) {
            for (n = t._next, i = r; i && i.pr > t.pr; ) i = i._next;
            (t._prev = i ? i._prev : a) ? (t._prev._next = t) : (r = t),
                (t._next = i) ? (i._prev = t) : (a = t),
                (t = n);
        }
        e._pt = r;
    },
    Yn = (function () {
        function s(t, n, i, r, a, o, h, l, u) {
            (this.t = n),
                (this.s = r),
                (this.c = a),
                (this.p = i),
                (this.r = o || w1),
                (this.d = h || this),
                (this.set = l || Cg),
                (this.pr = u || 0),
                (this._next = t),
                t && (t._prev = this);
        }
        var e = s.prototype;
        return (
            (e.modifier = function (n, i, r) {
                (this.mSet = this.mSet || this.set),
                    (this.set = HP),
                    (this.m = n),
                    (this.mt = r),
                    (this.tween = i);
            }),
            s
        );
    })();
zn(
    vg +
        "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    function (s) {
        return (_g[s] = 1);
    }
);
ls.TweenMax = ls.TweenLite = $t;
ls.TimelineLite = ls.TimelineMax = Cn;
yt = new Cn({
    sortChildren: !1,
    defaults: Ho,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0,
});
is.stringFilter = d1;
var Aa = [],
    nu = {},
    KP = [],
    R0 = 0,
    ZP = 0,
    mf = function (e) {
        return (nu[e] || KP).map(function (t) {
            return t();
        });
    },
    qp = function () {
        var e = Date.now(),
            t = [];
        e - R0 > 2 &&
            (mf("matchMediaInit"),
            Aa.forEach(function (n) {
                var i = n.queries,
                    r = n.conditions,
                    a,
                    o,
                    h,
                    l;
                for (o in i)
                    (a = fi.matchMedia(i[o]).matches),
                        a && (h = 1),
                        a !== r[o] && ((r[o] = a), (l = 1));
                l && (n.revert(), h && t.push(n));
            }),
            mf("matchMediaRevert"),
            t.forEach(function (n) {
                return n.onMatch(n, function (i) {
                    return n.add(null, i);
                });
            }),
            (R0 = e),
            mf("matchMedia"));
    },
    A1 = (function () {
        function s(t, n) {
            (this.selector = n && jp(n)),
                (this.data = []),
                (this._r = []),
                (this.isReverted = !1),
                (this.id = ZP++),
                t && this.add(t);
        }
        var e = s.prototype;
        return (
            (e.add = function (n, i, r) {
                Et(n) && ((r = i), (i = n), (n = Et));
                var a = this,
                    o = function () {
                        var l = _t,
                            u = a.selector,
                            c;
                        return (
                            l && l !== a && l.data.push(a),
                            r && (a.selector = jp(r)),
                            (_t = a),
                            (c = i.apply(a, arguments)),
                            Et(c) && a._r.push(c),
                            (_t = l),
                            (a.selector = u),
                            (a.isReverted = !1),
                            c
                        );
                    };
                return (
                    (a.last = o),
                    n === Et
                        ? o(a, function (h) {
                              return a.add(null, h);
                          })
                        : n
                        ? (a[n] = o)
                        : o
                );
            }),
            (e.ignore = function (n) {
                var i = _t;
                (_t = null), n(this), (_t = i);
            }),
            (e.getTweens = function () {
                var n = [];
                return (
                    this.data.forEach(function (i) {
                        return i instanceof s
                            ? n.push.apply(n, i.getTweens())
                            : i instanceof $t &&
                                  !(i.parent && i.parent.data === "nested") &&
                                  n.push(i);
                    }),
                    n
                );
            }),
            (e.clear = function () {
                this._r.length = this.data.length = 0;
            }),
            (e.kill = function (n, i) {
                var r = this;
                if (
                    (n
                        ? (function () {
                              for (
                                  var o = r.getTweens(), h = r.data.length, l;
                                  h--;

                              )
                                  (l = r.data[h]),
                                      l.data === "isFlip" &&
                                          (l.revert(),
                                          l
                                              .getChildren(!0, !0, !1)
                                              .forEach(function (u) {
                                                  return o.splice(
                                                      o.indexOf(u),
                                                      1
                                                  );
                                              }));
                              for (
                                  o
                                      .map(function (u) {
                                          return {
                                              g:
                                                  u._dur ||
                                                  u._delay ||
                                                  (u._sat &&
                                                      !u._sat.vars
                                                          .immediateRender)
                                                      ? u.globalTime(0)
                                                      : -1 / 0,
                                              t: u,
                                          };
                                      })
                                      .sort(function (u, c) {
                                          return c.g - u.g || -1 / 0;
                                      })
                                      .forEach(function (u) {
                                          return u.t.revert(n);
                                      }),
                                      h = r.data.length;
                                  h--;

                              )
                                  (l = r.data[h]),
                                      l instanceof Cn
                                          ? l.data !== "nested" &&
                                            (l.scrollTrigger &&
                                                l.scrollTrigger.revert(),
                                            l.kill())
                                          : !(l instanceof $t) &&
                                            l.revert &&
                                            l.revert(n);
                              r._r.forEach(function (u) {
                                  return u(n, r);
                              }),
                                  (r.isReverted = !0);
                          })()
                        : this.data.forEach(function (o) {
                              return o.kill && o.kill();
                          }),
                    this.clear(),
                    i)
                )
                    for (var a = Aa.length; a--; )
                        Aa[a].id === this.id && Aa.splice(a, 1);
            }),
            (e.revert = function (n) {
                this.kill(n || {});
            }),
            s
        );
    })(),
    QP = (function () {
        function s(t) {
            (this.contexts = []), (this.scope = t), _t && _t.data.push(this);
        }
        var e = s.prototype;
        return (
            (e.add = function (n, i, r) {
                Si(n) || (n = { matches: n });
                var a = new A1(0, r || this.scope),
                    o = (a.conditions = {}),
                    h,
                    l,
                    u;
                _t && !a.selector && (a.selector = _t.selector),
                    this.contexts.push(a),
                    (i = a.add("onMatch", i)),
                    (a.queries = n);
                for (l in n)
                    l === "all"
                        ? (u = 1)
                        : ((h = fi.matchMedia(n[l])),
                          h &&
                              (Aa.indexOf(a) < 0 && Aa.push(a),
                              (o[l] = h.matches) && (u = 1),
                              h.addListener
                                  ? h.addListener(qp)
                                  : h.addEventListener("change", qp)));
                return (
                    u &&
                        i(a, function (c) {
                            return a.add(null, c);
                        }),
                    this
                );
            }),
            (e.revert = function (n) {
                this.kill(n || {});
            }),
            (e.kill = function (n) {
                this.contexts.forEach(function (i) {
                    return i.kill(n, !0);
                });
            }),
            s
        );
    })(),
    Au = {
        registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            t.forEach(function (i) {
                return h1(i);
            });
        },
        timeline: function (e) {
            return new Cn(e);
        },
        getTweensOf: function (e, t) {
            return yt.getTweensOf(e, t);
        },
        getProperty: function (e, t, n, i) {
            Zt(e) && (e = As(e)[0]);
            var r = wa(e || {}).get,
                a = n ? Kw : Hw;
            return (
                n === "native" && (n = ""),
                e &&
                    (t
                        ? a(((Jn[t] && Jn[t].get) || r)(e, t, n, i))
                        : function (o, h, l) {
                              return a(((Jn[o] && Jn[o].get) || r)(e, o, h, l));
                          })
            );
        },
        quickSetter: function (e, t, n) {
            if (((e = As(e)), e.length > 1)) {
                var i = e.map(function (u) {
                        return jn.quickSetter(u, t, n);
                    }),
                    r = i.length;
                return function (u) {
                    for (var c = r; c--; ) i[c](u);
                };
            }
            e = e[0] || {};
            var a = Jn[t],
                o = wa(e),
                h = (o.harness && (o.harness.aliases || {})[t]) || t,
                l = a
                    ? function (u) {
                          var c = new a();
                          (yo._pt = 0),
                              c.init(e, n ? u + n : u, yo, 0, [e]),
                              c.render(1, c),
                              yo._pt && Sg(1, yo);
                      }
                    : o.set(e, h);
            return a
                ? l
                : function (u) {
                      return l(e, h, n ? u + n : u, o, 1);
                  };
        },
        quickTo: function (e, t, n) {
            var i,
                r = jn.to(
                    e,
                    hs(
                        ((i = {}),
                        (i[t] = "+=0.1"),
                        (i.paused = !0),
                        (i.stagger = 0),
                        i),
                        n || {}
                    )
                ),
                a = function (h, l, u) {
                    return r.resetTo(t, h, l, u);
                };
            return (a.tween = r), a;
        },
        isTweening: function (e) {
            return yt.getTweensOf(e, !0).length > 0;
        },
        defaults: function (e) {
            return (
                e && e.ease && (e.ease = Ca(e.ease, Ho.ease)), P0(Ho, e || {})
            );
        },
        config: function (e) {
            return P0(is, e || {});
        },
        registerEffect: function (e) {
            var t = e.name,
                n = e.effect,
                i = e.plugins,
                r = e.defaults,
                a = e.extendTimeline;
            (i || "").split(",").forEach(function (o) {
                return (
                    o &&
                    !Jn[o] &&
                    !ls[o] &&
                    Th(t + " effect requires " + o + " plugin.")
                );
            }),
                (uf[t] = function (o, h, l) {
                    return n(As(o), hs(h || {}, r), l);
                }),
                a &&
                    (Cn.prototype[t] = function (o, h, l) {
                        return this.add(
                            uf[t](o, Si(h) ? h : (l = h) && {}, this),
                            l
                        );
                    });
        },
        registerEase: function (e, t) {
            ke[e] = Ca(t);
        },
        parseEase: function (e, t) {
            return arguments.length ? Ca(e, t) : ke;
        },
        getById: function (e) {
            return yt.getById(e);
        },
        exportRoot: function (e, t) {
            e === void 0 && (e = {});
            var n = new Cn(e),
                i,
                r;
            for (
                n.smoothChildTiming = Un(e.smoothChildTiming),
                    yt.remove(n),
                    n._dp = 0,
                    n._time = n._tTime = yt._time,
                    i = yt._first;
                i;

            )
                (r = i._next),
                    (t ||
                        !(
                            !i._dur &&
                            i instanceof $t &&
                            i.vars.onComplete === i._targets[0]
                        )) &&
                        _i(n, i, i._start - i._delay),
                    (i = r);
            return _i(yt, n, 0), n;
        },
        context: function (e, t) {
            return e ? new A1(e, t) : _t;
        },
        matchMedia: function (e) {
            return new QP(e);
        },
        matchMediaRefresh: function () {
            return (
                Aa.forEach(function (e) {
                    var t = e.conditions,
                        n,
                        i;
                    for (i in t) t[i] && ((t[i] = !1), (n = 1));
                    n && e.revert();
                }) || qp()
            );
        },
        addEventListener: function (e, t) {
            var n = nu[e] || (nu[e] = []);
            ~n.indexOf(t) || n.push(t);
        },
        removeEventListener: function (e, t) {
            var n = nu[e],
                i = n && n.indexOf(t);
            i >= 0 && n.splice(i, 1);
        },
        utils: {
            wrap: MP,
            wrapYoyo: IP,
            distribute: s1,
            random: r1,
            snap: i1,
            normalize: TP,
            getUnit: mn,
            clamp: SP,
            splitColor: c1,
            toArray: As,
            selector: jp,
            mapRange: o1,
            pipe: PP,
            unitize: kP,
            interpolate: RP,
            shuffle: n1,
        },
        install: Gw,
        effects: uf,
        ticker: ns,
        updateRoot: Cn.updateRoot,
        plugins: Jn,
        globalTimeline: yt,
        core: {
            PropTween: Yn,
            globals: jw,
            Tween: $t,
            Timeline: Cn,
            Animation: Lh,
            getCache: wa,
            _removeLinkedListItem: yd,
            reverting: function () {
                return ln;
            },
            context: function (e) {
                return e && _t && (_t.data.push(e), (e._ctx = _t)), _t;
            },
            suppressOverwrites: function (e) {
                return (dg = e);
            },
        },
    };
zn("to,from,fromTo,delayedCall,set,killTweensOf", function (s) {
    return (Au[s] = $t[s]);
});
ns.add(Cn.updateRoot);
yo = Au.to({}, { duration: 0 });
var JP = function (e, t) {
        for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
            n = n._next;
        return n;
    },
    ek = function (e, t) {
        var n = e._targets,
            i,
            r,
            a;
        for (i in t)
            for (r = n.length; r--; )
                (a = e._ptLookup[r][i]),
                    a &&
                        (a = a.d) &&
                        (a._pt && (a = JP(a, i)),
                        a && a.modifier && a.modifier(t[i], e, n[r], i));
    },
    gf = function (e, t) {
        return {
            name: e,
            headless: 1,
            rawVars: 1,
            init: function (i, r, a) {
                a._onInit = function (o) {
                    var h, l;
                    if (
                        (Zt(r) &&
                            ((h = {}),
                            zn(r, function (u) {
                                return (h[u] = 1);
                            }),
                            (r = h)),
                        t)
                    ) {
                        h = {};
                        for (l in r) h[l] = t(r[l]);
                        r = h;
                    }
                    ek(o, r);
                };
            },
        };
    },
    jn =
        Au.registerPlugin(
            {
                name: "attr",
                init: function (e, t, n, i, r) {
                    var a, o, h;
                    this.tween = n;
                    for (a in t)
                        (h = e.getAttribute(a) || ""),
                            (o = this.add(
                                e,
                                "setAttribute",
                                (h || 0) + "",
                                t[a],
                                i,
                                r,
                                0,
                                0,
                                a
                            )),
                            (o.op = a),
                            (o.b = h),
                            this._props.push(a);
                },
                render: function (e, t) {
                    for (var n = t._pt; n; )
                        ln ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
                            (n = n._next);
                },
            },
            {
                name: "endArray",
                headless: 1,
                init: function (e, t) {
                    for (var n = t.length; n--; )
                        this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
                },
            },
            gf("roundProps", Wp),
            gf("modifiers"),
            gf("snap", i1)
        ) || Au;
$t.version = Cn.version = jn.version = "3.13.0";
Yw = 1;
pg() && Jo();
ke.Power0;
ke.Power1;
ke.Power2;
ke.Power3;
ke.Power4;
ke.Linear;
ke.Quad;
ke.Cubic;
ke.Quart;
ke.Quint;
ke.Strong;
ke.Elastic;
ke.Back;
ke.SteppedEase;
ke.Bounce;
ke.Sine;
ke.Expo;
ke.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var L0,
    kr,
    Ro,
    Eg,
    fa,
    O0,
    Pg,
    tk = function () {
        return typeof window < "u";
    },
    ir = {},
    oa = 180 / Math.PI,
    Lo = Math.PI / 180,
    io = Math.atan2,
    B0 = 1e8,
    kg = /([A-Z])/g,
    nk = /(left|right|width|margin|padding|x)/i,
    sk = /[\s,\(]\S/,
    vi = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity",
    },
    Hp = function (e, t) {
        return t.set(
            t.t,
            t.p,
            Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
            t
        );
    },
    ik = function (e, t) {
        return t.set(
            t.t,
            t.p,
            e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
            t
        );
    },
    rk = function (e, t) {
        return t.set(
            t.t,
            t.p,
            e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
            t
        );
    },
    ak = function (e, t) {
        var n = t.s + t.c * e;
        t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
    },
    S1 = function (e, t) {
        return t.set(t.t, t.p, e ? t.e : t.b, t);
    },
    E1 = function (e, t) {
        return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
    },
    ok = function (e, t, n) {
        return (e.style[t] = n);
    },
    lk = function (e, t, n) {
        return e.style.setProperty(t, n);
    },
    hk = function (e, t, n) {
        return (e._gsap[t] = n);
    },
    ck = function (e, t, n) {
        return (e._gsap.scaleX = e._gsap.scaleY = n);
    },
    uk = function (e, t, n, i, r) {
        var a = e._gsap;
        (a.scaleX = a.scaleY = n), a.renderTransform(r, a);
    },
    dk = function (e, t, n, i, r) {
        var a = e._gsap;
        (a[t] = n), a.renderTransform(r, a);
    },
    wt = "transform",
    Gn = wt + "Origin",
    fk = function s(e, t) {
        var n = this,
            i = this.target,
            r = i.style,
            a = i._gsap;
        if (e in ir && r) {
            if (((this.tfm = this.tfm || {}), e !== "transform"))
                (e = vi[e] || e),
                    ~e.indexOf(",")
                        ? e.split(",").forEach(function (o) {
                              return (n.tfm[o] = ji(i, o));
                          })
                        : (this.tfm[e] = a.x ? a[e] : ji(i, e)),
                    e === Gn && (this.tfm.zOrigin = a.zOrigin);
            else
                return vi.transform.split(",").forEach(function (o) {
                    return s.call(n, o, t);
                });
            if (this.props.indexOf(wt) >= 0) return;
            a.svg &&
                ((this.svgo = i.getAttribute("data-svg-origin")),
                this.props.push(Gn, t, "")),
                (e = wt);
        }
        (r || t) && this.props.push(e, t, r[e]);
    },
    P1 = function (e) {
        e.translate &&
            (e.removeProperty("translate"),
            e.removeProperty("scale"),
            e.removeProperty("rotate"));
    },
    pk = function () {
        var e = this.props,
            t = this.target,
            n = t.style,
            i = t._gsap,
            r,
            a;
        for (r = 0; r < e.length; r += 3)
            e[r + 1]
                ? e[r + 1] === 2
                    ? t[e[r]](e[r + 2])
                    : (t[e[r]] = e[r + 2])
                : e[r + 2]
                ? (n[e[r]] = e[r + 2])
                : n.removeProperty(
                      e[r].substr(0, 2) === "--"
                          ? e[r]
                          : e[r].replace(kg, "-$1").toLowerCase()
                  );
        if (this.tfm) {
            for (a in this.tfm) i[a] = this.tfm[a];
            i.svg &&
                (i.renderTransform(),
                t.setAttribute("data-svg-origin", this.svgo || "")),
                (r = Pg()),
                (!r || !r.isStart) &&
                    !n[wt] &&
                    (P1(n),
                    i.zOrigin &&
                        n[Gn] &&
                        ((n[Gn] += " " + i.zOrigin + "px"),
                        (i.zOrigin = 0),
                        i.renderTransform()),
                    (i.uncache = 1));
        }
    },
    k1 = function (e, t) {
        var n = { target: e, props: [], revert: pk, save: fk };
        return (
            e._gsap || jn.core.getCache(e),
            t &&
                e.style &&
                e.nodeType &&
                t.split(",").forEach(function (i) {
                    return n.save(i);
                }),
            n
        );
    },
    T1,
    Kp = function (e, t) {
        var n = kr.createElementNS
            ? kr.createElementNS(
                  (t || "http://www.w3.org/1999/xhtml").replace(
                      /^https/,
                      "http"
                  ),
                  e
              )
            : kr.createElement(e);
        return n && n.style ? n : kr.createElement(e);
    },
    Ss = function s(e, t, n) {
        var i = getComputedStyle(e);
        return (
            i[t] ||
            i.getPropertyValue(t.replace(kg, "-$1").toLowerCase()) ||
            i.getPropertyValue(t) ||
            (!n && s(e, el(t) || t, 1)) ||
            ""
        );
    },
    F0 = "O,Moz,ms,Ms,Webkit".split(","),
    el = function (e, t, n) {
        var i = t || fa,
            r = i.style,
            a = 5;
        if (e in r && !n) return e;
        for (
            e = e.charAt(0).toUpperCase() + e.substr(1);
            a-- && !(F0[a] + e in r);

        );
        return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? F0[a] : "") + e;
    },
    Zp = function () {
        tk() &&
            window.document &&
            ((L0 = window),
            (kr = L0.document),
            (Ro = kr.documentElement),
            (fa = Kp("div") || { style: {} }),
            Kp("div"),
            (wt = el(wt)),
            (Gn = wt + "Origin"),
            (fa.style.cssText =
                "border-width:0;line-height:0;position:absolute;padding:0"),
            (T1 = !!el("perspective")),
            (Pg = jn.core.reverting),
            (Eg = 1));
    },
    $0 = function (e) {
        var t = e.ownerSVGElement,
            n = Kp(
                "svg",
                (t && t.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"
            ),
            i = e.cloneNode(!0),
            r;
        (i.style.display = "block"), n.appendChild(i), Ro.appendChild(n);
        try {
            r = i.getBBox();
        } catch {}
        return n.removeChild(i), Ro.removeChild(n), r;
    },
    D0 = function (e, t) {
        for (var n = t.length; n--; )
            if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
    },
    M1 = function (e) {
        var t, n;
        try {
            t = e.getBBox();
        } catch {
            (t = $0(e)), (n = 1);
        }
        return (
            (t && (t.width || t.height)) || n || (t = $0(e)),
            t && !t.width && !t.x && !t.y
                ? {
                      x: +D0(e, ["x", "cx", "x1"]) || 0,
                      y: +D0(e, ["y", "cy", "y1"]) || 0,
                      width: 0,
                      height: 0,
                  }
                : t
        );
    },
    I1 = function (e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && M1(e));
    },
    La = function (e, t) {
        if (t) {
            var n = e.style,
                i;
            t in ir && t !== Gn && (t = wt),
                n.removeProperty
                    ? ((i = t.substr(0, 2)),
                      (i === "ms" || t.substr(0, 6) === "webkit") &&
                          (t = "-" + t),
                      n.removeProperty(
                          i === "--" ? t : t.replace(kg, "-$1").toLowerCase()
                      ))
                    : n.removeAttribute(t);
        }
    },
    Tr = function (e, t, n, i, r, a) {
        var o = new Yn(e._pt, t, n, 0, 1, a ? E1 : S1);
        return (e._pt = o), (o.b = i), (o.e = r), e._props.push(n), o;
    },
    N0 = { deg: 1, rad: 1, turn: 1 },
    mk = { grid: 1, flex: 1 },
    Yr = function s(e, t, n, i) {
        var r = parseFloat(n) || 0,
            a = (n + "").trim().substr((r + "").length) || "px",
            o = fa.style,
            h = nk.test(t),
            l = e.tagName.toLowerCase() === "svg",
            u = (l ? "client" : "offset") + (h ? "Width" : "Height"),
            c = 100,
            d = i === "px",
            f = i === "%",
            p,
            m,
            g,
            _;
        if (i === a || !r || N0[i] || N0[a]) return r;
        if (
            (a !== "px" && !d && (r = s(e, t, n, "px")),
            (_ = e.getCTM && I1(e)),
            (f || a === "%") && (ir[t] || ~t.indexOf("adius")))
        )
            return (
                (p = _ ? e.getBBox()[h ? "width" : "height"] : e[u]),
                Rt(f ? (r / p) * c : (r / 100) * p)
            );
        if (
            ((o[h ? "width" : "height"] = c + (d ? a : i)),
            (m =
                (i !== "rem" && ~t.indexOf("adius")) ||
                (i === "em" && e.appendChild && !l)
                    ? e
                    : e.parentNode),
            _ && (m = (e.ownerSVGElement || {}).parentNode),
            (!m || m === kr || !m.appendChild) && (m = kr.body),
            (g = m._gsap),
            g && f && g.width && h && g.time === ns.time && !g.uncache)
        )
            return Rt((r / g.width) * c);
        if (f && (t === "height" || t === "width")) {
            var v = e.style[t];
            (e.style[t] = c + i), (p = e[u]), v ? (e.style[t] = v) : La(e, t);
        } else
            (f || a === "%") &&
                !mk[Ss(m, "display")] &&
                (o.position = Ss(e, "position")),
                m === e && (o.position = "static"),
                m.appendChild(fa),
                (p = fa[u]),
                m.removeChild(fa),
                (o.position = "absolute");
        return (
            h && f && ((g = wa(m)), (g.time = ns.time), (g.width = m[u])),
            Rt(d ? (p * r) / c : p && r ? (c / p) * r : 0)
        );
    },
    ji = function (e, t, n, i) {
        var r;
        return (
            Eg || Zp(),
            t in vi &&
                t !== "transform" &&
                ((t = vi[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
            ir[t] && t !== "transform"
                ? ((r = Bh(e, i)),
                  (r =
                      t !== "transformOrigin"
                          ? r[t]
                          : r.svg
                          ? r.origin
                          : Eu(Ss(e, Gn)) + " " + r.zOrigin + "px"))
                : ((r = e.style[t]),
                  (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) &&
                      (r =
                          (Su[t] && Su[t](e, t, n)) ||
                          Ss(e, t) ||
                          Xw(e, t) ||
                          (t === "opacity" ? 1 : 0))),
            n && !~(r + "").trim().indexOf(" ") ? Yr(e, t, r, n) + n : r
        );
    },
    gk = function (e, t, n, i) {
        if (!n || n === "none") {
            var r = el(t, e, 1),
                a = r && Ss(e, r, 1);
            a && a !== n
                ? ((t = r), (n = a))
                : t === "borderColor" && (n = Ss(e, "borderTopColor"));
        }
        var o = new Yn(this._pt, e.style, t, 0, 1, x1),
            h = 0,
            l = 0,
            u,
            c,
            d,
            f,
            p,
            m,
            g,
            _,
            v,
            b,
            y,
            C;
        if (
            ((o.b = n),
            (o.e = i),
            (n += ""),
            (i += ""),
            i.substring(0, 6) === "var(--" &&
                (i = Ss(e, i.substring(4, i.indexOf(")")))),
            i === "auto" &&
                ((m = e.style[t]),
                (e.style[t] = i),
                (i = Ss(e, t) || i),
                m ? (e.style[t] = m) : La(e, t)),
            (u = [n, i]),
            d1(u),
            (n = u[0]),
            (i = u[1]),
            (d = n.match(bo) || []),
            (C = i.match(bo) || []),
            C.length)
        ) {
            for (; (c = bo.exec(i)); )
                (g = c[0]),
                    (v = i.substring(h, c.index)),
                    p
                        ? (p = (p + 1) % 5)
                        : (v.substr(-5) === "rgba(" ||
                              v.substr(-5) === "hsla(") &&
                          (p = 1),
                    g !== (m = d[l++] || "") &&
                        ((f = parseFloat(m) || 0),
                        (y = m.substr((f + "").length)),
                        g.charAt(1) === "=" && (g = Io(f, g) + y),
                        (_ = parseFloat(g)),
                        (b = g.substr((_ + "").length)),
                        (h = bo.lastIndex - b.length),
                        b ||
                            ((b = b || is.units[t] || y),
                            h === i.length && ((i += b), (o.e += b))),
                        y !== b && (f = Yr(e, t, m, b) || 0),
                        (o._pt = {
                            _next: o._pt,
                            p: v || l === 1 ? v : ",",
                            s: f,
                            c: _ - f,
                            m: (p && p < 4) || t === "zIndex" ? Math.round : 0,
                        }));
            o.c = h < i.length ? i.substring(h, i.length) : "";
        } else o.r = t === "display" && i === "none" ? E1 : S1;
        return Uw.test(i) && (o.e = 0), (this._pt = o), o;
    },
    V0 = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%",
    },
    _k = function (e) {
        var t = e.split(" "),
            n = t[0],
            i = t[1] || "50%";
        return (
            (n === "top" || n === "bottom" || i === "left" || i === "right") &&
                ((e = n), (n = i), (i = e)),
            (t[0] = V0[n] || n),
            (t[1] = V0[i] || i),
            t.join(" ")
        );
    },
    vk = function (e, t) {
        if (t.tween && t.tween._time === t.tween._dur) {
            var n = t.t,
                i = n.style,
                r = t.u,
                a = n._gsap,
                o,
                h,
                l;
            if (r === "all" || r === !0) (i.cssText = ""), (h = 1);
            else
                for (r = r.split(","), l = r.length; --l > -1; )
                    (o = r[l]),
                        ir[o] &&
                            ((h = 1), (o = o === "transformOrigin" ? Gn : wt)),
                        La(n, o);
            h &&
                (La(n, wt),
                a &&
                    (a.svg && n.removeAttribute("transform"),
                    (i.scale = i.rotate = i.translate = "none"),
                    Bh(n, 1),
                    (a.uncache = 1),
                    P1(i)));
        }
    },
    Su = {
        clearProps: function (e, t, n, i, r) {
            if (r.data !== "isFromStart") {
                var a = (e._pt = new Yn(e._pt, t, n, 0, 0, vk));
                return (
                    (a.u = i), (a.pr = -10), (a.tween = r), e._props.push(n), 1
                );
            }
        },
    },
    Oh = [1, 0, 0, 1, 0, 0],
    R1 = {},
    L1 = function (e) {
        return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
    },
    U0 = function (e) {
        var t = Ss(e, wt);
        return L1(t) ? Oh : t.substr(7).match(Vw).map(Rt);
    },
    Tg = function (e, t) {
        var n = e._gsap || wa(e),
            i = e.style,
            r = U0(e),
            a,
            o,
            h,
            l;
        return n.svg && e.getAttribute("transform")
            ? ((h = e.transform.baseVal.consolidate().matrix),
              (r = [h.a, h.b, h.c, h.d, h.e, h.f]),
              r.join(",") === "1,0,0,1,0,0" ? Oh : r)
            : (r === Oh &&
                  !e.offsetParent &&
                  e !== Ro &&
                  !n.svg &&
                  ((h = i.display),
                  (i.display = "block"),
                  (a = e.parentNode),
                  (!a ||
                      (!e.offsetParent && !e.getBoundingClientRect().width)) &&
                      ((l = 1), (o = e.nextElementSibling), Ro.appendChild(e)),
                  (r = U0(e)),
                  h ? (i.display = h) : La(e, "display"),
                  l &&
                      (o
                          ? a.insertBefore(e, o)
                          : a
                          ? a.appendChild(e)
                          : Ro.removeChild(e))),
              t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
    },
    Qp = function (e, t, n, i, r, a) {
        var o = e._gsap,
            h = r || Tg(e, !0),
            l = o.xOrigin || 0,
            u = o.yOrigin || 0,
            c = o.xOffset || 0,
            d = o.yOffset || 0,
            f = h[0],
            p = h[1],
            m = h[2],
            g = h[3],
            _ = h[4],
            v = h[5],
            b = t.split(" "),
            y = parseFloat(b[0]) || 0,
            C = parseFloat(b[1]) || 0,
            w,
            A,
            E,
            S;
        n
            ? h !== Oh &&
              (A = f * g - p * m) &&
              ((E = y * (g / A) + C * (-m / A) + (m * v - g * _) / A),
              (S = y * (-p / A) + C * (f / A) - (f * v - p * _) / A),
              (y = E),
              (C = S))
            : ((w = M1(e)),
              (y = w.x + (~b[0].indexOf("%") ? (y / 100) * w.width : y)),
              (C =
                  w.y +
                  (~(b[1] || b[0]).indexOf("%") ? (C / 100) * w.height : C))),
            i || (i !== !1 && o.smooth)
                ? ((_ = y - l),
                  (v = C - u),
                  (o.xOffset = c + (_ * f + v * m) - _),
                  (o.yOffset = d + (_ * p + v * g) - v))
                : (o.xOffset = o.yOffset = 0),
            (o.xOrigin = y),
            (o.yOrigin = C),
            (o.smooth = !!i),
            (o.origin = t),
            (o.originIsAbsolute = !!n),
            (e.style[Gn] = "0px 0px"),
            a &&
                (Tr(a, o, "xOrigin", l, y),
                Tr(a, o, "yOrigin", u, C),
                Tr(a, o, "xOffset", c, o.xOffset),
                Tr(a, o, "yOffset", d, o.yOffset)),
            e.setAttribute("data-svg-origin", y + " " + C);
    },
    Bh = function (e, t) {
        var n = e._gsap || new g1(e);
        if ("x" in n && !t && !n.uncache) return n;
        var i = e.style,
            r = n.scaleX < 0,
            a = "px",
            o = "deg",
            h = getComputedStyle(e),
            l = Ss(e, Gn) || "0",
            u,
            c,
            d,
            f,
            p,
            m,
            g,
            _,
            v,
            b,
            y,
            C,
            w,
            A,
            E,
            S,
            P,
            k,
            R,
            M,
            T,
            O,
            L,
            F,
            Y,
            V,
            W,
            Z,
            J,
            G,
            j,
            H;
        return (
            (u = c = d = m = g = _ = v = b = y = 0),
            (f = p = 1),
            (n.svg = !!(e.getCTM && I1(e))),
            h.translate &&
                ((h.translate !== "none" ||
                    h.scale !== "none" ||
                    h.rotate !== "none") &&
                    (i[wt] =
                        (h.translate !== "none"
                            ? "translate3d(" +
                              (h.translate + " 0 0")
                                  .split(" ")
                                  .slice(0, 3)
                                  .join(", ") +
                              ") "
                            : "") +
                        (h.rotate !== "none"
                            ? "rotate(" + h.rotate + ") "
                            : "") +
                        (h.scale !== "none"
                            ? "scale(" + h.scale.split(" ").join(",") + ") "
                            : "") +
                        (h[wt] !== "none" ? h[wt] : "")),
                (i.scale = i.rotate = i.translate = "none")),
            (A = Tg(e, n.svg)),
            n.svg &&
                (n.uncache
                    ? ((Y = e.getBBox()),
                      (l = n.xOrigin - Y.x + "px " + (n.yOrigin - Y.y) + "px"),
                      (F = ""))
                    : (F = !t && e.getAttribute("data-svg-origin")),
                Qp(e, F || l, !!F || n.originIsAbsolute, n.smooth !== !1, A)),
            (C = n.xOrigin || 0),
            (w = n.yOrigin || 0),
            A !== Oh &&
                ((k = A[0]),
                (R = A[1]),
                (M = A[2]),
                (T = A[3]),
                (u = O = A[4]),
                (c = L = A[5]),
                A.length === 6
                    ? ((f = Math.sqrt(k * k + R * R)),
                      (p = Math.sqrt(T * T + M * M)),
                      (m = k || R ? io(R, k) * oa : 0),
                      (v = M || T ? io(M, T) * oa + m : 0),
                      v && (p *= Math.abs(Math.cos(v * Lo))),
                      n.svg &&
                          ((u -= C - (C * k + w * M)),
                          (c -= w - (C * R + w * T))))
                    : ((H = A[6]),
                      (G = A[7]),
                      (W = A[8]),
                      (Z = A[9]),
                      (J = A[10]),
                      (j = A[11]),
                      (u = A[12]),
                      (c = A[13]),
                      (d = A[14]),
                      (E = io(H, J)),
                      (g = E * oa),
                      E &&
                          ((S = Math.cos(-E)),
                          (P = Math.sin(-E)),
                          (F = O * S + W * P),
                          (Y = L * S + Z * P),
                          (V = H * S + J * P),
                          (W = O * -P + W * S),
                          (Z = L * -P + Z * S),
                          (J = H * -P + J * S),
                          (j = G * -P + j * S),
                          (O = F),
                          (L = Y),
                          (H = V)),
                      (E = io(-M, J)),
                      (_ = E * oa),
                      E &&
                          ((S = Math.cos(-E)),
                          (P = Math.sin(-E)),
                          (F = k * S - W * P),
                          (Y = R * S - Z * P),
                          (V = M * S - J * P),
                          (j = T * P + j * S),
                          (k = F),
                          (R = Y),
                          (M = V)),
                      (E = io(R, k)),
                      (m = E * oa),
                      E &&
                          ((S = Math.cos(E)),
                          (P = Math.sin(E)),
                          (F = k * S + R * P),
                          (Y = O * S + L * P),
                          (R = R * S - k * P),
                          (L = L * S - O * P),
                          (k = F),
                          (O = Y)),
                      g &&
                          Math.abs(g) + Math.abs(m) > 359.9 &&
                          ((g = m = 0), (_ = 180 - _)),
                      (f = Rt(Math.sqrt(k * k + R * R + M * M))),
                      (p = Rt(Math.sqrt(L * L + H * H))),
                      (E = io(O, L)),
                      (v = Math.abs(E) > 2e-4 ? E * oa : 0),
                      (y = j ? 1 / (j < 0 ? -j : j) : 0)),
                n.svg &&
                    ((F = e.getAttribute("transform")),
                    (n.forceCSS =
                        e.setAttribute("transform", "") || !L1(Ss(e, wt))),
                    F && e.setAttribute("transform", F))),
            Math.abs(v) > 90 &&
                Math.abs(v) < 270 &&
                (r
                    ? ((f *= -1),
                      (v += m <= 0 ? 180 : -180),
                      (m += m <= 0 ? 180 : -180))
                    : ((p *= -1), (v += v <= 0 ? 180 : -180))),
            (t = t || n.uncache),
            (n.x =
                u -
                ((n.xPercent =
                    u &&
                    ((!t && n.xPercent) ||
                        (Math.round(e.offsetWidth / 2) === Math.round(-u)
                            ? -50
                            : 0)))
                    ? (e.offsetWidth * n.xPercent) / 100
                    : 0) +
                a),
            (n.y =
                c -
                ((n.yPercent =
                    c &&
                    ((!t && n.yPercent) ||
                        (Math.round(e.offsetHeight / 2) === Math.round(-c)
                            ? -50
                            : 0)))
                    ? (e.offsetHeight * n.yPercent) / 100
                    : 0) +
                a),
            (n.z = d + a),
            (n.scaleX = Rt(f)),
            (n.scaleY = Rt(p)),
            (n.rotation = Rt(m) + o),
            (n.rotationX = Rt(g) + o),
            (n.rotationY = Rt(_) + o),
            (n.skewX = v + o),
            (n.skewY = b + o),
            (n.transformPerspective = y + a),
            (n.zOrigin =
                parseFloat(l.split(" ")[2]) || (!t && n.zOrigin) || 0) &&
                (i[Gn] = Eu(l)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = is.force3D),
            (n.renderTransform = n.svg ? yk : T1 ? O1 : bk),
            (n.uncache = 0),
            n
        );
    },
    Eu = function (e) {
        return (e = e.split(" "))[0] + " " + e[1];
    },
    _f = function (e, t, n) {
        var i = mn(t);
        return Rt(parseFloat(t) + parseFloat(Yr(e, "x", n + "px", i))) + i;
    },
    bk = function (e, t) {
        (t.z = "0px"),
            (t.rotationY = t.rotationX = "0deg"),
            (t.force3D = 0),
            O1(e, t);
    },
    Jr = "0deg",
    kl = "0px",
    ea = ") ",
    O1 = function (e, t) {
        var n = t || this,
            i = n.xPercent,
            r = n.yPercent,
            a = n.x,
            o = n.y,
            h = n.z,
            l = n.rotation,
            u = n.rotationY,
            c = n.rotationX,
            d = n.skewX,
            f = n.skewY,
            p = n.scaleX,
            m = n.scaleY,
            g = n.transformPerspective,
            _ = n.force3D,
            v = n.target,
            b = n.zOrigin,
            y = "",
            C = (_ === "auto" && e && e !== 1) || _ === !0;
        if (b && (c !== Jr || u !== Jr)) {
            var w = parseFloat(u) * Lo,
                A = Math.sin(w),
                E = Math.cos(w),
                S;
            (w = parseFloat(c) * Lo),
                (S = Math.cos(w)),
                (a = _f(v, a, A * S * -b)),
                (o = _f(v, o, -Math.sin(w) * -b)),
                (h = _f(v, h, E * S * -b + b));
        }
        g !== kl && (y += "perspective(" + g + ea),
            (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
            (C || a !== kl || o !== kl || h !== kl) &&
                (y +=
                    h !== kl || C
                        ? "translate3d(" + a + ", " + o + ", " + h + ") "
                        : "translate(" + a + ", " + o + ea),
            l !== Jr && (y += "rotate(" + l + ea),
            u !== Jr && (y += "rotateY(" + u + ea),
            c !== Jr && (y += "rotateX(" + c + ea),
            (d !== Jr || f !== Jr) && (y += "skew(" + d + ", " + f + ea),
            (p !== 1 || m !== 1) && (y += "scale(" + p + ", " + m + ea),
            (v.style[wt] = y || "translate(0, 0)");
    },
    yk = function (e, t) {
        var n = t || this,
            i = n.xPercent,
            r = n.yPercent,
            a = n.x,
            o = n.y,
            h = n.rotation,
            l = n.skewX,
            u = n.skewY,
            c = n.scaleX,
            d = n.scaleY,
            f = n.target,
            p = n.xOrigin,
            m = n.yOrigin,
            g = n.xOffset,
            _ = n.yOffset,
            v = n.forceCSS,
            b = parseFloat(a),
            y = parseFloat(o),
            C,
            w,
            A,
            E,
            S;
        (h = parseFloat(h)),
            (l = parseFloat(l)),
            (u = parseFloat(u)),
            u && ((u = parseFloat(u)), (l += u), (h += u)),
            h || l
                ? ((h *= Lo),
                  (l *= Lo),
                  (C = Math.cos(h) * c),
                  (w = Math.sin(h) * c),
                  (A = Math.sin(h - l) * -d),
                  (E = Math.cos(h - l) * d),
                  l &&
                      ((u *= Lo),
                      (S = Math.tan(l - u)),
                      (S = Math.sqrt(1 + S * S)),
                      (A *= S),
                      (E *= S),
                      u &&
                          ((S = Math.tan(u)),
                          (S = Math.sqrt(1 + S * S)),
                          (C *= S),
                          (w *= S))),
                  (C = Rt(C)),
                  (w = Rt(w)),
                  (A = Rt(A)),
                  (E = Rt(E)))
                : ((C = c), (E = d), (w = A = 0)),
            ((b && !~(a + "").indexOf("px")) ||
                (y && !~(o + "").indexOf("px"))) &&
                ((b = Yr(f, "x", a, "px")), (y = Yr(f, "y", o, "px"))),
            (p || m || g || _) &&
                ((b = Rt(b + p - (p * C + m * A) + g)),
                (y = Rt(y + m - (p * w + m * E) + _))),
            (i || r) &&
                ((S = f.getBBox()),
                (b = Rt(b + (i / 100) * S.width)),
                (y = Rt(y + (r / 100) * S.height))),
            (S =
                "matrix(" +
                C +
                "," +
                w +
                "," +
                A +
                "," +
                E +
                "," +
                b +
                "," +
                y +
                ")"),
            f.setAttribute("transform", S),
            v && (f.style[wt] = S);
    },
    wk = function (e, t, n, i, r) {
        var a = 360,
            o = Zt(r),
            h = parseFloat(r) * (o && ~r.indexOf("rad") ? oa : 1),
            l = h - i,
            u = i + l + "deg",
            c,
            d;
        return (
            o &&
                ((c = r.split("_")[1]),
                c === "short" &&
                    ((l %= a), l !== l % (a / 2) && (l += l < 0 ? a : -a)),
                c === "cw" && l < 0
                    ? (l = ((l + a * B0) % a) - ~~(l / a) * a)
                    : c === "ccw" &&
                      l > 0 &&
                      (l = ((l - a * B0) % a) - ~~(l / a) * a)),
            (e._pt = d = new Yn(e._pt, t, n, i, l, ik)),
            (d.e = u),
            (d.u = "deg"),
            e._props.push(n),
            d
        );
    },
    z0 = function (e, t) {
        for (var n in t) e[n] = t[n];
        return e;
    },
    xk = function (e, t, n) {
        var i = z0({}, n._gsap),
            r = "perspective,force3D,transformOrigin,svgOrigin",
            a = n.style,
            o,
            h,
            l,
            u,
            c,
            d,
            f,
            p;
        i.svg
            ? ((l = n.getAttribute("transform")),
              n.setAttribute("transform", ""),
              (a[wt] = t),
              (o = Bh(n, 1)),
              La(n, wt),
              n.setAttribute("transform", l))
            : ((l = getComputedStyle(n)[wt]),
              (a[wt] = t),
              (o = Bh(n, 1)),
              (a[wt] = l));
        for (h in ir)
            (l = i[h]),
                (u = o[h]),
                l !== u &&
                    r.indexOf(h) < 0 &&
                    ((f = mn(l)),
                    (p = mn(u)),
                    (c = f !== p ? Yr(n, h, l, p) : parseFloat(l)),
                    (d = parseFloat(u)),
                    (e._pt = new Yn(e._pt, o, h, c, d - c, Hp)),
                    (e._pt.u = p || 0),
                    e._props.push(h));
        z0(o, i);
    };
zn("padding,margin,Width,Radius", function (s, e) {
    var t = "Top",
        n = "Right",
        i = "Bottom",
        r = "Left",
        a = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function (
            o
        ) {
            return e < 2 ? s + o : "border" + o + s;
        });
    Su[e > 1 ? "border" + s : s] = function (o, h, l, u, c) {
        var d, f;
        if (arguments.length < 4)
            return (
                (d = a.map(function (p) {
                    return ji(o, p, l);
                })),
                (f = d.join(" ")),
                f.split(d[0]).length === 5 ? d[0] : f
            );
        (d = (u + "").split(" ")),
            (f = {}),
            a.forEach(function (p, m) {
                return (f[p] = d[m] = d[m] || d[((m - 1) / 2) | 0]);
            }),
            o.init(h, f, c);
    };
});
var B1 = {
    name: "css",
    register: Zp,
    targetTest: function (e) {
        return e.style && e.nodeType;
    },
    init: function (e, t, n, i, r) {
        var a = this._props,
            o = e.style,
            h = n.vars.startAt,
            l,
            u,
            c,
            d,
            f,
            p,
            m,
            g,
            _,
            v,
            b,
            y,
            C,
            w,
            A,
            E;
        Eg || Zp(),
            (this.styles = this.styles || k1(e)),
            (E = this.styles.props),
            (this.tween = n);
        for (m in t)
            if (
                m !== "autoRound" &&
                ((u = t[m]), !(Jn[m] && _1(m, t, n, i, e, r)))
            ) {
                if (
                    ((f = typeof u),
                    (p = Su[m]),
                    f === "function" &&
                        ((u = u.call(n, i, e, r)), (f = typeof u)),
                    f === "string" && ~u.indexOf("random(") && (u = Ih(u)),
                    p)
                )
                    p(this, e, m, u, n) && (A = 1);
                else if (m.substr(0, 2) === "--")
                    (l = (getComputedStyle(e).getPropertyValue(m) + "").trim()),
                        (u += ""),
                        (Dr.lastIndex = 0),
                        Dr.test(l) || ((g = mn(l)), (_ = mn(u))),
                        _ ? g !== _ && (l = Yr(e, m, l, _) + _) : g && (u += g),
                        this.add(o, "setProperty", l, u, i, r, 0, 0, m),
                        a.push(m),
                        E.push(m, 0, o[m]);
                else if (f !== "undefined") {
                    if (
                        (h && m in h
                            ? ((l =
                                  typeof h[m] == "function"
                                      ? h[m].call(n, i, e, r)
                                      : h[m]),
                              Zt(l) && ~l.indexOf("random(") && (l = Ih(l)),
                              mn(l + "") ||
                                  l === "auto" ||
                                  (l += is.units[m] || mn(ji(e, m)) || ""),
                              (l + "").charAt(1) === "=" && (l = ji(e, m)))
                            : (l = ji(e, m)),
                        (d = parseFloat(l)),
                        (v =
                            f === "string" &&
                            u.charAt(1) === "=" &&
                            u.substr(0, 2)),
                        v && (u = u.substr(2)),
                        (c = parseFloat(u)),
                        m in vi &&
                            (m === "autoAlpha" &&
                                (d === 1 &&
                                    ji(e, "visibility") === "hidden" &&
                                    c &&
                                    (d = 0),
                                E.push("visibility", 0, o.visibility),
                                Tr(
                                    this,
                                    o,
                                    "visibility",
                                    d ? "inherit" : "hidden",
                                    c ? "inherit" : "hidden",
                                    !c
                                )),
                            m !== "scale" &&
                                m !== "transform" &&
                                ((m = vi[m]),
                                ~m.indexOf(",") && (m = m.split(",")[0]))),
                        (b = m in ir),
                        b)
                    ) {
                        if (
                            (this.styles.save(m),
                            f === "string" &&
                                u.substring(0, 6) === "var(--" &&
                                ((u = Ss(e, u.substring(4, u.indexOf(")")))),
                                (c = parseFloat(u))),
                            y ||
                                ((C = e._gsap),
                                (C.renderTransform && !t.parseTransform) ||
                                    Bh(e, t.parseTransform),
                                (w = t.smoothOrigin !== !1 && C.smooth),
                                (y = this._pt =
                                    new Yn(
                                        this._pt,
                                        o,
                                        wt,
                                        0,
                                        1,
                                        C.renderTransform,
                                        C,
                                        0,
                                        -1
                                    )),
                                (y.dep = 1)),
                            m === "scale")
                        )
                            (this._pt = new Yn(
                                this._pt,
                                C,
                                "scaleY",
                                C.scaleY,
                                (v ? Io(C.scaleY, v + c) : c) - C.scaleY || 0,
                                Hp
                            )),
                                (this._pt.u = 0),
                                a.push("scaleY", m),
                                (m += "X");
                        else if (m === "transformOrigin") {
                            E.push(Gn, 0, o[Gn]),
                                (u = _k(u)),
                                C.svg
                                    ? Qp(e, u, 0, w, 0, this)
                                    : ((_ = parseFloat(u.split(" ")[2]) || 0),
                                      _ !== C.zOrigin &&
                                          Tr(this, C, "zOrigin", C.zOrigin, _),
                                      Tr(this, o, m, Eu(l), Eu(u)));
                            continue;
                        } else if (m === "svgOrigin") {
                            Qp(e, u, 1, w, 0, this);
                            continue;
                        } else if (m in R1) {
                            wk(this, C, m, d, v ? Io(d, v + u) : u);
                            continue;
                        } else if (m === "smoothOrigin") {
                            Tr(this, C, "smooth", C.smooth, u);
                            continue;
                        } else if (m === "force3D") {
                            C[m] = u;
                            continue;
                        } else if (m === "transform") {
                            xk(this, u, e);
                            continue;
                        }
                    } else m in o || (m = el(m) || m);
                    if (
                        b ||
                        ((c || c === 0) &&
                            (d || d === 0) &&
                            !sk.test(u) &&
                            m in o)
                    )
                        (g = (l + "").substr((d + "").length)),
                            c || (c = 0),
                            (_ = mn(u) || (m in is.units ? is.units[m] : g)),
                            g !== _ && (d = Yr(e, m, l, _)),
                            (this._pt = new Yn(
                                this._pt,
                                b ? C : o,
                                m,
                                d,
                                (v ? Io(d, v + c) : c) - d,
                                !b &&
                                (_ === "px" || m === "zIndex") &&
                                t.autoRound !== !1
                                    ? ak
                                    : Hp
                            )),
                            (this._pt.u = _ || 0),
                            g !== _ &&
                                _ !== "%" &&
                                ((this._pt.b = l), (this._pt.r = rk));
                    else if (m in o) gk.call(this, e, m, l, v ? v + u : u);
                    else if (m in e)
                        this.add(e, m, l || e[m], v ? v + u : u, i, r);
                    else if (m !== "parseTransform") {
                        gg(m, u);
                        continue;
                    }
                    b ||
                        (m in o
                            ? E.push(m, 0, o[m])
                            : typeof e[m] == "function"
                            ? E.push(m, 2, e[m]())
                            : E.push(m, 1, l || e[m])),
                        a.push(m);
                }
            }
        A && C1(this);
    },
    render: function (e, t) {
        if (t.tween._time || !Pg())
            for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
        else t.styles.revert();
    },
    get: ji,
    aliases: vi,
    getSetter: function (e, t, n) {
        var i = vi[t];
        return (
            i && i.indexOf(",") < 0 && (t = i),
            t in ir && t !== Gn && (e._gsap.x || ji(e, "x"))
                ? n && O0 === n
                    ? t === "scale"
                        ? ck
                        : hk
                    : (O0 = n || {}) && (t === "scale" ? uk : dk)
                : e.style && !fg(e.style[t])
                ? ok
                : ~t.indexOf("-")
                ? lk
                : Ag(e, t)
        );
    },
    core: { _removeProperty: La, _getMatrix: Tg },
};
jn.utils.checkPrefix = el;
jn.core.getStyleSaver = k1;
(function (s, e, t, n) {
    var i = zn(s + "," + e + "," + t, function (r) {
        ir[r] = 1;
    });
    zn(e, function (r) {
        (is.units[r] = "deg"), (R1[r] = 1);
    }),
        (vi[i[13]] = s + "," + e),
        zn(n, function (r) {
            var a = r.split(":");
            vi[a[1]] = i[a[0]];
        });
})(
    "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
    "rotation,rotationX,rotationY,skewX,skewY",
    "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
    "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
zn(
    "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
    function (s) {
        is.units[s] = "px";
    }
);
jn.registerPlugin(B1);
var Je = jn.registerPlugin(B1) || jn;
Je.core.Tween;
/*!
 * paths 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var Ck = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
    Ak = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
    Sk = Math.PI / 180,
    Sc = Math.sin,
    Ec = Math.cos,
    ch = Math.abs,
    Tl = Math.sqrt,
    Ek = function (e) {
        return typeof e == "number";
    },
    Y0 = 1e5,
    ur = function (e) {
        return Math.round(e * Y0) / Y0 || 0;
    };
function Pk(s, e, t, n, i, r, a) {
    for (var o = s.length, h, l, u, c, d; --o > -1; )
        for (h = s[o], l = h.length, u = 0; u < l; u += 2)
            (c = h[u]),
                (d = h[u + 1]),
                (h[u] = c * e + d * n + r),
                (h[u + 1] = c * t + d * i + a);
    return (s._dirty = 1), s;
}
function kk(s, e, t, n, i, r, a, o, h) {
    if (!(s === o && e === h)) {
        (t = ch(t)), (n = ch(n));
        var l = (i % 360) * Sk,
            u = Ec(l),
            c = Sc(l),
            d = Math.PI,
            f = d * 2,
            p = (s - o) / 2,
            m = (e - h) / 2,
            g = u * p + c * m,
            _ = -c * p + u * m,
            v = g * g,
            b = _ * _,
            y = v / (t * t) + b / (n * n);
        y > 1 && ((t = Tl(y) * t), (n = Tl(y) * n));
        var C = t * t,
            w = n * n,
            A = (C * w - C * b - w * v) / (C * b + w * v);
        A < 0 && (A = 0);
        var E = (r === a ? -1 : 1) * Tl(A),
            S = E * ((t * _) / n),
            P = E * -((n * g) / t),
            k = (s + o) / 2,
            R = (e + h) / 2,
            M = k + (u * S - c * P),
            T = R + (c * S + u * P),
            O = (g - S) / t,
            L = (_ - P) / n,
            F = (-g - S) / t,
            Y = (-_ - P) / n,
            V = O * O + L * L,
            W = (L < 0 ? -1 : 1) * Math.acos(O / Tl(V)),
            Z =
                (O * Y - L * F < 0 ? -1 : 1) *
                Math.acos((O * F + L * Y) / Tl(V * (F * F + Y * Y)));
        isNaN(Z) && (Z = d),
            !a && Z > 0 ? (Z -= f) : a && Z < 0 && (Z += f),
            (W %= f),
            (Z %= f);
        var J = Math.ceil(ch(Z) / (f / 4)),
            G = [],
            j = Z / J,
            H = ((4 / 3) * Sc(j / 2)) / (1 + Ec(j / 2)),
            pe = u * t,
            _e = c * t,
            ve = c * -n,
            re = u * n,
            le;
        for (le = 0; le < J; le++)
            (i = W + le * j),
                (g = Ec(i)),
                (_ = Sc(i)),
                (O = Ec((i += j))),
                (L = Sc(i)),
                G.push(g - H * _, _ + H * g, O + H * L, L - H * O, O, L);
        for (le = 0; le < G.length; le += 2)
            (g = G[le]),
                (_ = G[le + 1]),
                (G[le] = g * pe + _ * ve + M),
                (G[le + 1] = g * _e + _ * re + T);
        return (G[le - 2] = o), (G[le - 1] = h), G;
    }
}
function Tk(s) {
    var e =
            (s + "")
                .replace(Ak, function (S) {
                    var P = +S;
                    return P < 1e-4 && P > -1e-4 ? 0 : P;
                })
                .match(Ck) || [],
        t = [],
        n = 0,
        i = 0,
        r = 2 / 3,
        a = e.length,
        o = 0,
        h = "ERROR: malformed path: " + s,
        l,
        u,
        c,
        d,
        f,
        p,
        m,
        g,
        _,
        v,
        b,
        y,
        C,
        w,
        A,
        E = function (P, k, R, M) {
            (v = (R - P) / 3),
                (b = (M - k) / 3),
                m.push(P + v, k + b, R - v, M - b, R, M);
        };
    if (!s || !isNaN(e[0]) || isNaN(e[1])) return console.log(h), t;
    for (l = 0; l < a; l++)
        if (
            ((C = f),
            isNaN(e[l]) ? ((f = e[l].toUpperCase()), (p = f !== e[l])) : l--,
            (c = +e[l + 1]),
            (d = +e[l + 2]),
            p && ((c += n), (d += i)),
            l || ((g = c), (_ = d)),
            f === "M")
        )
            m && (m.length < 8 ? (t.length -= 1) : (o += m.length)),
                (n = g = c),
                (i = _ = d),
                (m = [c, d]),
                t.push(m),
                (l += 2),
                (f = "L");
        else if (f === "C")
            m || (m = [0, 0]),
                p || (n = i = 0),
                m.push(
                    c,
                    d,
                    n + e[l + 3] * 1,
                    i + e[l + 4] * 1,
                    (n += e[l + 5] * 1),
                    (i += e[l + 6] * 1)
                ),
                (l += 6);
        else if (f === "S")
            (v = n),
                (b = i),
                (C === "C" || C === "S") &&
                    ((v += n - m[m.length - 4]), (b += i - m[m.length - 3])),
                p || (n = i = 0),
                m.push(v, b, c, d, (n += e[l + 3] * 1), (i += e[l + 4] * 1)),
                (l += 4);
        else if (f === "Q")
            (v = n + (c - n) * r),
                (b = i + (d - i) * r),
                p || (n = i = 0),
                (n += e[l + 3] * 1),
                (i += e[l + 4] * 1),
                m.push(v, b, n + (c - n) * r, i + (d - i) * r, n, i),
                (l += 4);
        else if (f === "T")
            (v = n - m[m.length - 4]),
                (b = i - m[m.length - 3]),
                m.push(
                    n + v,
                    i + b,
                    c + (n + v * 1.5 - c) * r,
                    d + (i + b * 1.5 - d) * r,
                    (n = c),
                    (i = d)
                ),
                (l += 2);
        else if (f === "H") E(n, i, (n = c), i), (l += 1);
        else if (f === "V") E(n, i, n, (i = c + (p ? i - n : 0))), (l += 1);
        else if (f === "L" || f === "Z")
            f === "Z" && ((c = g), (d = _), (m.closed = !0)),
                (f === "L" || ch(n - c) > 0.5 || ch(i - d) > 0.5) &&
                    (E(n, i, c, d), f === "L" && (l += 2)),
                (n = c),
                (i = d);
        else if (f === "A") {
            if (
                ((w = e[l + 4]),
                (A = e[l + 5]),
                (v = e[l + 6]),
                (b = e[l + 7]),
                (u = 7),
                w.length > 1 &&
                    (w.length < 3
                        ? ((b = v), (v = A), u--)
                        : ((b = A), (v = w.substr(2)), (u -= 2)),
                    (A = w.charAt(1)),
                    (w = w.charAt(0))),
                (y = kk(
                    n,
                    i,
                    +e[l + 1],
                    +e[l + 2],
                    +e[l + 3],
                    +w,
                    +A,
                    (p ? n : 0) + v * 1,
                    (p ? i : 0) + b * 1
                )),
                (l += u),
                y)
            )
                for (u = 0; u < y.length; u++) m.push(y[u]);
            (n = m[m.length - 2]), (i = m[m.length - 1]);
        } else console.log(h);
    return (
        (l = m.length),
        l < 6
            ? (t.pop(), (l = 0))
            : m[0] === m[l - 2] && m[1] === m[l - 1] && (m.closed = !0),
        (t.totalPoints = o + l),
        t
    );
}
function Mk(s) {
    Ek(s[0]) && (s = [s]);
    var e = "",
        t = s.length,
        n,
        i,
        r,
        a;
    for (i = 0; i < t; i++) {
        for (
            a = s[i],
                e += "M" + ur(a[0]) + "," + ur(a[1]) + " C",
                n = a.length,
                r = 2;
            r < n;
            r++
        )
            e +=
                ur(a[r++]) +
                "," +
                ur(a[r++]) +
                " " +
                ur(a[r++]) +
                "," +
                ur(a[r++]) +
                " " +
                ur(a[r++]) +
                "," +
                ur(a[r]) +
                " ";
        a.closed && (e += "z");
    }
    return e;
}
/*!
 * CustomEase 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var Dn,
    F1,
    $1 = function () {
        return (
            Dn ||
            (typeof window < "u" &&
                (Dn = window.gsap) &&
                Dn.registerPlugin &&
                Dn)
        );
    },
    G0 = function () {
        (Dn = $1()),
            Dn
                ? (Dn.registerEase("_CE", Oa.create), (F1 = 1))
                : console.warn("Please gsap.registerPlugin(CustomEase)");
    },
    Ik = 1e20,
    Pc = function (e) {
        return ~~(e * 1e3 + (e < 0 ? -0.5 : 0.5)) / 1e3;
    },
    Rk = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
    Lk = /[cLlsSaAhHvVtTqQ]/g,
    Ok = function (e) {
        var t = e.length,
            n = Ik,
            i;
        for (i = 1; i < t; i += 6) +e[i] < n && (n = +e[i]);
        return n;
    },
    Bk = function (e, t, n) {
        !n && n !== 0 && (n = Math.max(+e[e.length - 1], +e[1]));
        var i = +e[0] * -1,
            r = -n,
            a = e.length,
            o = 1 / (+e[a - 2] + i),
            h =
                -t ||
                (Math.abs(+e[a - 1] - +e[1]) < 0.01 * (+e[a - 2] - +e[0])
                    ? Ok(e) + r
                    : +e[a - 1] + r),
            l;
        for (h ? (h = 1 / h) : (h = -o), l = 0; l < a; l += 2)
            (e[l] = (+e[l] + i) * o), (e[l + 1] = (+e[l + 1] + r) * h);
    },
    Fk = function s(e, t, n, i, r, a, o, h, l, u, c) {
        var d = (e + n) / 2,
            f = (t + i) / 2,
            p = (n + r) / 2,
            m = (i + a) / 2,
            g = (r + o) / 2,
            _ = (a + h) / 2,
            v = (d + p) / 2,
            b = (f + m) / 2,
            y = (p + g) / 2,
            C = (m + _) / 2,
            w = (v + y) / 2,
            A = (b + C) / 2,
            E = o - e,
            S = h - t,
            P = Math.abs((n - o) * S - (i - h) * E),
            k = Math.abs((r - o) * S - (a - h) * E),
            R;
        return (
            u ||
                ((u = [
                    { x: e, y: t },
                    { x: o, y: h },
                ]),
                (c = 1)),
            u.splice(c || u.length - 1, 0, { x: w, y: A }),
            (P + k) * (P + k) > l * (E * E + S * S) &&
                ((R = u.length),
                s(e, t, d, f, v, b, w, A, l, u, c),
                s(w, A, y, C, g, _, o, h, l, u, c + 1 + (u.length - R))),
            u
        );
    },
    Oa = (function () {
        function s(t, n, i) {
            F1 || G0(), (this.id = t), this.setData(n, i);
        }
        var e = s.prototype;
        return (
            (e.setData = function (n, i) {
                (i = i || {}), (n = n || "0,0,1,1");
                var r = n.match(Rk),
                    a = 1,
                    o = [],
                    h = [],
                    l = i.precision || 1,
                    u = l <= 1,
                    c,
                    d,
                    f,
                    p,
                    m,
                    g,
                    _,
                    v,
                    b;
                if (
                    ((this.data = n),
                    (Lk.test(n) || (~n.indexOf("M") && n.indexOf("C") < 0)) &&
                        (r = Tk(n)[0]),
                    (c = r.length),
                    c === 4)
                )
                    r.unshift(0, 0), r.push(1, 1), (c = 8);
                else if ((c - 2) % 6) throw "Invalid CustomEase";
                for (
                    (+r[0] != 0 || +r[c - 2] != 1) &&
                        Bk(r, i.height, i.originY),
                        this.segment = r,
                        p = 2;
                    p < c;
                    p += 6
                )
                    (d = { x: +r[p - 2], y: +r[p - 1] }),
                        (f = { x: +r[p + 4], y: +r[p + 5] }),
                        o.push(d, f),
                        Fk(
                            d.x,
                            d.y,
                            +r[p],
                            +r[p + 1],
                            +r[p + 2],
                            +r[p + 3],
                            f.x,
                            f.y,
                            1 / (l * 2e5),
                            o,
                            o.length - 1
                        );
                for (c = o.length, p = 0; p < c; p++)
                    (_ = o[p]),
                        (v = o[p - 1] || _),
                        (_.x > v.x ||
                            (v.y !== _.y && v.x === _.x) ||
                            _ === v) &&
                        _.x <= 1
                            ? ((v.cx = _.x - v.x),
                              (v.cy = _.y - v.y),
                              (v.n = _),
                              (v.nx = _.x),
                              u &&
                                  p > 1 &&
                                  Math.abs(
                                      v.cy / v.cx - o[p - 2].cy / o[p - 2].cx
                                  ) > 2 &&
                                  (u = 0),
                              v.cx < a &&
                                  (v.cx
                                      ? (a = v.cx)
                                      : ((v.cx = 0.001),
                                        p === c - 1 &&
                                            ((v.x -= 0.001),
                                            (a = Math.min(a, 0.001)),
                                            (u = 0)))))
                            : (o.splice(p--, 1), c--);
                if (
                    ((c = (1 / a + 1) | 0), (m = 1 / c), (g = 0), (_ = o[0]), u)
                ) {
                    for (p = 0; p < c; p++)
                        (b = p * m),
                            _.nx < b && (_ = o[++g]),
                            (d = _.y + ((b - _.x) / _.cx) * _.cy),
                            (h[p] = { x: b, cx: m, y: d, cy: 0, nx: 9 }),
                            p && (h[p - 1].cy = d - h[p - 1].y);
                    (g = o[o.length - 1]),
                        (h[c - 1].cy = g.y - d),
                        (h[c - 1].cx = g.x - h[h.length - 1].x);
                } else {
                    for (p = 0; p < c; p++)
                        _.nx < p * m && (_ = o[++g]), (h[p] = _);
                    g < o.length - 1 && (h[p - 1] = o[o.length - 2]);
                }
                return (
                    (this.ease = function (y) {
                        var C = h[(y * c) | 0] || h[c - 1];
                        return (
                            C.nx < y && (C = C.n),
                            C.y + ((y - C.x) / C.cx) * C.cy
                        );
                    }),
                    (this.ease.custom = this),
                    this.id && Dn && Dn.registerEase(this.id, this.ease),
                    this
                );
            }),
            (e.getSVGData = function (n) {
                return s.getSVGData(this, n);
            }),
            (s.create = function (n, i, r) {
                return new s(n, i, r).ease;
            }),
            (s.register = function (n) {
                (Dn = n), G0();
            }),
            (s.get = function (n) {
                return Dn.parseEase(n);
            }),
            (s.getSVGData = function (n, i) {
                i = i || {};
                var r = i.width || 100,
                    a = i.height || 100,
                    o = i.x || 0,
                    h = (i.y || 0) + a,
                    l = Dn.utils.toArray(i.path)[0],
                    u,
                    c,
                    d,
                    f,
                    p,
                    m,
                    g,
                    _,
                    v,
                    b;
                if (
                    (i.invert && ((a = -a), (h = 0)),
                    typeof n == "string" && (n = Dn.parseEase(n)),
                    n.custom && (n = n.custom),
                    n instanceof s)
                )
                    u = Mk(Pk([n.segment], r, 0, 0, -a, o, h));
                else {
                    for (
                        u = [o, h],
                            g = Math.max(5, (i.precision || 1) * 200),
                            f = 1 / g,
                            g += 2,
                            _ = 5 / g,
                            v = Pc(o + f * r),
                            b = Pc(h + n(f) * -a),
                            c = (b - h) / (v - o),
                            d = 2;
                        d < g;
                        d++
                    )
                        (p = Pc(o + d * f * r)),
                            (m = Pc(h + n(d * f) * -a)),
                            (Math.abs((m - b) / (p - v) - c) > _ ||
                                d === g - 1) &&
                                (u.push(v, b), (c = (m - b) / (p - v))),
                            (v = p),
                            (b = m);
                    u = "M" + u.join(",");
                }
                return l && l.setAttribute("d", u), u;
            }),
            s
        );
    })();
Oa.version = "3.13.0";
Oa.headless = !0;
$1() && Dn.registerPlugin(Oa);
Je.registerPlugin(Oa);
let $k = 1;
function D1(s, e) {
    if ((e || (e = "customEase" + $k++), Oa.get(e)))
        throw new Error("Custom ease already registered: " + e);
    return Oa.create(e, s);
}
const Dk = 5860457,
    Mr = { x: 5, y: 3 },
    It = { x: 5, y: 6 },
    ut = 107.5,
    uh = 1,
    j0 = { x: 216, y: 698 },
    tl = { symbol: "s" },
    Nk = { symbol: "x" },
    Vk = { symbol: "1" },
    N1 = { symbol: "q" };
D1(
    "M0,0 C0.566,0.382 0.6,1.015 0.6,1.015 0.6,1.015 0.694,0.972 0.799,0.974 0.869,0.975 0.931,0.989 1,1 "
);
D1("M0,0 C0.046,0.493 0.173,0.695 0.299,0.821 0.453,0.94 0.504,1 1,1");
const W0 = { reelRevealOffsetDuration: 0.1, anticipationDuration: 0.6 },
    Uk = {
        1: { static: "tnt_static", land: "tnt_land", win: "tnt_win" },
        2: {
            static: "diamond_static",
            land: "diamond_static",
            win: "diamond_static",
        },
        3: {
            static: "gold_static",
            land: "gold_static",
            win: "gold_static",
            upgrade: "gold_upgrade",
        },
        4: {
            static: "iron_static",
            land: "iron_static",
            win: "iron_static",
            upgrade: "iron_upgrade",
        },
        5: {
            static: "wood_static",
            land: "wood_static",
            win: "wood_static",
            upgrade: "wood_upgrade",
        },
        q: {
            static: "upgrade_static",
            land: "upgrade_land",
            win: "upgrade_win",
        },
        s: { land: "bonus_land", static: "bonus_static", win: "bonus_win" },
        x: { land: "dead", win: "dead", static: "dead" },
    },
    zk = [
        [
            { symbol: "1" },
            { symbol: "2" },
            { symbol: "3" },
            { symbol: "x" },
            { symbol: "x" },
        ],
        [
            { symbol: "5" },
            { symbol: "q" },
            { symbol: "1" },
            { symbol: "4" },
            { symbol: "1" },
        ],
        [
            { symbol: "s" },
            { symbol: "x" },
            { symbol: "5" },
            { symbol: "2" },
            { symbol: "x" },
        ],
        [
            { symbol: "3" },
            { symbol: "4" },
            { symbol: "x" },
            { symbol: "x" },
            { symbol: "x" },
        ],
        [
            { symbol: "4" },
            { symbol: "s" },
            { symbol: "x" },
            { symbol: "x" },
            { symbol: "2" },
        ],
        [
            { symbol: "5" },
            { symbol: "1" },
            { symbol: "x" },
            { symbol: "1" },
            { symbol: "x" },
        ],
    ],
    Yk = [
        "d",
        "d",
        "c",
        "r",
        "g",
        "m",
        "d",
        "d",
        "c",
        "r",
        "g",
        "o",
        "d",
        "d",
        "c",
        "r",
        "g",
        "m",
        "d",
        "d",
        "c",
        "r",
        "g",
        "o",
        "d",
        "d",
        "c",
        "r",
        "g",
        "m",
    ],
    Gk = { 5: 1, 4: 2, 3: 3, 2: 5, 1: 1, s: 0, q: 0, x: 0 },
    jk = { d: 1, c: 2, r: 4, g: 5, m: 6, o: 7 },
    Wk = { d: 0, c: 0.1, r: 1, g: 3, m: 5, o: 25 };
function Xk(s, e) {
    const t = new Set();
    return (
        s.forEach((n, i) => {
            n.forEach((r, a) => {
                r.symbol === e && t.add({ reel: i, row: a });
            });
        }),
        t
    );
}
function qk(s, e) {
    let t = 0;
    const n = s.flat();
    for (let i = 0; i < n.length; i++)
        if ((n[i].symbol === tl.symbol && (t += 1), t === e)) return i;
    return s.length;
}
function X0(s) {
    const e = [];
    for (let t = 0; t < Mr.x; t++) {
        const n = [];
        for (let i = 0; i < Mr.y; i++) {
            const r = s[t * Mr.y + i];
            n.push({ symbol: r });
        }
        e.push(n);
    }
    return e;
}
function q0(s) {
    const e = { s: 1, 5: 10, 4: 7, 3: 5, 2: 3, 1: 1, q: 1, x: 10 };
    function t(a, o) {
        const h = o.reduce((u, c) => u + c, 0);
        let l = Math.random() * h;
        for (let u = 0; u < a.length; u++) {
            if (l < o[u]) return a[u];
            l -= o[u];
        }
        return a[a.length - 1];
    }
    const n = Object.keys(e),
        i = Object.values(e);
    return { symbol: t(n, i) };
}
function Hk(s) {
    switch (s) {
        case "d":
            return "dirt";
        case "c":
            return "stone";
        case "r":
            return "ruby";
        case "g":
            return "gold";
        case "m":
            return "diamond";
        case "o":
            return "obsidian";
        default:
            throw new Error(`Unknown block symbol: ${s}`);
    }
}
const Kk = "modulepreload",
    Zk = function (s, e) {
        return new URL(s, e).href;
    },
    H0 = {},
    Pu = function (e, t, n) {
        let i = Promise.resolve();
        if (t && t.length > 0) {
            let a = function (u) {
                return Promise.all(
                    u.map((c) =>
                        Promise.resolve(c).then(
                            (d) => ({ status: "fulfilled", value: d }),
                            (d) => ({ status: "rejected", reason: d })
                        )
                    )
                );
            };
            const o = document.getElementsByTagName("link"),
                h = document.querySelector("meta[property=csp-nonce]"),
                l =
                    (h == null ? void 0 : h.nonce) ||
                    (h == null ? void 0 : h.getAttribute("nonce"));
            i = a(
                t.map((u) => {
                    if (((u = Zk(u, n)), u in H0)) return;
                    H0[u] = !0;
                    const c = u.endsWith(".css"),
                        d = c ? '[rel="stylesheet"]' : "";
                    if (!!n)
                        for (let m = o.length - 1; m >= 0; m--) {
                            const g = o[m];
                            if (g.href === u && (!c || g.rel === "stylesheet"))
                                return;
                        }
                    else if (document.querySelector(`link[href="${u}"]${d}`))
                        return;
                    const p = document.createElement("link");
                    if (
                        ((p.rel = c ? "stylesheet" : Kk),
                        c || (p.as = "script"),
                        (p.crossOrigin = ""),
                        (p.href = u),
                        l && p.setAttribute("nonce", l),
                        document.head.appendChild(p),
                        c)
                    )
                        return new Promise((m, g) => {
                            p.addEventListener("load", m),
                                p.addEventListener("error", () =>
                                    g(
                                        new Error(
                                            `Unable to preload CSS for ${u}`
                                        )
                                    )
                                );
                        });
                })
            );
        }
        function r(a) {
            const o = new Event("vite:preloadError", { cancelable: !0 });
            if (((o.payload = a), window.dispatchEvent(o), !o.defaultPrevented))
                throw a;
        }
        return i.then((a) => {
            for (const o of a || []) o.status === "rejected" && r(o.reason);
            return e().catch(r);
        });
    };
var ee = ((s) => (
    (s.Application = "application"),
    (s.WebGLPipes = "webgl-pipes"),
    (s.WebGLPipesAdaptor = "webgl-pipes-adaptor"),
    (s.WebGLSystem = "webgl-system"),
    (s.WebGPUPipes = "webgpu-pipes"),
    (s.WebGPUPipesAdaptor = "webgpu-pipes-adaptor"),
    (s.WebGPUSystem = "webgpu-system"),
    (s.CanvasSystem = "canvas-system"),
    (s.CanvasPipesAdaptor = "canvas-pipes-adaptor"),
    (s.CanvasPipes = "canvas-pipes"),
    (s.Asset = "asset"),
    (s.LoadParser = "load-parser"),
    (s.ResolveParser = "resolve-parser"),
    (s.CacheParser = "cache-parser"),
    (s.DetectionParser = "detection-parser"),
    (s.MaskEffect = "mask-effect"),
    (s.BlendMode = "blend-mode"),
    (s.TextureSource = "texture-source"),
    (s.Environment = "environment"),
    (s.ShapeBuilder = "shape-builder"),
    (s.Batcher = "batcher"),
    s
))(ee || {});
const Jp = (s) => {
        if (typeof s == "function" || (typeof s == "object" && s.extension)) {
            if (!s.extension)
                throw new Error(
                    "Extension class must have an extension object"
                );
            s = {
                ...(typeof s.extension != "object"
                    ? { type: s.extension }
                    : s.extension),
                ref: s,
            };
        }
        if (typeof s == "object") s = { ...s };
        else throw new Error("Invalid extension type");
        return typeof s.type == "string" && (s.type = [s.type]), s;
    },
    kc = (s, e) => Jp(s).priority ?? e,
    Ot = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...s) {
            return (
                s.map(Jp).forEach((e) => {
                    e.type.forEach((t) => {
                        var n, i;
                        return (i = (n = this._removeHandlers)[t]) == null
                            ? void 0
                            : i.call(n, e);
                    });
                }),
                this
            );
        },
        add(...s) {
            return (
                s.map(Jp).forEach((e) => {
                    e.type.forEach((t) => {
                        var r, a;
                        const n = this._addHandlers,
                            i = this._queue;
                        n[t]
                            ? (a = n[t]) == null || a.call(n, e)
                            : ((i[t] = i[t] || []),
                              (r = i[t]) == null || r.push(e));
                    });
                }),
                this
            );
        },
        handle(s, e, t) {
            var a;
            const n = this._addHandlers,
                i = this._removeHandlers;
            if (n[s] || i[s])
                throw new Error(`Extension type ${s} already has a handler`);
            (n[s] = e), (i[s] = t);
            const r = this._queue;
            return (
                r[s] &&
                    ((a = r[s]) == null || a.forEach((o) => e(o)), delete r[s]),
                this
            );
        },
        handleByMap(s, e) {
            return this.handle(
                s,
                (t) => {
                    t.name && (e[t.name] = t.ref);
                },
                (t) => {
                    t.name && delete e[t.name];
                }
            );
        },
        handleByNamedList(s, e, t = -1) {
            return this.handle(
                s,
                (n) => {
                    e.findIndex((r) => r.name === n.name) >= 0 ||
                        (e.push({ name: n.name, value: n.ref }),
                        e.sort((r, a) => kc(a.value, t) - kc(r.value, t)));
                },
                (n) => {
                    const i = e.findIndex((r) => r.name === n.name);
                    i !== -1 && e.splice(i, 1);
                }
            );
        },
        handleByList(s, e, t = -1) {
            return this.handle(
                s,
                (n) => {
                    e.includes(n.ref) ||
                        (e.push(n.ref), e.sort((i, r) => kc(r, t) - kc(i, t)));
                },
                (n) => {
                    const i = e.indexOf(n.ref);
                    i !== -1 && e.splice(i, 1);
                }
            );
        },
        mixin(s, ...e) {
            for (const t of e)
                Object.defineProperties(
                    s.prototype,
                    Object.getOwnPropertyDescriptors(t)
                );
        },
    },
    Qk = {
        extension: { type: ee.Environment, name: "browser", priority: -1 },
        test: () => !0,
        load: async () => {
            await Pu(
                () => import("./browserAll-CSnNg6po.js"),
                __vite__mapDeps([0, 1, 2]),
                import.meta.url
            );
        },
    },
    Jk = {
        extension: { type: ee.Environment, name: "webworker", priority: 0 },
        test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async () => {
            await Pu(
                () => import("./webworkerAll-Dusud6Lz.js"),
                __vite__mapDeps([1, 2]),
                import.meta.url
            );
        },
    };
class Wt {
    constructor(e, t, n) {
        (this._x = t || 0), (this._y = n || 0), (this._observer = e);
    }
    clone(e) {
        return new Wt(e ?? this._observer, this._x, this._y);
    }
    set(e = 0, t = e) {
        return (
            (this._x !== e || this._y !== t) &&
                ((this._x = e), (this._y = t), this._observer._onUpdate(this)),
            this
        );
    }
    copyFrom(e) {
        return (
            (this._x !== e.x || this._y !== e.y) &&
                ((this._x = e.x),
                (this._y = e.y),
                this._observer._onUpdate(this)),
            this
        );
    }
    copyTo(e) {
        return e.set(this._x, this._y), e;
    }
    equals(e) {
        return e.x === this._x && e.y === this._y;
    }
    toString() {
        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
    }
    get x() {
        return this._x;
    }
    set x(e) {
        this._x !== e && ((this._x = e), this._observer._onUpdate(this));
    }
    get y() {
        return this._y;
    }
    set y(e) {
        this._y !== e && ((this._y = e), this._observer._onUpdate(this));
    }
}
var Ml =
    typeof globalThis < "u"
        ? globalThis
        : typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : typeof self < "u"
        ? self
        : {};
function V1(s) {
    return s &&
        s.__esModule &&
        Object.prototype.hasOwnProperty.call(s, "default")
        ? s.default
        : s;
}
var vf = { exports: {} },
    K0;
function eT() {
    return (
        K0 ||
            ((K0 = 1),
            (function (s) {
                var e = Object.prototype.hasOwnProperty,
                    t = "~";
                function n() {}
                Object.create &&
                    ((n.prototype = Object.create(null)),
                    new n().__proto__ || (t = !1));
                function i(h, l, u) {
                    (this.fn = h), (this.context = l), (this.once = u || !1);
                }
                function r(h, l, u, c, d) {
                    if (typeof u != "function")
                        throw new TypeError("The listener must be a function");
                    var f = new i(u, c || h, d),
                        p = t ? t + l : l;
                    return (
                        h._events[p]
                            ? h._events[p].fn
                                ? (h._events[p] = [h._events[p], f])
                                : h._events[p].push(f)
                            : ((h._events[p] = f), h._eventsCount++),
                        h
                    );
                }
                function a(h, l) {
                    --h._eventsCount === 0
                        ? (h._events = new n())
                        : delete h._events[l];
                }
                function o() {
                    (this._events = new n()), (this._eventsCount = 0);
                }
                (o.prototype.eventNames = function () {
                    var l = [],
                        u,
                        c;
                    if (this._eventsCount === 0) return l;
                    for (c in (u = this._events))
                        e.call(u, c) && l.push(t ? c.slice(1) : c);
                    return Object.getOwnPropertySymbols
                        ? l.concat(Object.getOwnPropertySymbols(u))
                        : l;
                }),
                    (o.prototype.listeners = function (l) {
                        var u = t ? t + l : l,
                            c = this._events[u];
                        if (!c) return [];
                        if (c.fn) return [c.fn];
                        for (
                            var d = 0, f = c.length, p = new Array(f);
                            d < f;
                            d++
                        )
                            p[d] = c[d].fn;
                        return p;
                    }),
                    (o.prototype.listenerCount = function (l) {
                        var u = t ? t + l : l,
                            c = this._events[u];
                        return c ? (c.fn ? 1 : c.length) : 0;
                    }),
                    (o.prototype.emit = function (l, u, c, d, f, p) {
                        var m = t ? t + l : l;
                        if (!this._events[m]) return !1;
                        var g = this._events[m],
                            _ = arguments.length,
                            v,
                            b;
                        if (g.fn) {
                            switch (
                                (g.once &&
                                    this.removeListener(l, g.fn, void 0, !0),
                                _)
                            ) {
                                case 1:
                                    return g.fn.call(g.context), !0;
                                case 2:
                                    return g.fn.call(g.context, u), !0;
                                case 3:
                                    return g.fn.call(g.context, u, c), !0;
                                case 4:
                                    return g.fn.call(g.context, u, c, d), !0;
                                case 5:
                                    return g.fn.call(g.context, u, c, d, f), !0;
                                case 6:
                                    return (
                                        g.fn.call(g.context, u, c, d, f, p), !0
                                    );
                            }
                            for (b = 1, v = new Array(_ - 1); b < _; b++)
                                v[b - 1] = arguments[b];
                            g.fn.apply(g.context, v);
                        } else {
                            var y = g.length,
                                C;
                            for (b = 0; b < y; b++)
                                switch (
                                    (g[b].once &&
                                        this.removeListener(
                                            l,
                                            g[b].fn,
                                            void 0,
                                            !0
                                        ),
                                    _)
                                ) {
                                    case 1:
                                        g[b].fn.call(g[b].context);
                                        break;
                                    case 2:
                                        g[b].fn.call(g[b].context, u);
                                        break;
                                    case 3:
                                        g[b].fn.call(g[b].context, u, c);
                                        break;
                                    case 4:
                                        g[b].fn.call(g[b].context, u, c, d);
                                        break;
                                    default:
                                        if (!v)
                                            for (
                                                C = 1, v = new Array(_ - 1);
                                                C < _;
                                                C++
                                            )
                                                v[C - 1] = arguments[C];
                                        g[b].fn.apply(g[b].context, v);
                                }
                        }
                        return !0;
                    }),
                    (o.prototype.on = function (l, u, c) {
                        return r(this, l, u, c, !1);
                    }),
                    (o.prototype.once = function (l, u, c) {
                        return r(this, l, u, c, !0);
                    }),
                    (o.prototype.removeListener = function (l, u, c, d) {
                        var f = t ? t + l : l;
                        if (!this._events[f]) return this;
                        if (!u) return a(this, f), this;
                        var p = this._events[f];
                        if (p.fn)
                            p.fn === u &&
                                (!d || p.once) &&
                                (!c || p.context === c) &&
                                a(this, f);
                        else {
                            for (var m = 0, g = [], _ = p.length; m < _; m++)
                                (p[m].fn !== u ||
                                    (d && !p[m].once) ||
                                    (c && p[m].context !== c)) &&
                                    g.push(p[m]);
                            g.length
                                ? (this._events[f] = g.length === 1 ? g[0] : g)
                                : a(this, f);
                        }
                        return this;
                    }),
                    (o.prototype.removeAllListeners = function (l) {
                        var u;
                        return (
                            l
                                ? ((u = t ? t + l : l),
                                  this._events[u] && a(this, u))
                                : ((this._events = new n()),
                                  (this._eventsCount = 0)),
                            this
                        );
                    }),
                    (o.prototype.off = o.prototype.removeListener),
                    (o.prototype.addListener = o.prototype.on),
                    (o.prefixed = t),
                    (o.EventEmitter = o),
                    (s.exports = o);
            })(vf)),
        vf.exports
    );
}
var tT = eT();
const ti = V1(tT),
    nT = Math.PI * 2,
    sT = 180 / Math.PI,
    iT = Math.PI / 180;
class gn {
    constructor(e = 0, t = 0) {
        (this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
    }
    clone() {
        return new gn(this.x, this.y);
    }
    copyFrom(e) {
        return this.set(e.x, e.y), this;
    }
    copyTo(e) {
        return e.set(this.x, this.y), e;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y;
    }
    set(e = 0, t = e) {
        return (this.x = e), (this.y = t), this;
    }
    toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
        return (bf.x = 0), (bf.y = 0), bf;
    }
}
const bf = new gn();
class Ce {
    constructor(e = 1, t = 0, n = 0, i = 1, r = 0, a = 0) {
        (this.array = null),
            (this.a = e),
            (this.b = t),
            (this.c = n),
            (this.d = i),
            (this.tx = r),
            (this.ty = a);
    }
    fromArray(e) {
        (this.a = e[0]),
            (this.b = e[1]),
            (this.c = e[3]),
            (this.d = e[4]),
            (this.tx = e[2]),
            (this.ty = e[5]);
    }
    set(e, t, n, i, r, a) {
        return (
            (this.a = e),
            (this.b = t),
            (this.c = n),
            (this.d = i),
            (this.tx = r),
            (this.ty = a),
            this
        );
    }
    toArray(e, t) {
        this.array || (this.array = new Float32Array(9));
        const n = t || this.array;
        return (
            e
                ? ((n[0] = this.a),
                  (n[1] = this.b),
                  (n[2] = 0),
                  (n[3] = this.c),
                  (n[4] = this.d),
                  (n[5] = 0),
                  (n[6] = this.tx),
                  (n[7] = this.ty),
                  (n[8] = 1))
                : ((n[0] = this.a),
                  (n[1] = this.c),
                  (n[2] = this.tx),
                  (n[3] = this.b),
                  (n[4] = this.d),
                  (n[5] = this.ty),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 1)),
            n
        );
    }
    apply(e, t) {
        t = t || new gn();
        const n = e.x,
            i = e.y;
        return (
            (t.x = this.a * n + this.c * i + this.tx),
            (t.y = this.b * n + this.d * i + this.ty),
            t
        );
    }
    applyInverse(e, t) {
        t = t || new gn();
        const n = this.a,
            i = this.b,
            r = this.c,
            a = this.d,
            o = this.tx,
            h = this.ty,
            l = 1 / (n * a + r * -i),
            u = e.x,
            c = e.y;
        return (
            (t.x = a * l * u + -r * l * c + (h * r - o * a) * l),
            (t.y = n * l * c + -i * l * u + (-h * n + o * i) * l),
            t
        );
    }
    translate(e, t) {
        return (this.tx += e), (this.ty += t), this;
    }
    scale(e, t) {
        return (
            (this.a *= e),
            (this.d *= t),
            (this.c *= e),
            (this.b *= t),
            (this.tx *= e),
            (this.ty *= t),
            this
        );
    }
    rotate(e) {
        const t = Math.cos(e),
            n = Math.sin(e),
            i = this.a,
            r = this.c,
            a = this.tx;
        return (
            (this.a = i * t - this.b * n),
            (this.b = i * n + this.b * t),
            (this.c = r * t - this.d * n),
            (this.d = r * n + this.d * t),
            (this.tx = a * t - this.ty * n),
            (this.ty = a * n + this.ty * t),
            this
        );
    }
    append(e) {
        const t = this.a,
            n = this.b,
            i = this.c,
            r = this.d;
        return (
            (this.a = e.a * t + e.b * i),
            (this.b = e.a * n + e.b * r),
            (this.c = e.c * t + e.d * i),
            (this.d = e.c * n + e.d * r),
            (this.tx = e.tx * t + e.ty * i + this.tx),
            (this.ty = e.tx * n + e.ty * r + this.ty),
            this
        );
    }
    appendFrom(e, t) {
        const n = e.a,
            i = e.b,
            r = e.c,
            a = e.d,
            o = e.tx,
            h = e.ty,
            l = t.a,
            u = t.b,
            c = t.c,
            d = t.d;
        return (
            (this.a = n * l + i * c),
            (this.b = n * u + i * d),
            (this.c = r * l + a * c),
            (this.d = r * u + a * d),
            (this.tx = o * l + h * c + t.tx),
            (this.ty = o * u + h * d + t.ty),
            this
        );
    }
    setTransform(e, t, n, i, r, a, o, h, l) {
        return (
            (this.a = Math.cos(o + l) * r),
            (this.b = Math.sin(o + l) * r),
            (this.c = -Math.sin(o - h) * a),
            (this.d = Math.cos(o - h) * a),
            (this.tx = e - (n * this.a + i * this.c)),
            (this.ty = t - (n * this.b + i * this.d)),
            this
        );
    }
    prepend(e) {
        const t = this.tx;
        if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
            const n = this.a,
                i = this.c;
            (this.a = n * e.a + this.b * e.c),
                (this.b = n * e.b + this.b * e.d),
                (this.c = i * e.a + this.d * e.c),
                (this.d = i * e.b + this.d * e.d);
        }
        return (
            (this.tx = t * e.a + this.ty * e.c + e.tx),
            (this.ty = t * e.b + this.ty * e.d + e.ty),
            this
        );
    }
    decompose(e) {
        const t = this.a,
            n = this.b,
            i = this.c,
            r = this.d,
            a = e.pivot,
            o = -Math.atan2(-i, r),
            h = Math.atan2(n, t),
            l = Math.abs(o + h);
        return (
            l < 1e-5 || Math.abs(nT - l) < 1e-5
                ? ((e.rotation = h), (e.skew.x = e.skew.y = 0))
                : ((e.rotation = 0), (e.skew.x = o), (e.skew.y = h)),
            (e.scale.x = Math.sqrt(t * t + n * n)),
            (e.scale.y = Math.sqrt(i * i + r * r)),
            (e.position.x = this.tx + (a.x * t + a.y * i)),
            (e.position.y = this.ty + (a.x * n + a.y * r)),
            e
        );
    }
    invert() {
        const e = this.a,
            t = this.b,
            n = this.c,
            i = this.d,
            r = this.tx,
            a = e * i - t * n;
        return (
            (this.a = i / a),
            (this.b = -t / a),
            (this.c = -n / a),
            (this.d = e / a),
            (this.tx = (n * this.ty - i * r) / a),
            (this.ty = -(e * this.ty - t * r) / a),
            this
        );
    }
    isIdentity() {
        return (
            this.a === 1 &&
            this.b === 0 &&
            this.c === 0 &&
            this.d === 1 &&
            this.tx === 0 &&
            this.ty === 0
        );
    }
    identity() {
        return (
            (this.a = 1),
            (this.b = 0),
            (this.c = 0),
            (this.d = 1),
            (this.tx = 0),
            (this.ty = 0),
            this
        );
    }
    clone() {
        const e = new Ce();
        return (
            (e.a = this.a),
            (e.b = this.b),
            (e.c = this.c),
            (e.d = this.d),
            (e.tx = this.tx),
            (e.ty = this.ty),
            e
        );
    }
    copyTo(e) {
        return (
            (e.a = this.a),
            (e.b = this.b),
            (e.c = this.c),
            (e.d = this.d),
            (e.tx = this.tx),
            (e.ty = this.ty),
            e
        );
    }
    copyFrom(e) {
        return (
            (this.a = e.a),
            (this.b = e.b),
            (this.c = e.c),
            (this.d = e.d),
            (this.tx = e.tx),
            (this.ty = e.ty),
            this
        );
    }
    equals(e) {
        return (
            e.a === this.a &&
            e.b === this.b &&
            e.c === this.c &&
            e.d === this.d &&
            e.tx === this.tx &&
            e.ty === this.ty
        );
    }
    toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
        return aT.identity();
    }
    static get shared() {
        return rT.identity();
    }
}
const rT = new Ce(),
    aT = new Ce(),
    la = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    ha = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    ca = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    ua = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    em = [],
    U1 = [],
    Tc = Math.sign;
function oT() {
    for (let s = 0; s < 16; s++) {
        const e = [];
        em.push(e);
        for (let t = 0; t < 16; t++) {
            const n = Tc(la[s] * la[t] + ca[s] * ha[t]),
                i = Tc(ha[s] * la[t] + ua[s] * ha[t]),
                r = Tc(la[s] * ca[t] + ca[s] * ua[t]),
                a = Tc(ha[s] * ca[t] + ua[s] * ua[t]);
            for (let o = 0; o < 16; o++)
                if (la[o] === n && ha[o] === i && ca[o] === r && ua[o] === a) {
                    e.push(o);
                    break;
                }
        }
    }
    for (let s = 0; s < 16; s++) {
        const e = new Ce();
        e.set(la[s], ha[s], ca[s], ua[s], 0, 0), U1.push(e);
    }
}
oT();
const Ze = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (s) => la[s],
        uY: (s) => ha[s],
        vX: (s) => ca[s],
        vY: (s) => ua[s],
        inv: (s) => (s & 8 ? s & 15 : -s & 7),
        add: (s, e) => em[s][e],
        sub: (s, e) => em[s][Ze.inv(e)],
        rotate180: (s) => s ^ 4,
        isVertical: (s) => (s & 3) === 2,
        byDirection: (s, e) =>
            Math.abs(s) * 2 <= Math.abs(e)
                ? e >= 0
                    ? Ze.S
                    : Ze.N
                : Math.abs(e) * 2 <= Math.abs(s)
                ? s > 0
                    ? Ze.E
                    : Ze.W
                : e > 0
                ? s > 0
                    ? Ze.SE
                    : Ze.SW
                : s > 0
                ? Ze.NE
                : Ze.NW,
        matrixAppendRotationInv: (s, e, t = 0, n = 0) => {
            const i = U1[Ze.inv(e)];
            (i.tx = t), (i.ty = n), s.append(i);
        },
        transformRectCoords: (s, e, t, n) => {
            const { x: i, y: r, width: a, height: o } = s,
                { x: h, y: l, width: u, height: c } = e;
            return t === Ze.E
                ? (n.set(i + h, r + l, a, o), n)
                : t === Ze.S
                ? n.set(u - r - o + h, i + l, o, a)
                : t === Ze.W
                ? n.set(u - i - a + h, c - r - o + l, a, o)
                : t === Ze.N
                ? n.set(r + h, c - i - a + l, o, a)
                : n.set(i + h, r + l, a, o);
        },
    },
    Mc = [new gn(), new gn(), new gn(), new gn()];
class Lt {
    constructor(e = 0, t = 0, n = 0, i = 0) {
        (this.type = "rectangle"),
            (this.x = Number(e)),
            (this.y = Number(t)),
            (this.width = Number(n)),
            (this.height = Number(i));
    }
    get left() {
        return this.x;
    }
    get right() {
        return this.x + this.width;
    }
    get top() {
        return this.y;
    }
    get bottom() {
        return this.y + this.height;
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
        return new Lt(0, 0, 0, 0);
    }
    clone() {
        return new Lt(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(e) {
        return (
            (this.x = e.minX),
            (this.y = e.minY),
            (this.width = e.maxX - e.minX),
            (this.height = e.maxY - e.minY),
            this
        );
    }
    copyFrom(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.width = e.width),
            (this.height = e.height),
            this
        );
    }
    copyTo(e) {
        return e.copyFrom(this), e;
    }
    contains(e, t) {
        return this.width <= 0 || this.height <= 0
            ? !1
            : e >= this.x &&
                  e < this.x + this.width &&
                  t >= this.y &&
                  t < this.y + this.height;
    }
    strokeContains(e, t, n, i = 0.5) {
        const { width: r, height: a } = this;
        if (r <= 0 || a <= 0) return !1;
        const o = this.x,
            h = this.y,
            l = n * (1 - i),
            u = n - l,
            c = o - l,
            d = o + r + l,
            f = h - l,
            p = h + a + l,
            m = o + u,
            g = o + r - u,
            _ = h + u,
            v = h + a - u;
        return (
            e >= c &&
            e <= d &&
            t >= f &&
            t <= p &&
            !(e > m && e < g && t > _ && t < v)
        );
    }
    intersects(e, t) {
        if (!t) {
            const E = this.x < e.x ? e.x : this.x;
            if ((this.right > e.right ? e.right : this.right) <= E) return !1;
            const P = this.y < e.y ? e.y : this.y;
            return (this.bottom > e.bottom ? e.bottom : this.bottom) > P;
        }
        const n = this.left,
            i = this.right,
            r = this.top,
            a = this.bottom;
        if (i <= n || a <= r) return !1;
        const o = Mc[0].set(e.left, e.top),
            h = Mc[1].set(e.left, e.bottom),
            l = Mc[2].set(e.right, e.top),
            u = Mc[3].set(e.right, e.bottom);
        if (l.x <= o.x || h.y <= o.y) return !1;
        const c = Math.sign(t.a * t.d - t.b * t.c);
        if (
            c === 0 ||
            (t.apply(o, o),
            t.apply(h, h),
            t.apply(l, l),
            t.apply(u, u),
            Math.max(o.x, h.x, l.x, u.x) <= n ||
                Math.min(o.x, h.x, l.x, u.x) >= i ||
                Math.max(o.y, h.y, l.y, u.y) <= r ||
                Math.min(o.y, h.y, l.y, u.y) >= a)
        )
            return !1;
        const d = c * (h.y - o.y),
            f = c * (o.x - h.x),
            p = d * n + f * r,
            m = d * i + f * r,
            g = d * n + f * a,
            _ = d * i + f * a;
        if (
            Math.max(p, m, g, _) <= d * o.x + f * o.y ||
            Math.min(p, m, g, _) >= d * u.x + f * u.y
        )
            return !1;
        const v = c * (o.y - l.y),
            b = c * (l.x - o.x),
            y = v * n + b * r,
            C = v * i + b * r,
            w = v * n + b * a,
            A = v * i + b * a;
        return !(
            Math.max(y, C, w, A) <= v * o.x + b * o.y ||
            Math.min(y, C, w, A) >= v * u.x + b * u.y
        );
    }
    pad(e = 0, t = e) {
        return (
            (this.x -= e),
            (this.y -= t),
            (this.width += e * 2),
            (this.height += t * 2),
            this
        );
    }
    fit(e) {
        const t = Math.max(this.x, e.x),
            n = Math.min(this.x + this.width, e.x + e.width),
            i = Math.max(this.y, e.y),
            r = Math.min(this.y + this.height, e.y + e.height);
        return (
            (this.x = t),
            (this.width = Math.max(n - t, 0)),
            (this.y = i),
            (this.height = Math.max(r - i, 0)),
            this
        );
    }
    ceil(e = 1, t = 0.001) {
        const n = Math.ceil((this.x + this.width - t) * e) / e,
            i = Math.ceil((this.y + this.height - t) * e) / e;
        return (
            (this.x = Math.floor((this.x + t) * e) / e),
            (this.y = Math.floor((this.y + t) * e) / e),
            (this.width = n - this.x),
            (this.height = i - this.y),
            this
        );
    }
    scale(e, t = e) {
        return (
            (this.x *= e),
            (this.y *= t),
            (this.width *= e),
            (this.height *= t),
            this
        );
    }
    enlarge(e) {
        const t = Math.min(this.x, e.x),
            n = Math.max(this.x + this.width, e.x + e.width),
            i = Math.min(this.y, e.y),
            r = Math.max(this.y + this.height, e.y + e.height);
        return (
            (this.x = t),
            (this.width = n - t),
            (this.y = i),
            (this.height = r - i),
            this
        );
    }
    getBounds(e) {
        return e || (e = new Lt()), e.copyFrom(this), e;
    }
    containsRect(e) {
        if (this.width <= 0 || this.height <= 0) return !1;
        const t = e.x,
            n = e.y,
            i = e.x + e.width,
            r = e.y + e.height;
        return (
            t >= this.x &&
            t < this.x + this.width &&
            n >= this.y &&
            n < this.y + this.height &&
            i >= this.x &&
            i < this.x + this.width &&
            r >= this.y &&
            r < this.y + this.height
        );
    }
    set(e, t, n, i) {
        return (
            (this.x = e),
            (this.y = t),
            (this.width = n),
            (this.height = i),
            this
        );
    }
    toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
}
const yf = { default: -1 };
function Pt(s = "default") {
    return yf[s] === void 0 && (yf[s] = -1), ++yf[s];
}
const Z0 = new Set(),
    Ge = "8.0.0",
    lT = "8.3.4",
    wo = { quiet: !1, noColor: !1 },
    ae = (s, e, t = 3) => {
        if (wo.quiet || Z0.has(e)) return;
        let n = new Error().stack;
        const i = `${e}
Deprecated since v${s}`,
            r = typeof console.groupCollapsed == "function" && !wo.noColor;
        typeof n > "u"
            ? console.warn("PixiJS Deprecation Warning: ", i)
            : ((n = n
                  .split(
                      `
`
                  )
                  .splice(t).join(`
`)),
              r
                  ? (console.groupCollapsed(
                        "%cPixiJS Deprecation Warning: %c%s",
                        "color:#614108;background:#fffbe6",
                        "font-weight:normal;color:#614108;background:#fffbe6",
                        i
                    ),
                    console.warn(n),
                    console.groupEnd())
                  : (console.warn("PixiJS Deprecation Warning: ", i),
                    console.warn(n))),
            Z0.add(e);
    };
Object.defineProperties(ae, {
    quiet: {
        get: () => wo.quiet,
        set: (s) => {
            wo.quiet = s;
        },
        enumerable: !0,
        configurable: !1,
    },
    noColor: {
        get: () => wo.noColor,
        set: (s) => {
            wo.noColor = s;
        },
        enumerable: !0,
        configurable: !1,
    },
});
const z1 = () => {};
function ku(s) {
    return (
        (s += s === 0 ? 1 : 0),
        --s,
        (s |= s >>> 1),
        (s |= s >>> 2),
        (s |= s >>> 4),
        (s |= s >>> 8),
        (s |= s >>> 16),
        s + 1
    );
}
function Q0(s) {
    return !(s & (s - 1)) && !!s;
}
function Y1(s) {
    const e = {};
    for (const t in s) s[t] !== void 0 && (e[t] = s[t]);
    return e;
}
const J0 = Object.create(null);
function hT(s) {
    const e = J0[s];
    return e === void 0 && (J0[s] = Pt("resource")), e;
}
const G1 = class j1 extends ti {
    constructor(e = {}) {
        super(),
            (this._resourceType = "textureSampler"),
            (this._touched = 0),
            (this._maxAnisotropy = 1),
            (this.destroyed = !1),
            (e = { ...j1.defaultOptions, ...e }),
            (this.addressMode = e.addressMode),
            (this.addressModeU = e.addressModeU ?? this.addressModeU),
            (this.addressModeV = e.addressModeV ?? this.addressModeV),
            (this.addressModeW = e.addressModeW ?? this.addressModeW),
            (this.scaleMode = e.scaleMode),
            (this.magFilter = e.magFilter ?? this.magFilter),
            (this.minFilter = e.minFilter ?? this.minFilter),
            (this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter),
            (this.lodMinClamp = e.lodMinClamp),
            (this.lodMaxClamp = e.lodMaxClamp),
            (this.compare = e.compare),
            (this.maxAnisotropy = e.maxAnisotropy ?? 1);
    }
    set addressMode(e) {
        (this.addressModeU = e),
            (this.addressModeV = e),
            (this.addressModeW = e);
    }
    get addressMode() {
        return this.addressModeU;
    }
    set wrapMode(e) {
        ae(Ge, "TextureStyle.wrapMode is now TextureStyle.addressMode"),
            (this.addressMode = e);
    }
    get wrapMode() {
        return this.addressMode;
    }
    set scaleMode(e) {
        (this.magFilter = e), (this.minFilter = e), (this.mipmapFilter = e);
    }
    get scaleMode() {
        return this.magFilter;
    }
    set maxAnisotropy(e) {
        (this._maxAnisotropy = Math.min(e, 16)),
            this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
        return this._maxAnisotropy;
    }
    get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
    }
    update() {
        this.emit("change", this), (this._sharedResourceId = null);
    }
    _generateResourceId() {
        const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        return (this._sharedResourceId = hT(e)), this._resourceId;
    }
    destroy() {
        (this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this.removeAllListeners();
    }
};
G1.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" };
let Tu = G1;
const W1 = class X1 extends ti {
    constructor(e = {}) {
        super(),
            (this.options = e),
            (this.uid = Pt("textureSource")),
            (this._resourceType = "textureSource"),
            (this._resourceId = Pt("resource")),
            (this.uploadMethodId = "unknown"),
            (this._resolution = 1),
            (this.pixelWidth = 1),
            (this.pixelHeight = 1),
            (this.width = 1),
            (this.height = 1),
            (this.sampleCount = 1),
            (this.mipLevelCount = 1),
            (this.autoGenerateMipmaps = !1),
            (this.format = "rgba8unorm"),
            (this.dimension = "2d"),
            (this.antialias = !1),
            (this._touched = 0),
            (this._batchTick = -1),
            (this._textureBindLocation = -1),
            (e = { ...X1.defaultOptions, ...e }),
            (this.label = e.label ?? ""),
            (this.resource = e.resource),
            (this.autoGarbageCollect = e.autoGarbageCollect),
            (this._resolution = e.resolution),
            e.width
                ? (this.pixelWidth = e.width * this._resolution)
                : (this.pixelWidth = this.resource
                      ? this.resourceWidth ?? 1
                      : 1),
            e.height
                ? (this.pixelHeight = e.height * this._resolution)
                : (this.pixelHeight = this.resource
                      ? this.resourceHeight ?? 1
                      : 1),
            (this.width = this.pixelWidth / this._resolution),
            (this.height = this.pixelHeight / this._resolution),
            (this.format = e.format),
            (this.dimension = e.dimensions),
            (this.mipLevelCount = e.mipLevelCount),
            (this.autoGenerateMipmaps = e.autoGenerateMipmaps),
            (this.sampleCount = e.sampleCount),
            (this.antialias = e.antialias),
            (this.alphaMode = e.alphaMode),
            (this.style = new Tu(Y1(e))),
            (this.destroyed = !1),
            this._refreshPOT();
    }
    get source() {
        return this;
    }
    get style() {
        return this._style;
    }
    set style(e) {
        var t, n;
        this.style !== e &&
            ((t = this._style) == null ||
                t.off("change", this._onStyleChange, this),
            (this._style = e),
            (n = this._style) == null ||
                n.on("change", this._onStyleChange, this),
            this._onStyleChange());
    }
    set maxAnisotropy(e) {
        this._style.maxAnisotropy = e;
    }
    get maxAnisotropy() {
        return this._style.maxAnisotropy;
    }
    get addressMode() {
        return this._style.addressMode;
    }
    set addressMode(e) {
        this._style.addressMode = e;
    }
    get repeatMode() {
        return this._style.addressMode;
    }
    set repeatMode(e) {
        this._style.addressMode = e;
    }
    get magFilter() {
        return this._style.magFilter;
    }
    set magFilter(e) {
        this._style.magFilter = e;
    }
    get minFilter() {
        return this._style.minFilter;
    }
    set minFilter(e) {
        this._style.minFilter = e;
    }
    get mipmapFilter() {
        return this._style.mipmapFilter;
    }
    set mipmapFilter(e) {
        this._style.mipmapFilter = e;
    }
    get lodMinClamp() {
        return this._style.lodMinClamp;
    }
    set lodMinClamp(e) {
        this._style.lodMinClamp = e;
    }
    get lodMaxClamp() {
        return this._style.lodMaxClamp;
    }
    set lodMaxClamp(e) {
        this._style.lodMaxClamp = e;
    }
    _onStyleChange() {
        this.emit("styleChange", this);
    }
    update() {
        if (this.resource) {
            const e = this._resolution;
            if (this.resize(this.resourceWidth / e, this.resourceHeight / e))
                return;
        }
        this.emit("update", this);
    }
    destroy() {
        (this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this._style && (this._style.destroy(), (this._style = null)),
            (this.uploadMethodId = null),
            (this.resource = null),
            this.removeAllListeners();
    }
    unload() {
        (this._resourceId = Pt("resource")),
            this.emit("change", this),
            this.emit("unload", this);
    }
    get resourceWidth() {
        const { resource: e } = this;
        return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
    }
    get resourceHeight() {
        const { resource: e } = this;
        return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(e) {
        this._resolution !== e &&
            ((this._resolution = e),
            (this.width = this.pixelWidth / e),
            (this.height = this.pixelHeight / e));
    }
    resize(e, t, n) {
        n || (n = this._resolution),
            e || (e = this.width),
            t || (t = this.height);
        const i = Math.round(e * n),
            r = Math.round(t * n);
        return (
            (this.width = i / n),
            (this.height = r / n),
            (this._resolution = n),
            this.pixelWidth === i && this.pixelHeight === r
                ? !1
                : (this._refreshPOT(),
                  (this.pixelWidth = i),
                  (this.pixelHeight = r),
                  this.emit("resize", this),
                  (this._resourceId = Pt("resource")),
                  this.emit("change", this),
                  !0)
        );
    }
    updateMipmaps() {
        this.autoGenerateMipmaps &&
            this.mipLevelCount > 1 &&
            this.emit("updateMipmaps", this);
    }
    set wrapMode(e) {
        this._style.wrapMode = e;
    }
    get wrapMode() {
        return this._style.wrapMode;
    }
    set scaleMode(e) {
        this._style.scaleMode = e;
    }
    get scaleMode() {
        return this._style.scaleMode;
    }
    _refreshPOT() {
        this.isPowerOfTwo = Q0(this.pixelWidth) && Q0(this.pixelHeight);
    }
    static test(e) {
        throw new Error("Unimplemented");
    }
};
W1.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: !1,
    sampleCount: 1,
    antialias: !1,
    autoGarbageCollect: !1,
};
let cs = W1;
class Mg extends cs {
    constructor(e) {
        const t = e.resource || new Float32Array(e.width * e.height * 4);
        let n = e.format;
        n ||
            (t instanceof Float32Array
                ? (n = "rgba32float")
                : t instanceof Int32Array || t instanceof Uint32Array
                ? (n = "rgba32uint")
                : t instanceof Int16Array || t instanceof Uint16Array
                ? (n = "rgba16uint")
                : (t instanceof Int8Array, (n = "bgra8unorm"))),
            super({ ...e, resource: t, format: n }),
            (this.uploadMethodId = "buffer");
    }
    static test(e) {
        return (
            e instanceof Int8Array ||
            e instanceof Uint8Array ||
            e instanceof Uint8ClampedArray ||
            e instanceof Int16Array ||
            e instanceof Uint16Array ||
            e instanceof Int32Array ||
            e instanceof Uint32Array ||
            e instanceof Float32Array
        );
    }
}
Mg.extension = ee.TextureSource;
const ev = new Ce();
class cT {
    constructor(e, t) {
        (this.mapCoord = new Ce()),
            (this.uClampFrame = new Float32Array(4)),
            (this.uClampOffset = new Float32Array(2)),
            (this._textureID = -1),
            (this._updateID = 0),
            (this.clampOffset = 0),
            typeof t > "u"
                ? (this.clampMargin = e.width < 10 ? 0 : 0.5)
                : (this.clampMargin = t),
            (this.isSimple = !1),
            (this.texture = e);
    }
    get texture() {
        return this._texture;
    }
    set texture(e) {
        var t;
        this.texture !== e &&
            ((t = this._texture) == null ||
                t.removeListener("update", this.update, this),
            (this._texture = e),
            this._texture.addListener("update", this.update, this),
            this.update());
    }
    multiplyUvs(e, t) {
        t === void 0 && (t = e);
        const n = this.mapCoord;
        for (let i = 0; i < e.length; i += 2) {
            const r = e[i],
                a = e[i + 1];
            (t[i] = r * n.a + a * n.c + n.tx),
                (t[i + 1] = r * n.b + a * n.d + n.ty);
        }
        return t;
    }
    update() {
        const e = this._texture;
        this._updateID++;
        const t = e.uvs;
        this.mapCoord.set(
            t.x1 - t.x0,
            t.y1 - t.y0,
            t.x3 - t.x0,
            t.y3 - t.y0,
            t.x0,
            t.y0
        );
        const n = e.orig,
            i = e.trim;
        i &&
            (ev.set(
                n.width / i.width,
                0,
                0,
                n.height / i.height,
                -i.x / i.width,
                -i.y / i.height
            ),
            this.mapCoord.append(ev));
        const r = e.source,
            a = this.uClampFrame,
            o = this.clampMargin / r._resolution,
            h = this.clampOffset / r._resolution;
        return (
            (a[0] = (e.frame.x + o + h) / r.width),
            (a[1] = (e.frame.y + o + h) / r.height),
            (a[2] = (e.frame.x + e.frame.width - o + h) / r.width),
            (a[3] = (e.frame.y + e.frame.height - o + h) / r.height),
            (this.uClampOffset[0] = this.clampOffset / r.pixelWidth),
            (this.uClampOffset[1] = this.clampOffset / r.pixelHeight),
            (this.isSimple =
                e.frame.width === r.width &&
                e.frame.height === r.height &&
                e.rotate === 0),
            !0
        );
    }
}
let we = class extends ti {
    constructor({
        source: e,
        label: t,
        frame: n,
        orig: i,
        trim: r,
        defaultAnchor: a,
        defaultBorders: o,
        rotate: h,
        dynamic: l,
    } = {}) {
        if (
            (super(),
            (this.uid = Pt("texture")),
            (this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0,
            }),
            (this.frame = new Lt()),
            (this.noFrame = !1),
            (this.dynamic = !1),
            (this.isTexture = !0),
            (this.label = t),
            (this.source = (e == null ? void 0 : e.source) ?? new cs()),
            (this.noFrame = !n),
            n)
        )
            this.frame.copyFrom(n);
        else {
            const { width: u, height: c } = this._source;
            (this.frame.width = u), (this.frame.height = c);
        }
        (this.orig = i || this.frame),
            (this.trim = r),
            (this.rotate = h ?? 0),
            (this.defaultAnchor = a),
            (this.defaultBorders = o),
            (this.destroyed = !1),
            (this.dynamic = l || !1),
            this.updateUvs();
    }
    set source(e) {
        this._source && this._source.off("resize", this.update, this),
            (this._source = e),
            e.on("resize", this.update, this),
            this.emit("update", this);
    }
    get source() {
        return this._source;
    }
    get textureMatrix() {
        return (
            this._textureMatrix || (this._textureMatrix = new cT(this)),
            this._textureMatrix
        );
    }
    get width() {
        return this.orig.width;
    }
    get height() {
        return this.orig.height;
    }
    updateUvs() {
        const { uvs: e, frame: t } = this,
            { width: n, height: i } = this._source,
            r = t.x / n,
            a = t.y / i,
            o = t.width / n,
            h = t.height / i;
        let l = this.rotate;
        if (l) {
            const u = o / 2,
                c = h / 2,
                d = r + u,
                f = a + c;
            (l = Ze.add(l, Ze.NW)),
                (e.x0 = d + u * Ze.uX(l)),
                (e.y0 = f + c * Ze.uY(l)),
                (l = Ze.add(l, 2)),
                (e.x1 = d + u * Ze.uX(l)),
                (e.y1 = f + c * Ze.uY(l)),
                (l = Ze.add(l, 2)),
                (e.x2 = d + u * Ze.uX(l)),
                (e.y2 = f + c * Ze.uY(l)),
                (l = Ze.add(l, 2)),
                (e.x3 = d + u * Ze.uX(l)),
                (e.y3 = f + c * Ze.uY(l));
        } else
            (e.x0 = r),
                (e.y0 = a),
                (e.x1 = r + o),
                (e.y1 = a),
                (e.x2 = r + o),
                (e.y2 = a + h),
                (e.x3 = r),
                (e.y3 = a + h);
    }
    destroy(e = !1) {
        this._source && e && (this._source.destroy(), (this._source = null)),
            (this._textureMatrix = null),
            (this.destroyed = !0),
            this.emit("destroy", this),
            this.removeAllListeners();
    }
    update() {
        this.noFrame &&
            ((this.frame.width = this._source.width),
            (this.frame.height = this._source.height)),
            this.updateUvs(),
            this.emit("update", this);
    }
    get baseTexture() {
        return (
            ae(Ge, "Texture.baseTexture is now Texture.source"), this._source
        );
    }
};
we.EMPTY = new we({ label: "EMPTY", source: new cs({ label: "EMPTY" }) });
we.EMPTY.destroy = z1;
we.WHITE = new we({
    source: new Mg({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE",
    }),
    label: "WHITE",
});
we.WHITE.destroy = z1;
function uT(s, e, t) {
    const { width: n, height: i } = t.orig,
        r = t.trim;
    if (r) {
        const a = r.width,
            o = r.height;
        (s.minX = r.x - e._x * n),
            (s.maxX = s.minX + a),
            (s.minY = r.y - e._y * i),
            (s.maxY = s.minY + o);
    } else
        (s.minX = -e._x * n),
            (s.maxX = s.minX + n),
            (s.minY = -e._y * i),
            (s.maxY = s.minY + i);
}
const tv = new Ce();
class Hs {
    constructor(e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0) {
        (this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = -1 / 0),
            (this.maxY = -1 / 0),
            (this.matrix = tv),
            (this.minX = e),
            (this.minY = t),
            (this.maxX = n),
            (this.maxY = i);
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
        this._rectangle || (this._rectangle = new Lt());
        const e = this._rectangle;
        return (
            this.minX > this.maxX || this.minY > this.maxY
                ? ((e.x = 0), (e.y = 0), (e.width = 0), (e.height = 0))
                : e.copyFromBounds(this),
            e
        );
    }
    clear() {
        return (
            (this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = -1 / 0),
            (this.maxY = -1 / 0),
            (this.matrix = tv),
            this
        );
    }
    set(e, t, n, i) {
        (this.minX = e), (this.minY = t), (this.maxX = n), (this.maxY = i);
    }
    addFrame(e, t, n, i, r) {
        r || (r = this.matrix);
        const a = r.a,
            o = r.b,
            h = r.c,
            l = r.d,
            u = r.tx,
            c = r.ty;
        let d = this.minX,
            f = this.minY,
            p = this.maxX,
            m = this.maxY,
            g = a * e + h * t + u,
            _ = o * e + l * t + c;
        g < d && (d = g),
            _ < f && (f = _),
            g > p && (p = g),
            _ > m && (m = _),
            (g = a * n + h * t + u),
            (_ = o * n + l * t + c),
            g < d && (d = g),
            _ < f && (f = _),
            g > p && (p = g),
            _ > m && (m = _),
            (g = a * e + h * i + u),
            (_ = o * e + l * i + c),
            g < d && (d = g),
            _ < f && (f = _),
            g > p && (p = g),
            _ > m && (m = _),
            (g = a * n + h * i + u),
            (_ = o * n + l * i + c),
            g < d && (d = g),
            _ < f && (f = _),
            g > p && (p = g),
            _ > m && (m = _),
            (this.minX = d),
            (this.minY = f),
            (this.maxX = p),
            (this.maxY = m);
    }
    addRect(e, t) {
        this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
    }
    addBounds(e, t) {
        this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    addBoundsMask(e) {
        (this.minX = this.minX > e.minX ? this.minX : e.minX),
            (this.minY = this.minY > e.minY ? this.minY : e.minY),
            (this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX),
            (this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY);
    }
    applyMatrix(e) {
        const t = this.minX,
            n = this.minY,
            i = this.maxX,
            r = this.maxY,
            { a, b: o, c: h, d: l, tx: u, ty: c } = e;
        let d = a * t + h * n + u,
            f = o * t + l * n + c;
        (this.minX = d),
            (this.minY = f),
            (this.maxX = d),
            (this.maxY = f),
            (d = a * i + h * n + u),
            (f = o * i + l * n + c),
            (this.minX = d < this.minX ? d : this.minX),
            (this.minY = f < this.minY ? f : this.minY),
            (this.maxX = d > this.maxX ? d : this.maxX),
            (this.maxY = f > this.maxY ? f : this.maxY),
            (d = a * t + h * r + u),
            (f = o * t + l * r + c),
            (this.minX = d < this.minX ? d : this.minX),
            (this.minY = f < this.minY ? f : this.minY),
            (this.maxX = d > this.maxX ? d : this.maxX),
            (this.maxY = f > this.maxY ? f : this.maxY),
            (d = a * i + h * r + u),
            (f = o * i + l * r + c),
            (this.minX = d < this.minX ? d : this.minX),
            (this.minY = f < this.minY ? f : this.minY),
            (this.maxX = d > this.maxX ? d : this.maxX),
            (this.maxY = f > this.maxY ? f : this.maxY);
    }
    fit(e) {
        return (
            this.minX < e.left && (this.minX = e.left),
            this.maxX > e.right && (this.maxX = e.right),
            this.minY < e.top && (this.minY = e.top),
            this.maxY > e.bottom && (this.maxY = e.bottom),
            this
        );
    }
    fitBounds(e, t, n, i) {
        return (
            this.minX < e && (this.minX = e),
            this.maxX > t && (this.maxX = t),
            this.minY < n && (this.minY = n),
            this.maxY > i && (this.maxY = i),
            this
        );
    }
    pad(e, t = e) {
        return (
            (this.minX -= e),
            (this.maxX += e),
            (this.minY -= t),
            (this.maxY += t),
            this
        );
    }
    ceil() {
        return (
            (this.minX = Math.floor(this.minX)),
            (this.minY = Math.floor(this.minY)),
            (this.maxX = Math.ceil(this.maxX)),
            (this.maxY = Math.ceil(this.maxY)),
            this
        );
    }
    clone() {
        return new Hs(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(e, t = e) {
        return (
            (this.minX *= e),
            (this.minY *= t),
            (this.maxX *= e),
            (this.maxY *= t),
            this
        );
    }
    get x() {
        return this.minX;
    }
    set x(e) {
        const t = this.maxX - this.minX;
        (this.minX = e), (this.maxX = e + t);
    }
    get y() {
        return this.minY;
    }
    set y(e) {
        const t = this.maxY - this.minY;
        (this.minY = e), (this.maxY = e + t);
    }
    get width() {
        return this.maxX - this.minX;
    }
    set width(e) {
        this.maxX = this.minX + e;
    }
    get height() {
        return this.maxY - this.minY;
    }
    set height(e) {
        this.maxY = this.minY + e;
    }
    get left() {
        return this.minX;
    }
    get right() {
        return this.maxX;
    }
    get top() {
        return this.minY;
    }
    get bottom() {
        return this.maxY;
    }
    get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
        return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(e, t, n, i) {
        let r = this.minX,
            a = this.minY,
            o = this.maxX,
            h = this.maxY;
        i || (i = this.matrix);
        const l = i.a,
            u = i.b,
            c = i.c,
            d = i.d,
            f = i.tx,
            p = i.ty;
        for (let m = t; m < n; m += 2) {
            const g = e[m],
                _ = e[m + 1],
                v = l * g + c * _ + f,
                b = u * g + d * _ + p;
            (r = v < r ? v : r),
                (a = b < a ? b : a),
                (o = v > o ? v : o),
                (h = b > h ? b : h);
        }
        (this.minX = r), (this.minY = a), (this.maxX = o), (this.maxY = h);
    }
    containsPoint(e, t) {
        return (
            this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t
        );
    }
    toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(e) {
        return (
            (this.minX = e.minX),
            (this.minY = e.minY),
            (this.maxX = e.maxX),
            (this.maxY = e.maxY),
            this
        );
    }
}
var dT = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
    Ni = function (s) {
        return typeof s == "string" ? s.length > 0 : typeof s == "number";
    },
    Xt = function (s, e, t) {
        return (
            e === void 0 && (e = 0),
            t === void 0 && (t = Math.pow(10, e)),
            Math.round(t * s) / t + 0
        );
    },
    Es = function (s, e, t) {
        return (
            e === void 0 && (e = 0),
            t === void 0 && (t = 1),
            s > t ? t : s > e ? s : e
        );
    },
    q1 = function (s) {
        return (s = isFinite(s) ? s % 360 : 0) > 0 ? s : s + 360;
    },
    nv = function (s) {
        return {
            r: Es(s.r, 0, 255),
            g: Es(s.g, 0, 255),
            b: Es(s.b, 0, 255),
            a: Es(s.a),
        };
    },
    wf = function (s) {
        return { r: Xt(s.r), g: Xt(s.g), b: Xt(s.b), a: Xt(s.a, 3) };
    },
    fT = /^#([0-9a-f]{3,8})$/i,
    Ic = function (s) {
        var e = s.toString(16);
        return e.length < 2 ? "0" + e : e;
    },
    H1 = function (s) {
        var e = s.r,
            t = s.g,
            n = s.b,
            i = s.a,
            r = Math.max(e, t, n),
            a = r - Math.min(e, t, n),
            o = a
                ? r === e
                    ? (t - n) / a
                    : r === t
                    ? 2 + (n - e) / a
                    : 4 + (e - t) / a
                : 0;
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: r ? (a / r) * 100 : 0,
            v: (r / 255) * 100,
            a: i,
        };
    },
    K1 = function (s) {
        var e = s.h,
            t = s.s,
            n = s.v,
            i = s.a;
        (e = (e / 360) * 6), (t /= 100), (n /= 100);
        var r = Math.floor(e),
            a = n * (1 - t),
            o = n * (1 - (e - r) * t),
            h = n * (1 - (1 - e + r) * t),
            l = r % 6;
        return {
            r: 255 * [n, o, a, a, h, n][l],
            g: 255 * [h, n, n, o, a, a][l],
            b: 255 * [a, a, h, n, n, o][l],
            a: i,
        };
    },
    sv = function (s) {
        return {
            h: q1(s.h),
            s: Es(s.s, 0, 100),
            l: Es(s.l, 0, 100),
            a: Es(s.a),
        };
    },
    iv = function (s) {
        return { h: Xt(s.h), s: Xt(s.s), l: Xt(s.l), a: Xt(s.a, 3) };
    },
    rv = function (s) {
        return K1(
            ((t = (e = s).s),
            {
                h: e.h,
                s:
                    (t *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0
                        ? ((2 * t) / (n + t)) * 100
                        : 0,
                v: n + t,
                a: e.a,
            })
        );
        var e, t, n;
    },
    dh = function (s) {
        return {
            h: (e = H1(s)).h,
            s:
                (i = ((200 - (t = e.s)) * (n = e.v)) / 100) > 0 && i < 200
                    ? ((t * n) / 100 / (i <= 100 ? i : 200 - i)) * 100
                    : 0,
            l: i / 2,
            a: e.a,
        };
        var e, t, n, i;
    },
    pT =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    mT =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    gT =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    _T =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    tm = {
        string: [
            [
                function (s) {
                    var e = fT.exec(s);
                    return e
                        ? (s = e[1]).length <= 4
                            ? {
                                  r: parseInt(s[0] + s[0], 16),
                                  g: parseInt(s[1] + s[1], 16),
                                  b: parseInt(s[2] + s[2], 16),
                                  a:
                                      s.length === 4
                                          ? Xt(
                                                parseInt(s[3] + s[3], 16) / 255,
                                                2
                                            )
                                          : 1,
                              }
                            : s.length === 6 || s.length === 8
                            ? {
                                  r: parseInt(s.substr(0, 2), 16),
                                  g: parseInt(s.substr(2, 2), 16),
                                  b: parseInt(s.substr(4, 2), 16),
                                  a:
                                      s.length === 8
                                          ? Xt(
                                                parseInt(s.substr(6, 2), 16) /
                                                    255,
                                                2
                                            )
                                          : 1,
                              }
                            : null
                        : null;
                },
                "hex",
            ],
            [
                function (s) {
                    var e = gT.exec(s) || _T.exec(s);
                    return e
                        ? e[2] !== e[4] || e[4] !== e[6]
                            ? null
                            : nv({
                                  r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                                  g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                                  b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                                  a:
                                      e[7] === void 0
                                          ? 1
                                          : Number(e[7]) / (e[8] ? 100 : 1),
                              })
                        : null;
                },
                "rgb",
            ],
            [
                function (s) {
                    var e = pT.exec(s) || mT.exec(s);
                    if (!e) return null;
                    var t,
                        n,
                        i = sv({
                            h:
                                ((t = e[1]),
                                (n = e[2]),
                                n === void 0 && (n = "deg"),
                                Number(t) * (dT[n] || 1)),
                            s: Number(e[3]),
                            l: Number(e[4]),
                            a:
                                e[5] === void 0
                                    ? 1
                                    : Number(e[5]) / (e[6] ? 100 : 1),
                        });
                    return rv(i);
                },
                "hsl",
            ],
        ],
        object: [
            [
                function (s) {
                    var e = s.r,
                        t = s.g,
                        n = s.b,
                        i = s.a,
                        r = i === void 0 ? 1 : i;
                    return Ni(e) && Ni(t) && Ni(n)
                        ? nv({
                              r: Number(e),
                              g: Number(t),
                              b: Number(n),
                              a: Number(r),
                          })
                        : null;
                },
                "rgb",
            ],
            [
                function (s) {
                    var e = s.h,
                        t = s.s,
                        n = s.l,
                        i = s.a,
                        r = i === void 0 ? 1 : i;
                    if (!Ni(e) || !Ni(t) || !Ni(n)) return null;
                    var a = sv({
                        h: Number(e),
                        s: Number(t),
                        l: Number(n),
                        a: Number(r),
                    });
                    return rv(a);
                },
                "hsl",
            ],
            [
                function (s) {
                    var e = s.h,
                        t = s.s,
                        n = s.v,
                        i = s.a,
                        r = i === void 0 ? 1 : i;
                    if (!Ni(e) || !Ni(t) || !Ni(n)) return null;
                    var a = (function (o) {
                        return {
                            h: q1(o.h),
                            s: Es(o.s, 0, 100),
                            v: Es(o.v, 0, 100),
                            a: Es(o.a),
                        };
                    })({
                        h: Number(e),
                        s: Number(t),
                        v: Number(n),
                        a: Number(r),
                    });
                    return K1(a);
                },
                "hsv",
            ],
        ],
    },
    av = function (s, e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t][0](s);
            if (n) return [n, e[t][1]];
        }
        return [null, void 0];
    },
    vT = function (s) {
        return typeof s == "string"
            ? av(s.trim(), tm.string)
            : typeof s == "object" && s !== null
            ? av(s, tm.object)
            : [null, void 0];
    },
    xf = function (s, e) {
        var t = dh(s);
        return { h: t.h, s: Es(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
    },
    Cf = function (s) {
        return (299 * s.r + 587 * s.g + 114 * s.b) / 1e3 / 255;
    },
    ov = function (s, e) {
        var t = dh(s);
        return { h: t.h, s: t.s, l: Es(t.l + 100 * e, 0, 100), a: t.a };
    },
    nm = (function () {
        function s(e) {
            (this.parsed = vT(e)[0]),
                (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
        }
        return (
            (s.prototype.isValid = function () {
                return this.parsed !== null;
            }),
            (s.prototype.brightness = function () {
                return Xt(Cf(this.rgba), 2);
            }),
            (s.prototype.isDark = function () {
                return Cf(this.rgba) < 0.5;
            }),
            (s.prototype.isLight = function () {
                return Cf(this.rgba) >= 0.5;
            }),
            (s.prototype.toHex = function () {
                return (
                    (e = wf(this.rgba)),
                    (t = e.r),
                    (n = e.g),
                    (i = e.b),
                    (a = (r = e.a) < 1 ? Ic(Xt(255 * r)) : ""),
                    "#" + Ic(t) + Ic(n) + Ic(i) + a
                );
                var e, t, n, i, r, a;
            }),
            (s.prototype.toRgb = function () {
                return wf(this.rgba);
            }),
            (s.prototype.toRgbString = function () {
                return (
                    (e = wf(this.rgba)),
                    (t = e.r),
                    (n = e.g),
                    (i = e.b),
                    (r = e.a) < 1
                        ? "rgba(" + t + ", " + n + ", " + i + ", " + r + ")"
                        : "rgb(" + t + ", " + n + ", " + i + ")"
                );
                var e, t, n, i, r;
            }),
            (s.prototype.toHsl = function () {
                return iv(dh(this.rgba));
            }),
            (s.prototype.toHslString = function () {
                return (
                    (e = iv(dh(this.rgba))),
                    (t = e.h),
                    (n = e.s),
                    (i = e.l),
                    (r = e.a) < 1
                        ? "hsla(" + t + ", " + n + "%, " + i + "%, " + r + ")"
                        : "hsl(" + t + ", " + n + "%, " + i + "%)"
                );
                var e, t, n, i, r;
            }),
            (s.prototype.toHsv = function () {
                return (
                    (e = H1(this.rgba)),
                    { h: Xt(e.h), s: Xt(e.s), v: Xt(e.v), a: Xt(e.a, 3) }
                );
                var e;
            }),
            (s.prototype.invert = function () {
                return li({
                    r: 255 - (e = this.rgba).r,
                    g: 255 - e.g,
                    b: 255 - e.b,
                    a: e.a,
                });
                var e;
            }),
            (s.prototype.saturate = function (e) {
                return e === void 0 && (e = 0.1), li(xf(this.rgba, e));
            }),
            (s.prototype.desaturate = function (e) {
                return e === void 0 && (e = 0.1), li(xf(this.rgba, -e));
            }),
            (s.prototype.grayscale = function () {
                return li(xf(this.rgba, -1));
            }),
            (s.prototype.lighten = function (e) {
                return e === void 0 && (e = 0.1), li(ov(this.rgba, e));
            }),
            (s.prototype.darken = function (e) {
                return e === void 0 && (e = 0.1), li(ov(this.rgba, -e));
            }),
            (s.prototype.rotate = function (e) {
                return e === void 0 && (e = 15), this.hue(this.hue() + e);
            }),
            (s.prototype.alpha = function (e) {
                return typeof e == "number"
                    ? li({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e })
                    : Xt(this.rgba.a, 3);
                var t;
            }),
            (s.prototype.hue = function (e) {
                var t = dh(this.rgba);
                return typeof e == "number"
                    ? li({ h: e, s: t.s, l: t.l, a: t.a })
                    : Xt(t.h);
            }),
            (s.prototype.isEqual = function (e) {
                return this.toHex() === li(e).toHex();
            }),
            s
        );
    })(),
    li = function (s) {
        return s instanceof nm ? s : new nm(s);
    },
    lv = [],
    bT = function (s) {
        s.forEach(function (e) {
            lv.indexOf(e) < 0 && (e(nm, tm), lv.push(e));
        });
    };
function yT(s, e) {
    var t = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000",
        },
        n = {};
    for (var i in t) n[t[i]] = i;
    var r = {};
    (s.prototype.toName = function (a) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return "transparent";
        var o,
            h,
            l = n[this.toHex()];
        if (l) return l;
        if (a != null && a.closest) {
            var u = this.toRgb(),
                c = 1 / 0,
                d = "black";
            if (!r.length) for (var f in t) r[f] = new s(t[f]).toRgb();
            for (var p in t) {
                var m =
                    ((o = u),
                    (h = r[p]),
                    Math.pow(o.r - h.r, 2) +
                        Math.pow(o.g - h.g, 2) +
                        Math.pow(o.b - h.b, 2));
                m < c && ((c = m), (d = p));
            }
            return d;
        }
    }),
        e.string.push([
            function (a) {
                var o = a.toLowerCase(),
                    h = o === "transparent" ? "#0000" : t[o];
                return h ? new s(h).toRgb() : null;
            },
            "name",
        ]);
}
bT([yT]);
const nl = class Jl {
    constructor(e = 16777215) {
        (this._value = null),
            (this._components = new Float32Array(4)),
            this._components.fill(1),
            (this._int = 16777215),
            (this.value = e);
    }
    get red() {
        return this._components[0];
    }
    get green() {
        return this._components[1];
    }
    get blue() {
        return this._components[2];
    }
    get alpha() {
        return this._components[3];
    }
    setValue(e) {
        return (this.value = e), this;
    }
    set value(e) {
        if (e instanceof Jl)
            (this._value = this._cloneSource(e._value)),
                (this._int = e._int),
                this._components.set(e._components);
        else {
            if (e === null) throw new Error("Cannot set Color#value to null");
            (this._value === null || !this._isSourceEqual(this._value, e)) &&
                ((this._value = this._cloneSource(e)),
                this._normalize(this._value));
        }
    }
    get value() {
        return this._value;
    }
    _cloneSource(e) {
        return typeof e == "string" ||
            typeof e == "number" ||
            e instanceof Number ||
            e === null
            ? e
            : Array.isArray(e) || ArrayBuffer.isView(e)
            ? e.slice(0)
            : typeof e == "object" && e !== null
            ? { ...e }
            : e;
    }
    _isSourceEqual(e, t) {
        const n = typeof e;
        if (n !== typeof t) return !1;
        if (n === "number" || n === "string" || e instanceof Number)
            return e === t;
        if (
            (Array.isArray(e) && Array.isArray(t)) ||
            (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
        )
            return e.length !== t.length ? !1 : e.every((r, a) => r === t[a]);
        if (e !== null && t !== null) {
            const r = Object.keys(e),
                a = Object.keys(t);
            return r.length !== a.length ? !1 : r.every((o) => e[o] === t[o]);
        }
        return e === t;
    }
    toRgba() {
        const [e, t, n, i] = this._components;
        return { r: e, g: t, b: n, a: i };
    }
    toRgb() {
        const [e, t, n] = this._components;
        return { r: e, g: t, b: n };
    }
    toRgbaString() {
        const [e, t, n] = this.toUint8RgbArray();
        return `rgba(${e},${t},${n},${this.alpha})`;
    }
    toUint8RgbArray(e) {
        const [t, n, i] = this._components;
        return (
            this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb),
            (e[0] = Math.round(t * 255)),
            (e[1] = Math.round(n * 255)),
            (e[2] = Math.round(i * 255)),
            e
        );
    }
    toArray(e) {
        this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
        const [t, n, i, r] = this._components;
        return (e[0] = t), (e[1] = n), (e[2] = i), (e[3] = r), e;
    }
    toRgbArray(e) {
        this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
        const [t, n, i] = this._components;
        return (e[0] = t), (e[1] = n), (e[2] = i), e;
    }
    toNumber() {
        return this._int;
    }
    toBgrNumber() {
        const [e, t, n] = this.toUint8RgbArray();
        return (n << 16) + (t << 8) + e;
    }
    toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
        const [t, n, i, r] = Jl._temp.setValue(e)._components;
        return (
            (this._components[0] *= t),
            (this._components[1] *= n),
            (this._components[2] *= i),
            (this._components[3] *= r),
            this._refreshInt(),
            (this._value = null),
            this
        );
    }
    premultiply(e, t = !0) {
        return (
            t &&
                ((this._components[0] *= e),
                (this._components[1] *= e),
                (this._components[2] *= e)),
            (this._components[3] = e),
            this._refreshInt(),
            (this._value = null),
            this
        );
    }
    toPremultiplied(e, t = !0) {
        if (e === 1) return (255 << 24) + this._int;
        if (e === 0) return t ? 0 : this._int;
        let n = (this._int >> 16) & 255,
            i = (this._int >> 8) & 255,
            r = this._int & 255;
        return (
            t &&
                ((n = (n * e + 0.5) | 0),
                (i = (i * e + 0.5) | 0),
                (r = (r * e + 0.5) | 0)),
            ((e * 255) << 24) + (n << 16) + (i << 8) + r
        );
    }
    toHex() {
        const e = this._int.toString(16);
        return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - t.length) + t;
    }
    setAlpha(e) {
        return (this._components[3] = this._clamp(e)), this;
    }
    _normalize(e) {
        let t, n, i, r;
        if (
            (typeof e == "number" || e instanceof Number) &&
            e >= 0 &&
            e <= 16777215
        ) {
            const a = e;
            (t = ((a >> 16) & 255) / 255),
                (n = ((a >> 8) & 255) / 255),
                (i = (a & 255) / 255),
                (r = 1);
        } else if (
            (Array.isArray(e) || e instanceof Float32Array) &&
            e.length >= 3 &&
            e.length <= 4
        )
            (e = this._clamp(e)), ([t, n, i, r = 1] = e);
        else if (
            (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
            e.length >= 3 &&
            e.length <= 4
        )
            (e = this._clamp(e, 0, 255)),
                ([t, n, i, r = 255] = e),
                (t /= 255),
                (n /= 255),
                (i /= 255),
                (r /= 255);
        else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
                const o = Jl.HEX_PATTERN.exec(e);
                o && (e = `#${o[2]}`);
            }
            const a = li(e);
            a.isValid() &&
                (({ r: t, g: n, b: i, a: r } = a.rgba),
                (t /= 255),
                (n /= 255),
                (i /= 255));
        }
        if (t !== void 0)
            (this._components[0] = t),
                (this._components[1] = n),
                (this._components[2] = i),
                (this._components[3] = r),
                this._refreshInt();
        else throw new Error(`Unable to convert color ${e}`);
    }
    _refreshInt() {
        this._clamp(this._components);
        const [e, t, n] = this._components;
        this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((n * 255) | 0);
    }
    _clamp(e, t = 0, n = 1) {
        return typeof e == "number"
            ? Math.min(Math.max(e, t), n)
            : (e.forEach((i, r) => {
                  e[r] = Math.min(Math.max(i, t), n);
              }),
              e);
    }
    static isColorLike(e) {
        return (
            typeof e == "number" ||
            typeof e == "string" ||
            e instanceof Number ||
            e instanceof Jl ||
            Array.isArray(e) ||
            e instanceof Uint8Array ||
            e instanceof Uint8ClampedArray ||
            e instanceof Float32Array ||
            (e.r !== void 0 && e.g !== void 0 && e.b !== void 0) ||
            (e.r !== void 0 &&
                e.g !== void 0 &&
                e.b !== void 0 &&
                e.a !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.l !== void 0) ||
            (e.h !== void 0 &&
                e.s !== void 0 &&
                e.l !== void 0 &&
                e.a !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.v !== void 0) ||
            (e.h !== void 0 &&
                e.s !== void 0 &&
                e.v !== void 0 &&
                e.a !== void 0)
        );
    }
};
nl.shared = new nl();
nl._temp = new nl();
nl.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Vt = nl;
const wT = { cullArea: null, cullable: !1, cullableChildren: !0 };
let Af = 0;
const hv = 500;
function it(...s) {
    Af !== hv &&
        (Af++,
        Af === hv
            ? console.warn(
                  "PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."
              )
            : console.warn("PixiJS Warning: ", ...s));
}
const cc = {
    _registeredResources: new Set(),
    register(s) {
        this._registeredResources.add(s);
    },
    unregister(s) {
        this._registeredResources.delete(s);
    },
    release() {
        this._registeredResources.forEach((s) => s.clear());
    },
    get registeredCount() {
        return this._registeredResources.size;
    },
    isRegistered(s) {
        return this._registeredResources.has(s);
    },
    reset() {
        this._registeredResources.clear();
    },
};
let xT = class {
    constructor(e, t) {
        (this._pool = []),
            (this._count = 0),
            (this._index = 0),
            (this._classType = e),
            t && this.prepopulate(t);
    }
    prepopulate(e) {
        for (let t = 0; t < e; t++)
            this._pool[this._index++] = new this._classType();
        this._count += e;
    }
    get(e) {
        var n;
        let t;
        return (
            this._index > 0
                ? (t = this._pool[--this._index])
                : (t = new this._classType()),
            (n = t.init) == null || n.call(t, e),
            t
        );
    }
    return(e) {
        var t;
        (t = e.reset) == null || t.call(e), (this._pool[this._index++] = e);
    }
    get totalSize() {
        return this._count;
    }
    get totalFree() {
        return this._index;
    }
    get totalUsed() {
        return this._count - this._index;
    }
    clear() {
        if (this._pool.length > 0 && this._pool[0].destroy)
            for (let e = 0; e < this._index; e++) this._pool[e].destroy();
        (this._pool.length = 0), (this._count = 0), (this._index = 0);
    }
};
class CT {
    constructor() {
        this._poolsByClass = new Map();
    }
    prepopulate(e, t) {
        this.getPool(e).prepopulate(t);
    }
    get(e, t) {
        return this.getPool(e).get(t);
    }
    return(e) {
        this.getPool(e.constructor).return(e);
    }
    getPool(e) {
        return (
            this._poolsByClass.has(e) || this._poolsByClass.set(e, new xT(e)),
            this._poolsByClass.get(e)
        );
    }
    stats() {
        const e = {};
        return (
            this._poolsByClass.forEach((t) => {
                const n = e[t._classType.name]
                    ? t._classType.name + t._classType.ID
                    : t._classType.name;
                e[n] = {
                    free: t.totalFree,
                    used: t.totalUsed,
                    size: t.totalSize,
                };
            }),
            e
        );
    }
    clear() {
        this._poolsByClass.forEach((e) => e.clear()),
            this._poolsByClass.clear();
    }
}
const Ms = new CT();
cc.register(Ms);
const AT = {
    get isCachedAsTexture() {
        var s;
        return !!((s = this.renderGroup) != null && s.isCachedAsTexture);
    },
    cacheAsTexture(s) {
        typeof s == "boolean" && s === !1
            ? this.disableRenderGroup()
            : (this.enableRenderGroup(),
              this.renderGroup.enableCacheAsTexture(s === !0 ? {} : s));
    },
    updateCacheTexture() {
        var s;
        (s = this.renderGroup) == null || s.updateCacheTexture();
    },
    get cacheAsBitmap() {
        return this.isCachedAsTexture;
    },
    set cacheAsBitmap(s) {
        ae(
            "v8.6.0",
            "cacheAsBitmap is deprecated, use cacheAsTexture instead."
        ),
            this.cacheAsTexture(s);
    },
};
function ST(s, e, t) {
    const n = s.length;
    let i;
    if (e >= n || t === 0) return;
    t = e + t > n ? n - e : t;
    const r = n - t;
    for (i = e; i < r; ++i) s[i] = s[i + t];
    s.length = r;
}
const ET = {
        allowChildren: !0,
        removeChildren(s = 0, e) {
            var r;
            const t = e ?? this.children.length,
                n = t - s,
                i = [];
            if (n > 0 && n <= t) {
                for (let o = t - 1; o >= s; o--) {
                    const h = this.children[o];
                    h && (i.push(h), (h.parent = null));
                }
                ST(this.children, s, t);
                const a = this.renderGroup || this.parentRenderGroup;
                a && a.removeChildren(i);
                for (let o = 0; o < i.length; ++o) {
                    const h = i[o];
                    (r = h.parentRenderLayer) == null || r.detach(h),
                        this.emit("childRemoved", h, this, o),
                        i[o].emit("removed", this);
                }
                return i.length > 0 && this._didViewChangeTick++, i;
            } else if (n === 0 && this.children.length === 0) return i;
            throw new RangeError(
                "removeChildren: numeric values are outside the acceptable range."
            );
        },
        removeChildAt(s) {
            const e = this.getChildAt(s);
            return this.removeChild(e);
        },
        getChildAt(s) {
            if (s < 0 || s >= this.children.length)
                throw new Error(`getChildAt: Index (${s}) does not exist.`);
            return this.children[s];
        },
        setChildIndex(s, e) {
            if (e < 0 || e >= this.children.length)
                throw new Error(
                    `The index ${e} supplied is out of bounds ${this.children.length}`
                );
            this.getChildIndex(s), this.addChildAt(s, e);
        },
        getChildIndex(s) {
            const e = this.children.indexOf(s);
            if (e === -1)
                throw new Error(
                    "The supplied Container must be a child of the caller"
                );
            return e;
        },
        addChildAt(s, e) {
            this.allowChildren ||
                ae(
                    Ge,
                    "addChildAt: Only Containers will be allowed to add children in v8.0.0"
                );
            const { children: t } = this;
            if (e < 0 || e > t.length)
                throw new Error(
                    `${s}addChildAt: The index ${e} supplied is out of bounds ${t.length}`
                );
            if (s.parent) {
                const i = s.parent.children.indexOf(s);
                if (s.parent === this && i === e) return s;
                i !== -1 && s.parent.children.splice(i, 1);
            }
            e === t.length ? t.push(s) : t.splice(e, 0, s),
                (s.parent = this),
                (s.didChange = !0),
                (s._updateFlags = 15);
            const n = this.renderGroup || this.parentRenderGroup;
            return (
                n && n.addChild(s),
                this.sortableChildren && (this.sortDirty = !0),
                this.emit("childAdded", s, this, e),
                s.emit("added", this),
                s
            );
        },
        swapChildren(s, e) {
            if (s === e) return;
            const t = this.getChildIndex(s),
                n = this.getChildIndex(e);
            (this.children[t] = e), (this.children[n] = s);
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0), this._didContainerChangeTick++;
        },
        removeFromParent() {
            var s;
            (s = this.parent) == null || s.removeChild(this);
        },
        reparentChild(...s) {
            return s.length === 1
                ? this.reparentChildAt(s[0], this.children.length)
                : (s.forEach((e) =>
                      this.reparentChildAt(e, this.children.length)
                  ),
                  s[0]);
        },
        reparentChildAt(s, e) {
            if (s.parent === this) return this.setChildIndex(s, e), s;
            const t = s.worldTransform.clone();
            s.removeFromParent(), this.addChildAt(s, e);
            const n = this.worldTransform.clone();
            return n.invert(), t.prepend(n), s.setFromMatrix(t), s;
        },
        replaceChild(s, e) {
            s.updateLocalTransform(),
                this.addChildAt(e, this.getChildIndex(s)),
                e.setFromMatrix(s.localTransform),
                e.updateLocalTransform(),
                this.removeChild(s);
        },
    },
    PT = {
        collectRenderables(s, e, t) {
            (this.parentRenderLayer && this.parentRenderLayer !== t) ||
                this.globalDisplayStatus < 7 ||
                !this.includeInBuild ||
                (this.sortableChildren && this.sortChildren(),
                this.isSimple
                    ? this.collectRenderablesSimple(s, e, t)
                    : this.renderGroup
                    ? e.renderPipes.renderGroup.addRenderGroup(
                          this.renderGroup,
                          s
                      )
                    : this.collectRenderablesWithEffects(s, e, t));
        },
        collectRenderablesSimple(s, e, t) {
            const n = this.children,
                i = n.length;
            for (let r = 0; r < i; r++) n[r].collectRenderables(s, e, t);
        },
        collectRenderablesWithEffects(s, e, t) {
            const { renderPipes: n } = e;
            for (let i = 0; i < this.effects.length; i++) {
                const r = this.effects[i];
                n[r.pipe].push(r, this, s);
            }
            this.collectRenderablesSimple(s, e, t);
            for (let i = this.effects.length - 1; i >= 0; i--) {
                const r = this.effects[i];
                n[r.pipe].pop(r, this, s);
            }
        },
    };
class cv {
    constructor() {
        (this.pipe = "filter"), (this.priority = 1);
    }
    destroy() {
        for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
        (this.filters = null), (this.filterArea = null);
    }
}
class kT {
    constructor() {
        (this._effectClasses = []),
            (this._tests = []),
            (this._initialized = !1);
    }
    init() {
        this._initialized ||
            ((this._initialized = !0),
            this._effectClasses.forEach((e) => {
                this.add({ test: e.test, maskClass: e });
            }));
    }
    add(e) {
        this._tests.push(e);
    }
    getMaskEffect(e) {
        this._initialized || this.init();
        for (let t = 0; t < this._tests.length; t++) {
            const n = this._tests[t];
            if (n.test(e)) return Ms.get(n.maskClass, e);
        }
        return e;
    }
    returnMaskEffect(e) {
        Ms.return(e);
    }
}
const sm = new kT();
Ot.handleByList(ee.MaskEffect, sm._effectClasses);
const TT = {
        _maskEffect: null,
        _maskOptions: { inverse: !1 },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
            const s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0);
        },
        addEffect(s) {
            this.effects.indexOf(s) === -1 &&
                (this.effects.push(s),
                this.effects.sort((t, n) => t.priority - n.priority),
                this._markStructureAsChanged(),
                this._updateIsSimple());
        },
        removeEffect(s) {
            const e = this.effects.indexOf(s);
            e !== -1 &&
                (this.effects.splice(e, 1),
                this._markStructureAsChanged(),
                this._updateIsSimple());
        },
        set mask(s) {
            const e = this._maskEffect;
            (e == null ? void 0 : e.mask) !== s &&
                (e &&
                    (this.removeEffect(e),
                    sm.returnMaskEffect(e),
                    (this._maskEffect = null)),
                s != null &&
                    ((this._maskEffect = sm.getMaskEffect(s)),
                    this.addEffect(this._maskEffect)));
        },
        get mask() {
            var s;
            return (s = this._maskEffect) == null ? void 0 : s.mask;
        },
        setMask(s) {
            (this._maskOptions = { ...this._maskOptions, ...s }),
                s.mask && (this.mask = s.mask),
                this._markStructureAsChanged();
        },
        set filters(s) {
            var r;
            !Array.isArray(s) && s && (s = [s]);
            const e = this._filterEffect || (this._filterEffect = new cv());
            s = s;
            const t = (s == null ? void 0 : s.length) > 0,
                n = ((r = e.filters) == null ? void 0 : r.length) > 0,
                i = t !== n;
            (s = Array.isArray(s) ? s.slice(0) : s),
                (e.filters = Object.freeze(s)),
                i &&
                    (t
                        ? this.addEffect(e)
                        : (this.removeEffect(e), (e.filters = s ?? null)));
        },
        get filters() {
            var s;
            return (s = this._filterEffect) == null ? void 0 : s.filters;
        },
        set filterArea(s) {
            this._filterEffect || (this._filterEffect = new cv()),
                (this._filterEffect.filterArea = s);
        },
        get filterArea() {
            var s;
            return (s = this._filterEffect) == null ? void 0 : s.filterArea;
        },
    },
    MT = {
        label: null,
        get name() {
            return (
                ae(
                    Ge,
                    "Container.name property has been removed, use Container.label instead"
                ),
                this.label
            );
        },
        set name(s) {
            ae(
                Ge,
                "Container.name property has been removed, use Container.label instead"
            ),
                (this.label = s);
        },
        getChildByName(s, e = !1) {
            return this.getChildByLabel(s, e);
        },
        getChildByLabel(s, e = !1) {
            const t = this.children;
            for (let n = 0; n < t.length; n++) {
                const i = t[n];
                if (i.label === s || (s instanceof RegExp && s.test(i.label)))
                    return i;
            }
            if (e)
                for (let n = 0; n < t.length; n++) {
                    const r = t[n].getChildByLabel(s, !0);
                    if (r) return r;
                }
            return null;
        },
        getChildrenByLabel(s, e = !1, t = []) {
            const n = this.children;
            for (let i = 0; i < n.length; i++) {
                const r = n[i];
                (r.label === s || (s instanceof RegExp && s.test(r.label))) &&
                    t.push(r);
            }
            if (e)
                for (let i = 0; i < n.length; i++)
                    n[i].getChildrenByLabel(s, !0, t);
            return t;
        },
    },
    Sn = Ms.getPool(Ce),
    Zi = Ms.getPool(Hs),
    IT = new Ce(),
    RT = {
        getFastGlobalBounds(s, e) {
            e || (e = new Hs()),
                e.clear(),
                this._getGlobalBoundsRecursive(!!s, e, this.parentRenderLayer),
                e.isValid || e.set(0, 0, 0, 0);
            const t = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(t.worldTransform), e;
        },
        _getGlobalBoundsRecursive(s, e, t) {
            let n = e;
            if (
                (s && this.parentRenderLayer && this.parentRenderLayer !== t) ||
                this.localDisplayStatus !== 7 ||
                !this.measurable
            )
                return;
            const i = !!this.effects.length;
            if (
                ((this.renderGroup || i) && (n = Zi.get().clear()),
                this.boundsArea)
            )
                e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const a = this.bounds;
                    n.addFrame(
                        a.minX,
                        a.minY,
                        a.maxX,
                        a.maxY,
                        this.groupTransform
                    );
                }
                const r = this.children;
                for (let a = 0; a < r.length; a++)
                    r[a]._getGlobalBoundsRecursive(s, n, t);
            }
            if (i) {
                let r = !1;
                const a = this.renderGroup || this.parentRenderGroup;
                for (let o = 0; o < this.effects.length; o++)
                    this.effects[o].addBounds &&
                        (r || ((r = !0), n.applyMatrix(a.worldTransform)),
                        this.effects[o].addBounds(n, !0));
                r && n.applyMatrix(a.worldTransform.copyTo(IT).invert()),
                    e.addBounds(n),
                    Zi.return(n);
            } else
                this.renderGroup &&
                    (e.addBounds(n, this.relativeGroupTransform), Zi.return(n));
        },
    };
function Z1(s, e, t) {
    t.clear();
    let n, i;
    return (
        s.parent
            ? e
                ? (n = s.parent.worldTransform)
                : ((i = Sn.get().identity()), (n = Ig(s, i)))
            : (n = Ce.IDENTITY),
        Q1(s, t, n, e),
        i && Sn.return(i),
        t.isValid || t.set(0, 0, 0, 0),
        t
    );
}
function Q1(s, e, t, n) {
    var o, h;
    if (!s.visible || !s.measurable) return;
    let i;
    n
        ? (i = s.worldTransform)
        : (s.updateLocalTransform(),
          (i = Sn.get()),
          i.appendFrom(s.localTransform, t));
    const r = e,
        a = !!s.effects.length;
    if ((a && (e = Zi.get().clear()), s.boundsArea)) e.addRect(s.boundsArea, i);
    else {
        const l = s.bounds;
        l && !l.isEmpty() && ((e.matrix = i), e.addBounds(l));
        for (let u = 0; u < s.children.length; u++) Q1(s.children[u], e, i, n);
    }
    if (a) {
        for (let l = 0; l < s.effects.length; l++)
            (h = (o = s.effects[l]).addBounds) == null || h.call(o, e);
        r.addBounds(e, Ce.IDENTITY), Zi.return(e);
    }
    n || Sn.return(i);
}
function Ig(s, e) {
    const t = s.parent;
    return (
        t && (Ig(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e
    );
}
function J1(s, e) {
    if (s === 16777215 || !e) return e;
    if (e === 16777215 || !s) return s;
    const t = (s >> 16) & 255,
        n = (s >> 8) & 255,
        i = s & 255,
        r = (e >> 16) & 255,
        a = (e >> 8) & 255,
        o = e & 255,
        h = ((t * r) / 255) | 0,
        l = ((n * a) / 255) | 0,
        u = ((i * o) / 255) | 0;
    return (h << 16) + (l << 8) + u;
}
const uv = 16777215;
function dv(s, e) {
    return s === uv ? e : e === uv ? s : J1(s, e);
}
function su(s) {
    return ((s & 255) << 16) + (s & 65280) + ((s >> 16) & 255);
}
const LT = {
    getGlobalAlpha(s) {
        if (s)
            return this.renderGroup
                ? this.renderGroup.worldAlpha
                : this.parentRenderGroup
                ? this.parentRenderGroup.worldAlpha * this.alpha
                : this.alpha;
        let e = this.alpha,
            t = this.parent;
        for (; t; ) (e *= t.alpha), (t = t.parent);
        return e;
    },
    getGlobalTransform(s = new Ce(), e) {
        if (e) return s.copyFrom(this.worldTransform);
        this.updateLocalTransform();
        const t = Ig(this, Sn.get().identity());
        return s.appendFrom(this.localTransform, t), Sn.return(t), s;
    },
    getGlobalTint(s) {
        if (s)
            return this.renderGroup
                ? su(this.renderGroup.worldColor)
                : this.parentRenderGroup
                ? su(dv(this.localColor, this.parentRenderGroup.worldColor))
                : this.tint;
        let e = this.localColor,
            t = this.parent;
        for (; t; ) (e = dv(e, t.localColor)), (t = t.parent);
        return su(e);
    },
};
function ex(s, e, t) {
    return (
        e.clear(),
        t || (t = Ce.IDENTITY),
        tx(s, e, t, s, !0),
        e.isValid || e.set(0, 0, 0, 0),
        e
    );
}
function tx(s, e, t, n, i) {
    var h, l;
    let r;
    if (i) (r = Sn.get()), (r = t.copyTo(r));
    else {
        if (!s.visible || !s.measurable) return;
        s.updateLocalTransform();
        const u = s.localTransform;
        (r = Sn.get()), r.appendFrom(u, t);
    }
    const a = e,
        o = !!s.effects.length;
    if ((o && (e = Zi.get().clear()), s.boundsArea)) e.addRect(s.boundsArea, r);
    else {
        s.renderPipeId && ((e.matrix = r), e.addBounds(s.bounds));
        const u = s.children;
        for (let c = 0; c < u.length; c++) tx(u[c], e, r, n, !1);
    }
    if (o) {
        for (let u = 0; u < s.effects.length; u++)
            (l = (h = s.effects[u]).addLocalBounds) == null || l.call(h, e, n);
        a.addBounds(e, Ce.IDENTITY), Zi.return(e);
    }
    Sn.return(r);
}
function nx(s, e) {
    const t = s.children;
    for (let n = 0; n < t.length; n++) {
        const i = t[n],
            r = i.uid,
            a =
                ((i._didViewChangeTick & 65535) << 16) |
                (i._didContainerChangeTick & 65535),
            o = e.index;
        (e.data[o] !== r || e.data[o + 1] !== a) &&
            ((e.data[e.index] = r),
            (e.data[e.index + 1] = a),
            (e.didChange = !0)),
            (e.index = o + 2),
            i.children.length && nx(i, e);
    }
    return e.didChange;
}
const OT = new Ce(),
    BT = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(s, e) {
            const t = Math.sign(this.scale.x) || 1;
            e !== 0 ? (this.scale.x = (s / e) * t) : (this.scale.x = t);
        },
        _setHeight(s, e) {
            const t = Math.sign(this.scale.y) || 1;
            e !== 0 ? (this.scale.y = (s / e) * t) : (this.scale.y = t);
        },
        getLocalBounds() {
            this._localBoundsCacheData ||
                (this._localBoundsCacheData = {
                    data: [],
                    index: 1,
                    didChange: !1,
                    localBounds: new Hs(),
                });
            const s = this._localBoundsCacheData;
            return (
                (s.index = 1),
                (s.didChange = !1),
                s.data[0] !== this._didViewChangeTick &&
                    ((s.didChange = !0), (s.data[0] = this._didViewChangeTick)),
                nx(this, s),
                s.didChange && ex(this, s.localBounds, OT),
                s.localBounds
            );
        },
        getBounds(s, e) {
            return Z1(this, s, e || new Hs());
        },
    },
    FT = {
        _onRender: null,
        set onRender(s) {
            const e = this.renderGroup || this.parentRenderGroup;
            if (!s) {
                this._onRender && (e == null || e.removeOnRender(this)),
                    (this._onRender = null);
                return;
            }
            this._onRender || e == null || e.addOnRender(this),
                (this._onRender = s);
        },
        get onRender() {
            return this._onRender;
        },
    },
    $T = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
            return this._zIndex;
        },
        set zIndex(s) {
            this._zIndex !== s &&
                ((this._zIndex = s), this.depthOfChildModified());
        },
        depthOfChildModified() {
            this.parent &&
                ((this.parent.sortableChildren = !0),
                (this.parent.sortDirty = !0)),
                this.parentRenderGroup &&
                    (this.parentRenderGroup.structureDidChange = !0);
        },
        sortChildren() {
            this.sortDirty && ((this.sortDirty = !1), this.children.sort(DT));
        },
    };
function DT(s, e) {
    return s._zIndex - e._zIndex;
}
const NT = {
    getGlobalPosition(s = new gn(), e = !1) {
        return (
            this.parent
                ? this.parent.toGlobal(this._position, s, e)
                : ((s.x = this._position.x), (s.y = this._position.y)),
            s
        );
    },
    toGlobal(s, e, t = !1) {
        const n = this.getGlobalTransform(Sn.get(), t);
        return (e = n.apply(s, e)), Sn.return(n), e;
    },
    toLocal(s, e, t, n) {
        e && (s = e.toGlobal(s, t, n));
        const i = this.getGlobalTransform(Sn.get(), n);
        return (t = i.applyInverse(s, t)), Sn.return(i), t;
    },
};
class sx {
    constructor() {
        (this.uid = Pt("instructionSet")),
            (this.instructions = []),
            (this.instructionSize = 0),
            (this.renderables = []),
            (this.gcTick = 0);
    }
    reset() {
        this.instructionSize = 0;
    }
    destroy() {
        (this.instructions.length = 0),
            (this.renderables.length = 0),
            (this.renderPipes = null),
            (this.gcTick = 0);
    }
    add(e) {
        this.instructions[this.instructionSize++] = e;
    }
    log() {
        (this.instructions.length = this.instructionSize),
            console.table(this.instructions, ["type", "action"]);
    }
}
let VT = 0;
class UT {
    constructor(e) {
        (this._poolKeyHash = Object.create(null)),
            (this._texturePool = {}),
            (this.textureOptions = e || {}),
            (this.enableFullScreen = !1),
            (this.textureStyle = new Tu(this.textureOptions));
    }
    createTexture(e, t, n) {
        const i = new cs({
            ...this.textureOptions,
            width: e,
            height: t,
            resolution: 1,
            antialias: n,
            autoGarbageCollect: !1,
        });
        return new we({ source: i, label: `texturePool_${VT++}` });
    }
    getOptimalTexture(e, t, n = 1, i) {
        let r = Math.ceil(e * n - 1e-6),
            a = Math.ceil(t * n - 1e-6);
        (r = ku(r)), (a = ku(a));
        const o = (r << 17) + (a << 1) + (i ? 1 : 0);
        this._texturePool[o] || (this._texturePool[o] = []);
        let h = this._texturePool[o].pop();
        return (
            h || (h = this.createTexture(r, a, i)),
            (h.source._resolution = n),
            (h.source.width = r / n),
            (h.source.height = a / n),
            (h.source.pixelWidth = r),
            (h.source.pixelHeight = a),
            (h.frame.x = 0),
            (h.frame.y = 0),
            (h.frame.width = e),
            (h.frame.height = t),
            h.updateUvs(),
            (this._poolKeyHash[h.uid] = o),
            h
        );
    }
    getSameSizeTexture(e, t = !1) {
        const n = e.source;
        return this.getOptimalTexture(e.width, e.height, n._resolution, t);
    }
    returnTexture(e, t = !1) {
        const n = this._poolKeyHash[e.uid];
        t && (e.source.style = this.textureStyle), this._texturePool[n].push(e);
    }
    clear(e) {
        if (((e = e !== !1), e))
            for (const t in this._texturePool) {
                const n = this._texturePool[t];
                if (n) for (let i = 0; i < n.length; i++) n[i].destroy(!0);
            }
        this._texturePool = {};
    }
}
const Gr = new UT();
cc.register(Gr);
class zT {
    constructor() {
        (this.renderPipeId = "renderGroup"),
            (this.root = null),
            (this.canBundle = !1),
            (this.renderGroupParent = null),
            (this.renderGroupChildren = []),
            (this.worldTransform = new Ce()),
            (this.worldColorAlpha = 4294967295),
            (this.worldColor = 16777215),
            (this.worldAlpha = 1),
            (this.childrenToUpdate = Object.create(null)),
            (this.updateTick = 0),
            (this.gcTick = 0),
            (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
            (this.structureDidChange = !0),
            (this.instructionSet = new sx()),
            (this._onRenderContainers = []),
            (this.textureNeedsUpdate = !0),
            (this.isCachedAsTexture = !1),
            (this._matrixDirty = 7);
    }
    init(e) {
        (this.root = e), e._onRender && this.addOnRender(e), (e.didChange = !0);
        const t = e.children;
        for (let n = 0; n < t.length; n++) {
            const i = t[n];
            (i._updateFlags = 15), this.addChild(i);
        }
    }
    enableCacheAsTexture(e = {}) {
        (this.textureOptions = e),
            (this.isCachedAsTexture = !0),
            (this.textureNeedsUpdate = !0);
    }
    disableCacheAsTexture() {
        (this.isCachedAsTexture = !1),
            this.texture &&
                (Gr.returnTexture(this.texture, !0), (this.texture = null));
    }
    updateCacheTexture() {
        this.textureNeedsUpdate = !0;
        const e = this._parentCacheAsTextureRenderGroup;
        e && !e.textureNeedsUpdate && e.updateCacheTexture();
    }
    reset() {
        this.renderGroupChildren.length = 0;
        for (const e in this.childrenToUpdate) {
            const t = this.childrenToUpdate[e];
            t.list.fill(null), (t.index = 0);
        }
        (this.childrenRenderablesToUpdate.index = 0),
            this.childrenRenderablesToUpdate.list.fill(null),
            (this.root = null),
            (this.updateTick = 0),
            (this.structureDidChange = !0),
            (this._onRenderContainers.length = 0),
            (this.renderGroupParent = null),
            this.disableCacheAsTexture();
    }
    get localTransform() {
        return this.root.localTransform;
    }
    addRenderGroupChild(e) {
        e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
            (e.renderGroupParent = this),
            this.renderGroupChildren.push(e);
    }
    _removeRenderGroupChild(e) {
        const t = this.renderGroupChildren.indexOf(e);
        t > -1 && this.renderGroupChildren.splice(t, 1),
            (e.renderGroupParent = null);
    }
    addChild(e) {
        if (
            ((this.structureDidChange = !0),
            (e.parentRenderGroup = this),
            (e.updateTick = -1),
            e.parent === this.root
                ? (e.relativeRenderGroupDepth = 1)
                : (e.relativeRenderGroupDepth =
                      e.parent.relativeRenderGroupDepth + 1),
            (e.didChange = !0),
            this.onChildUpdate(e),
            e.renderGroup)
        ) {
            this.addRenderGroupChild(e.renderGroup);
            return;
        }
        e._onRender && this.addOnRender(e);
        const t = e.children;
        for (let n = 0; n < t.length; n++) this.addChild(t[n]);
    }
    removeChild(e) {
        if (
            ((this.structureDidChange = !0),
            e._onRender && (e.renderGroup || this.removeOnRender(e)),
            (e.parentRenderGroup = null),
            e.renderGroup)
        ) {
            this._removeRenderGroupChild(e.renderGroup);
            return;
        }
        const t = e.children;
        for (let n = 0; n < t.length; n++) this.removeChild(t[n]);
    }
    removeChildren(e) {
        for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
    }
    onChildUpdate(e) {
        let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
        t ||
            (t = this.childrenToUpdate[e.relativeRenderGroupDepth] =
                { index: 0, list: [] }),
            (t.list[t.index++] = e);
    }
    updateRenderable(e) {
        e.globalDisplayStatus < 7 ||
            (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(
                e
            ),
            (e.didViewUpdate = !1));
    }
    onChildViewUpdate(e) {
        this.childrenRenderablesToUpdate.list[
            this.childrenRenderablesToUpdate.index++
        ] = e;
    }
    get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(e) {
        this._onRenderContainers.push(e);
    }
    removeOnRender(e) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
    }
    runOnRender(e) {
        for (let t = 0; t < this._onRenderContainers.length; t++)
            this._onRenderContainers[t]._onRender(e);
    }
    destroy() {
        this.disableCacheAsTexture(),
            (this.renderGroupParent = null),
            (this.root = null),
            (this.childrenRenderablesToUpdate = null),
            (this.childrenToUpdate = null),
            (this.renderGroupChildren = null),
            (this._onRenderContainers = null),
            (this.instructionSet = null);
    }
    getChildren(e = []) {
        const t = this.root.children;
        for (let n = 0; n < t.length; n++) this._getChildren(t[n], e);
        return e;
    }
    _getChildren(e, t = []) {
        if ((t.push(e), e.renderGroup)) return t;
        const n = e.children;
        for (let i = 0; i < n.length; i++) this._getChildren(n[i], t);
        return t;
    }
    invalidateMatrices() {
        this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
        return (this._matrixDirty & 1) === 0
            ? this._inverseWorldTransform
            : ((this._matrixDirty &= -2),
              this._inverseWorldTransform ||
                  (this._inverseWorldTransform = new Ce()),
              this._inverseWorldTransform
                  .copyFrom(this.worldTransform)
                  .invert());
    }
    get textureOffsetInverseTransform() {
        return (this._matrixDirty & 2) === 0
            ? this._textureOffsetInverseTransform
            : ((this._matrixDirty &= -3),
              this._textureOffsetInverseTransform ||
                  (this._textureOffsetInverseTransform = new Ce()),
              this._textureOffsetInverseTransform
                  .copyFrom(this.inverseWorldTransform)
                  .translate(-this._textureBounds.x, -this._textureBounds.y));
    }
    get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0)
            return this._inverseParentTextureTransform;
        this._matrixDirty &= -5;
        const e = this._parentCacheAsTextureRenderGroup;
        return e
            ? (this._inverseParentTextureTransform ||
                  (this._inverseParentTextureTransform = new Ce()),
              this._inverseParentTextureTransform
                  .copyFrom(this.worldTransform)
                  .prepend(e.inverseWorldTransform)
                  .translate(-e._textureBounds.x, -e._textureBounds.y))
            : this.worldTransform;
    }
    get cacheToLocalTransform() {
        return this.isCachedAsTexture
            ? this.textureOffsetInverseTransform
            : this._parentCacheAsTextureRenderGroup
            ? this._parentCacheAsTextureRenderGroup
                  .textureOffsetInverseTransform
            : null;
    }
}
function YT(s, e, t = {}) {
    for (const n in e) !t[n] && e[n] !== void 0 && (s[n] = e[n]);
}
const Sf = new Wt(null),
    Rc = new Wt(null),
    Ef = new Wt(null, 1, 1),
    Lc = new Wt(null),
    fv = 1,
    GT = 2,
    Pf = 4;
class hn extends ti {
    constructor(e = {}) {
        var t, n;
        super(),
            (this.uid = Pt("renderable")),
            (this._updateFlags = 15),
            (this.renderGroup = null),
            (this.parentRenderGroup = null),
            (this.parentRenderGroupIndex = 0),
            (this.didChange = !1),
            (this.didViewUpdate = !1),
            (this.relativeRenderGroupDepth = 0),
            (this.children = []),
            (this.parent = null),
            (this.includeInBuild = !0),
            (this.measurable = !0),
            (this.isSimple = !0),
            (this.updateTick = -1),
            (this.localTransform = new Ce()),
            (this.relativeGroupTransform = new Ce()),
            (this.groupTransform = this.relativeGroupTransform),
            (this.destroyed = !1),
            (this._position = new Wt(this, 0, 0)),
            (this._scale = Ef),
            (this._pivot = Rc),
            (this._origin = Lc),
            (this._skew = Sf),
            (this._cx = 1),
            (this._sx = 0),
            (this._cy = 0),
            (this._sy = 1),
            (this._rotation = 0),
            (this.localColor = 16777215),
            (this.localAlpha = 1),
            (this.groupAlpha = 1),
            (this.groupColor = 16777215),
            (this.groupColorAlpha = 4294967295),
            (this.localBlendMode = "inherit"),
            (this.groupBlendMode = "normal"),
            (this.localDisplayStatus = 7),
            (this.globalDisplayStatus = 7),
            (this._didContainerChangeTick = 0),
            (this._didViewChangeTick = 0),
            (this._didLocalTransformChangeId = -1),
            (this.effects = []),
            YT(this, e, { children: !0, parent: !0, effects: !0 }),
            (t = e.children) == null || t.forEach((i) => this.addChild(i)),
            (n = e.parent) == null || n.addChild(this);
    }
    static mixin(e) {
        ae(
            "8.8.0",
            "Container.mixin is deprecated, please use extensions.mixin instead."
        ),
            Ot.mixin(hn, e);
    }
    set _didChangeId(e) {
        (this._didViewChangeTick = (e >> 12) & 4095),
            (this._didContainerChangeTick = e & 4095);
    }
    get _didChangeId() {
        return (
            (this._didContainerChangeTick & 4095) |
            ((this._didViewChangeTick & 4095) << 12)
        );
    }
    addChild(...e) {
        if (
            (this.allowChildren ||
                ae(
                    Ge,
                    "addChild: Only Containers will be allowed to add children in v8.0.0"
                ),
            e.length > 1)
        ) {
            for (let i = 0; i < e.length; i++) this.addChild(e[i]);
            return e[0];
        }
        const t = e[0],
            n = this.renderGroup || this.parentRenderGroup;
        return t.parent === this
            ? (this.children.splice(this.children.indexOf(t), 1),
              this.children.push(t),
              n && (n.structureDidChange = !0),
              t)
            : (t.parent && t.parent.removeChild(t),
              this.children.push(t),
              this.sortableChildren && (this.sortDirty = !0),
              (t.parent = this),
              (t.didChange = !0),
              (t._updateFlags = 15),
              n && n.addChild(t),
              this.emit("childAdded", t, this, this.children.length - 1),
              t.emit("added", this),
              this._didViewChangeTick++,
              t._zIndex !== 0 && t.depthOfChildModified(),
              t);
    }
    removeChild(...e) {
        if (e.length > 1) {
            for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
            return e[0];
        }
        const t = e[0],
            n = this.children.indexOf(t);
        return (
            n > -1 &&
                (this._didViewChangeTick++,
                this.children.splice(n, 1),
                this.renderGroup
                    ? this.renderGroup.removeChild(t)
                    : this.parentRenderGroup &&
                      this.parentRenderGroup.removeChild(t),
                t.parentRenderLayer && t.parentRenderLayer.detach(t),
                (t.parent = null),
                this.emit("childRemoved", t, this, n),
                t.emit("removed", this)),
            t
        );
    }
    _onUpdate(e) {
        e && e === this._skew && this._updateSkew(),
            this._didContainerChangeTick++,
            !this.didChange &&
                ((this.didChange = !0),
                this.parentRenderGroup &&
                    this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(e) {
        !!this.renderGroup !== e &&
            (e ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
        return !!this.renderGroup;
    }
    enableRenderGroup() {
        if (this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this),
            (this.renderGroup = Ms.get(zT, this)),
            (this.groupTransform = Ce.IDENTITY),
            e == null || e.addChild(this),
            this._updateIsSimple();
    }
    disableRenderGroup() {
        if (!this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this),
            Ms.return(this.renderGroup),
            (this.renderGroup = null),
            (this.groupTransform = this.relativeGroupTransform),
            e == null || e.addChild(this),
            this._updateIsSimple();
    }
    _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
        return (
            this._worldTransform || (this._worldTransform = new Ce()),
            this.renderGroup
                ? this._worldTransform.copyFrom(this.renderGroup.worldTransform)
                : this.parentRenderGroup &&
                  this._worldTransform.appendFrom(
                      this.relativeGroupTransform,
                      this.parentRenderGroup.worldTransform
                  ),
            this._worldTransform
        );
    }
    get x() {
        return this._position.x;
    }
    set x(e) {
        this._position.x = e;
    }
    get y() {
        return this._position.y;
    }
    set y(e) {
        this._position.y = e;
    }
    get position() {
        return this._position;
    }
    set position(e) {
        this._position.copyFrom(e);
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(e) {
        this._rotation !== e &&
            ((this._rotation = e), this._onUpdate(this._skew));
    }
    get angle() {
        return this.rotation * sT;
    }
    set angle(e) {
        this.rotation = e * iT;
    }
    get pivot() {
        return (
            this._pivot === Rc && (this._pivot = new Wt(this, 0, 0)),
            this._pivot
        );
    }
    set pivot(e) {
        this._pivot === Rc &&
            ((this._pivot = new Wt(this, 0, 0)),
            this._origin !== Lc &&
                it(
                    "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully."
                )),
            typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
    }
    get skew() {
        return (
            this._skew === Sf && (this._skew = new Wt(this, 0, 0)), this._skew
        );
    }
    set skew(e) {
        this._skew === Sf && (this._skew = new Wt(this, 0, 0)),
            this._skew.copyFrom(e);
    }
    get scale() {
        return (
            this._scale === Ef && (this._scale = new Wt(this, 1, 1)),
            this._scale
        );
    }
    set scale(e) {
        this._scale === Ef && (this._scale = new Wt(this, 0, 0)),
            typeof e == "string" && (e = parseFloat(e)),
            typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
    }
    get origin() {
        return (
            this._origin === Lc && (this._origin = new Wt(this, 0, 0)),
            this._origin
        );
    }
    set origin(e) {
        this._origin === Lc &&
            ((this._origin = new Wt(this, 0, 0)),
            this._pivot !== Rc &&
                it(
                    "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully."
                )),
            typeof e == "number"
                ? this._origin.set(e)
                : this._origin.copyFrom(e);
    }
    get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(e) {
        const t = this.getLocalBounds().width;
        this._setWidth(e, t);
    }
    get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(e) {
        const t = this.getLocalBounds().height;
        this._setHeight(e, t);
    }
    getSize(e) {
        e || (e = {});
        const t = this.getLocalBounds();
        return (
            (e.width = Math.abs(this.scale.x * t.width)),
            (e.height = Math.abs(this.scale.y * t.height)),
            e
        );
    }
    setSize(e, t) {
        const n = this.getLocalBounds();
        typeof e == "object"
            ? ((t = e.height ?? e.width), (e = e.width))
            : t ?? (t = e),
            e !== void 0 && this._setWidth(e, n.width),
            t !== void 0 && this._setHeight(t, n.height);
    }
    _updateSkew() {
        const e = this._rotation,
            t = this._skew;
        (this._cx = Math.cos(e + t._y)),
            (this._sx = Math.sin(e + t._y)),
            (this._cy = -Math.sin(e - t._x)),
            (this._sy = Math.cos(e - t._x));
    }
    updateTransform(e) {
        return (
            this.position.set(
                typeof e.x == "number" ? e.x : this.position.x,
                typeof e.y == "number" ? e.y : this.position.y
            ),
            this.scale.set(
                typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x,
                typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y
            ),
            (this.rotation =
                typeof e.rotation == "number" ? e.rotation : this.rotation),
            this.skew.set(
                typeof e.skewX == "number" ? e.skewX : this.skew.x,
                typeof e.skewY == "number" ? e.skewY : this.skew.y
            ),
            this.pivot.set(
                typeof e.pivotX == "number" ? e.pivotX : this.pivot.x,
                typeof e.pivotY == "number" ? e.pivotY : this.pivot.y
            ),
            this.origin.set(
                typeof e.originX == "number" ? e.originX : this.origin.x,
                typeof e.originY == "number" ? e.originY : this.origin.y
            ),
            this
        );
    }
    setFromMatrix(e) {
        e.decompose(this);
    }
    updateLocalTransform() {
        const e = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === e) return;
        this._didLocalTransformChangeId = e;
        const t = this.localTransform,
            n = this._scale,
            i = this._pivot,
            r = this._origin,
            a = this._position,
            o = n._x,
            h = n._y,
            l = i._x,
            u = i._y,
            c = -r._x,
            d = -r._y;
        (t.a = this._cx * o),
            (t.b = this._sx * o),
            (t.c = this._cy * h),
            (t.d = this._sy * h),
            (t.tx = a._x - (l * t.a + u * t.c) + (c * t.a + d * t.c) - c),
            (t.ty = a._y - (l * t.b + u * t.d) + (c * t.b + d * t.d) - d);
    }
    set alpha(e) {
        e !== this.localAlpha &&
            ((this.localAlpha = e),
            (this._updateFlags |= fv),
            this._onUpdate());
    }
    get alpha() {
        return this.localAlpha;
    }
    set tint(e) {
        const n = Vt.shared.setValue(e ?? 16777215).toBgrNumber();
        n !== this.localColor &&
            ((this.localColor = n),
            (this._updateFlags |= fv),
            this._onUpdate());
    }
    get tint() {
        return su(this.localColor);
    }
    set blendMode(e) {
        this.localBlendMode !== e &&
            (this.parentRenderGroup &&
                (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= GT),
            (this.localBlendMode = e),
            this._onUpdate());
    }
    get blendMode() {
        return this.localBlendMode;
    }
    get visible() {
        return !!(this.localDisplayStatus & 2);
    }
    set visible(e) {
        const t = e ? 2 : 0;
        (this.localDisplayStatus & 2) !== t &&
            (this.parentRenderGroup &&
                (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= Pf),
            (this.localDisplayStatus ^= 2),
            this._onUpdate());
    }
    get culled() {
        return !(this.localDisplayStatus & 4);
    }
    set culled(e) {
        const t = e ? 0 : 4;
        (this.localDisplayStatus & 4) !== t &&
            (this.parentRenderGroup &&
                (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= Pf),
            (this.localDisplayStatus ^= 4),
            this._onUpdate());
    }
    get renderable() {
        return !!(this.localDisplayStatus & 1);
    }
    set renderable(e) {
        const t = e ? 1 : 0;
        (this.localDisplayStatus & 1) !== t &&
            ((this._updateFlags |= Pf),
            (this.localDisplayStatus ^= 1),
            this.parentRenderGroup &&
                (this.parentRenderGroup.structureDidChange = !0),
            this._onUpdate());
    }
    get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(e = !1) {
        var i;
        if (this.destroyed) return;
        this.destroyed = !0;
        let t;
        if (
            (this.children.length &&
                (t = this.removeChildren(0, this.children.length)),
            this.removeFromParent(),
            (this.parent = null),
            (this._maskEffect = null),
            (this._filterEffect = null),
            (this.effects = null),
            (this._position = null),
            (this._scale = null),
            (this._pivot = null),
            (this._origin = null),
            (this._skew = null),
            this.emit("destroyed", this),
            this.removeAllListeners(),
            (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && t)
        )
            for (let r = 0; r < t.length; ++r) t[r].destroy(e);
        (i = this.renderGroup) == null || i.destroy(),
            (this.renderGroup = null);
    }
}
Ot.mixin(hn, ET, RT, NT, FT, BT, TT, MT, $T, wT, AT, LT, PT);
class Cd extends hn {
    constructor(e) {
        super(e),
            (this.canBundle = !0),
            (this.allowChildren = !1),
            (this._roundPixels = 0),
            (this._lastUsed = -1),
            (this._gpuData = Object.create(null)),
            (this._bounds = new Hs(0, 1, 0, 0)),
            (this._boundsDirty = !0);
    }
    get bounds() {
        return this._boundsDirty
            ? (this.updateBounds(), (this._boundsDirty = !1), this._bounds)
            : this._bounds;
    }
    get roundPixels() {
        return !!this._roundPixels;
    }
    set roundPixels(e) {
        this._roundPixels = e ? 1 : 0;
    }
    containsPoint(e) {
        const t = this.bounds,
            { x: n, y: i } = e;
        return n >= t.minX && n <= t.maxX && i >= t.minY && i <= t.maxY;
    }
    onViewUpdate() {
        if (
            (this._didViewChangeTick++,
            (this._boundsDirty = !0),
            this.didViewUpdate)
        )
            return;
        this.didViewUpdate = !0;
        const e = this.renderGroup || this.parentRenderGroup;
        e && e.onChildViewUpdate(this);
    }
    destroy(e) {
        var t, n;
        super.destroy(e), (this._bounds = null);
        for (const i in this._gpuData)
            (n = (t = this._gpuData[i]).destroy) == null || n.call(t);
        this._gpuData = null;
    }
    collectRenderablesSimple(e, t, n) {
        const { renderPipes: i } = t;
        i.blendMode.pushBlendMode(this, this.groupBlendMode, e),
            i[this.renderPipeId].addRenderable(this, e),
            (this.didViewUpdate = !1);
        const a = this.children,
            o = a.length;
        for (let h = 0; h < o; h++) a[h].collectRenderables(e, t, n);
        i.blendMode.popBlendMode(e);
    }
}
class sl extends Cd {
    constructor(e = we.EMPTY) {
        e instanceof we && (e = { texture: e });
        const {
            texture: t = we.EMPTY,
            anchor: n,
            roundPixels: i,
            width: r,
            height: a,
            ...o
        } = e;
        super({ label: "Sprite", ...o }),
            (this.renderPipeId = "sprite"),
            (this.batched = !0),
            (this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (this._anchor = new Wt({
                _onUpdate: () => {
                    this.onViewUpdate();
                },
            })),
            n
                ? (this.anchor = n)
                : t.defaultAnchor && (this.anchor = t.defaultAnchor),
            (this.texture = t),
            (this.allowChildren = !1),
            (this.roundPixels = i ?? !1),
            r !== void 0 && (this.width = r),
            a !== void 0 && (this.height = a);
    }
    static from(e, t = !1) {
        return e instanceof we ? new sl(e) : new sl(we.from(e, t));
    }
    set texture(e) {
        e || (e = we.EMPTY);
        const t = this._texture;
        t !== e &&
            (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            (this._texture = e),
            this._width &&
                this._setWidth(this._width, this._texture.orig.width),
            this._height &&
                this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate());
    }
    get texture() {
        return this._texture;
    }
    get visualBounds() {
        return (
            uT(this._visualBounds, this._anchor, this._texture),
            this._visualBounds
        );
    }
    get sourceBounds() {
        return (
            ae(
                "8.6.1",
                "Sprite.sourceBounds is deprecated, use visualBounds instead."
            ),
            this.visualBounds
        );
    }
    updateBounds() {
        const e = this._anchor,
            t = this._texture,
            n = this._bounds,
            { width: i, height: r } = t.orig;
        (n.minX = -e._x * i),
            (n.maxX = n.minX + i),
            (n.minY = -e._y * r),
            (n.maxY = n.minY + r);
    }
    destroy(e = !1) {
        if (
            (super.destroy(e),
            typeof e == "boolean" ? e : e == null ? void 0 : e.texture)
        ) {
            const n =
                typeof e == "boolean"
                    ? e
                    : e == null
                    ? void 0
                    : e.textureSource;
            this._texture.destroy(n);
        }
        (this._texture = null),
            (this._visualBounds = null),
            (this._bounds = null),
            (this._anchor = null),
            (this._gpuData = null);
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
        this._setWidth(e, this._texture.orig.width), (this._width = e);
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
        this._setHeight(e, this._texture.orig.height), (this._height = e);
    }
    getSize(e) {
        return (
            e || (e = {}),
            (e.width = Math.abs(this.scale.x) * this._texture.orig.width),
            (e.height = Math.abs(this.scale.y) * this._texture.orig.height),
            e
        );
    }
    setSize(e, t) {
        typeof e == "object"
            ? ((t = e.height ?? e.width), (e = e.width))
            : t ?? (t = e),
            e !== void 0 && this._setWidth(e, this._texture.orig.width),
            t !== void 0 && this._setHeight(t, this._texture.orig.height);
    }
}
const jT = new Hs();
function ix(s, e, t) {
    const n = jT;
    (s.measurable = !0), Z1(s, t, n), e.addBoundsMask(n), (s.measurable = !1);
}
function rx(s, e, t) {
    const n = Zi.get();
    s.measurable = !0;
    const i = Sn.get().identity(),
        r = ax(s, t, i);
    ex(s, n, r),
        (s.measurable = !1),
        e.addBoundsMask(n),
        Sn.return(i),
        Zi.return(n);
}
function ax(s, e, t) {
    return s
        ? (s !== e &&
              (ax(s.parent, e, t),
              s.updateLocalTransform(),
              t.append(s.localTransform)),
          t)
        : (it("Mask bounds, renderable is not inside the root container"), t);
}
class ox {
    constructor(e) {
        (this.priority = 0),
            (this.inverse = !1),
            (this.pipe = "alphaMask"),
            e != null && e.mask && this.init(e.mask);
    }
    init(e) {
        (this.mask = e),
            (this.renderMaskToTexture = !(e instanceof sl)),
            (this.mask.renderable = this.renderMaskToTexture),
            (this.mask.includeInBuild = !this.renderMaskToTexture),
            (this.mask.measurable = !1);
    }
    reset() {
        (this.mask.measurable = !0), (this.mask = null);
    }
    addBounds(e, t) {
        this.inverse || ix(this.mask, e, t);
    }
    addLocalBounds(e, t) {
        rx(this.mask, e, t);
    }
    containsPoint(e, t) {
        const n = this.mask;
        return t(n, e);
    }
    destroy() {
        this.reset();
    }
    static test(e) {
        return e instanceof sl;
    }
}
ox.extension = ee.MaskEffect;
class lx {
    constructor(e) {
        (this.priority = 0),
            (this.pipe = "colorMask"),
            e != null && e.mask && this.init(e.mask);
    }
    init(e) {
        this.mask = e;
    }
    destroy() {}
    static test(e) {
        return typeof e == "number";
    }
}
lx.extension = ee.MaskEffect;
class hx {
    constructor(e) {
        (this.priority = 0),
            (this.pipe = "stencilMask"),
            e != null && e.mask && this.init(e.mask);
    }
    init(e) {
        (this.mask = e),
            (this.mask.includeInBuild = !1),
            (this.mask.measurable = !1);
    }
    reset() {
        (this.mask.measurable = !0),
            (this.mask.includeInBuild = !0),
            (this.mask = null);
    }
    addBounds(e, t) {
        ix(this.mask, e, t);
    }
    addLocalBounds(e, t) {
        rx(this.mask, e, t);
    }
    containsPoint(e, t) {
        const n = this.mask;
        return t(n, e);
    }
    destroy() {
        this.reset();
    }
    static test(e) {
        return e instanceof hn;
    }
}
hx.extension = ee.MaskEffect;
const WT = {
    createCanvas: (s, e) => {
        const t = document.createElement("canvas");
        return (t.width = s), (t.height = e), t;
    },
    createImage: () => new Image(),
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (s, e) => fetch(s, e),
    parseXML: (s) => new DOMParser().parseFromString(s, "text/xml"),
};
let pv = WT;
const rt = {
    get() {
        return pv;
    },
    set(s) {
        pv = s;
    },
};
class cx extends cs {
    constructor(e) {
        e.resource || (e.resource = rt.get().createCanvas()),
            e.width ||
                ((e.width = e.resource.width),
                e.autoDensity || (e.width /= e.resolution)),
            e.height ||
                ((e.height = e.resource.height),
                e.autoDensity || (e.height /= e.resolution)),
            super(e),
            (this.uploadMethodId = "image"),
            (this.autoDensity = e.autoDensity),
            this.resizeCanvas(),
            (this.transparent = !!e.transparent);
    }
    resizeCanvas() {
        this.autoDensity &&
            "style" in this.resource &&
            ((this.resource.style.width = `${this.width}px`),
            (this.resource.style.height = `${this.height}px`)),
            (this.resource.width !== this.pixelWidth ||
                this.resource.height !== this.pixelHeight) &&
                ((this.resource.width = this.pixelWidth),
                (this.resource.height = this.pixelHeight));
    }
    resize(e = this.width, t = this.height, n = this._resolution) {
        const i = super.resize(e, t, n);
        return i && this.resizeCanvas(), i;
    }
    static test(e) {
        return (
            (globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
            (globalThis.OffscreenCanvas && e instanceof OffscreenCanvas)
        );
    }
    get context2D() {
        return (
            this._context2D ||
            (this._context2D = this.resource.getContext("2d"))
        );
    }
}
cx.extension = ee.TextureSource;
class Ba extends cs {
    constructor(e) {
        super(e),
            (this.uploadMethodId = "image"),
            (this.autoGarbageCollect = !0);
    }
    static test(e) {
        return (
            (globalThis.HTMLImageElement && e instanceof HTMLImageElement) ||
            (typeof ImageBitmap < "u" && e instanceof ImageBitmap) ||
            (globalThis.VideoFrame && e instanceof VideoFrame)
        );
    }
}
Ba.extension = ee.TextureSource;
var im = ((s) => (
    (s[(s.INTERACTION = 50)] = "INTERACTION"),
    (s[(s.HIGH = 25)] = "HIGH"),
    (s[(s.NORMAL = 0)] = "NORMAL"),
    (s[(s.LOW = -25)] = "LOW"),
    (s[(s.UTILITY = -50)] = "UTILITY"),
    s
))(im || {});
class kf {
    constructor(e, t = null, n = 0, i = !1) {
        (this.next = null),
            (this.previous = null),
            (this._destroyed = !1),
            (this._fn = e),
            (this._context = t),
            (this.priority = n),
            (this._once = i);
    }
    match(e, t = null) {
        return this._fn === e && this._context === t;
    }
    emit(e) {
        this._fn &&
            (this._context ? this._fn.call(this._context, e) : this._fn(e));
        const t = this.next;
        return (
            this._once && this.destroy(!0),
            this._destroyed && (this.next = null),
            t
        );
    }
    connect(e) {
        (this.previous = e),
            e.next && (e.next.previous = this),
            (this.next = e.next),
            (e.next = this);
    }
    destroy(e = !1) {
        (this._destroyed = !0),
            (this._fn = null),
            (this._context = null),
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous);
        const t = this.next;
        return (this.next = e ? null : t), (this.previous = null), t;
    }
}
const ux = class qn {
    constructor() {
        (this.autoStart = !1),
            (this.deltaTime = 1),
            (this.lastTime = -1),
            (this.speed = 1),
            (this.started = !1),
            (this._requestId = null),
            (this._maxElapsedMS = 100),
            (this._minElapsedMS = 0),
            (this._protected = !1),
            (this._lastFrame = -1),
            (this._head = new kf(null, null, 1 / 0)),
            (this.deltaMS = 1 / qn.targetFPMS),
            (this.elapsedMS = 1 / qn.targetFPMS),
            (this._tick = (e) => {
                (this._requestId = null),
                    this.started &&
                        (this.update(e),
                        this.started &&
                            this._requestId === null &&
                            this._head.next &&
                            (this._requestId = requestAnimationFrame(
                                this._tick
                            )));
            });
    }
    _requestIfNeeded() {
        this._requestId === null &&
            this._head.next &&
            ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)));
    }
    _cancelIfNeeded() {
        this._requestId !== null &&
            (cancelAnimationFrame(this._requestId), (this._requestId = null));
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, t, n = im.NORMAL) {
        return this._addListener(new kf(e, t, n));
    }
    addOnce(e, t, n = im.NORMAL) {
        return this._addListener(new kf(e, t, n, !0));
    }
    _addListener(e) {
        let t = this._head.next,
            n = this._head;
        if (!t) e.connect(n);
        else {
            for (; t; ) {
                if (e.priority > t.priority) {
                    e.connect(n);
                    break;
                }
                (n = t), (t = t.next);
            }
            e.previous || e.connect(n);
        }
        return this._startIfPossible(), this;
    }
    remove(e, t) {
        let n = this._head.next;
        for (; n; ) n.match(e, t) ? (n = n.destroy()) : (n = n.next);
        return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
        if (!this._head) return 0;
        let e = 0,
            t = this._head;
        for (; (t = t.next); ) e++;
        return e;
    }
    start() {
        this.started || ((this.started = !0), this._requestIfNeeded());
    }
    stop() {
        this.started && ((this.started = !1), this._cancelIfNeeded());
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e; ) e = e.destroy(!0);
            this._head.destroy(), (this._head = null);
        }
    }
    update(e = performance.now()) {
        let t;
        if (e > this.lastTime) {
            if (
                ((t = this.elapsedMS = e - this.lastTime),
                t > this._maxElapsedMS && (t = this._maxElapsedMS),
                (t *= this.speed),
                this._minElapsedMS)
            ) {
                const r = (e - this._lastFrame) | 0;
                if (r < this._minElapsedMS) return;
                this._lastFrame = e - (r % this._minElapsedMS);
            }
            (this.deltaMS = t), (this.deltaTime = this.deltaMS * qn.targetFPMS);
            const n = this._head;
            let i = n.next;
            for (; i; ) i = i.emit(this);
            n.next || this._cancelIfNeeded();
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e;
    }
    get FPS() {
        return 1e3 / this.elapsedMS;
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
        const t = Math.min(this.maxFPS, e),
            n = Math.min(Math.max(0, t) / 1e3, qn.targetFPMS);
        this._maxElapsedMS = 1 / n;
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
            const t = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (t / 1e3);
        }
    }
    static get shared() {
        if (!qn._shared) {
            const e = (qn._shared = new qn());
            (e.autoStart = !0), (e._protected = !0);
        }
        return qn._shared;
    }
    static get system() {
        if (!qn._system) {
            const e = (qn._system = new qn());
            (e.autoStart = !0), (e._protected = !0);
        }
        return qn._system;
    }
};
ux.targetFPMS = 0.06;
let Ir = ux,
    Tf;
async function dx() {
    return (
        Tf ??
            (Tf = (async () => {
                var a;
                const e = rt.get().createCanvas(1, 1).getContext("webgl");
                if (!e) return "premultiply-alpha-on-upload";
                const t = await new Promise((o) => {
                    const h = document.createElement("video");
                    (h.onloadeddata = () => o(h)),
                        (h.onerror = () => o(null)),
                        (h.autoplay = !1),
                        (h.crossOrigin = "anonymous"),
                        (h.preload = "auto"),
                        (h.src =
                            "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
                        h.load();
                });
                if (!t) return "premultiply-alpha-on-upload";
                const n = e.createTexture();
                e.bindTexture(e.TEXTURE_2D, n);
                const i = e.createFramebuffer();
                e.bindFramebuffer(e.FRAMEBUFFER, i),
                    e.framebufferTexture2D(
                        e.FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0,
                        e.TEXTURE_2D,
                        n,
                        0
                    ),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
                    e.texImage2D(
                        e.TEXTURE_2D,
                        0,
                        e.RGBA,
                        e.RGBA,
                        e.UNSIGNED_BYTE,
                        t
                    );
                const r = new Uint8Array(4);
                return (
                    e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, r),
                    e.deleteFramebuffer(i),
                    e.deleteTexture(n),
                    (a = e.getExtension("WEBGL_lose_context")) == null ||
                        a.loseContext(),
                    r[0] <= r[3]
                        ? "premultiplied-alpha"
                        : "premultiply-alpha-on-upload"
                );
            })()),
        Tf
    );
}
const Ad = class fx extends cs {
    constructor(e) {
        super(e),
            (this.isReady = !1),
            (this.uploadMethodId = "video"),
            (e = { ...fx.defaultOptions, ...e }),
            (this._autoUpdate = !0),
            (this._isConnectedToTicker = !1),
            (this._updateFPS = e.updateFPS || 0),
            (this._msToNextUpdate = 0),
            (this.autoPlay = e.autoPlay !== !1),
            (this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload"),
            (this._videoFrameRequestCallback =
                this._videoFrameRequestCallback.bind(this)),
            (this._videoFrameRequestCallbackHandle = null),
            (this._load = null),
            (this._resolve = null),
            (this._reject = null),
            (this._onCanPlay = this._onCanPlay.bind(this)),
            (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
            (this._onError = this._onError.bind(this)),
            (this._onPlayStart = this._onPlayStart.bind(this)),
            (this._onPlayStop = this._onPlayStop.bind(this)),
            (this._onSeeked = this._onSeeked.bind(this)),
            e.autoLoad !== !1 && this.load();
    }
    updateFrame() {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const e = Ir.shared.elapsedMS * this.resource.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
            }
            (!this._updateFPS || this._msToNextUpdate <= 0) &&
                (this._msToNextUpdate = this._updateFPS
                    ? Math.floor(1e3 / this._updateFPS)
                    : 0),
                this.isValid && this.update();
        }
    }
    _videoFrameRequestCallback() {
        this.updateFrame(),
            this.destroyed
                ? (this._videoFrameRequestCallbackHandle = null)
                : (this._videoFrameRequestCallbackHandle =
                      this.resource.requestVideoFrameCallback(
                          this._videoFrameRequestCallback
                      ));
    }
    get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
        if (this._load) return this._load;
        const e = this.resource,
            t = this.options;
        return (
            (e.readyState === e.HAVE_ENOUGH_DATA ||
                e.readyState === e.HAVE_FUTURE_DATA) &&
                e.width &&
                e.height &&
                (e.complete = !0),
            e.addEventListener("play", this._onPlayStart),
            e.addEventListener("pause", this._onPlayStop),
            e.addEventListener("seeked", this._onSeeked),
            this._isSourceReady()
                ? this._mediaReady()
                : (t.preload || e.addEventListener("canplay", this._onCanPlay),
                  e.addEventListener("canplaythrough", this._onCanPlayThrough),
                  e.addEventListener("error", this._onError, !0)),
            (this.alphaMode = await dx()),
            (this._load = new Promise((n, i) => {
                this.isValid
                    ? n(this)
                    : ((this._resolve = n),
                      (this._reject = i),
                      t.preloadTimeoutMs !== void 0 &&
                          (this._preloadTimeout = setTimeout(() => {
                              this._onError(
                                  new ErrorEvent(
                                      `Preload exceeded timeout of ${t.preloadTimeoutMs}ms`
                                  )
                              );
                          })),
                      e.load());
            })),
            this._load
        );
    }
    _onError(e) {
        this.resource.removeEventListener("error", this._onError, !0),
            this.emit("error", e),
            this._reject &&
                (this._reject(e),
                (this._reject = null),
                (this._resolve = null));
    }
    _isSourcePlaying() {
        const e = this.resource;
        return !e.paused && !e.ended;
    }
    _isSourceReady() {
        return this.resource.readyState > 2;
    }
    _onPlayStart() {
        this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
        this._configureAutoUpdate();
    }
    _onSeeked() {
        this._autoUpdate &&
            !this._isSourcePlaying() &&
            ((this._msToNextUpdate = 0),
            this.updateFrame(),
            (this._msToNextUpdate = 0));
    }
    _onCanPlay() {
        this.resource.removeEventListener("canplay", this._onCanPlay),
            this._mediaReady();
    }
    _onCanPlayThrough() {
        this.resource.removeEventListener("canplaythrough", this._onCanPlay),
            this._preloadTimeout &&
                (clearTimeout(this._preloadTimeout),
                (this._preloadTimeout = void 0)),
            this._mediaReady();
    }
    _mediaReady() {
        const e = this.resource;
        this.isValid &&
            ((this.isReady = !0), this.resize(e.videoWidth, e.videoHeight)),
            (this._msToNextUpdate = 0),
            this.updateFrame(),
            (this._msToNextUpdate = 0),
            this._resolve &&
                (this._resolve(this),
                (this._resolve = null),
                (this._reject = null)),
            this._isSourcePlaying()
                ? this._onPlayStart()
                : this.autoPlay && this.resource.play();
    }
    destroy() {
        this._configureAutoUpdate();
        const e = this.resource;
        e &&
            (e.removeEventListener("play", this._onPlayStart),
            e.removeEventListener("pause", this._onPlayStop),
            e.removeEventListener("seeked", this._onSeeked),
            e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlayThrough),
            e.removeEventListener("error", this._onError, !0),
            e.pause(),
            (e.src = ""),
            e.load()),
            super.destroy();
    }
    get autoUpdate() {
        return this._autoUpdate;
    }
    set autoUpdate(e) {
        e !== this._autoUpdate &&
            ((this._autoUpdate = e), this._configureAutoUpdate());
    }
    get updateFPS() {
        return this._updateFPS;
    }
    set updateFPS(e) {
        e !== this._updateFPS &&
            ((this._updateFPS = e), this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying()
            ? !this._updateFPS && this.resource.requestVideoFrameCallback
                ? (this._isConnectedToTicker &&
                      (Ir.shared.remove(this.updateFrame, this),
                      (this._isConnectedToTicker = !1),
                      (this._msToNextUpdate = 0)),
                  this._videoFrameRequestCallbackHandle === null &&
                      (this._videoFrameRequestCallbackHandle =
                          this.resource.requestVideoFrameCallback(
                              this._videoFrameRequestCallback
                          )))
                : (this._videoFrameRequestCallbackHandle !== null &&
                      (this.resource.cancelVideoFrameCallback(
                          this._videoFrameRequestCallbackHandle
                      ),
                      (this._videoFrameRequestCallbackHandle = null)),
                  this._isConnectedToTicker ||
                      (Ir.shared.add(this.updateFrame, this),
                      (this._isConnectedToTicker = !0),
                      (this._msToNextUpdate = 0)))
            : (this._videoFrameRequestCallbackHandle !== null &&
                  (this.resource.cancelVideoFrameCallback(
                      this._videoFrameRequestCallbackHandle
                  ),
                  (this._videoFrameRequestCallbackHandle = null)),
              this._isConnectedToTicker &&
                  (Ir.shared.remove(this.updateFrame, this),
                  (this._isConnectedToTicker = !1),
                  (this._msToNextUpdate = 0)));
    }
    static test(e) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
    }
};
Ad.extension = ee.TextureSource;
Ad.defaultOptions = {
    ...cs.defaultOptions,
    autoLoad: !0,
    autoPlay: !0,
    updateFPS: 0,
    crossorigin: !0,
    loop: !1,
    muted: !0,
    playsinline: !0,
    preload: !1,
};
Ad.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" };
let fh = Ad;
const zs = (s, e, t = !1) => (
    Array.isArray(s) || (s = [s]),
    e ? s.map((n) => (typeof n == "string" || t ? e(n) : n)) : s
);
class XT {
    constructor() {
        (this._parsers = []),
            (this._cache = new Map()),
            (this._cacheMap = new Map());
    }
    reset() {
        this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
        return this._cache.has(e);
    }
    get(e) {
        const t = this._cache.get(e);
        return t || it(`[Assets] Asset id ${e} was not found in the Cache`), t;
    }
    set(e, t) {
        const n = zs(e);
        let i;
        for (let h = 0; h < this.parsers.length; h++) {
            const l = this.parsers[h];
            if (l.test(t)) {
                i = l.getCacheableAssets(n, t);
                break;
            }
        }
        const r = new Map(Object.entries(i || {}));
        i ||
            n.forEach((h) => {
                r.set(h, t);
            });
        const a = [...r.keys()],
            o = { cacheKeys: a, keys: n };
        n.forEach((h) => {
            this._cacheMap.set(h, o);
        }),
            a.forEach((h) => {
                const l = i ? i[h] : t;
                this._cache.has(h) &&
                    this._cache.get(h) !== l &&
                    it("[Cache] already has key:", h),
                    this._cache.set(h, r.get(h));
            });
    }
    remove(e) {
        if (!this._cacheMap.has(e)) {
            it(`[Assets] Asset id ${e} was not found in the Cache`);
            return;
        }
        const t = this._cacheMap.get(e);
        t.cacheKeys.forEach((i) => {
            this._cache.delete(i);
        }),
            t.keys.forEach((i) => {
                this._cacheMap.delete(i);
            });
    }
    get parsers() {
        return this._parsers;
    }
}
const et = new XT(),
    rm = [];
Ot.handleByList(ee.TextureSource, rm);
function px(s = {}) {
    const e = s && s.resource,
        t = e ? s.resource : s,
        n = e ? s : { resource: s };
    for (let i = 0; i < rm.length; i++) {
        const r = rm[i];
        if (r.test(t)) return new r(n);
    }
    throw new Error(`Could not find a source type for resource: ${n.resource}`);
}
function qT(s = {}, e = !1) {
    const t = s && s.resource,
        n = t ? s.resource : s,
        i = t ? s : { resource: s };
    if (!e && et.has(n)) return et.get(n);
    const r = new we({ source: px(i) });
    return (
        r.on("destroy", () => {
            et.has(n) && et.remove(n);
        }),
        e || et.set(n, r),
        r
    );
}
function HT(s, e = !1) {
    return typeof s == "string"
        ? et.get(s)
        : s instanceof cs
        ? new we({ source: s })
        : qT(s, e);
}
we.from = HT;
cs.from = px;
Ot.add(ox, lx, hx, fh, Ba, cx, Mg);
var Ii = ((s) => (
    (s[(s.Low = 0)] = "Low"),
    (s[(s.Normal = 1)] = "Normal"),
    (s[(s.High = 2)] = "High"),
    s
))(Ii || {});
function $s(s) {
    if (typeof s != "string")
        throw new TypeError(
            `Path must be a string. Received ${JSON.stringify(s)}`
        );
}
function Il(s) {
    return s.split("?")[0].split("#")[0];
}
function KT(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function ZT(s, e, t) {
    return s.replace(new RegExp(KT(e), "g"), t);
}
function QT(s, e) {
    let t = "",
        n = 0,
        i = -1,
        r = 0,
        a = -1;
    for (let o = 0; o <= s.length; ++o) {
        if (o < s.length) a = s.charCodeAt(o);
        else {
            if (a === 47) break;
            a = 47;
        }
        if (a === 47) {
            if (!(i === o - 1 || r === 1))
                if (i !== o - 1 && r === 2) {
                    if (
                        t.length < 2 ||
                        n !== 2 ||
                        t.charCodeAt(t.length - 1) !== 46 ||
                        t.charCodeAt(t.length - 2) !== 46
                    ) {
                        if (t.length > 2) {
                            const h = t.lastIndexOf("/");
                            if (h !== t.length - 1) {
                                h === -1
                                    ? ((t = ""), (n = 0))
                                    : ((t = t.slice(0, h)),
                                      (n = t.length - 1 - t.lastIndexOf("/"))),
                                    (i = o),
                                    (r = 0);
                                continue;
                            }
                        } else if (t.length === 2 || t.length === 1) {
                            (t = ""), (n = 0), (i = o), (r = 0);
                            continue;
                        }
                    }
                } else
                    t.length > 0
                        ? (t += `/${s.slice(i + 1, o)}`)
                        : (t = s.slice(i + 1, o)),
                        (n = o - i - 1);
            (i = o), (r = 0);
        } else a === 46 && r !== -1 ? ++r : (r = -1);
    }
    return t;
}
const on = {
    toPosix(s) {
        return ZT(s, "\\", "/");
    },
    isUrl(s) {
        return /^https?:/.test(this.toPosix(s));
    },
    isDataUrl(s) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
            s
        );
    },
    isBlobUrl(s) {
        return s.startsWith("blob:");
    },
    hasProtocol(s) {
        return /^[^/:]+:/.test(this.toPosix(s));
    },
    getProtocol(s) {
        $s(s), (s = this.toPosix(s));
        const e = /^file:\/\/\//.exec(s);
        if (e) return e[0];
        const t = /^[^/:]+:\/{0,2}/.exec(s);
        return t ? t[0] : "";
    },
    toAbsolute(s, e, t) {
        if (($s(s), this.isDataUrl(s) || this.isBlobUrl(s))) return s;
        const n = Il(this.toPosix(e ?? rt.get().getBaseUrl())),
            i = Il(this.toPosix(t ?? this.rootname(n)));
        return (
            (s = this.toPosix(s)),
            s.startsWith("/")
                ? on.join(i, s.slice(1))
                : this.isAbsolute(s)
                ? s
                : this.join(n, s)
        );
    },
    normalize(s) {
        if (($s(s), s.length === 0)) return ".";
        if (this.isDataUrl(s) || this.isBlobUrl(s)) return s;
        s = this.toPosix(s);
        let e = "";
        const t = s.startsWith("/");
        this.hasProtocol(s) &&
            ((e = this.rootname(s)), (s = s.slice(e.length)));
        const n = s.endsWith("/");
        return (
            (s = QT(s)), s.length > 0 && n && (s += "/"), t ? `/${s}` : e + s
        );
    },
    isAbsolute(s) {
        return (
            $s(s),
            (s = this.toPosix(s)),
            this.hasProtocol(s) ? !0 : s.startsWith("/")
        );
    },
    join(...s) {
        if (s.length === 0) return ".";
        let e;
        for (let t = 0; t < s.length; ++t) {
            const n = s[t];
            if (($s(n), n.length > 0))
                if (e === void 0) e = n;
                else {
                    const i = s[t - 1] ?? "";
                    this.joinExtensions.includes(this.extname(i).toLowerCase())
                        ? (e += `/../${n}`)
                        : (e += `/${n}`);
                }
        }
        return e === void 0 ? "." : this.normalize(e);
    },
    dirname(s) {
        if (($s(s), s.length === 0)) return ".";
        s = this.toPosix(s);
        let e = s.charCodeAt(0);
        const t = e === 47;
        let n = -1,
            i = !0;
        const r = this.getProtocol(s),
            a = s;
        s = s.slice(r.length);
        for (let o = s.length - 1; o >= 1; --o)
            if (((e = s.charCodeAt(o)), e === 47)) {
                if (!i) {
                    n = o;
                    break;
                }
            } else i = !1;
        return n === -1
            ? t
                ? "/"
                : this.isUrl(a)
                ? r + s
                : r
            : t && n === 1
            ? "//"
            : r + s.slice(0, n);
    },
    rootname(s) {
        $s(s), (s = this.toPosix(s));
        let e = "";
        if (
            (s.startsWith("/") ? (e = "/") : (e = this.getProtocol(s)),
            this.isUrl(s))
        ) {
            const t = s.indexOf("/", e.length);
            t !== -1 ? (e = s.slice(0, t)) : (e = s),
                e.endsWith("/") || (e += "/");
        }
        return e;
    },
    basename(s, e) {
        $s(s), e && $s(e), (s = Il(this.toPosix(s)));
        let t = 0,
            n = -1,
            i = !0,
            r;
        if (e !== void 0 && e.length > 0 && e.length <= s.length) {
            if (e.length === s.length && e === s) return "";
            let a = e.length - 1,
                o = -1;
            for (r = s.length - 1; r >= 0; --r) {
                const h = s.charCodeAt(r);
                if (h === 47) {
                    if (!i) {
                        t = r + 1;
                        break;
                    }
                } else
                    o === -1 && ((i = !1), (o = r + 1)),
                        a >= 0 &&
                            (h === e.charCodeAt(a)
                                ? --a === -1 && (n = r)
                                : ((a = -1), (n = o)));
            }
            return (
                t === n ? (n = o) : n === -1 && (n = s.length), s.slice(t, n)
            );
        }
        for (r = s.length - 1; r >= 0; --r)
            if (s.charCodeAt(r) === 47) {
                if (!i) {
                    t = r + 1;
                    break;
                }
            } else n === -1 && ((i = !1), (n = r + 1));
        return n === -1 ? "" : s.slice(t, n);
    },
    extname(s) {
        $s(s), (s = Il(this.toPosix(s)));
        let e = -1,
            t = 0,
            n = -1,
            i = !0,
            r = 0;
        for (let a = s.length - 1; a >= 0; --a) {
            const o = s.charCodeAt(a);
            if (o === 47) {
                if (!i) {
                    t = a + 1;
                    break;
                }
                continue;
            }
            n === -1 && ((i = !1), (n = a + 1)),
                o === 46
                    ? e === -1
                        ? (e = a)
                        : r !== 1 && (r = 1)
                    : e !== -1 && (r = -1);
        }
        return e === -1 ||
            n === -1 ||
            r === 0 ||
            (r === 1 && e === n - 1 && e === t + 1)
            ? ""
            : s.slice(e, n);
    },
    parse(s) {
        $s(s);
        const e = { root: "", dir: "", base: "", ext: "", name: "" };
        if (s.length === 0) return e;
        s = Il(this.toPosix(s));
        let t = s.charCodeAt(0);
        const n = this.isAbsolute(s);
        let i;
        (e.root = this.rootname(s)),
            n || this.hasProtocol(s) ? (i = 1) : (i = 0);
        let r = -1,
            a = 0,
            o = -1,
            h = !0,
            l = s.length - 1,
            u = 0;
        for (; l >= i; --l) {
            if (((t = s.charCodeAt(l)), t === 47)) {
                if (!h) {
                    a = l + 1;
                    break;
                }
                continue;
            }
            o === -1 && ((h = !1), (o = l + 1)),
                t === 46
                    ? r === -1
                        ? (r = l)
                        : u !== 1 && (u = 1)
                    : r !== -1 && (u = -1);
        }
        return (
            r === -1 ||
            o === -1 ||
            u === 0 ||
            (u === 1 && r === o - 1 && r === a + 1)
                ? o !== -1 &&
                  (a === 0 && n
                      ? (e.base = e.name = s.slice(1, o))
                      : (e.base = e.name = s.slice(a, o)))
                : (a === 0 && n
                      ? ((e.name = s.slice(1, r)), (e.base = s.slice(1, o)))
                      : ((e.name = s.slice(a, r)), (e.base = s.slice(a, o))),
                  (e.ext = s.slice(r, o))),
            (e.dir = this.dirname(s)),
            e
        );
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"],
};
function mx(s, e, t, n, i) {
    const r = e[t];
    for (let a = 0; a < r.length; a++) {
        const o = r[a];
        t < e.length - 1
            ? mx(s.replace(n[t], o), e, t + 1, n, i)
            : i.push(s.replace(n[t], o));
    }
}
function JT(s) {
    const e = /\{(.*?)\}/g,
        t = s.match(e),
        n = [];
    if (t) {
        const i = [];
        t.forEach((r) => {
            const a = r.substring(1, r.length - 1).split(",");
            i.push(a);
        }),
            mx(s, i, 0, t, n);
    } else n.push(s);
    return n;
}
const Mu = (s) => !Array.isArray(s);
class Ha {
    constructor() {
        (this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
            extractAssetIdFromBundle: (e, t) =>
                t.replace(`${e}${this._bundleIdConnector}`, ""),
        }),
            (this._bundleIdConnector =
                this._defaultBundleIdentifierOptions.connector),
            (this._createBundleAssetId =
                this._defaultBundleIdentifierOptions.createBundleAssetId),
            (this._extractAssetIdFromBundle =
                this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._parsers = []),
            (this._resolverHash = {}),
            (this._bundles = {});
    }
    setBundleIdentifier(e) {
        if (
            ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
            (this._createBundleAssetId =
                e.createBundleAssetId ?? this._createBundleAssetId),
            (this._extractAssetIdFromBundle =
                e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
            this._extractAssetIdFromBundle(
                "foo",
                this._createBundleAssetId("foo", "bar")
            ) !== "bar")
        )
            throw new Error(
                "[Resolver] GenerateBundleAssetId are not working correctly"
            );
    }
    prefer(...e) {
        e.forEach((t) => {
            this._preferredOrder.push(t),
                t.priority || (t.priority = Object.keys(t.params));
        }),
            (this._resolverHash = {});
    }
    set basePath(e) {
        this._basePath = e;
    }
    get basePath() {
        return this._basePath;
    }
    set rootPath(e) {
        this._rootPath = e;
    }
    get rootPath() {
        return this._rootPath;
    }
    get parsers() {
        return this._parsers;
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._resolverHash = {}),
            (this._rootPath = null),
            (this._basePath = null),
            (this._manifest = null),
            (this._bundles = {}),
            (this._defaultSearchParams = null);
    }
    setDefaultSearchParams(e) {
        if (typeof e == "string") this._defaultSearchParams = e;
        else {
            const t = e;
            this._defaultSearchParams = Object.keys(t)
                .map(
                    (n) =>
                        `${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`
                )
                .join("&");
        }
    }
    getAlias(e) {
        const { alias: t, src: n } = e;
        return zs(
            t || n,
            (r) =>
                typeof r == "string"
                    ? r
                    : Array.isArray(r)
                    ? r.map((a) => (a == null ? void 0 : a.src) ?? a)
                    : r != null && r.src
                    ? r.src
                    : r,
            !0
        );
    }
    addManifest(e) {
        this._manifest &&
            it("[Resolver] Manifest already exists, this will be overwritten"),
            (this._manifest = e),
            e.bundles.forEach((t) => {
                this.addBundle(t.name, t.assets);
            });
    }
    addBundle(e, t) {
        const n = [];
        let i = t;
        Array.isArray(t) ||
            (i = Object.entries(t).map(([r, a]) =>
                typeof a == "string" || Array.isArray(a)
                    ? { alias: r, src: a }
                    : { alias: r, ...a }
            )),
            i.forEach((r) => {
                const a = r.src,
                    o = r.alias;
                let h;
                if (typeof o == "string") {
                    const l = this._createBundleAssetId(e, o);
                    n.push(l), (h = [o, l]);
                } else {
                    const l = o.map((u) => this._createBundleAssetId(e, u));
                    n.push(...l), (h = [...o, ...l]);
                }
                this.add({ ...r, alias: h, src: a });
            }),
            (this._bundles[e] = n);
    }
    add(e) {
        const t = [];
        Array.isArray(e) ? t.push(...e) : t.push(e);
        let n;
        (n = (r) => {
            this.hasKey(r) &&
                it(`[Resolver] already has key: ${r} overwriting`);
        }),
            zs(t).forEach((r) => {
                const { src: a } = r;
                let { data: o, format: h, loadParser: l, parser: u } = r;
                const c = zs(a).map((p) =>
                        typeof p == "string"
                            ? JT(p)
                            : Array.isArray(p)
                            ? p
                            : [p]
                    ),
                    d = this.getAlias(r);
                Array.isArray(d) ? d.forEach(n) : n(d);
                const f = [];
                c.forEach((p) => {
                    p.forEach((m) => {
                        let g = {};
                        if (typeof m != "object") {
                            g.src = m;
                            for (let _ = 0; _ < this._parsers.length; _++) {
                                const v = this._parsers[_];
                                if (v.test(m)) {
                                    g = v.parse(m);
                                    break;
                                }
                            }
                        } else
                            (o = m.data ?? o),
                                (h = m.format ?? h),
                                (m.loadParser || m.parser) &&
                                    ((l = m.loadParser ?? l),
                                    (u = m.parser ?? u)),
                                (g = { ...g, ...m });
                        if (!d)
                            throw new Error(
                                `[Resolver] alias is undefined for this asset: ${g.src}`
                            );
                        (g = this._buildResolvedAsset(g, {
                            aliases: d,
                            data: o,
                            format: h,
                            loadParser: l,
                            parser: u,
                        })),
                            f.push(g);
                    });
                }),
                    d.forEach((p) => {
                        this._assetMap[p] = f;
                    });
            });
    }
    resolveBundle(e) {
        const t = Mu(e);
        e = zs(e);
        const n = {};
        return (
            e.forEach((i) => {
                const r = this._bundles[i];
                if (r) {
                    const a = this.resolve(r),
                        o = {};
                    for (const h in a) {
                        const l = a[h];
                        o[this._extractAssetIdFromBundle(i, h)] = l;
                    }
                    n[i] = o;
                }
            }),
            t ? n[e[0]] : n
        );
    }
    resolveUrl(e) {
        const t = this.resolve(e);
        if (typeof e != "string") {
            const n = {};
            for (const i in t) n[i] = t[i].src;
            return n;
        }
        return t.src;
    }
    resolve(e) {
        const t = Mu(e);
        e = zs(e);
        const n = {};
        return (
            e.forEach((i) => {
                if (!this._resolverHash[i])
                    if (this._assetMap[i]) {
                        let r = this._assetMap[i];
                        const a = this._getPreferredOrder(r);
                        a == null ||
                            a.priority.forEach((o) => {
                                a.params[o].forEach((h) => {
                                    const l = r.filter((u) =>
                                        u[o] ? u[o] === h : !1
                                    );
                                    l.length && (r = l);
                                });
                            }),
                            (this._resolverHash[i] = r[0]);
                    } else
                        this._resolverHash[i] = this._buildResolvedAsset(
                            { alias: [i], src: i },
                            {}
                        );
                n[i] = this._resolverHash[i];
            }),
            t ? n[e[0]] : n
        );
    }
    hasKey(e) {
        return !!this._assetMap[e];
    }
    hasBundle(e) {
        return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
        for (let t = 0; t < e.length; t++) {
            const n = e[t],
                i = this._preferredOrder.find((r) =>
                    r.params.format.includes(n.format)
                );
            if (i) return i;
        }
        return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
        if (!this._defaultSearchParams) return e;
        const t = /\?/.test(e) ? "&" : "?";
        return `${e}${t}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(e, t) {
        const { aliases: n, data: i, loadParser: r, parser: a, format: o } = t;
        return (
            (this._basePath || this._rootPath) &&
                (e.src = on.toAbsolute(e.src, this._basePath, this._rootPath)),
            (e.alias = n ?? e.alias ?? [e.src]),
            (e.src = this._appendDefaultSearchParams(e.src)),
            (e.data = { ...(i || {}), ...e.data }),
            (e.loadParser = r ?? e.loadParser),
            (e.parser = a ?? e.parser),
            (e.format = o ?? e.format ?? eM(e.src)),
            e
        );
    }
}
Ha.RETINA_PREFIX = /@([0-9\.]+)x/;
function eM(s) {
    return s.split(".").pop().split("?").shift().split("#").shift();
}
const Iu = (s, e) => {
        const t = e.split("?")[1];
        return t && (s += `?${t}`), s;
    },
    gx = class eh {
        constructor(e, t) {
            this.linkedSheets = [];
            let n = e;
            (e == null ? void 0 : e.source) instanceof cs &&
                (n = { texture: e, data: t });
            const { texture: i, data: r, cachePrefix: a = "" } = n;
            (this.cachePrefix = a),
                (this._texture = i instanceof we ? i : null),
                (this.textureSource = i.source),
                (this.textures = {}),
                (this.animations = {}),
                (this.data = r);
            const o = parseFloat(r.meta.scale);
            o
                ? ((this.resolution = o),
                  (i.source.resolution = this.resolution))
                : (this.resolution = i.source._resolution),
                (this._frames = this.data.frames),
                (this._frameKeys = Object.keys(this._frames)),
                (this._batchIndex = 0),
                (this._callback = null);
        }
        parse() {
            return new Promise((e) => {
                (this._callback = e),
                    (this._batchIndex = 0),
                    this._frameKeys.length <= eh.BATCH_SIZE
                        ? (this._processFrames(0),
                          this._processAnimations(),
                          this._parseComplete())
                        : this._nextBatch();
            });
        }
        _processFrames(e) {
            let t = e;
            const n = eh.BATCH_SIZE;
            for (; t - e < n && t < this._frameKeys.length; ) {
                const i = this._frameKeys[t],
                    r = this._frames[i],
                    a = r.frame;
                if (a) {
                    let o = null,
                        h = null;
                    const l =
                            r.trimmed !== !1 && r.sourceSize
                                ? r.sourceSize
                                : r.frame,
                        u = new Lt(
                            0,
                            0,
                            Math.floor(l.w) / this.resolution,
                            Math.floor(l.h) / this.resolution
                        );
                    r.rotated
                        ? (o = new Lt(
                              Math.floor(a.x) / this.resolution,
                              Math.floor(a.y) / this.resolution,
                              Math.floor(a.h) / this.resolution,
                              Math.floor(a.w) / this.resolution
                          ))
                        : (o = new Lt(
                              Math.floor(a.x) / this.resolution,
                              Math.floor(a.y) / this.resolution,
                              Math.floor(a.w) / this.resolution,
                              Math.floor(a.h) / this.resolution
                          )),
                        r.trimmed !== !1 &&
                            r.spriteSourceSize &&
                            (h = new Lt(
                                Math.floor(r.spriteSourceSize.x) /
                                    this.resolution,
                                Math.floor(r.spriteSourceSize.y) /
                                    this.resolution,
                                Math.floor(a.w) / this.resolution,
                                Math.floor(a.h) / this.resolution
                            )),
                        (this.textures[i] = new we({
                            source: this.textureSource,
                            frame: o,
                            orig: u,
                            trim: h,
                            rotate: r.rotated ? 2 : 0,
                            defaultAnchor: r.anchor,
                            defaultBorders: r.borders,
                            label: i.toString(),
                        }));
                }
                t++;
            }
        }
        _processAnimations() {
            const e = this.data.animations || {};
            for (const t in e) {
                this.animations[t] = [];
                for (let n = 0; n < e[t].length; n++) {
                    const i = e[t][n];
                    this.animations[t].push(this.textures[i]);
                }
            }
        }
        _parseComplete() {
            const e = this._callback;
            (this._callback = null),
                (this._batchIndex = 0),
                e.call(this, this.textures);
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * eh.BATCH_SIZE),
                this._batchIndex++,
                setTimeout(() => {
                    this._batchIndex * eh.BATCH_SIZE < this._frameKeys.length
                        ? this._nextBatch()
                        : (this._processAnimations(), this._parseComplete());
                }, 0);
        }
        destroy(e = !1) {
            var t;
            for (const n in this.textures) this.textures[n].destroy();
            (this._frames = null),
                (this._frameKeys = null),
                (this.data = null),
                (this.textures = null),
                e &&
                    ((t = this._texture) == null || t.destroy(),
                    this.textureSource.destroy()),
                (this._texture = null),
                (this.textureSource = null),
                (this.linkedSheets = []);
        }
    };
gx.BATCH_SIZE = 1e3;
let mv = gx;
const tM = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc",
];
function _x(s, e, t) {
    const n = {};
    if (
        (s.forEach((i) => {
            n[i] = e;
        }),
        Object.keys(e.textures).forEach((i) => {
            n[`${e.cachePrefix}${i}`] = e.textures[i];
        }),
        !t)
    ) {
        const i = on.dirname(s[0]);
        e.linkedSheets.forEach((r, a) => {
            const o = _x([`${i}/${e.data.meta.related_multi_packs[a]}`], r, !0);
            Object.assign(n, o);
        });
    }
    return n;
}
const nM = {
    extension: ee.Asset,
    cache: {
        test: (s) => s instanceof mv,
        getCacheableAssets: (s, e) => _x(s, e, !1),
    },
    resolver: {
        extension: { type: ee.ResolveParser, name: "resolveSpritesheet" },
        test: (s) => {
            const t = s.split("?")[0].split("."),
                n = t.pop(),
                i = t.pop();
            return n === "json" && tM.includes(i);
        },
        parse: (s) => {
            var t;
            const e = s.split(".");
            return {
                resolution: parseFloat(
                    ((t = Ha.RETINA_PREFIX.exec(s)) == null ? void 0 : t[1]) ??
                        "1"
                ),
                format: e[e.length - 2],
                src: s,
            };
        },
    },
    loader: {
        name: "spritesheetLoader",
        id: "spritesheet",
        extension: {
            type: ee.LoadParser,
            priority: Ii.Normal,
            name: "spritesheetLoader",
        },
        async testParse(s, e) {
            return on.extname(e.src).toLowerCase() === ".json" && !!s.frames;
        },
        async parse(s, e, t) {
            var c, d;
            const {
                texture: n,
                imageFilename: i,
                textureOptions: r,
                cachePrefix: a,
            } = (e == null ? void 0 : e.data) ?? {};
            let o = on.dirname(e.src);
            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
            let h;
            if (n instanceof we) h = n;
            else {
                const f = Iu(o + (i ?? s.meta.image), e.src);
                h = (await t.load([{ src: f, data: r }]))[f];
            }
            const l = new mv({ texture: h.source, data: s, cachePrefix: a });
            await l.parse();
            const u =
                (c = s == null ? void 0 : s.meta) == null
                    ? void 0
                    : c.related_multi_packs;
            if (Array.isArray(u)) {
                const f = [];
                for (const m of u) {
                    if (typeof m != "string") continue;
                    let g = o + m;
                    ((d = e.data) != null && d.ignoreMultiPack) ||
                        ((g = Iu(g, e.src)),
                        f.push(
                            t.load({
                                src: g,
                                data: {
                                    textureOptions: r,
                                    ignoreMultiPack: !0,
                                },
                            })
                        ));
                }
                const p = await Promise.all(f);
                (l.linkedSheets = p),
                    p.forEach((m) => {
                        m.linkedSheets = [l].concat(
                            l.linkedSheets.filter((g) => g !== m)
                        );
                    });
            }
            return l;
        },
        async unload(s, e, t) {
            await t.unload(s.textureSource._sourceOrigin), s.destroy(!1);
        },
    },
};
Ot.add(nM);
const Mf = Object.create(null),
    gv = Object.create(null);
function Rg(s, e) {
    let t = gv[s];
    return (
        t === void 0 &&
            (Mf[e] === void 0 && (Mf[e] = 1), (gv[s] = t = Mf[e]++)),
        t
    );
}
let ro;
function vx() {
    return (
        (!ro || (ro != null && ro.isContextLost())) &&
            (ro = rt.get().createCanvas().getContext("webgl", {})),
        ro
    );
}
let Oc;
function sM() {
    if (!Oc) {
        Oc = "mediump";
        const s = vx();
        s &&
            s.getShaderPrecisionFormat &&
            (Oc = s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT)
                .precision
                ? "highp"
                : "mediump");
    }
    return Oc;
}
function iM(s, e, t) {
    return e
        ? s
        : t
        ? ((s = s.replace("out vec4 finalColor;", "")),
          `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `)
        : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `;
}
function rM(s, e, t) {
    const n = t
        ? e.maxSupportedFragmentPrecision
        : e.maxSupportedVertexPrecision;
    if (s.substring(0, 9) !== "precision") {
        let i = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
        return (
            i === "highp" && n !== "highp" && (i = "mediump"),
            `precision ${i} float;
${s}`
        );
    } else if (n !== "highp" && s.substring(0, 15) === "precision highp")
        return s.replace("precision highp", "precision mediump");
    return s;
}
function aM(s, e) {
    return e
        ? `#version 300 es
${s}`
        : s;
}
const oM = {},
    lM = {};
function hM(s, { name: e = "pixi-program" }, t = !0) {
    (e = e.replace(/\s+/g, "-")), (e += t ? "-fragment" : "-vertex");
    const n = t ? oM : lM;
    return (
        n[e] ? (n[e]++, (e += `-${n[e]}`)) : (n[e] = 1),
        s.indexOf("#define SHADER_NAME") !== -1
            ? s
            : `${`#define SHADER_NAME ${e}`}
${s}`
    );
}
function cM(s, e) {
    return e ? s.replace("#version 300 es", "") : s;
}
const If = {
        stripVersion: cM,
        ensurePrecision: rM,
        addProgramDefines: iM,
        setProgramName: hM,
        insertVersion: aM,
    },
    Rl = Object.create(null),
    bx = class am {
        constructor(e) {
            e = { ...am.defaultOptions, ...e };
            const t = e.fragment.indexOf("#version 300 es") !== -1,
                n = {
                    stripVersion: t,
                    ensurePrecision: {
                        requestedFragmentPrecision:
                            e.preferredFragmentPrecision,
                        requestedVertexPrecision: e.preferredVertexPrecision,
                        maxSupportedVertexPrecision: "highp",
                        maxSupportedFragmentPrecision: sM(),
                    },
                    setProgramName: { name: e.name },
                    addProgramDefines: t,
                    insertVersion: t,
                };
            let i = e.fragment,
                r = e.vertex;
            Object.keys(If).forEach((a) => {
                const o = n[a];
                (i = If[a](i, o, !0)), (r = If[a](r, o, !1));
            }),
                (this.fragment = i),
                (this.vertex = r),
                (this.transformFeedbackVaryings = e.transformFeedbackVaryings),
                (this._key = Rg(
                    `${this.vertex}:${this.fragment}`,
                    "gl-program"
                ));
        }
        destroy() {
            (this.fragment = null),
                (this.vertex = null),
                (this._attributeData = null),
                (this._uniformData = null),
                (this._uniformBlockData = null),
                (this.transformFeedbackVaryings = null),
                (Rl[this._cacheKey] = null);
        }
        static from(e) {
            const t = `${e.vertex}:${e.fragment}`;
            return Rl[t] || ((Rl[t] = new am(e)), (Rl[t]._cacheKey = t)), Rl[t];
        }
    };
bx.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump",
};
let vl = bx;
const _v = {
    uint8x2: { size: 2, stride: 2, normalised: !1 },
    uint8x4: { size: 4, stride: 4, normalised: !1 },
    sint8x2: { size: 2, stride: 2, normalised: !1 },
    sint8x4: { size: 4, stride: 4, normalised: !1 },
    unorm8x2: { size: 2, stride: 2, normalised: !0 },
    unorm8x4: { size: 4, stride: 4, normalised: !0 },
    snorm8x2: { size: 2, stride: 2, normalised: !0 },
    snorm8x4: { size: 4, stride: 4, normalised: !0 },
    uint16x2: { size: 2, stride: 4, normalised: !1 },
    uint16x4: { size: 4, stride: 8, normalised: !1 },
    sint16x2: { size: 2, stride: 4, normalised: !1 },
    sint16x4: { size: 4, stride: 8, normalised: !1 },
    unorm16x2: { size: 2, stride: 4, normalised: !0 },
    unorm16x4: { size: 4, stride: 8, normalised: !0 },
    snorm16x2: { size: 2, stride: 4, normalised: !0 },
    snorm16x4: { size: 4, stride: 8, normalised: !0 },
    float16x2: { size: 2, stride: 4, normalised: !1 },
    float16x4: { size: 4, stride: 8, normalised: !1 },
    float32: { size: 1, stride: 4, normalised: !1 },
    float32x2: { size: 2, stride: 8, normalised: !1 },
    float32x3: { size: 3, stride: 12, normalised: !1 },
    float32x4: { size: 4, stride: 16, normalised: !1 },
    uint32: { size: 1, stride: 4, normalised: !1 },
    uint32x2: { size: 2, stride: 8, normalised: !1 },
    uint32x3: { size: 3, stride: 12, normalised: !1 },
    uint32x4: { size: 4, stride: 16, normalised: !1 },
    sint32: { size: 1, stride: 4, normalised: !1 },
    sint32x2: { size: 2, stride: 8, normalised: !1 },
    sint32x3: { size: 3, stride: 12, normalised: !1 },
    sint32x4: { size: 4, stride: 16, normalised: !1 },
};
function uM(s) {
    return _v[s] ?? _v.float32;
}
const dM = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4",
};
function fM({ source: s, entryPoint: e }) {
    const t = {},
        n = s.indexOf(`fn ${e}`);
    if (n !== -1) {
        const i = s.indexOf("->", n);
        if (i !== -1) {
            const r = s.substring(n, i),
                a =
                    /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
            let o;
            for (; (o = a.exec(r)) !== null; ) {
                const h = dM[o[3]] ?? "float32";
                t[o[2]] = {
                    location: parseInt(o[1], 10),
                    format: h,
                    stride: uM(h).stride,
                    offset: 0,
                    instance: !1,
                    start: 0,
                };
            }
        }
    }
    return t;
}
function Rf(s) {
    var c, d;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
        t = /@group\((\d+)\)/,
        n = /@binding\((\d+)\)/,
        i = /var(<[^>]+>)? (\w+)/,
        r = /:\s*(\w+)/,
        a = /struct\s+(\w+)\s*{([^}]+)}/g,
        o = /(\w+)\s*:\s*([\w\<\>]+)/g,
        h = /struct\s+(\w+)/,
        l =
            (c = s.match(e)) == null
                ? void 0
                : c.map((f) => ({
                      group: parseInt(f.match(t)[1], 10),
                      binding: parseInt(f.match(n)[1], 10),
                      name: f.match(i)[2],
                      isUniform: f.match(i)[1] === "<uniform>",
                      type: f.match(r)[1],
                  }));
    if (!l) return { groups: [], structs: [] };
    const u =
        ((d = s.match(a)) == null
            ? void 0
            : d
                  .map((f) => {
                      const p = f.match(h)[1],
                          m = f.match(o).reduce((g, _) => {
                              const [v, b] = _.split(":");
                              return (g[v.trim()] = b.trim()), g;
                          }, {});
                      return m ? { name: p, members: m } : null;
                  })
                  .filter(({ name: f }) => l.some((p) => p.type === f))) ?? [];
    return { groups: l, structs: u };
}
var th = ((s) => (
    (s[(s.VERTEX = 1)] = "VERTEX"),
    (s[(s.FRAGMENT = 2)] = "FRAGMENT"),
    (s[(s.COMPUTE = 4)] = "COMPUTE"),
    s
))(th || {});
function pM({ groups: s }) {
    const e = [];
    for (let t = 0; t < s.length; t++) {
        const n = s[t];
        e[n.group] || (e[n.group] = []),
            n.isUniform
                ? e[n.group].push({
                      binding: n.binding,
                      visibility: th.VERTEX | th.FRAGMENT,
                      buffer: { type: "uniform" },
                  })
                : n.type === "sampler"
                ? e[n.group].push({
                      binding: n.binding,
                      visibility: th.FRAGMENT,
                      sampler: { type: "filtering" },
                  })
                : n.type === "texture_2d" &&
                  e[n.group].push({
                      binding: n.binding,
                      visibility: th.FRAGMENT,
                      texture: {
                          sampleType: "float",
                          viewDimension: "2d",
                          multisampled: !1,
                      },
                  });
    }
    return e;
}
function mM({ groups: s }) {
    const e = [];
    for (let t = 0; t < s.length; t++) {
        const n = s[t];
        e[n.group] || (e[n.group] = {}), (e[n.group][n.name] = n.binding);
    }
    return e;
}
function gM(s, e) {
    const t = new Set(),
        n = new Set(),
        i = [...s.structs, ...e.structs].filter((a) =>
            t.has(a.name) ? !1 : (t.add(a.name), !0)
        ),
        r = [...s.groups, ...e.groups].filter((a) => {
            const o = `${a.name}-${a.binding}`;
            return n.has(o) ? !1 : (n.add(o), !0);
        });
    return { structs: i, groups: r };
}
const Ll = Object.create(null);
class Hr {
    constructor(e) {
        var o, h;
        (this._layoutKey = 0), (this._attributeLocationsKey = 0);
        const { fragment: t, vertex: n, layout: i, gpuLayout: r, name: a } = e;
        if (
            ((this.name = a),
            (this.fragment = t),
            (this.vertex = n),
            t.source === n.source)
        ) {
            const l = Rf(t.source);
            this.structsAndGroups = l;
        } else {
            const l = Rf(n.source),
                u = Rf(t.source);
            this.structsAndGroups = gM(l, u);
        }
        (this.layout = i ?? mM(this.structsAndGroups)),
            (this.gpuLayout = r ?? pM(this.structsAndGroups)),
            (this.autoAssignGlobalUniforms =
                ((o = this.layout[0]) == null ? void 0 : o.globalUniforms) !==
                void 0),
            (this.autoAssignLocalUniforms =
                ((h = this.layout[1]) == null ? void 0 : h.localUniforms) !==
                void 0),
            this._generateProgramKey();
    }
    _generateProgramKey() {
        const { vertex: e, fragment: t } = this,
            n = e.source + t.source + e.entryPoint + t.entryPoint;
        this._layoutKey = Rg(n, "program");
    }
    get attributeData() {
        return (
            this._attributeData ?? (this._attributeData = fM(this.vertex)),
            this._attributeData
        );
    }
    destroy() {
        (this.gpuLayout = null),
            (this.layout = null),
            (this.structsAndGroups = null),
            (this.fragment = null),
            (this.vertex = null),
            (Ll[this._cacheKey] = null);
    }
    static from(e) {
        const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
        return Ll[t] || ((Ll[t] = new Hr(e)), (Ll[t]._cacheKey = t)), Ll[t];
    }
}
const yx = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>",
    ],
    _M = yx.reduce((s, e) => ((s[e] = !0), s), {});
function vM(s, e) {
    switch (s) {
        case "f32":
            return 0;
        case "vec2<f32>":
            return new Float32Array(2 * e);
        case "vec3<f32>":
            return new Float32Array(3 * e);
        case "vec4<f32>":
            return new Float32Array(4 * e);
        case "mat2x2<f32>":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3x3<f32>":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4x4<f32>":
            return new Float32Array([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]);
    }
    return null;
}
const wx = class xx {
    constructor(e, t) {
        (this._touched = 0),
            (this.uid = Pt("uniform")),
            (this._resourceType = "uniformGroup"),
            (this._resourceId = Pt("resource")),
            (this.isUniformGroup = !0),
            (this._dirtyId = 0),
            (this.destroyed = !1),
            (t = { ...xx.defaultOptions, ...t }),
            (this.uniformStructures = e);
        const n = {};
        for (const i in e) {
            const r = e[i];
            if (((r.name = i), (r.size = r.size ?? 1), !_M[r.type])) {
                const a = r.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
                if (a) {
                    const [, o, h] = a;
                    throw new Error(
                        `Uniform type ${r.type} is not supported. Use type: '${o}', size: ${h} instead.`
                    );
                }
                throw new Error(
                    `Uniform type ${
                        r.type
                    } is not supported. Supported uniform types are: ${yx.join(
                        ", "
                    )}`
                );
            }
            r.value ?? (r.value = vM(r.type, r.size)), (n[i] = r.value);
        }
        (this.uniforms = n),
            (this._dirtyId = 1),
            (this.ubo = t.ubo),
            (this.isStatic = t.isStatic),
            (this._signature = Rg(
                Object.keys(n)
                    .map((i) => `${i}-${e[i].type}`)
                    .join("-"),
                "uniform-group"
            ));
    }
    update() {
        this._dirtyId++;
    }
};
wx.defaultOptions = { ubo: !1, isStatic: !1 };
let Cx = wx;
class iu {
    constructor(e) {
        (this.resources = Object.create(null)), (this._dirty = !0);
        let t = 0;
        for (const n in e) {
            const i = e[n];
            this.setResource(i, t++);
        }
        this._updateKey();
    }
    _updateKey() {
        if (!this._dirty) return;
        this._dirty = !1;
        const e = [];
        let t = 0;
        for (const n in this.resources) e[t++] = this.resources[n]._resourceId;
        this._key = e.join("|");
    }
    setResource(e, t) {
        var i, r;
        const n = this.resources[t];
        e !== n &&
            (n &&
                ((i = e.off) == null ||
                    i.call(e, "change", this.onResourceChange, this)),
            (r = e.on) == null ||
                r.call(e, "change", this.onResourceChange, this),
            (this.resources[t] = e),
            (this._dirty = !0));
    }
    getResource(e) {
        return this.resources[e];
    }
    _touch(e) {
        const t = this.resources;
        for (const n in t) t[n]._touched = e;
    }
    destroy() {
        var t;
        const e = this.resources;
        for (const n in e) {
            const i = e[n];
            (t = i == null ? void 0 : i.off) == null ||
                t.call(i, "change", this.onResourceChange, this);
        }
        this.resources = null;
    }
    onResourceChange(e) {
        if (((this._dirty = !0), e.destroyed)) {
            const t = this.resources;
            for (const n in t) t[n] === e && (t[n] = null);
        } else this._updateKey();
    }
}
var Fh = ((s) => (
    (s[(s.WEBGL = 1)] = "WEBGL"),
    (s[(s.WEBGPU = 2)] = "WEBGPU"),
    (s[(s.BOTH = 3)] = "BOTH"),
    s
))(Fh || {});
class uc extends ti {
    constructor(e) {
        super(),
            (this.uid = Pt("shader")),
            (this._uniformBindMap = Object.create(null)),
            (this._ownedBindGroups = []);
        let {
            gpuProgram: t,
            glProgram: n,
            groups: i,
            resources: r,
            compatibleRenderers: a,
            groupMap: o,
        } = e;
        (this.gpuProgram = t),
            (this.glProgram = n),
            a === void 0 &&
                ((a = 0), t && (a |= Fh.WEBGPU), n && (a |= Fh.WEBGL)),
            (this.compatibleRenderers = a);
        const h = {};
        if ((!r && !i && (r = {}), r && i))
            throw new Error("[Shader] Cannot have both resources and groups");
        if (!t && i && !o)
            throw new Error(
                "[Shader] No group map or WebGPU shader provided - consider using resources instead."
            );
        if (!t && i && o)
            for (const l in o)
                for (const u in o[l]) {
                    const c = o[l][u];
                    h[c] = { group: l, binding: u, name: c };
                }
        else if (t && i && !o) {
            const l = t.structsAndGroups.groups;
            (o = {}),
                l.forEach((u) => {
                    (o[u.group] = o[u.group] || {}),
                        (o[u.group][u.binding] = u.name),
                        (h[u.name] = u);
                });
        } else if (r) {
            (i = {}),
                (o = {}),
                t &&
                    t.structsAndGroups.groups.forEach((c) => {
                        (o[c.group] = o[c.group] || {}),
                            (o[c.group][c.binding] = c.name),
                            (h[c.name] = c);
                    });
            let l = 0;
            for (const u in r)
                h[u] ||
                    (i[99] ||
                        ((i[99] = new iu()), this._ownedBindGroups.push(i[99])),
                    (h[u] = { group: 99, binding: l, name: u }),
                    (o[99] = o[99] || {}),
                    (o[99][l] = u),
                    l++);
            for (const u in r) {
                const c = u;
                let d = r[u];
                !d.source && !d._resourceType && (d = new Cx(d));
                const f = h[c];
                f &&
                    (i[f.group] ||
                        ((i[f.group] = new iu()),
                        this._ownedBindGroups.push(i[f.group])),
                    i[f.group].setResource(d, f.binding));
            }
        }
        (this.groups = i),
            (this._uniformBindMap = o),
            (this.resources = this._buildResourceAccessor(i, h));
    }
    addResource(e, t, n) {
        var i, r;
        (i = this._uniformBindMap)[t] || (i[t] = {}),
            (r = this._uniformBindMap[t])[n] || (r[n] = e),
            this.groups[t] ||
                ((this.groups[t] = new iu()),
                this._ownedBindGroups.push(this.groups[t]));
    }
    _buildResourceAccessor(e, t) {
        const n = {};
        for (const i in t) {
            const r = t[i];
            Object.defineProperty(n, r.name, {
                get() {
                    return e[r.group].getResource(r.binding);
                },
                set(a) {
                    e[r.group].setResource(a, r.binding);
                },
            });
        }
        return n;
    }
    destroy(e = !1) {
        var t, n;
        this.emit("destroy", this),
            e &&
                ((t = this.gpuProgram) == null || t.destroy(),
                (n = this.glProgram) == null || n.destroy()),
            (this.gpuProgram = null),
            (this.glProgram = null),
            this.removeAllListeners(),
            (this._uniformBindMap = null),
            this._ownedBindGroups.forEach((i) => {
                i.destroy();
            }),
            (this._ownedBindGroups = null),
            (this.resources = null),
            (this.groups = null);
    }
    static from(e) {
        const { gpu: t, gl: n, ...i } = e;
        let r, a;
        return (
            t && (r = Hr.from(t)),
            n && (a = vl.from(n)),
            new uc({ gpuProgram: r, glProgram: a, ...i })
        );
    }
}
const bM = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10,
    },
    Lf = 0,
    Of = 1,
    Bf = 2,
    Ff = 3,
    $f = 4,
    Df = 5,
    om = class Ax {
        constructor() {
            (this.data = 0),
                (this.blendMode = "normal"),
                (this.polygonOffset = 0),
                (this.blend = !0),
                (this.depthMask = !0);
        }
        get blend() {
            return !!(this.data & (1 << Lf));
        }
        set blend(e) {
            !!(this.data & (1 << Lf)) !== e && (this.data ^= 1 << Lf);
        }
        get offsets() {
            return !!(this.data & (1 << Of));
        }
        set offsets(e) {
            !!(this.data & (1 << Of)) !== e && (this.data ^= 1 << Of);
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return;
            }
            (this.culling = !0), (this.clockwiseFrontFace = e === "front");
        }
        get cullMode() {
            return this.culling
                ? this.clockwiseFrontFace
                    ? "front"
                    : "back"
                : "none";
        }
        get culling() {
            return !!(this.data & (1 << Bf));
        }
        set culling(e) {
            !!(this.data & (1 << Bf)) !== e && (this.data ^= 1 << Bf);
        }
        get depthTest() {
            return !!(this.data & (1 << Ff));
        }
        set depthTest(e) {
            !!(this.data & (1 << Ff)) !== e && (this.data ^= 1 << Ff);
        }
        get depthMask() {
            return !!(this.data & (1 << Df));
        }
        set depthMask(e) {
            !!(this.data & (1 << Df)) !== e && (this.data ^= 1 << Df);
        }
        get clockwiseFrontFace() {
            return !!(this.data & (1 << $f));
        }
        set clockwiseFrontFace(e) {
            !!(this.data & (1 << $f)) !== e && (this.data ^= 1 << $f);
        }
        get blendMode() {
            return this._blendMode;
        }
        set blendMode(e) {
            (this.blend = e !== "none"),
                (this._blendMode = e),
                (this._blendModeId = bM[e] || 0);
        }
        get polygonOffset() {
            return this._polygonOffset;
        }
        set polygonOffset(e) {
            (this.offsets = !!e), (this._polygonOffset = e);
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
            const e = new Ax();
            return (e.depthTest = !1), (e.blend = !0), e;
        }
    };
om.default2d = om.for2d();
let yM = om;
const Sx = class lm extends uc {
    constructor(e) {
        (e = { ...lm.defaultOptions, ...e }),
            super(e),
            (this.enabled = !0),
            (this._state = yM.for2d()),
            (this.blendMode = e.blendMode),
            (this.padding = e.padding),
            typeof e.antialias == "boolean"
                ? (this.antialias = e.antialias ? "on" : "off")
                : (this.antialias = e.antialias),
            (this.resolution = e.resolution),
            (this.blendRequired = e.blendRequired),
            (this.clipToViewport = e.clipToViewport),
            this.addResource("uTexture", 0, 1);
    }
    apply(e, t, n, i) {
        e.applyFilter(this, t, n, i);
    }
    get blendMode() {
        return this._state.blendMode;
    }
    set blendMode(e) {
        this._state.blendMode = e;
    }
    static from(e) {
        const { gpu: t, gl: n, ...i } = e;
        let r, a;
        return (
            t && (r = Hr.from(t)),
            n && (a = vl.from(n)),
            new lm({ gpuProgram: r, glProgram: a, ...i })
        );
    }
};
Sx.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: !1,
    clipToViewport: !0,
};
let Sd = Sx;
const hm = [];
Ot.handleByNamedList(ee.Environment, hm);
async function wM(s) {
    if (!s)
        for (let e = 0; e < hm.length; e++) {
            const t = hm[e];
            if (t.value.test()) {
                await t.value.load();
                return;
            }
        }
}
let Ol;
function xM() {
    if (typeof Ol == "boolean") return Ol;
    try {
        Ol =
            new Function(
                "param1",
                "param2",
                "param3",
                "return param1[param2] === param3;"
            )({ a: "b" }, "a", "b") === !0;
    } catch {
        Ol = !1;
    }
    return Ol;
}
function vv(s, e, t = 2) {
    const n = e && e.length,
        i = n ? e[0] * t : s.length;
    let r = Ex(s, 0, i, t, !0);
    const a = [];
    if (!r || r.next === r.prev) return a;
    let o, h, l;
    if ((n && (r = PM(s, e, r, t)), s.length > 80 * t)) {
        (o = s[0]), (h = s[1]);
        let u = o,
            c = h;
        for (let d = t; d < i; d += t) {
            const f = s[d],
                p = s[d + 1];
            f < o && (o = f),
                p < h && (h = p),
                f > u && (u = f),
                p > c && (c = p);
        }
        (l = Math.max(u - o, c - h)), (l = l !== 0 ? 32767 / l : 0);
    }
    return $h(r, a, t, o, h, l, 0), a;
}
function Ex(s, e, t, n, i) {
    let r;
    if (i === DM(s, e, t, n) > 0)
        for (let a = e; a < t; a += n) r = bv((a / n) | 0, s[a], s[a + 1], r);
    else
        for (let a = t - n; a >= e; a -= n)
            r = bv((a / n) | 0, s[a], s[a + 1], r);
    return r && il(r, r.next) && (Nh(r), (r = r.next)), r;
}
function Fa(s, e) {
    if (!s) return s;
    e || (e = s);
    let t = s,
        n;
    do
        if (
            ((n = !1),
            !t.steiner && (il(t, t.next) || xt(t.prev, t, t.next) === 0))
        ) {
            if ((Nh(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
        } else t = t.next;
    while (n || t !== e);
    return e;
}
function $h(s, e, t, n, i, r, a) {
    if (!s) return;
    !a && r && RM(s, n, i, r);
    let o = s;
    for (; s.prev !== s.next; ) {
        const h = s.prev,
            l = s.next;
        if (r ? AM(s, n, i, r) : CM(s)) {
            e.push(h.i, s.i, l.i), Nh(s), (s = l.next), (o = l.next);
            continue;
        }
        if (((s = l), s === o)) {
            a
                ? a === 1
                    ? ((s = SM(Fa(s), e)), $h(s, e, t, n, i, r, 2))
                    : a === 2 && EM(s, e, t, n, i, r)
                : $h(Fa(s), e, t, n, i, r, 1);
            break;
        }
    }
}
function CM(s) {
    const e = s.prev,
        t = s,
        n = s.next;
    if (xt(e, t, n) >= 0) return !1;
    const i = e.x,
        r = t.x,
        a = n.x,
        o = e.y,
        h = t.y,
        l = n.y,
        u = Math.min(i, r, a),
        c = Math.min(o, h, l),
        d = Math.max(i, r, a),
        f = Math.max(o, h, l);
    let p = n.next;
    for (; p !== e; ) {
        if (
            p.x >= u &&
            p.x <= d &&
            p.y >= c &&
            p.y <= f &&
            nh(i, o, r, h, a, l, p.x, p.y) &&
            xt(p.prev, p, p.next) >= 0
        )
            return !1;
        p = p.next;
    }
    return !0;
}
function AM(s, e, t, n) {
    const i = s.prev,
        r = s,
        a = s.next;
    if (xt(i, r, a) >= 0) return !1;
    const o = i.x,
        h = r.x,
        l = a.x,
        u = i.y,
        c = r.y,
        d = a.y,
        f = Math.min(o, h, l),
        p = Math.min(u, c, d),
        m = Math.max(o, h, l),
        g = Math.max(u, c, d),
        _ = cm(f, p, e, t, n),
        v = cm(m, g, e, t, n);
    let b = s.prevZ,
        y = s.nextZ;
    for (; b && b.z >= _ && y && y.z <= v; ) {
        if (
            (b.x >= f &&
                b.x <= m &&
                b.y >= p &&
                b.y <= g &&
                b !== i &&
                b !== a &&
                nh(o, u, h, c, l, d, b.x, b.y) &&
                xt(b.prev, b, b.next) >= 0) ||
            ((b = b.prevZ),
            y.x >= f &&
                y.x <= m &&
                y.y >= p &&
                y.y <= g &&
                y !== i &&
                y !== a &&
                nh(o, u, h, c, l, d, y.x, y.y) &&
                xt(y.prev, y, y.next) >= 0)
        )
            return !1;
        y = y.nextZ;
    }
    for (; b && b.z >= _; ) {
        if (
            b.x >= f &&
            b.x <= m &&
            b.y >= p &&
            b.y <= g &&
            b !== i &&
            b !== a &&
            nh(o, u, h, c, l, d, b.x, b.y) &&
            xt(b.prev, b, b.next) >= 0
        )
            return !1;
        b = b.prevZ;
    }
    for (; y && y.z <= v; ) {
        if (
            y.x >= f &&
            y.x <= m &&
            y.y >= p &&
            y.y <= g &&
            y !== i &&
            y !== a &&
            nh(o, u, h, c, l, d, y.x, y.y) &&
            xt(y.prev, y, y.next) >= 0
        )
            return !1;
        y = y.nextZ;
    }
    return !0;
}
function SM(s, e) {
    let t = s;
    do {
        const n = t.prev,
            i = t.next.next;
        !il(n, i) &&
            kx(n, t, t.next, i) &&
            Dh(n, i) &&
            Dh(i, n) &&
            (e.push(n.i, t.i, i.i), Nh(t), Nh(t.next), (t = s = i)),
            (t = t.next);
    } while (t !== s);
    return Fa(t);
}
function EM(s, e, t, n, i, r) {
    let a = s;
    do {
        let o = a.next.next;
        for (; o !== a.prev; ) {
            if (a.i !== o.i && BM(a, o)) {
                let h = Tx(a, o);
                (a = Fa(a, a.next)),
                    (h = Fa(h, h.next)),
                    $h(a, e, t, n, i, r, 0),
                    $h(h, e, t, n, i, r, 0);
                return;
            }
            o = o.next;
        }
        a = a.next;
    } while (a !== s);
}
function PM(s, e, t, n) {
    const i = [];
    for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r] * n,
            h = r < a - 1 ? e[r + 1] * n : s.length,
            l = Ex(s, o, h, n, !1);
        l === l.next && (l.steiner = !0), i.push(OM(l));
    }
    i.sort(kM);
    for (let r = 0; r < i.length; r++) t = TM(i[r], t);
    return t;
}
function kM(s, e) {
    let t = s.x - e.x;
    if (t === 0 && ((t = s.y - e.y), t === 0)) {
        const n = (s.next.y - s.y) / (s.next.x - s.x),
            i = (e.next.y - e.y) / (e.next.x - e.x);
        t = n - i;
    }
    return t;
}
function TM(s, e) {
    const t = MM(s, e);
    if (!t) return e;
    const n = Tx(t, s);
    return Fa(n, n.next), Fa(t, t.next);
}
function MM(s, e) {
    let t = e;
    const n = s.x,
        i = s.y;
    let r = -1 / 0,
        a;
    if (il(s, t)) return t;
    do {
        if (il(s, t.next)) return t.next;
        if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            const c = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (
                c <= n &&
                c > r &&
                ((r = c), (a = t.x < t.next.x ? t : t.next), c === n)
            )
                return a;
        }
        t = t.next;
    } while (t !== e);
    if (!a) return null;
    const o = a,
        h = a.x,
        l = a.y;
    let u = 1 / 0;
    t = a;
    do {
        if (
            n >= t.x &&
            t.x >= h &&
            n !== t.x &&
            Px(i < l ? n : r, i, h, l, i < l ? r : n, i, t.x, t.y)
        ) {
            const c = Math.abs(i - t.y) / (n - t.x);
            Dh(t, s) &&
                (c < u ||
                    (c === u && (t.x > a.x || (t.x === a.x && IM(a, t))))) &&
                ((a = t), (u = c));
        }
        t = t.next;
    } while (t !== o);
    return a;
}
function IM(s, e) {
    return xt(s.prev, s, e.prev) < 0 && xt(e.next, s, s.next) < 0;
}
function RM(s, e, t, n) {
    let i = s;
    do
        i.z === 0 && (i.z = cm(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
    while (i !== s);
    (i.prevZ.nextZ = null), (i.prevZ = null), LM(i);
}
function LM(s) {
    let e,
        t = 1;
    do {
        let n = s,
            i;
        s = null;
        let r = null;
        for (e = 0; n; ) {
            e++;
            let a = n,
                o = 0;
            for (let l = 0; l < t && (o++, (a = a.nextZ), !!a); l++);
            let h = t;
            for (; o > 0 || (h > 0 && a); )
                o !== 0 && (h === 0 || !a || n.z <= a.z)
                    ? ((i = n), (n = n.nextZ), o--)
                    : ((i = a), (a = a.nextZ), h--),
                    r ? (r.nextZ = i) : (s = i),
                    (i.prevZ = r),
                    (r = i);
            n = a;
        }
        (r.nextZ = null), (t *= 2);
    } while (e > 1);
    return s;
}
function cm(s, e, t, n, i) {
    return (
        (s = ((s - t) * i) | 0),
        (e = ((e - n) * i) | 0),
        (s = (s | (s << 8)) & 16711935),
        (s = (s | (s << 4)) & 252645135),
        (s = (s | (s << 2)) & 858993459),
        (s = (s | (s << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        s | (e << 1)
    );
}
function OM(s) {
    let e = s,
        t = s;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== s);
    return t;
}
function Px(s, e, t, n, i, r, a, o) {
    return (
        (i - a) * (e - o) >= (s - a) * (r - o) &&
        (s - a) * (n - o) >= (t - a) * (e - o) &&
        (t - a) * (r - o) >= (i - a) * (n - o)
    );
}
function nh(s, e, t, n, i, r, a, o) {
    return !(s === a && e === o) && Px(s, e, t, n, i, r, a, o);
}
function BM(s, e) {
    return (
        s.next.i !== e.i &&
        s.prev.i !== e.i &&
        !FM(s, e) &&
        ((Dh(s, e) &&
            Dh(e, s) &&
            $M(s, e) &&
            (xt(s.prev, s, e.prev) || xt(s, e.prev, e))) ||
            (il(s, e) &&
                xt(s.prev, s, s.next) > 0 &&
                xt(e.prev, e, e.next) > 0))
    );
}
function xt(s, e, t) {
    return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function il(s, e) {
    return s.x === e.x && s.y === e.y;
}
function kx(s, e, t, n) {
    const i = Fc(xt(s, e, t)),
        r = Fc(xt(s, e, n)),
        a = Fc(xt(t, n, s)),
        o = Fc(xt(t, n, e));
    return !!(
        (i !== r && a !== o) ||
        (i === 0 && Bc(s, t, e)) ||
        (r === 0 && Bc(s, n, e)) ||
        (a === 0 && Bc(t, s, n)) ||
        (o === 0 && Bc(t, e, n))
    );
}
function Bc(s, e, t) {
    return (
        e.x <= Math.max(s.x, t.x) &&
        e.x >= Math.min(s.x, t.x) &&
        e.y <= Math.max(s.y, t.y) &&
        e.y >= Math.min(s.y, t.y)
    );
}
function Fc(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function FM(s, e) {
    let t = s;
    do {
        if (
            t.i !== s.i &&
            t.next.i !== s.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            kx(t, t.next, s, e)
        )
            return !0;
        t = t.next;
    } while (t !== s);
    return !1;
}
function Dh(s, e) {
    return xt(s.prev, s, s.next) < 0
        ? xt(s, e, s.next) >= 0 && xt(s, s.prev, e) >= 0
        : xt(s, e, s.prev) < 0 || xt(s, s.next, e) < 0;
}
function $M(s, e) {
    let t = s,
        n = !1;
    const i = (s.x + e.x) / 2,
        r = (s.y + e.y) / 2;
    do
        t.y > r != t.next.y > r &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
    while (t !== s);
    return n;
}
function Tx(s, e) {
    const t = um(s.i, s.x, s.y),
        n = um(e.i, e.x, e.y),
        i = s.next,
        r = e.prev;
    return (
        (s.next = e),
        (e.prev = s),
        (t.next = i),
        (i.prev = t),
        (n.next = t),
        (t.prev = n),
        (r.next = n),
        (n.prev = r),
        n
    );
}
function bv(s, e, t, n) {
    const i = um(s, e, t);
    return (
        n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
        i
    );
}
function Nh(s) {
    (s.next.prev = s.prev),
        (s.prev.next = s.next),
        s.prevZ && (s.prevZ.nextZ = s.nextZ),
        s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function um(s, e, t) {
    return {
        i: s,
        x: e,
        y: t,
        prev: null,
        next: null,
        z: 0,
        prevZ: null,
        nextZ: null,
        steiner: !1,
    };
}
function DM(s, e, t, n) {
    let i = 0;
    for (let r = e, a = t - n; r < t; r += n)
        (i += (s[a] - s[r]) * (s[r + 1] + s[a + 1])), (a = r);
    return i;
}
const NM = vv.default || vv;
var Mx = ((s) => (
    (s[(s.NONE = 0)] = "NONE"),
    (s[(s.COLOR = 16384)] = "COLOR"),
    (s[(s.STENCIL = 1024)] = "STENCIL"),
    (s[(s.DEPTH = 256)] = "DEPTH"),
    (s[(s.COLOR_DEPTH = 16640)] = "COLOR_DEPTH"),
    (s[(s.COLOR_STENCIL = 17408)] = "COLOR_STENCIL"),
    (s[(s.DEPTH_STENCIL = 1280)] = "DEPTH_STENCIL"),
    (s[(s.ALL = 17664)] = "ALL"),
    s
))(Mx || {});
class VM {
    constructor(e) {
        (this.items = []), (this._name = e);
    }
    emit(e, t, n, i, r, a, o, h) {
        const { name: l, items: u } = this;
        for (let c = 0, d = u.length; c < d; c++)
            u[c][l](e, t, n, i, r, a, o, h);
        return this;
    }
    add(e) {
        return e[this._name] && (this.remove(e), this.items.push(e)), this;
    }
    remove(e) {
        const t = this.items.indexOf(e);
        return t !== -1 && this.items.splice(t, 1), this;
    }
    contains(e) {
        return this.items.indexOf(e) !== -1;
    }
    removeAll() {
        return (this.items.length = 0), this;
    }
    destroy() {
        this.removeAll(), (this.items = null), (this._name = null);
    }
    get empty() {
        return this.items.length === 0;
    }
    get name() {
        return this._name;
    }
}
const UM = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender",
    ],
    Ix = class Rx extends ti {
        constructor(e) {
            super(),
                (this.uid = Pt("renderer")),
                (this.runners = Object.create(null)),
                (this.renderPipes = Object.create(null)),
                (this._initOptions = {}),
                (this._systemsHash = Object.create(null)),
                (this.type = e.type),
                (this.name = e.name),
                (this.config = e);
            const t = [...UM, ...(this.config.runners ?? [])];
            this._addRunners(...t), this._unsafeEvalCheck();
        }
        async init(e = {}) {
            const t =
                e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await wM(t),
                this._addSystems(this.config.systems),
                this._addPipes(
                    this.config.renderPipes,
                    this.config.renderPipeAdaptors
                );
            for (const n in this._systemsHash)
                e = {
                    ...this._systemsHash[n].constructor.defaultOptions,
                    ...e,
                };
            (e = { ...Rx.defaultOptions, ...e }),
                (this._roundPixels = e.roundPixels ? 1 : 0);
            for (let n = 0; n < this.runners.init.items.length; n++)
                await this.runners.init.items[n].init(e);
            this._initOptions = e;
        }
        render(e, t) {
            let n = e;
            if (
                (n instanceof hn &&
                    ((n = { container: n }),
                    t &&
                        (ae(
                            Ge,
                            "passing a second argument is deprecated, please use render options instead"
                        ),
                        (n.target = t.renderTexture))),
                n.target || (n.target = this.view.renderTarget),
                n.target === this.view.renderTarget &&
                    ((this._lastObjectRendered = n.container),
                    n.clearColor ?? (n.clearColor = this.background.colorRgba),
                    n.clear ?? (n.clear = this.background.clearBeforeRender)),
                n.clearColor)
            ) {
                const i =
                    Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = i
                    ? n.clearColor
                    : Vt.shared.setValue(n.clearColor).toArray();
            }
            n.transform ||
                (n.container.updateLocalTransform(),
                (n.transform = n.container.localTransform)),
                n.container.visible &&
                    (n.container.enableRenderGroup(),
                    this.runners.prerender.emit(n),
                    this.runners.renderStart.emit(n),
                    this.runners.render.emit(n),
                    this.runners.renderEnd.emit(n),
                    this.runners.postrender.emit(n));
        }
        resize(e, t, n) {
            const i = this.view.resolution;
            this.view.resize(e, t, n),
                this.emit(
                    "resize",
                    this.view.screen.width,
                    this.view.screen.height,
                    this.view.resolution
                ),
                n !== void 0 &&
                    n !== i &&
                    this.runners.resolutionChange.emit(n);
        }
        clear(e = {}) {
            const t = this;
            e.target || (e.target = t.renderTarget.renderTarget),
                e.clearColor || (e.clearColor = this.background.colorRgba),
                e.clear ?? (e.clear = Mx.ALL);
            const { clear: n, clearColor: i, target: r } = e;
            Vt.shared.setValue(i ?? this.background.colorRgba),
                t.renderTarget.clear(r, n, Vt.shared.toArray());
        }
        get resolution() {
            return this.view.resolution;
        }
        set resolution(e) {
            (this.view.resolution = e), this.runners.resolutionChange.emit(e);
        }
        get width() {
            return this.view.texture.frame.width;
        }
        get height() {
            return this.view.texture.frame.height;
        }
        get canvas() {
            return this.view.canvas;
        }
        get lastObjectRendered() {
            return this._lastObjectRendered;
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen;
        }
        get screen() {
            return this.view.screen;
        }
        _addRunners(...e) {
            e.forEach((t) => {
                this.runners[t] = new VM(t);
            });
        }
        _addSystems(e) {
            let t;
            for (t in e) {
                const n = e[t];
                this._addSystem(n.value, n.name);
            }
        }
        _addSystem(e, t) {
            const n = new e(this);
            if (this[t])
                throw new Error(`Whoops! The name "${t}" is already in use`);
            (this[t] = n), (this._systemsHash[t] = n);
            for (const i in this.runners) this.runners[i].add(n);
            return this;
        }
        _addPipes(e, t) {
            const n = t.reduce((i, r) => ((i[r.name] = r.value), i), {});
            e.forEach((i) => {
                const r = i.value,
                    a = i.name,
                    o = n[a];
                (this.renderPipes[a] = new r(this, o ? new o() : null)),
                    this.runners.destroy.add(this.renderPipes[a]);
            });
        }
        destroy(e = !1) {
            this.runners.destroy.items.reverse(),
                this.runners.destroy.emit(e),
                Object.values(this.runners).forEach((t) => {
                    t.destroy();
                }),
                (e === !0 ||
                    (typeof e == "object" && e.releaseGlobalResources)) &&
                    cc.release(),
                (this._systemsHash = null),
                (this.renderPipes = null);
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e);
        }
        get roundPixels() {
            return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
            if (!xM())
                throw new Error(
                    "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support."
                );
        }
        resetState() {
            this.runners.resetState.emit();
        }
    };
Ix.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: !1,
    roundPixels: !1,
};
let Lx = Ix,
    $c;
function zM(s) {
    return (
        $c !== void 0 ||
            ($c = (() => {
                var t;
                const e = {
                    stencil: !0,
                    failIfMajorPerformanceCaveat:
                        s ?? Lx.defaultOptions.failIfMajorPerformanceCaveat,
                };
                try {
                    if (!rt.get().getWebGLRenderingContext()) return !1;
                    let i = rt.get().createCanvas().getContext("webgl", e);
                    const r = !!(
                        (t = i == null ? void 0 : i.getContextAttributes()) !=
                            null && t.stencil
                    );
                    if (i) {
                        const a = i.getExtension("WEBGL_lose_context");
                        a && a.loseContext();
                    }
                    return (i = null), r;
                } catch {
                    return !1;
                }
            })()),
        $c
    );
}
let Dc;
async function YM(s = {}) {
    return (
        Dc !== void 0 ||
            (Dc = await (async () => {
                const e = rt.get().getNavigator().gpu;
                if (!e) return !1;
                try {
                    return (
                        await (await e.requestAdapter(s)).requestDevice(), !0
                    );
                } catch {
                    return !1;
                }
            })()),
        Dc
    );
}
const yv = ["webgl", "webgpu", "canvas"];
async function GM(s) {
    let e = [];
    s.preference
        ? (e.push(s.preference),
          yv.forEach((r) => {
              r !== s.preference && e.push(r);
          }))
        : (e = yv.slice());
    let t,
        n = {};
    for (let r = 0; r < e.length; r++) {
        const a = e[r];
        if (a === "webgpu" && (await YM())) {
            const { WebGPURenderer: o } = await Pu(
                async () => {
                    const { WebGPURenderer: h } = await import(
                        "./WebGPURenderer-dpsYrxgD.js"
                    );
                    return { WebGPURenderer: h };
                },
                __vite__mapDeps([3, 2, 4]),
                import.meta.url
            );
            (t = o), (n = { ...s, ...s.webgpu });
            break;
        } else if (
            a === "webgl" &&
            zM(
                s.failIfMajorPerformanceCaveat ??
                    Lx.defaultOptions.failIfMajorPerformanceCaveat
            )
        ) {
            const { WebGLRenderer: o } = await Pu(
                async () => {
                    const { WebGLRenderer: h } = await import(
                        "./WebGLRenderer-B4qgeFrM.js"
                    );
                    return { WebGLRenderer: h };
                },
                __vite__mapDeps([5, 2, 4]),
                import.meta.url
            );
            (t = o), (n = { ...s, ...s.webgl });
            break;
        } else if (a === "canvas")
            throw (
                ((n = { ...s }),
                new Error("CanvasRenderer is not yet implemented"))
            );
    }
    if ((delete n.webgpu, delete n.webgl, !t))
        throw new Error("No available renderer for the current environment");
    const i = new t();
    return await i.init(n), i;
}
const Ox = "8.13.2";
class Bx {
    static init() {
        var e;
        (e = globalThis.__PIXI_APP_INIT__) == null ||
            e.call(globalThis, this, Ox);
    }
    static destroy() {}
}
Bx.extension = ee.Application;
class jM {
    constructor(e) {
        this._renderer = e;
    }
    init() {
        var e;
        (e = globalThis.__PIXI_RENDERER_INIT__) == null ||
            e.call(globalThis, this._renderer, Ox);
    }
    destroy() {
        this._renderer = null;
    }
}
jM.extension = {
    type: [ee.WebGLSystem, ee.WebGPUSystem],
    name: "initHook",
    priority: -10,
};
const Fx = class dm {
    constructor(...e) {
        (this.stage = new hn()),
            e[0] !== void 0 &&
                ae(
                    Ge,
                    "Application constructor options are deprecated, please use Application.init() instead."
                );
    }
    async init(e) {
        (e = { ...e }),
            (this.renderer = await GM(e)),
            dm._plugins.forEach((t) => {
                t.init.call(this, e);
            });
    }
    render() {
        this.renderer.render({ container: this.stage });
    }
    get canvas() {
        return this.renderer.canvas;
    }
    get view() {
        return (
            ae(
                Ge,
                "Application.view is deprecated, please use Application.canvas instead."
            ),
            this.renderer.canvas
        );
    }
    get screen() {
        return this.renderer.screen;
    }
    destroy(e = !1, t = !1) {
        const n = dm._plugins.slice(0);
        n.reverse(),
            n.forEach((i) => {
                i.destroy.call(this);
            }),
            this.stage.destroy(t),
            (this.stage = null),
            this.renderer.destroy(e),
            (this.renderer = null);
    }
};
Fx._plugins = [];
let $x = Fx;
Ot.handleByList(ee.Application, $x._plugins);
Ot.add(Bx);
class Dx extends ti {
    constructor() {
        super(...arguments),
            (this.chars = Object.create(null)),
            (this.lineHeight = 0),
            (this.fontFamily = ""),
            (this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }),
            (this.baseLineOffset = 0),
            (this.distanceField = { type: "none", range: 0 }),
            (this.pages = []),
            (this.applyFillAsTint = !0),
            (this.baseMeasurementFontSize = 100),
            (this.baseRenderedFontSize = 100);
    }
    get font() {
        return (
            ae(
                Ge,
                "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."
            ),
            this.fontFamily
        );
    }
    get pageTextures() {
        return (
            ae(
                Ge,
                "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."
            ),
            this.pages
        );
    }
    get size() {
        return (
            ae(
                Ge,
                "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."
            ),
            this.fontMetrics.fontSize
        );
    }
    get distanceFieldRange() {
        return (
            ae(
                Ge,
                "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."
            ),
            this.distanceField.range
        );
    }
    get distanceFieldType() {
        return (
            ae(
                Ge,
                "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."
            ),
            this.distanceField.type
        );
    }
    destroy(e = !1) {
        var t;
        this.emit("destroy", this), this.removeAllListeners();
        for (const n in this.chars)
            (t = this.chars[n].texture) == null || t.destroy();
        (this.chars = null),
            e &&
                (this.pages.forEach((n) => n.texture.destroy(!0)),
                (this.pages = null));
    }
}
/**
 * tiny-lru
 *
 * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 11.4.5
 */ class WM {
    constructor(e = 0, t = 0, n = !1) {
        (this.first = null),
            (this.items = Object.create(null)),
            (this.last = null),
            (this.max = e),
            (this.resetTtl = n),
            (this.size = 0),
            (this.ttl = t);
    }
    clear() {
        return (
            (this.first = null),
            (this.items = Object.create(null)),
            (this.last = null),
            (this.size = 0),
            this
        );
    }
    delete(e) {
        if (this.has(e)) {
            const t = this.items[e];
            delete this.items[e],
                this.size--,
                t.prev !== null && (t.prev.next = t.next),
                t.next !== null && (t.next.prev = t.prev),
                this.first === t && (this.first = t.next),
                this.last === t && (this.last = t.prev);
        }
        return this;
    }
    entries(e = this.keys()) {
        return e.map((t) => [t, this.get(t)]);
    }
    evict(e = !1) {
        if (e || this.size > 0) {
            const t = this.first;
            delete this.items[t.key],
                --this.size === 0
                    ? ((this.first = null), (this.last = null))
                    : ((this.first = t.next), (this.first.prev = null));
        }
        return this;
    }
    expiresAt(e) {
        let t;
        return this.has(e) && (t = this.items[e].expiry), t;
    }
    get(e) {
        const t = this.items[e];
        if (t !== void 0) {
            if (this.ttl > 0 && t.expiry <= Date.now()) {
                this.delete(e);
                return;
            }
            return this.moveToEnd(t), t.value;
        }
    }
    has(e) {
        return e in this.items;
    }
    moveToEnd(e) {
        this.last !== e &&
            (e.prev !== null && (e.prev.next = e.next),
            e.next !== null && (e.next.prev = e.prev),
            this.first === e && (this.first = e.next),
            (e.prev = this.last),
            (e.next = null),
            this.last !== null && (this.last.next = e),
            (this.last = e),
            this.first === null && (this.first = e));
    }
    keys() {
        const e = [];
        let t = this.first;
        for (; t !== null; ) e.push(t.key), (t = t.next);
        return e;
    }
    setWithEvicted(e, t, n = this.resetTtl) {
        let i = null;
        if (this.has(e)) this.set(e, t, !0, n);
        else {
            this.max > 0 &&
                this.size === this.max &&
                ((i = { ...this.first }), this.evict(!0));
            let r = (this.items[e] = {
                expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                key: e,
                prev: this.last,
                next: null,
                value: t,
            });
            ++this.size === 1 ? (this.first = r) : (this.last.next = r),
                (this.last = r);
        }
        return i;
    }
    set(e, t, n = !1, i = this.resetTtl) {
        let r = this.items[e];
        return (
            n || r !== void 0
                ? ((r.value = t),
                  n === !1 &&
                      i &&
                      (r.expiry =
                          this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
                  this.moveToEnd(r))
                : (this.max > 0 && this.size === this.max && this.evict(!0),
                  (r = this.items[e] =
                      {
                          expiry:
                              this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                          key: e,
                          prev: this.last,
                          next: null,
                          value: t,
                      }),
                  ++this.size === 1 ? (this.first = r) : (this.last.next = r),
                  (this.last = r)),
            this
        );
    }
    values(e = this.keys()) {
        return e.map((t) => this.get(t));
    }
}
function Nx(s = 1e3, e = 0, t = !1) {
    if (isNaN(s) || s < 0) throw new TypeError("Invalid max value");
    if (isNaN(e) || e < 0) throw new TypeError("Invalid ttl value");
    if (typeof t != "boolean") throw new TypeError("Invalid resetTtl value");
    return new WM(s, e, t);
}
const XM = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
];
function fm(s) {
    const e = typeof s.fontSize == "number" ? `${s.fontSize}px` : s.fontSize;
    let t = s.fontFamily;
    Array.isArray(s.fontFamily) || (t = s.fontFamily.split(","));
    for (let n = t.length - 1; n >= 0; n--) {
        let i = t[n].trim();
        !/([\"\'])[^\'\"]+\1/.test(i) && !XM.includes(i) && (i = `"${i}"`),
            (t[n] = i);
    }
    return `${s.fontStyle} ${s.fontVariant} ${s.fontWeight} ${e} ${t.join(
        ","
    )}`;
}
const Nf = { willReadFrequently: !0 },
    ni = class te {
        static get experimentalLetterSpacingSupported() {
            let e = te._experimentalLetterSpacingSupported;
            if (e === void 0) {
                const t = rt.get().getCanvasRenderingContext2D().prototype;
                e = te._experimentalLetterSpacingSupported =
                    "letterSpacing" in t || "textLetterSpacing" in t;
            }
            return e;
        }
        constructor(e, t, n, i, r, a, o, h, l) {
            (this.text = e),
                (this.style = t),
                (this.width = n),
                (this.height = i),
                (this.lines = r),
                (this.lineWidths = a),
                (this.lineHeight = o),
                (this.maxLineWidth = h),
                (this.fontProperties = l);
        }
        static measureText(e = " ", t, n = te._canvas, i = t.wordWrap) {
            var v;
            const r = `${e}-${t.styleKey}-wordWrap-${i}`;
            if (te._measurementCache.has(r)) return te._measurementCache.get(r);
            const a = fm(t),
                o = te.measureFont(a);
            o.fontSize === 0 &&
                ((o.fontSize = t.fontSize), (o.ascent = t.fontSize));
            const h = te.__context;
            h.font = a;
            const u = (i ? te._wordWrap(e, t, n) : e).split(/(?:\r\n|\r|\n)/),
                c = new Array(u.length);
            let d = 0;
            for (let b = 0; b < u.length; b++) {
                const y = te._measureText(u[b], t.letterSpacing, h);
                (c[b] = y), (d = Math.max(d, y));
            }
            const f = ((v = t._stroke) == null ? void 0 : v.width) || 0;
            let p = d + f;
            t.dropShadow && (p += t.dropShadow.distance);
            const m = t.lineHeight || o.fontSize;
            let g =
                Math.max(m, o.fontSize + f) + (u.length - 1) * (m + t.leading);
            t.dropShadow && (g += t.dropShadow.distance);
            const _ = new te(e, t, p, g, u, c, m + t.leading, d, o);
            return te._measurementCache.set(r, _), _;
        }
        static _measureText(e, t, n) {
            let i = !1;
            te.experimentalLetterSpacingSupported &&
                (te.experimentalLetterSpacing
                    ? ((n.letterSpacing = `${t}px`),
                      (n.textLetterSpacing = `${t}px`),
                      (i = !0))
                    : ((n.letterSpacing = "0px"),
                      (n.textLetterSpacing = "0px")));
            const r = n.measureText(e);
            let a = r.width;
            const o = -r.actualBoundingBoxLeft;
            let l = r.actualBoundingBoxRight - o;
            if (a > 0)
                if (i) (a -= t), (l -= t);
                else {
                    const u = (te.graphemeSegmenter(e).length - 1) * t;
                    (a += u), (l += u);
                }
            return Math.max(a, l);
        }
        static _wordWrap(e, t, n = te._canvas) {
            const i = n.getContext("2d", Nf);
            let r = 0,
                a = "",
                o = "";
            const h = Object.create(null),
                { letterSpacing: l, whiteSpace: u } = t,
                c = te._collapseSpaces(u),
                d = te._collapseNewlines(u);
            let f = !c;
            const p = t.wordWrapWidth + l,
                m = te._tokenize(e);
            for (let g = 0; g < m.length; g++) {
                let _ = m[g];
                if (te._isNewline(_)) {
                    if (!d) {
                        (o += te._addLine(a)), (f = !c), (a = ""), (r = 0);
                        continue;
                    }
                    _ = " ";
                }
                if (c) {
                    const b = te.isBreakingSpace(_),
                        y = te.isBreakingSpace(a[a.length - 1]);
                    if (b && y) continue;
                }
                const v = te._getFromCache(_, l, h, i);
                if (v > p)
                    if (
                        (a !== "" && ((o += te._addLine(a)), (a = ""), (r = 0)),
                        te.canBreakWords(_, t.breakWords))
                    ) {
                        const b = te.wordWrapSplit(_);
                        for (let y = 0; y < b.length; y++) {
                            let C = b[y],
                                w = C,
                                A = 1;
                            for (; b[y + A]; ) {
                                const S = b[y + A];
                                if (!te.canBreakChars(w, S, _, y, t.breakWords))
                                    C += S;
                                else break;
                                (w = S), A++;
                            }
                            y += A - 1;
                            const E = te._getFromCache(C, l, h, i);
                            E + r > p &&
                                ((o += te._addLine(a)),
                                (f = !1),
                                (a = ""),
                                (r = 0)),
                                (a += C),
                                (r += E);
                        }
                    } else {
                        a.length > 0 &&
                            ((o += te._addLine(a)), (a = ""), (r = 0));
                        const b = g === m.length - 1;
                        (o += te._addLine(_, !b)), (f = !1), (a = ""), (r = 0);
                    }
                else
                    v + r > p &&
                        ((f = !1), (o += te._addLine(a)), (a = ""), (r = 0)),
                        (a.length > 0 || !te.isBreakingSpace(_) || f) &&
                            ((a += _), (r += v));
            }
            return (o += te._addLine(a, !1)), o;
        }
        static _addLine(e, t = !0) {
            return (
                (e = te._trimRight(e)),
                (e = t
                    ? `${e}
`
                    : e),
                e
            );
        }
        static _getFromCache(e, t, n, i) {
            let r = n[e];
            return (
                typeof r != "number" &&
                    ((r = te._measureText(e, t, i) + t), (n[e] = r)),
                r
            );
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line";
        }
        static _collapseNewlines(e) {
            return e === "normal";
        }
        static _trimRight(e) {
            if (typeof e != "string") return "";
            for (let t = e.length - 1; t >= 0; t--) {
                const n = e[t];
                if (!te.isBreakingSpace(n)) break;
                e = e.slice(0, -1);
            }
            return e;
        }
        static _isNewline(e) {
            return typeof e != "string"
                ? !1
                : te._newlines.includes(e.charCodeAt(0));
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string"
                ? !1
                : te._breakingSpaces.includes(e.charCodeAt(0));
        }
        static _tokenize(e) {
            const t = [];
            let n = "";
            if (typeof e != "string") return t;
            for (let i = 0; i < e.length; i++) {
                const r = e[i],
                    a = e[i + 1];
                if (te.isBreakingSpace(r, a) || te._isNewline(r)) {
                    n !== "" && (t.push(n), (n = "")),
                        r === "\r" &&
                        a ===
                            `
`
                            ? (t.push(`\r
`),
                              i++)
                            : t.push(r);
                    continue;
                }
                n += r;
            }
            return n !== "" && t.push(n), t;
        }
        static canBreakWords(e, t) {
            return t;
        }
        static canBreakChars(e, t, n, i, r) {
            return !0;
        }
        static wordWrapSplit(e) {
            return te.graphemeSegmenter(e);
        }
        static measureFont(e) {
            if (te._fonts[e]) return te._fonts[e];
            const t = te._context;
            t.font = e;
            const n = t.measureText(te.METRICS_STRING + te.BASELINE_SYMBOL),
                i = {
                    ascent: n.actualBoundingBoxAscent,
                    descent: n.actualBoundingBoxDescent,
                    fontSize:
                        n.actualBoundingBoxAscent + n.actualBoundingBoxDescent,
                };
            return (te._fonts[e] = i), i;
        }
        static clearMetrics(e = "") {
            e ? delete te._fonts[e] : (te._fonts = {});
        }
        static get _canvas() {
            if (!te.__canvas) {
                let e;
                try {
                    const t = new OffscreenCanvas(0, 0),
                        n = t.getContext("2d", Nf);
                    if (n != null && n.measureText) return (te.__canvas = t), t;
                    e = rt.get().createCanvas();
                } catch {
                    e = rt.get().createCanvas();
                }
                (e.width = e.height = 10), (te.__canvas = e);
            }
            return te.__canvas;
        }
        static get _context() {
            return (
                te.__context ||
                    (te.__context = te._canvas.getContext("2d", Nf)),
                te.__context
            );
        }
    };
ni.METRICS_STRING = "|q";
ni.BASELINE_SYMBOL = "M";
ni.BASELINE_MULTIPLIER = 1.4;
ni.HEIGHT_MULTIPLIER = 2;
ni.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const s = new Intl.Segmenter();
        return (e) => {
            const t = s.segment(e),
                n = [];
            let i = 0;
            for (const r of t) n[i++] = r.segment;
            return n;
        };
    }
    return (s) => [...s];
})();
ni.experimentalLetterSpacing = !1;
ni._fonts = {};
ni._newlines = [10, 13];
ni._breakingSpaces = [
    9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
    12288,
];
ni._measurementCache = Nx(1e3);
let ru = ni;
const wv = [
        { offset: 0, color: "white" },
        { offset: 1, color: "black" },
    ],
    Lg = class pm {
        constructor(...e) {
            (this.uid = Pt("fillGradient")),
                (this._tick = 0),
                (this.type = "linear"),
                (this.colorStops = []);
            let t = qM(e);
            (t = {
                ...(t.type === "radial"
                    ? pm.defaultRadialOptions
                    : pm.defaultLinearOptions),
                ...Y1(t),
            }),
                (this._textureSize = t.textureSize),
                (this._wrapMode = t.wrapMode),
                t.type === "radial"
                    ? ((this.center = t.center),
                      (this.outerCenter = t.outerCenter ?? this.center),
                      (this.innerRadius = t.innerRadius),
                      (this.outerRadius = t.outerRadius),
                      (this.scale = t.scale),
                      (this.rotation = t.rotation))
                    : ((this.start = t.start), (this.end = t.end)),
                (this.textureSpace = t.textureSpace),
                (this.type = t.type),
                t.colorStops.forEach((i) => {
                    this.addColorStop(i.offset, i.color);
                });
        }
        addColorStop(e, t) {
            return (
                this.colorStops.push({
                    offset: e,
                    color: Vt.shared.setValue(t).toHexa(),
                }),
                this
            );
        }
        buildLinearGradient() {
            if (this.texture) return;
            let { x: e, y: t } = this.start,
                { x: n, y: i } = this.end,
                r = n - e,
                a = i - t;
            const o = r < 0 || a < 0;
            if (this._wrapMode === "clamp-to-edge") {
                if (r < 0) {
                    const g = e;
                    (e = n), (n = g), (r *= -1);
                }
                if (a < 0) {
                    const g = t;
                    (t = i), (i = g), (a *= -1);
                }
            }
            const h = this.colorStops.length ? this.colorStops : wv,
                l = this._textureSize,
                { canvas: u, context: c } = Cv(l, 1),
                d = o
                    ? c.createLinearGradient(this._textureSize, 0, 0, 0)
                    : c.createLinearGradient(0, 0, this._textureSize, 0);
            xv(d, h),
                (c.fillStyle = d),
                c.fillRect(0, 0, l, 1),
                (this.texture = new we({
                    source: new Ba({
                        resource: u,
                        addressMode: this._wrapMode,
                    }),
                }));
            const f = Math.sqrt(r * r + a * a),
                p = Math.atan2(a, r),
                m = new Ce();
            m.scale(f / l, 1),
                m.rotate(p),
                m.translate(e, t),
                this.textureSpace === "local" && m.scale(l, l),
                (this.transform = m);
        }
        buildGradient() {
            this.texture || this._tick++,
                this.type === "linear"
                    ? this.buildLinearGradient()
                    : this.buildRadialGradient();
        }
        buildRadialGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : wv,
                t = this._textureSize,
                { canvas: n, context: i } = Cv(t, t),
                { x: r, y: a } = this.center,
                { x: o, y: h } = this.outerCenter,
                l = this.innerRadius,
                u = this.outerRadius,
                c = o - u,
                d = h - u,
                f = t / (u * 2),
                p = (r - c) * f,
                m = (a - d) * f,
                g = i.createRadialGradient(
                    p,
                    m,
                    l * f,
                    (o - c) * f,
                    (h - d) * f,
                    u * f
                );
            xv(g, e),
                (i.fillStyle = e[e.length - 1].color),
                i.fillRect(0, 0, t, t),
                (i.fillStyle = g),
                i.translate(p, m),
                i.rotate(this.rotation),
                i.scale(1, this.scale),
                i.translate(-p, -m),
                i.fillRect(0, 0, t, t),
                (this.texture = new we({
                    source: new Ba({
                        resource: n,
                        addressMode: this._wrapMode,
                    }),
                }));
            const _ = new Ce();
            _.scale(1 / f, 1 / f),
                _.translate(c, d),
                this.textureSpace === "local" && _.scale(t, t),
                (this.transform = _);
        }
        destroy() {
            var e;
            (e = this.texture) == null || e.destroy(!0),
                (this.texture = null),
                (this.transform = null),
                (this.colorStops = []),
                (this.start = null),
                (this.end = null),
                (this.center = null),
                (this.outerCenter = null);
        }
        get styleKey() {
            return `fill-gradient-${this.uid}-${this._tick}`;
        }
    };
Lg.defaultLinearOptions = {
    start: { x: 0, y: 0 },
    end: { x: 0, y: 1 },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge",
};
Lg.defaultRadialOptions = {
    center: { x: 0.5, y: 0.5 },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256,
    wrapMode: "clamp-to-edge",
};
let rr = Lg;
function xv(s, e) {
    for (let t = 0; t < e.length; t++) {
        const n = e[t];
        s.addColorStop(n.offset, n.color);
    }
}
function Cv(s, e) {
    const t = rt.get().createCanvas(s, e),
        n = t.getContext("2d");
    return { canvas: t, context: n };
}
function qM(s) {
    let e = s[0] ?? {};
    return (
        (typeof e == "number" || s[1]) &&
            (ae("8.5.2", "use options object instead"),
            (e = {
                type: "linear",
                start: { x: s[0], y: s[1] },
                end: { x: s[2], y: s[3] },
                textureSpace: s[4],
                textureSize: s[5] ?? rr.defaultLinearOptions.textureSize,
            })),
        e
    );
}
const Av = {
    repeat: { addressModeU: "repeat", addressModeV: "repeat" },
    "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" },
    "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" },
    "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
    },
};
class Ed {
    constructor(e, t) {
        (this.uid = Pt("fillPattern")),
            (this._tick = 0),
            (this.transform = new Ce()),
            (this.texture = e),
            this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
            t &&
                ((e.source.style.addressModeU = Av[t].addressModeU),
                (e.source.style.addressModeV = Av[t].addressModeV));
    }
    setTransform(e) {
        const t = this.texture;
        this.transform.copyFrom(e),
            this.transform.invert(),
            this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
            this._tick++;
    }
    get texture() {
        return this._texture;
    }
    set texture(e) {
        this._texture !== e && ((this._texture = e), this._tick++);
    }
    get styleKey() {
        return `fill-pattern-${this.uid}-${this._tick}`;
    }
    destroy() {
        this.texture.destroy(!0), (this.texture = null);
    }
}
var Vf, Sv;
function HM() {
    if (Sv) return Vf;
    (Sv = 1), (Vf = t);
    var s = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
        e = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
    function t(r) {
        var a = [];
        return (
            r.replace(e, function (o, h, l) {
                var u = h.toLowerCase();
                for (
                    l = i(l),
                        u == "m" &&
                            l.length > 2 &&
                            (a.push([h].concat(l.splice(0, 2))),
                            (u = "l"),
                            (h = h == "m" ? "l" : "L"));
                    ;

                ) {
                    if (l.length == s[u]) return l.unshift(h), a.push(l);
                    if (l.length < s[u]) throw new Error("malformed path data");
                    a.push([h].concat(l.splice(0, s[u])));
                }
            }),
            a
        );
    }
    var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
    function i(r) {
        var a = r.match(n);
        return a ? a.map(Number) : [];
    }
    return Vf;
}
var KM = HM();
const ZM = V1(KM);
function QM(s, e) {
    const t = ZM(s),
        n = [];
    let i = null,
        r = 0,
        a = 0;
    for (let o = 0; o < t.length; o++) {
        const h = t[o],
            l = h[0],
            u = h;
        switch (l) {
            case "M":
                (r = u[1]), (a = u[2]), e.moveTo(r, a);
                break;
            case "m":
                (r += u[1]), (a += u[2]), e.moveTo(r, a);
                break;
            case "H":
                (r = u[1]), e.lineTo(r, a);
                break;
            case "h":
                (r += u[1]), e.lineTo(r, a);
                break;
            case "V":
                (a = u[1]), e.lineTo(r, a);
                break;
            case "v":
                (a += u[1]), e.lineTo(r, a);
                break;
            case "L":
                (r = u[1]), (a = u[2]), e.lineTo(r, a);
                break;
            case "l":
                (r += u[1]), (a += u[2]), e.lineTo(r, a);
                break;
            case "C":
                (r = u[5]),
                    (a = u[6]),
                    e.bezierCurveTo(u[1], u[2], u[3], u[4], r, a);
                break;
            case "c":
                e.bezierCurveTo(
                    r + u[1],
                    a + u[2],
                    r + u[3],
                    a + u[4],
                    r + u[5],
                    a + u[6]
                ),
                    (r += u[5]),
                    (a += u[6]);
                break;
            case "S":
                (r = u[3]), (a = u[4]), e.bezierCurveToShort(u[1], u[2], r, a);
                break;
            case "s":
                e.bezierCurveToShort(r + u[1], a + u[2], r + u[3], a + u[4]),
                    (r += u[3]),
                    (a += u[4]);
                break;
            case "Q":
                (r = u[3]), (a = u[4]), e.quadraticCurveTo(u[1], u[2], r, a);
                break;
            case "q":
                e.quadraticCurveTo(r + u[1], a + u[2], r + u[3], a + u[4]),
                    (r += u[3]),
                    (a += u[4]);
                break;
            case "T":
                (r = u[1]), (a = u[2]), e.quadraticCurveToShort(r, a);
                break;
            case "t":
                (r += u[1]), (a += u[2]), e.quadraticCurveToShort(r, a);
                break;
            case "A":
                (r = u[6]),
                    (a = u[7]),
                    e.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, a);
                break;
            case "a":
                (r += u[6]),
                    (a += u[7]),
                    e.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, a);
                break;
            case "Z":
            case "z":
                e.closePath(),
                    n.length > 0 &&
                        ((i = n.pop()),
                        i
                            ? ((r = i.startX), (a = i.startY))
                            : ((r = 0), (a = 0))),
                    (i = null);
                break;
            default:
                it(`Unknown SVG path command: ${l}`);
        }
        l !== "Z" &&
            l !== "z" &&
            i === null &&
            ((i = { startX: r, startY: a }), n.push(i));
    }
    return e;
}
class Og {
    constructor(e = 0, t = 0, n = 0) {
        (this.type = "circle"), (this.x = e), (this.y = t), (this.radius = n);
    }
    clone() {
        return new Og(this.x, this.y, this.radius);
    }
    contains(e, t) {
        if (this.radius <= 0) return !1;
        const n = this.radius * this.radius;
        let i = this.x - e,
            r = this.y - t;
        return (i *= i), (r *= r), i + r <= n;
    }
    strokeContains(e, t, n, i = 0.5) {
        if (this.radius === 0) return !1;
        const r = this.x - e,
            a = this.y - t,
            o = this.radius,
            h = (1 - i) * n,
            l = Math.sqrt(r * r + a * a);
        return l <= o + h && l > o - (n - h);
    }
    getBounds(e) {
        return (
            e || (e = new Lt()),
            (e.x = this.x - this.radius),
            (e.y = this.y - this.radius),
            (e.width = this.radius * 2),
            (e.height = this.radius * 2),
            e
        );
    }
    copyFrom(e) {
        return (this.x = e.x), (this.y = e.y), (this.radius = e.radius), this;
    }
    copyTo(e) {
        return e.copyFrom(this), e;
    }
    toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
}
class Bg {
    constructor(e = 0, t = 0, n = 0, i = 0) {
        (this.type = "ellipse"),
            (this.x = e),
            (this.y = t),
            (this.halfWidth = n),
            (this.halfHeight = i);
    }
    clone() {
        return new Bg(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(e, t) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
        let n = (e - this.x) / this.halfWidth,
            i = (t - this.y) / this.halfHeight;
        return (n *= n), (i *= i), n + i <= 1;
    }
    strokeContains(e, t, n, i = 0.5) {
        const { halfWidth: r, halfHeight: a } = this;
        if (r <= 0 || a <= 0) return !1;
        const o = n * (1 - i),
            h = n - o,
            l = r - h,
            u = a - h,
            c = r + o,
            d = a + o,
            f = e - this.x,
            p = t - this.y,
            m = (f * f) / (l * l) + (p * p) / (u * u),
            g = (f * f) / (c * c) + (p * p) / (d * d);
        return m > 1 && g <= 1;
    }
    getBounds(e) {
        return (
            e || (e = new Lt()),
            (e.x = this.x - this.halfWidth),
            (e.y = this.y - this.halfHeight),
            (e.width = this.halfWidth * 2),
            (e.height = this.halfHeight * 2),
            e
        );
    }
    copyFrom(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.halfWidth = e.halfWidth),
            (this.halfHeight = e.halfHeight),
            this
        );
    }
    copyTo(e) {
        return e.copyFrom(this), e;
    }
    toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
}
function JM(s, e, t, n, i, r) {
    const a = s - t,
        o = e - n,
        h = i - t,
        l = r - n,
        u = a * h + o * l,
        c = h * h + l * l;
    let d = -1;
    c !== 0 && (d = u / c);
    let f, p;
    d < 0
        ? ((f = t), (p = n))
        : d > 1
        ? ((f = i), (p = r))
        : ((f = t + d * h), (p = n + d * l));
    const m = s - f,
        g = e - p;
    return m * m + g * g;
}
let e3, t3;
class ph {
    constructor(...e) {
        this.type = "polygon";
        let t = Array.isArray(e[0]) ? e[0] : e;
        if (typeof t[0] != "number") {
            const n = [];
            for (let i = 0, r = t.length; i < r; i++) n.push(t[i].x, t[i].y);
            t = n;
        }
        (this.points = t), (this.closePath = !0);
    }
    isClockwise() {
        let e = 0;
        const t = this.points,
            n = t.length;
        for (let i = 0; i < n; i += 2) {
            const r = t[i],
                a = t[i + 1],
                o = t[(i + 2) % n],
                h = t[(i + 3) % n];
            e += (o - r) * (h + a);
        }
        return e < 0;
    }
    containsPolygon(e) {
        const t = this.getBounds(e3),
            n = e.getBounds(t3);
        if (!t.containsRect(n)) return !1;
        const i = e.points;
        for (let r = 0; r < i.length; r += 2) {
            const a = i[r],
                o = i[r + 1];
            if (!this.contains(a, o)) return !1;
        }
        return !0;
    }
    clone() {
        const e = this.points.slice(),
            t = new ph(e);
        return (t.closePath = this.closePath), t;
    }
    contains(e, t) {
        let n = !1;
        const i = this.points.length / 2;
        for (let r = 0, a = i - 1; r < i; a = r++) {
            const o = this.points[r * 2],
                h = this.points[r * 2 + 1],
                l = this.points[a * 2],
                u = this.points[a * 2 + 1];
            h > t != u > t && e < (l - o) * ((t - h) / (u - h)) + o && (n = !n);
        }
        return n;
    }
    strokeContains(e, t, n, i = 0.5) {
        const r = n * n,
            a = r * (1 - i),
            o = r - a,
            { points: h } = this,
            l = h.length - (this.closePath ? 0 : 2);
        for (let u = 0; u < l; u += 2) {
            const c = h[u],
                d = h[u + 1],
                f = h[(u + 2) % h.length],
                p = h[(u + 3) % h.length],
                m = JM(e, t, c, d, f, p),
                g = Math.sign((f - c) * (t - d) - (p - d) * (e - c));
            if (m <= (g < 0 ? o : a)) return !0;
        }
        return !1;
    }
    getBounds(e) {
        e || (e = new Lt());
        const t = this.points;
        let n = 1 / 0,
            i = -1 / 0,
            r = 1 / 0,
            a = -1 / 0;
        for (let o = 0, h = t.length; o < h; o += 2) {
            const l = t[o],
                u = t[o + 1];
            (n = l < n ? l : n),
                (i = l > i ? l : i),
                (r = u < r ? u : r),
                (a = u > a ? u : a);
        }
        return (e.x = n), (e.width = i - n), (e.y = r), (e.height = a - r), e;
    }
    copyFrom(e) {
        return (
            (this.points = e.points.slice()),
            (this.closePath = e.closePath),
            this
        );
    }
    copyTo(e) {
        return e.copyFrom(this), e;
    }
    toString() {
        return `[pixi.js/math:PolygoncloseStroke=${
            this.closePath
        }points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
    }
    get lastX() {
        return this.points[this.points.length - 2];
    }
    get lastY() {
        return this.points[this.points.length - 1];
    }
    get x() {
        return (
            ae(
                "8.11.0",
                "Polygon.lastX is deprecated, please use Polygon.lastX instead."
            ),
            this.points[this.points.length - 2]
        );
    }
    get y() {
        return (
            ae(
                "8.11.0",
                "Polygon.y is deprecated, please use Polygon.lastY instead."
            ),
            this.points[this.points.length - 1]
        );
    }
    get startX() {
        return this.points[0];
    }
    get startY() {
        return this.points[1];
    }
}
const Nc = (s, e, t, n, i, r, a) => {
    const o = s - t,
        h = e - n,
        l = Math.sqrt(o * o + h * h);
    return l >= i - r && l <= i + a;
};
class Fg {
    constructor(e = 0, t = 0, n = 0, i = 0, r = 20) {
        (this.type = "roundedRectangle"),
            (this.x = e),
            (this.y = t),
            (this.width = n),
            (this.height = i),
            (this.radius = r);
    }
    getBounds(e) {
        return (
            e || (e = new Lt()),
            (e.x = this.x),
            (e.y = this.y),
            (e.width = this.width),
            (e.height = this.height),
            e
        );
    }
    clone() {
        return new Fg(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.width = e.width),
            (this.height = e.height),
            this
        );
    }
    copyTo(e) {
        return e.copyFrom(this), e;
    }
    contains(e, t) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (
            e >= this.x &&
            e <= this.x + this.width &&
            t >= this.y &&
            t <= this.y + this.height
        ) {
            const n = Math.max(
                0,
                Math.min(this.radius, Math.min(this.width, this.height) / 2)
            );
            if (
                (t >= this.y + n && t <= this.y + this.height - n) ||
                (e >= this.x + n && e <= this.x + this.width - n)
            )
                return !0;
            let i = e - (this.x + n),
                r = t - (this.y + n);
            const a = n * n;
            if (
                i * i + r * r <= a ||
                ((i = e - (this.x + this.width - n)), i * i + r * r <= a) ||
                ((r = t - (this.y + this.height - n)), i * i + r * r <= a) ||
                ((i = e - (this.x + n)), i * i + r * r <= a)
            )
                return !0;
        }
        return !1;
    }
    strokeContains(e, t, n, i = 0.5) {
        const { x: r, y: a, width: o, height: h, radius: l } = this,
            u = n * (1 - i),
            c = n - u,
            d = r + l,
            f = a + l,
            p = o - l * 2,
            m = h - l * 2,
            g = r + o,
            _ = a + h;
        return (((e >= r - u && e <= r + c) || (e >= g - c && e <= g + u)) &&
            t >= f &&
            t <= f + m) ||
            (((t >= a - u && t <= a + c) || (t >= _ - c && t <= _ + u)) &&
                e >= d &&
                e <= d + p)
            ? !0
            : (e < d && t < f && Nc(e, t, d, f, l, c, u)) ||
                  (e > g - l && t < f && Nc(e, t, g - l, f, l, c, u)) ||
                  (e > g - l && t > _ - l && Nc(e, t, g - l, _ - l, l, c, u)) ||
                  (e < d && t > _ - l && Nc(e, t, d, _ - l, l, c, u));
    }
    toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
}
const Vx = {};
function n3(s, e, t) {
    let n = 2166136261;
    for (let i = 0; i < e; i++)
        (n ^= s[i].uid), (n = Math.imul(n, 16777619)), (n >>>= 0);
    return Vx[n] || s3(s, e, n, t);
}
function s3(s, e, t, n) {
    const i = {};
    let r = 0;
    for (let o = 0; o < n; o++) {
        const h = o < e ? s[o] : we.EMPTY.source;
        (i[r++] = h.source), (i[r++] = h.style);
    }
    const a = new iu(i);
    return (Vx[t] = a), a;
}
class Ev {
    constructor(e) {
        typeof e == "number"
            ? (this.rawBinaryData = new ArrayBuffer(e))
            : e instanceof Uint8Array
            ? (this.rawBinaryData = e.buffer)
            : (this.rawBinaryData = e),
            (this.uint32View = new Uint32Array(this.rawBinaryData)),
            (this.float32View = new Float32Array(this.rawBinaryData)),
            (this.size = this.rawBinaryData.byteLength);
    }
    get int8View() {
        return (
            this._int8View ||
                (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
        );
    }
    get uint8View() {
        return (
            this._uint8View ||
                (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
        );
    }
    get int16View() {
        return (
            this._int16View ||
                (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
        );
    }
    get int32View() {
        return (
            this._int32View ||
                (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
        );
    }
    get float64View() {
        return (
            this._float64Array ||
                (this._float64Array = new Float64Array(this.rawBinaryData)),
            this._float64Array
        );
    }
    get bigUint64View() {
        return (
            this._bigUint64Array ||
                (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
            this._bigUint64Array
        );
    }
    view(e) {
        return this[`${e}View`];
    }
    destroy() {
        (this.rawBinaryData = null),
            (this._int8View = null),
            (this._uint8View = null),
            (this._int16View = null),
            (this.uint16View = null),
            (this._int32View = null),
            (this.uint32View = null),
            (this.float32View = null);
    }
    static sizeOf(e) {
        switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`);
        }
    }
}
function mm(s, e) {
    const t = (s.byteLength / 8) | 0,
        n = new Float64Array(s, 0, t);
    new Float64Array(e, 0, t).set(n);
    const r = s.byteLength - t * 8;
    if (r > 0) {
        const a = new Uint8Array(s, t * 8, r);
        new Uint8Array(e, t * 8, r).set(a);
    }
}
const i3 = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" };
var r3 = ((s) => (
    (s[(s.DISABLED = 0)] = "DISABLED"),
    (s[(s.RENDERING_MASK_ADD = 1)] = "RENDERING_MASK_ADD"),
    (s[(s.MASK_ACTIVE = 2)] = "MASK_ACTIVE"),
    (s[(s.INVERSE_MASK_ACTIVE = 3)] = "INVERSE_MASK_ACTIVE"),
    (s[(s.RENDERING_MASK_REMOVE = 4)] = "RENDERING_MASK_REMOVE"),
    (s[(s.NONE = 5)] = "NONE"),
    s
))(r3 || {});
function Pv(s, e) {
    return (e.alphaMode === "no-premultiply-alpha" && i3[s]) || s;
}
const a3 = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}",
].join(`
`);
function o3(s) {
    let e = "";
    for (let t = 0; t < s; ++t)
        t > 0 &&
            (e += `
else `),
            t < s - 1 && (e += `if(test == ${t}.0){}`);
    return e;
}
function l3(s, e) {
    if (s === 0)
        throw new Error(
            "Invalid value of `0` passed to `checkMaxIfStatementsInShader`"
        );
    const t = e.createShader(e.FRAGMENT_SHADER);
    try {
        for (;;) {
            const n = a3.replace(/%forloop%/gi, o3(s));
            if (
                (e.shaderSource(t, n),
                e.compileShader(t),
                !e.getShaderParameter(t, e.COMPILE_STATUS))
            )
                s = (s / 2) | 0;
            else break;
        }
    } finally {
        e.deleteShader(t);
    }
    return s;
}
let ao = null;
function h3() {
    var e;
    if (ao) return ao;
    const s = vx();
    return (
        (ao = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)),
        (ao = l3(ao, s)),
        (e = s.getExtension("WEBGL_lose_context")) == null || e.loseContext(),
        ao
    );
}
class c3 {
    constructor() {
        (this.ids = Object.create(null)),
            (this.textures = []),
            (this.count = 0);
    }
    clear() {
        for (let e = 0; e < this.count; e++) {
            const t = this.textures[e];
            (this.textures[e] = null), (this.ids[t.uid] = null);
        }
        this.count = 0;
    }
}
class u3 {
    constructor() {
        (this.renderPipeId = "batch"),
            (this.action = "startBatch"),
            (this.start = 0),
            (this.size = 0),
            (this.textures = new c3()),
            (this.blendMode = "normal"),
            (this.topology = "triangle-strip"),
            (this.canBundle = !0);
    }
    destroy() {
        (this.textures = null),
            (this.gpuBindGroup = null),
            (this.bindGroup = null),
            (this.batcher = null);
    }
}
const mh = [];
let Ru = 0;
cc.register({
    clear: () => {
        if (mh.length > 0) for (const s of mh) s && s.destroy();
        (mh.length = 0), (Ru = 0);
    },
});
function kv() {
    return Ru > 0 ? mh[--Ru] : new u3();
}
function Tv(s) {
    mh[Ru++] = s;
}
let Bl = 0;
const Ux = class zx {
    constructor(e) {
        (this.uid = Pt("batcher")),
            (this.dirty = !0),
            (this.batchIndex = 0),
            (this.batches = []),
            (this._elements = []),
            (e = { ...zx.defaultOptions, ...e }),
            e.maxTextures ||
                (ae(
                    "v8.8.0",
                    "maxTextures is a required option for Batcher now, please pass it in the options"
                ),
                (e.maxTextures = h3()));
        const {
            maxTextures: t,
            attributesInitialSize: n,
            indicesInitialSize: i,
        } = e;
        (this.attributeBuffer = new Ev(n * 4)),
            (this.indexBuffer = new Uint16Array(i)),
            (this.maxTextures = t);
    }
    begin() {
        (this.elementSize = 0),
            (this.elementStart = 0),
            (this.indexSize = 0),
            (this.attributeSize = 0);
        for (let e = 0; e < this.batchIndex; e++) Tv(this.batches[e]);
        (this.batchIndex = 0),
            (this._batchIndexStart = 0),
            (this._batchIndexSize = 0),
            (this.dirty = !0);
    }
    add(e) {
        (this._elements[this.elementSize++] = e),
            (e._indexStart = this.indexSize),
            (e._attributeStart = this.attributeSize),
            (e._batcher = this),
            (this.indexSize += e.indexSize),
            (this.attributeSize += e.attributeSize * this.vertexSize);
    }
    checkAndUpdateTexture(e, t) {
        const n = e._batch.textures.ids[t._source.uid];
        return !n && n !== 0 ? !1 : ((e._textureId = n), (e.texture = t), !0);
    }
    updateElement(e) {
        this.dirty = !0;
        const t = this.attributeBuffer;
        e.packAsQuad
            ? this.packQuadAttributes(
                  e,
                  t.float32View,
                  t.uint32View,
                  e._attributeStart,
                  e._textureId
              )
            : this.packAttributes(
                  e,
                  t.float32View,
                  t.uint32View,
                  e._attributeStart,
                  e._textureId
              );
    }
    break(e) {
        const t = this._elements;
        if (!t[this.elementStart]) return;
        let n = kv(),
            i = n.textures;
        i.clear();
        const r = t[this.elementStart];
        let a = Pv(r.blendMode, r.texture._source),
            o = r.topology;
        this.attributeSize * 4 > this.attributeBuffer.size &&
            this._resizeAttributeBuffer(this.attributeSize * 4),
            this.indexSize > this.indexBuffer.length &&
                this._resizeIndexBuffer(this.indexSize);
        const h = this.attributeBuffer.float32View,
            l = this.attributeBuffer.uint32View,
            u = this.indexBuffer;
        let c = this._batchIndexSize,
            d = this._batchIndexStart,
            f = "startBatch";
        const p = this.maxTextures;
        for (let m = this.elementStart; m < this.elementSize; ++m) {
            const g = t[m];
            t[m] = null;
            const v = g.texture._source,
                b = Pv(g.blendMode, v),
                y = a !== b || o !== g.topology;
            if (v._batchTick === Bl && !y) {
                (g._textureId = v._textureBindLocation),
                    (c += g.indexSize),
                    g.packAsQuad
                        ? (this.packQuadAttributes(
                              g,
                              h,
                              l,
                              g._attributeStart,
                              g._textureId
                          ),
                          this.packQuadIndex(
                              u,
                              g._indexStart,
                              g._attributeStart / this.vertexSize
                          ))
                        : (this.packAttributes(
                              g,
                              h,
                              l,
                              g._attributeStart,
                              g._textureId
                          ),
                          this.packIndex(
                              g,
                              u,
                              g._indexStart,
                              g._attributeStart / this.vertexSize
                          )),
                    (g._batch = n);
                continue;
            }
            (v._batchTick = Bl),
                (i.count >= p || y) &&
                    (this._finishBatch(n, d, c - d, i, a, o, e, f),
                    (f = "renderBatch"),
                    (d = c),
                    (a = b),
                    (o = g.topology),
                    (n = kv()),
                    (i = n.textures),
                    i.clear(),
                    ++Bl),
                (g._textureId = v._textureBindLocation = i.count),
                (i.ids[v.uid] = i.count),
                (i.textures[i.count++] = v),
                (g._batch = n),
                (c += g.indexSize),
                g.packAsQuad
                    ? (this.packQuadAttributes(
                          g,
                          h,
                          l,
                          g._attributeStart,
                          g._textureId
                      ),
                      this.packQuadIndex(
                          u,
                          g._indexStart,
                          g._attributeStart / this.vertexSize
                      ))
                    : (this.packAttributes(
                          g,
                          h,
                          l,
                          g._attributeStart,
                          g._textureId
                      ),
                      this.packIndex(
                          g,
                          u,
                          g._indexStart,
                          g._attributeStart / this.vertexSize
                      ));
        }
        i.count > 0 &&
            (this._finishBatch(n, d, c - d, i, a, o, e, f), (d = c), ++Bl),
            (this.elementStart = this.elementSize),
            (this._batchIndexStart = d),
            (this._batchIndexSize = c);
    }
    _finishBatch(e, t, n, i, r, a, o, h) {
        (e.gpuBindGroup = null),
            (e.bindGroup = null),
            (e.action = h),
            (e.batcher = this),
            (e.textures = i),
            (e.blendMode = r),
            (e.topology = a),
            (e.start = t),
            (e.size = n),
            ++Bl,
            (this.batches[this.batchIndex++] = e),
            o.add(e);
    }
    finish(e) {
        this.break(e);
    }
    ensureAttributeBuffer(e) {
        e * 4 <= this.attributeBuffer.size ||
            this._resizeAttributeBuffer(e * 4);
    }
    ensureIndexBuffer(e) {
        e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
    }
    _resizeAttributeBuffer(e) {
        const t = Math.max(e, this.attributeBuffer.size * 2),
            n = new Ev(t);
        mm(this.attributeBuffer.rawBinaryData, n.rawBinaryData),
            (this.attributeBuffer = n);
    }
    _resizeIndexBuffer(e) {
        const t = this.indexBuffer;
        let n = Math.max(e, t.length * 1.5);
        n += n % 2;
        const i = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
        if (i.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
            for (let r = 0; r < t.length; r++) i[r] = t[r];
        else mm(t.buffer, i.buffer);
        this.indexBuffer = i;
    }
    packQuadIndex(e, t, n) {
        (e[t] = n + 0),
            (e[t + 1] = n + 1),
            (e[t + 2] = n + 2),
            (e[t + 3] = n + 0),
            (e[t + 4] = n + 2),
            (e[t + 5] = n + 3);
    }
    packIndex(e, t, n, i) {
        const r = e.indices,
            a = e.indexSize,
            o = e.indexOffset,
            h = e.attributeOffset;
        for (let l = 0; l < a; l++) t[n++] = i + r[l + o] - h;
    }
    destroy() {
        if (this.batches !== null) {
            for (let e = 0; e < this.batches.length; e++) Tv(this.batches[e]);
            this.batches = null;
            for (let e = 0; e < this._elements.length; e++)
                this._elements[e] && (this._elements[e]._batch = null);
            (this._elements = null),
                (this.indexBuffer = null),
                this.attributeBuffer.destroy(),
                (this.attributeBuffer = null);
        }
    }
};
Ux.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6,
};
let Yx = Ux;
var qt = ((s) => (
    (s[(s.MAP_READ = 1)] = "MAP_READ"),
    (s[(s.MAP_WRITE = 2)] = "MAP_WRITE"),
    (s[(s.COPY_SRC = 4)] = "COPY_SRC"),
    (s[(s.COPY_DST = 8)] = "COPY_DST"),
    (s[(s.INDEX = 16)] = "INDEX"),
    (s[(s.VERTEX = 32)] = "VERTEX"),
    (s[(s.UNIFORM = 64)] = "UNIFORM"),
    (s[(s.STORAGE = 128)] = "STORAGE"),
    (s[(s.INDIRECT = 256)] = "INDIRECT"),
    (s[(s.QUERY_RESOLVE = 512)] = "QUERY_RESOLVE"),
    (s[(s.STATIC = 1024)] = "STATIC"),
    s
))(qt || {});
class $a extends ti {
    constructor(e) {
        let { data: t, size: n } = e;
        const { usage: i, label: r, shrinkToFit: a } = e;
        super(),
            (this.uid = Pt("buffer")),
            (this._resourceType = "buffer"),
            (this._resourceId = Pt("resource")),
            (this._touched = 0),
            (this._updateID = 1),
            (this._dataInt32 = null),
            (this.shrinkToFit = !0),
            (this.destroyed = !1),
            t instanceof Array && (t = new Float32Array(t)),
            (this._data = t),
            n ?? (n = t == null ? void 0 : t.byteLength);
        const o = !!t;
        (this.descriptor = {
            size: n,
            usage: i,
            mappedAtCreation: o,
            label: r,
        }),
            (this.shrinkToFit = a ?? !0);
    }
    get data() {
        return this._data;
    }
    set data(e) {
        this.setDataWithSize(e, e.length, !0);
    }
    get dataInt32() {
        return (
            this._dataInt32 ||
                (this._dataInt32 = new Int32Array(this.data.buffer)),
            this._dataInt32
        );
    }
    get static() {
        return !!(this.descriptor.usage & qt.STATIC);
    }
    set static(e) {
        e
            ? (this.descriptor.usage |= qt.STATIC)
            : (this.descriptor.usage &= ~qt.STATIC);
    }
    setDataWithSize(e, t, n) {
        if (
            (this._updateID++,
            (this._updateSize = t * e.BYTES_PER_ELEMENT),
            this._data === e)
        ) {
            n && this.emit("update", this);
            return;
        }
        const i = this._data;
        if (
            ((this._data = e),
            (this._dataInt32 = null),
            !i || i.length !== e.length)
        ) {
            !this.shrinkToFit && i && e.byteLength < i.byteLength
                ? n && this.emit("update", this)
                : ((this.descriptor.size = e.byteLength),
                  (this._resourceId = Pt("resource")),
                  this.emit("change", this));
            return;
        }
        n && this.emit("update", this);
    }
    update(e) {
        (this._updateSize = e ?? this._updateSize),
            this._updateID++,
            this.emit("update", this);
    }
    destroy() {
        (this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            (this._data = null),
            (this.descriptor = null),
            this.removeAllListeners();
    }
}
function Gx(s, e) {
    if (!(s instanceof $a)) {
        let t = e ? qt.INDEX : qt.VERTEX;
        s instanceof Array &&
            (e
                ? ((s = new Uint32Array(s)), (t = qt.INDEX | qt.COPY_DST))
                : ((s = new Float32Array(s)), (t = qt.VERTEX | qt.COPY_DST))),
            (s = new $a({
                data: s,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: t,
            }));
    }
    return s;
}
function d3(s, e, t) {
    const n = s.getAttribute(e);
    if (!n) return (t.minX = 0), (t.minY = 0), (t.maxX = 0), (t.maxY = 0), t;
    const i = n.buffer.data;
    let r = 1 / 0,
        a = 1 / 0,
        o = -1 / 0,
        h = -1 / 0;
    const l = i.BYTES_PER_ELEMENT,
        u = (n.offset || 0) / l,
        c = (n.stride || 8) / l;
    for (let d = u; d < i.length; d += c) {
        const f = i[d],
            p = i[d + 1];
        f > o && (o = f), p > h && (h = p), f < r && (r = f), p < a && (a = p);
    }
    return (t.minX = r), (t.minY = a), (t.maxX = o), (t.maxY = h), t;
}
function f3(s) {
    return (
        (s instanceof $a || Array.isArray(s) || s.BYTES_PER_ELEMENT) &&
            (s = { buffer: s }),
        (s.buffer = Gx(s.buffer, !1)),
        s
    );
}
class jx extends ti {
    constructor(e = {}) {
        super(),
            (this.uid = Pt("geometry")),
            (this._layoutKey = 0),
            (this.instanceCount = 1),
            (this._bounds = new Hs()),
            (this._boundsDirty = !0);
        const { attributes: t, indexBuffer: n, topology: i } = e;
        if (((this.buffers = []), (this.attributes = {}), t))
            for (const r in t) this.addAttribute(r, t[r]);
        (this.instanceCount = e.instanceCount ?? 1),
            n && this.addIndex(n),
            (this.topology = i || "triangle-list");
    }
    onBufferUpdate() {
        (this._boundsDirty = !0), this.emit("update", this);
    }
    getAttribute(e) {
        return this.attributes[e];
    }
    getIndex() {
        return this.indexBuffer;
    }
    getBuffer(e) {
        return this.getAttribute(e).buffer;
    }
    getSize() {
        for (const e in this.attributes) {
            const t = this.attributes[e];
            return t.buffer.data.length / (t.stride / 4 || t.size);
        }
        return 0;
    }
    addAttribute(e, t) {
        const n = f3(t);
        this.buffers.indexOf(n.buffer) === -1 &&
            (this.buffers.push(n.buffer),
            n.buffer.on("update", this.onBufferUpdate, this),
            n.buffer.on("change", this.onBufferUpdate, this)),
            (this.attributes[e] = n);
    }
    addIndex(e) {
        (this.indexBuffer = Gx(e, !0)), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
        return this._boundsDirty
            ? ((this._boundsDirty = !1), d3(this, "aPosition", this._bounds))
            : this._bounds;
    }
    destroy(e = !1) {
        this.emit("destroy", this),
            this.removeAllListeners(),
            e && this.buffers.forEach((t) => t.destroy()),
            (this.attributes = null),
            (this.buffers = null),
            (this.indexBuffer = null),
            (this._bounds = null);
    }
}
const p3 = new Float32Array(1),
    m3 = new Uint32Array(1);
class g3 extends jx {
    constructor() {
        const t = new $a({
                data: p3,
                label: "attribute-batch-buffer",
                usage: qt.VERTEX | qt.COPY_DST,
                shrinkToFit: !1,
            }),
            n = new $a({
                data: m3,
                label: "index-batch-buffer",
                usage: qt.INDEX | qt.COPY_DST,
                shrinkToFit: !1,
            }),
            i = 24;
        super({
            attributes: {
                aPosition: {
                    buffer: t,
                    format: "float32x2",
                    stride: i,
                    offset: 0,
                },
                aUV: { buffer: t, format: "float32x2", stride: i, offset: 8 },
                aColor: {
                    buffer: t,
                    format: "unorm8x4",
                    stride: i,
                    offset: 16,
                },
                aTextureIdAndRound: {
                    buffer: t,
                    format: "uint16x2",
                    stride: i,
                    offset: 20,
                },
            },
            indexBuffer: n,
        });
    }
}
function Mv(s, e, t) {
    if (s)
        for (const n in s) {
            const i = n.toLocaleLowerCase(),
                r = e[i];
            if (r) {
                let a = s[n];
                n === "header" &&
                    (a = a
                        .replace(/@in\s+[^;]+;\s*/g, "")
                        .replace(/@out\s+[^;]+;\s*/g, "")),
                    t && r.push(`//----${t}----//`),
                    r.push(a);
            } else it(`${n} placement hook does not exist in shader`);
        }
}
const _3 = /\{\{(.*?)\}\}/g;
function Iv(s) {
    var n;
    const e = {};
    return (
        (
            ((n = s.match(_3)) == null
                ? void 0
                : n.map((i) => i.replace(/[{()}]/g, ""))) ?? []
        ).forEach((i) => {
            e[i] = [];
        }),
        e
    );
}
function Rv(s, e) {
    let t;
    const n = /@in\s+([^;]+);/g;
    for (; (t = n.exec(s)) !== null; ) e.push(t[1]);
}
function Lv(s, e, t = !1) {
    const n = [];
    Rv(e, n),
        s.forEach((o) => {
            o.header && Rv(o.header, n);
        });
    const i = n;
    t && i.sort();
    const r = i.map((o, h) => `       @location(${h}) ${o},`).join(`
`);
    let a = e.replace(/@in\s+[^;]+;\s*/g, "");
    return (
        (a = a.replace(
            "{{in}}",
            `
${r}
`
        )),
        a
    );
}
function Ov(s, e) {
    let t;
    const n = /@out\s+([^;]+);/g;
    for (; (t = n.exec(s)) !== null; ) e.push(t[1]);
}
function v3(s) {
    const t = /\b(\w+)\s*:/g.exec(s);
    return t ? t[1] : "";
}
function b3(s) {
    const e = /@.*?\s+/g;
    return s.replace(e, "");
}
function y3(s, e) {
    const t = [];
    Ov(e, t),
        s.forEach((h) => {
            h.header && Ov(h.header, t);
        });
    let n = 0;
    const i = t
            .sort()
            .map((h) =>
                h.indexOf("builtin") > -1 ? h : `@location(${n++}) ${h}`
            ).join(`,
`),
        r = t.sort().map((h) => `       var ${b3(h)};`).join(`
`),
        a = `return VSOutput(
            ${t.sort().map((h) => ` ${v3(h)}`).join(`,
`)});`;
    let o = e.replace(/@out\s+[^;]+;\s*/g, "");
    return (
        (o = o.replace(
            "{{struct}}",
            `
${i}
`
        )),
        (o = o.replace(
            "{{start}}",
            `
${r}
`
        )),
        (o = o.replace(
            "{{return}}",
            `
${a}
`
        )),
        o
    );
}
function Bv(s, e) {
    let t = s;
    for (const n in e) {
        const i = e[n];
        i.join(`
`).length
            ? (t = t.replace(
                  `{{${n}}}`,
                  `//-----${n} START-----//
${i.join(`
`)}
//----${n} FINISH----//`
              ))
            : (t = t.replace(`{{${n}}}`, ""));
    }
    return t;
}
const Rr = Object.create(null),
    Uf = new Map();
let w3 = 0;
function x3({ template: s, bits: e }) {
    const t = Wx(s, e);
    if (Rr[t]) return Rr[t];
    const { vertex: n, fragment: i } = A3(s, e);
    return (Rr[t] = Xx(n, i, e)), Rr[t];
}
function C3({ template: s, bits: e }) {
    const t = Wx(s, e);
    return Rr[t] || (Rr[t] = Xx(s.vertex, s.fragment, e)), Rr[t];
}
function A3(s, e) {
    const t = e.map((a) => a.vertex).filter((a) => !!a),
        n = e.map((a) => a.fragment).filter((a) => !!a);
    let i = Lv(t, s.vertex, !0);
    i = y3(t, i);
    const r = Lv(n, s.fragment, !0);
    return { vertex: i, fragment: r };
}
function Wx(s, e) {
    return (
        e
            .map((t) => (Uf.has(t) || Uf.set(t, w3++), Uf.get(t)))
            .sort((t, n) => t - n)
            .join("-") +
        s.vertex +
        s.fragment
    );
}
function Xx(s, e, t) {
    const n = Iv(s),
        i = Iv(e);
    return (
        t.forEach((r) => {
            Mv(r.vertex, n, r.name), Mv(r.fragment, i, r.name);
        }),
        { vertex: Bv(s, n), fragment: Bv(e, i) }
    );
}
const S3 = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,
    E3 = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,
    P3 = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,
    k3 = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`,
    T3 = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `,
        },
    },
    M3 = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `,
        },
    };
function qx({ bits: s, name: e }) {
    const t = x3({ template: { fragment: E3, vertex: S3 }, bits: [T3, ...s] });
    return Hr.from({
        name: e,
        vertex: { source: t.vertex, entryPoint: "main" },
        fragment: { source: t.fragment, entryPoint: "main" },
    });
}
function Hx({ bits: s, name: e }) {
    return new vl({
        name: e,
        ...C3({ template: { vertex: P3, fragment: k3 }, bits: [M3, ...s] }),
    });
}
const Kx = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `,
        },
    },
    Zx = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `,
        },
    },
    zf = {};
function I3(s) {
    const e = [];
    if (s === 1)
        e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
            e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
        let t = 0;
        for (let n = 0; n < s; n++)
            e.push(
                `@group(1) @binding(${t++}) var textureSource${
                    n + 1
                }: texture_2d<f32>;`
            ),
                e.push(
                    `@group(1) @binding(${t++}) var textureSampler${
                        n + 1
                    }: sampler;`
                );
    }
    return e.join(`
`);
}
function R3(s) {
    const e = [];
    if (s === 1)
        e.push(
            "outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"
        );
    else {
        e.push("switch vTextureId {");
        for (let t = 0; t < s; t++)
            t === s - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`),
                e.push(
                    `      outColor = textureSampleGrad(textureSource${
                        t + 1
                    }, textureSampler${t + 1}, vUV, uvDx, uvDy);`
                ),
                e.push("      break;}");
        e.push("}");
    }
    return e.join(`
`);
}
function Qx(s) {
    return (
        zf[s] ||
            (zf[s] = {
                name: "texture-batch-bit",
                vertex: {
                    header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                    main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                    end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `,
                },
                fragment: {
                    header: `
                @in @interpolate(flat) vTextureId: u32;

                ${I3(s)}
            `,
                    main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${R3(s)}
            `,
                },
            }),
        zf[s]
    );
}
const Yf = {};
function L3(s) {
    const e = [];
    for (let t = 0; t < s; t++)
        t > 0 && e.push("else"),
            t < s - 1 && e.push(`if(vTextureId < ${t}.5)`),
            e.push("{"),
            e.push(`	outColor = texture(uTextures[${t}], vUV);`),
            e.push("}");
    return e.join(`
`);
}
function Jx(s) {
    return (
        Yf[s] ||
            (Yf[s] = {
                name: "texture-batch-bit",
                vertex: {
                    header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                    main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                    end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `,
                },
                fragment: {
                    header: `
                in float vTextureId;

                uniform sampler2D uTextures[${s}];

            `,
                    main: `

                ${L3(s)}
            `,
                },
            }),
        Yf[s]
    );
}
const eC = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
        },
    },
    tC = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
        },
    },
    Fv = {};
function nC(s) {
    let e = Fv[s];
    if (e) return e;
    const t = new Int32Array(s);
    for (let n = 0; n < s; n++) t[n] = n;
    return (
        (e = Fv[s] =
            new Cx(
                { uTextures: { value: t, type: "i32", size: s } },
                { isStatic: !0 }
            )),
        e
    );
}
class O3 extends uc {
    constructor(e) {
        const t = Hx({ name: "batch", bits: [Zx, Jx(e), tC] }),
            n = qx({ name: "batch", bits: [Kx, Qx(e), eC] });
        super({
            glProgram: t,
            gpuProgram: n,
            resources: { batchSamplers: nC(e) },
        });
    }
}
let Gf = null;
const sC = class iC extends Yx {
    constructor(e) {
        super(e),
            (this.geometry = new g3()),
            (this.name = iC.extension.name),
            (this.vertexSize = 6),
            Gf ?? (Gf = new O3(e.maxTextures)),
            (this.shader = Gf);
    }
    packAttributes(e, t, n, i, r) {
        const a = (r << 16) | (e.roundPixels & 65535),
            o = e.transform,
            h = o.a,
            l = o.b,
            u = o.c,
            c = o.d,
            d = o.tx,
            f = o.ty,
            { positions: p, uvs: m } = e,
            g = e.color,
            _ = e.attributeOffset,
            v = _ + e.attributeSize;
        for (let b = _; b < v; b++) {
            const y = b * 2,
                C = p[y],
                w = p[y + 1];
            (t[i++] = h * C + u * w + d),
                (t[i++] = c * w + l * C + f),
                (t[i++] = m[y]),
                (t[i++] = m[y + 1]),
                (n[i++] = g),
                (n[i++] = a);
        }
    }
    packQuadAttributes(e, t, n, i, r) {
        const a = e.texture,
            o = e.transform,
            h = o.a,
            l = o.b,
            u = o.c,
            c = o.d,
            d = o.tx,
            f = o.ty,
            p = e.bounds,
            m = p.maxX,
            g = p.minX,
            _ = p.maxY,
            v = p.minY,
            b = a.uvs,
            y = e.color,
            C = (r << 16) | (e.roundPixels & 65535);
        (t[i + 0] = h * g + u * v + d),
            (t[i + 1] = c * v + l * g + f),
            (t[i + 2] = b.x0),
            (t[i + 3] = b.y0),
            (n[i + 4] = y),
            (n[i + 5] = C),
            (t[i + 6] = h * m + u * v + d),
            (t[i + 7] = c * v + l * m + f),
            (t[i + 8] = b.x1),
            (t[i + 9] = b.y1),
            (n[i + 10] = y),
            (n[i + 11] = C),
            (t[i + 12] = h * m + u * _ + d),
            (t[i + 13] = c * _ + l * m + f),
            (t[i + 14] = b.x2),
            (t[i + 15] = b.y2),
            (n[i + 16] = y),
            (n[i + 17] = C),
            (t[i + 18] = h * g + u * _ + d),
            (t[i + 19] = c * _ + l * g + f),
            (t[i + 20] = b.x3),
            (t[i + 21] = b.y3),
            (n[i + 22] = y),
            (n[i + 23] = C);
    }
};
sC.extension = { type: [ee.Batcher], name: "default" };
let B3 = sC;
function F3(s, e, t, n, i, r, a, o = null) {
    let h = 0;
    (t *= e), (i *= r);
    const l = o.a,
        u = o.b,
        c = o.c,
        d = o.d,
        f = o.tx,
        p = o.ty;
    for (; h < a; ) {
        const m = s[t],
            g = s[t + 1];
        (n[i] = l * m + c * g + f),
            (n[i + 1] = u * m + d * g + p),
            (i += r),
            (t += e),
            h++;
    }
}
function $3(s, e, t, n) {
    let i = 0;
    for (e *= t; i < n; ) (s[e] = 0), (s[e + 1] = 0), (e += t), i++;
}
function rC(s, e, t, n, i) {
    const r = e.a,
        a = e.b,
        o = e.c,
        h = e.d,
        l = e.tx,
        u = e.ty;
    t || (t = 0), n || (n = 2), i || (i = s.length / n - t);
    let c = t * n;
    for (let d = 0; d < i; d++) {
        const f = s[c],
            p = s[c + 1];
        (s[c] = r * f + o * p + l), (s[c + 1] = a * f + h * p + u), (c += n);
    }
}
const D3 = new Ce();
class aC {
    constructor() {
        (this.packAsQuad = !1),
            (this.batcherName = "default"),
            (this.topology = "triangle-list"),
            (this.applyTransform = !0),
            (this.roundPixels = 0),
            (this._batcher = null),
            (this._batch = null);
    }
    get uvs() {
        return this.geometryData.uvs;
    }
    get positions() {
        return this.geometryData.vertices;
    }
    get indices() {
        return this.geometryData.indices;
    }
    get blendMode() {
        return this.renderable && this.applyTransform
            ? this.renderable.groupBlendMode
            : "normal";
    }
    get color() {
        const e = this.baseColor,
            t = (e >> 16) | (e & 65280) | ((e & 255) << 16),
            n = this.renderable;
        return n
            ? J1(t, n.groupColor) + ((this.alpha * n.groupAlpha * 255) << 24)
            : t + ((this.alpha * 255) << 24);
    }
    get transform() {
        var e;
        return (
            ((e = this.renderable) == null ? void 0 : e.groupTransform) || D3
        );
    }
    copyTo(e) {
        (e.indexOffset = this.indexOffset),
            (e.indexSize = this.indexSize),
            (e.attributeOffset = this.attributeOffset),
            (e.attributeSize = this.attributeSize),
            (e.baseColor = this.baseColor),
            (e.alpha = this.alpha),
            (e.texture = this.texture),
            (e.geometryData = this.geometryData),
            (e.topology = this.topology);
    }
    reset() {
        (this.applyTransform = !0),
            (this.renderable = null),
            (this.topology = "triangle-list");
    }
    destroy() {
        (this.renderable = null),
            (this.texture = null),
            (this.geometryData = null),
            (this._batcher = null),
            (this._batch = null);
    }
}
const Vh = {
        extension: { type: ee.ShapeBuilder, name: "circle" },
        build(s, e) {
            let t, n, i, r, a, o;
            if (s.type === "circle") {
                const y = s;
                if (((a = o = y.radius), a <= 0)) return !1;
                (t = y.x), (n = y.y), (i = r = 0);
            } else if (s.type === "ellipse") {
                const y = s;
                if (((a = y.halfWidth), (o = y.halfHeight), a <= 0 || o <= 0))
                    return !1;
                (t = y.x), (n = y.y), (i = r = 0);
            } else {
                const y = s,
                    C = y.width / 2,
                    w = y.height / 2;
                (t = y.x + C),
                    (n = y.y + w),
                    (a = o = Math.max(0, Math.min(y.radius, Math.min(C, w)))),
                    (i = C - a),
                    (r = w - o);
            }
            if (i < 0 || r < 0) return !1;
            const h = Math.ceil(2.3 * Math.sqrt(a + o)),
                l = h * 8 + (i ? 4 : 0) + (r ? 4 : 0);
            if (l === 0) return !1;
            if (h === 0)
                return (
                    (e[0] = e[6] = t + i),
                    (e[1] = e[3] = n + r),
                    (e[2] = e[4] = t - i),
                    (e[5] = e[7] = n - r),
                    !0
                );
            let u = 0,
                c = h * 4 + (i ? 2 : 0) + 2,
                d = c,
                f = l,
                p = i + a,
                m = r,
                g = t + p,
                _ = t - p,
                v = n + m;
            if (((e[u++] = g), (e[u++] = v), (e[--c] = v), (e[--c] = _), r)) {
                const y = n - m;
                (e[d++] = _), (e[d++] = y), (e[--f] = y), (e[--f] = g);
            }
            for (let y = 1; y < h; y++) {
                const C = (Math.PI / 2) * (y / h),
                    w = i + Math.cos(C) * a,
                    A = r + Math.sin(C) * o,
                    E = t + w,
                    S = t - w,
                    P = n + A,
                    k = n - A;
                (e[u++] = E),
                    (e[u++] = P),
                    (e[--c] = P),
                    (e[--c] = S),
                    (e[d++] = S),
                    (e[d++] = k),
                    (e[--f] = k),
                    (e[--f] = E);
            }
            (p = i), (m = r + o), (g = t + p), (_ = t - p), (v = n + m);
            const b = n - m;
            return (
                (e[u++] = g),
                (e[u++] = v),
                (e[--f] = b),
                (e[--f] = g),
                i && ((e[u++] = _), (e[u++] = v), (e[--f] = b), (e[--f] = _)),
                !0
            );
        },
        triangulate(s, e, t, n, i, r) {
            if (s.length === 0) return;
            let a = 0,
                o = 0;
            for (let u = 0; u < s.length; u += 2) (a += s[u]), (o += s[u + 1]);
            (a /= s.length / 2), (o /= s.length / 2);
            let h = n;
            (e[h * t] = a), (e[h * t + 1] = o);
            const l = h++;
            for (let u = 0; u < s.length; u += 2)
                (e[h * t] = s[u]),
                    (e[h * t + 1] = s[u + 1]),
                    u > 0 && ((i[r++] = h), (i[r++] = l), (i[r++] = h - 1)),
                    h++;
            (i[r++] = l + 1), (i[r++] = l), (i[r++] = h - 1);
        },
    },
    N3 = { ...Vh, extension: { ...Vh.extension, name: "ellipse" } },
    V3 = { ...Vh, extension: { ...Vh.extension, name: "roundedRectangle" } },
    oC = 1e-4,
    $v = 1e-4;
function U3(s) {
    const e = s.length;
    if (e < 6) return 1;
    let t = 0;
    for (let n = 0, i = s[e - 2], r = s[e - 1]; n < e; n += 2) {
        const a = s[n],
            o = s[n + 1];
        (t += (a - i) * (o + r)), (i = a), (r = o);
    }
    return t < 0 ? -1 : 1;
}
function Dv(s, e, t, n, i, r, a, o) {
    const h = s - t * i,
        l = e - n * i,
        u = s + t * r,
        c = e + n * r;
    let d, f;
    a ? ((d = n), (f = -t)) : ((d = -n), (f = t));
    const p = h + d,
        m = l + f,
        g = u + d,
        _ = c + f;
    return o.push(p, m), o.push(g, _), 2;
}
function ta(s, e, t, n, i, r, a, o) {
    const h = t - s,
        l = n - e;
    let u = Math.atan2(h, l),
        c = Math.atan2(i - s, r - e);
    o && u < c ? (u += Math.PI * 2) : !o && u > c && (c += Math.PI * 2);
    let d = u;
    const f = c - u,
        p = Math.abs(f),
        m = Math.sqrt(h * h + l * l),
        g = (((15 * p * Math.sqrt(m)) / Math.PI) >> 0) + 1,
        _ = f / g;
    if (((d += _), o)) {
        a.push(s, e), a.push(t, n);
        for (let v = 1, b = d; v < g; v++, b += _)
            a.push(s, e), a.push(s + Math.sin(b) * m, e + Math.cos(b) * m);
        a.push(s, e), a.push(i, r);
    } else {
        a.push(t, n), a.push(s, e);
        for (let v = 1, b = d; v < g; v++, b += _)
            a.push(s + Math.sin(b) * m, e + Math.cos(b) * m), a.push(s, e);
        a.push(i, r), a.push(s, e);
    }
    return g * 2;
}
function z3(s, e, t, n, i, r) {
    const a = oC;
    if (s.length === 0) return;
    const o = e;
    let h = o.alignment;
    if (e.alignment !== 0.5) {
        let V = U3(s);
        h = (h - 0.5) * V + 0.5;
    }
    const l = new gn(s[0], s[1]),
        u = new gn(s[s.length - 2], s[s.length - 1]),
        c = n,
        d = Math.abs(l.x - u.x) < a && Math.abs(l.y - u.y) < a;
    if (c) {
        (s = s.slice()),
            d && (s.pop(), s.pop(), u.set(s[s.length - 2], s[s.length - 1]));
        const V = (l.x + u.x) * 0.5,
            W = (u.y + l.y) * 0.5;
        s.unshift(V, W), s.push(V, W);
    }
    const f = i,
        p = s.length / 2;
    let m = s.length;
    const g = f.length / 2,
        _ = o.width / 2,
        v = _ * _,
        b = o.miterLimit * o.miterLimit;
    let y = s[0],
        C = s[1],
        w = s[2],
        A = s[3],
        E = 0,
        S = 0,
        P = -(C - A),
        k = y - w,
        R = 0,
        M = 0,
        T = Math.sqrt(P * P + k * k);
    (P /= T), (k /= T), (P *= _), (k *= _);
    const O = h,
        L = (1 - O) * 2,
        F = O * 2;
    c ||
        (o.cap === "round"
            ? (m +=
                  ta(
                      y - P * (L - F) * 0.5,
                      C - k * (L - F) * 0.5,
                      y - P * L,
                      C - k * L,
                      y + P * F,
                      C + k * F,
                      f,
                      !0
                  ) + 2)
            : o.cap === "square" && (m += Dv(y, C, P, k, L, F, !0, f))),
        f.push(y - P * L, C - k * L),
        f.push(y + P * F, C + k * F);
    for (let V = 1; V < p - 1; ++V) {
        (y = s[(V - 1) * 2]),
            (C = s[(V - 1) * 2 + 1]),
            (w = s[V * 2]),
            (A = s[V * 2 + 1]),
            (E = s[(V + 1) * 2]),
            (S = s[(V + 1) * 2 + 1]),
            (P = -(C - A)),
            (k = y - w),
            (T = Math.sqrt(P * P + k * k)),
            (P /= T),
            (k /= T),
            (P *= _),
            (k *= _),
            (R = -(A - S)),
            (M = w - E),
            (T = Math.sqrt(R * R + M * M)),
            (R /= T),
            (M /= T),
            (R *= _),
            (M *= _);
        const W = w - y,
            Z = C - A,
            J = w - E,
            G = S - A,
            j = W * J + Z * G,
            H = Z * J - G * W,
            pe = H < 0;
        if (Math.abs(H) < 0.001 * Math.abs(j)) {
            f.push(w - P * L, A - k * L),
                f.push(w + P * F, A + k * F),
                j >= 0 &&
                    (o.join === "round"
                        ? (m +=
                              ta(
                                  w,
                                  A,
                                  w - P * L,
                                  A - k * L,
                                  w - R * L,
                                  A - M * L,
                                  f,
                                  !1
                              ) + 4)
                        : (m += 2),
                    f.push(w - R * F, A - M * F),
                    f.push(w + R * L, A + M * L));
            continue;
        }
        const _e = (-P + y) * (-k + A) - (-P + w) * (-k + C),
            ve = (-R + E) * (-M + A) - (-R + w) * (-M + S),
            re = (W * ve - J * _e) / H,
            le = (G * _e - Z * ve) / H,
            at = (re - w) * (re - w) + (le - A) * (le - A),
            Ft = w + (re - w) * L,
            Ae = A + (le - A) * L,
            Fe = w - (re - w) * F,
            $e = A - (le - A) * F,
            Gt = Math.min(W * W + Z * Z, J * J + G * G),
            ct = pe ? L : F,
            Xe = Gt + ct * ct * v;
        at <= Xe
            ? o.join === "bevel" || at / v > b
                ? (pe
                      ? (f.push(Ft, Ae),
                        f.push(w + P * F, A + k * F),
                        f.push(Ft, Ae),
                        f.push(w + R * F, A + M * F))
                      : (f.push(w - P * L, A - k * L),
                        f.push(Fe, $e),
                        f.push(w - R * L, A - M * L),
                        f.push(Fe, $e)),
                  (m += 2))
                : o.join === "round"
                ? pe
                    ? (f.push(Ft, Ae),
                      f.push(w + P * F, A + k * F),
                      (m +=
                          ta(
                              w,
                              A,
                              w + P * F,
                              A + k * F,
                              w + R * F,
                              A + M * F,
                              f,
                              !0
                          ) + 4),
                      f.push(Ft, Ae),
                      f.push(w + R * F, A + M * F))
                    : (f.push(w - P * L, A - k * L),
                      f.push(Fe, $e),
                      (m +=
                          ta(
                              w,
                              A,
                              w - P * L,
                              A - k * L,
                              w - R * L,
                              A - M * L,
                              f,
                              !1
                          ) + 4),
                      f.push(w - R * L, A - M * L),
                      f.push(Fe, $e))
                : (f.push(Ft, Ae), f.push(Fe, $e))
            : (f.push(w - P * L, A - k * L),
              f.push(w + P * F, A + k * F),
              o.join === "round"
                  ? pe
                      ? (m +=
                            ta(
                                w,
                                A,
                                w + P * F,
                                A + k * F,
                                w + R * F,
                                A + M * F,
                                f,
                                !0
                            ) + 2)
                      : (m +=
                            ta(
                                w,
                                A,
                                w - P * L,
                                A - k * L,
                                w - R * L,
                                A - M * L,
                                f,
                                !1
                            ) + 2)
                  : o.join === "miter" &&
                    at / v <= b &&
                    (pe
                        ? (f.push(Fe, $e), f.push(Fe, $e))
                        : (f.push(Ft, Ae), f.push(Ft, Ae)),
                    (m += 2)),
              f.push(w - R * L, A - M * L),
              f.push(w + R * F, A + M * F),
              (m += 2));
    }
    (y = s[(p - 2) * 2]),
        (C = s[(p - 2) * 2 + 1]),
        (w = s[(p - 1) * 2]),
        (A = s[(p - 1) * 2 + 1]),
        (P = -(C - A)),
        (k = y - w),
        (T = Math.sqrt(P * P + k * k)),
        (P /= T),
        (k /= T),
        (P *= _),
        (k *= _),
        f.push(w - P * L, A - k * L),
        f.push(w + P * F, A + k * F),
        c ||
            (o.cap === "round"
                ? (m +=
                      ta(
                          w - P * (L - F) * 0.5,
                          A - k * (L - F) * 0.5,
                          w - P * L,
                          A - k * L,
                          w + P * F,
                          A + k * F,
                          f,
                          !1
                      ) + 2)
                : o.cap === "square" && (m += Dv(w, A, P, k, L, F, !1, f)));
    const Y = $v * $v;
    for (let V = g; V < m + g - 2; ++V)
        (y = f[V * 2]),
            (C = f[V * 2 + 1]),
            (w = f[(V + 1) * 2]),
            (A = f[(V + 1) * 2 + 1]),
            (E = f[(V + 2) * 2]),
            (S = f[(V + 2) * 2 + 1]),
            !(Math.abs(y * (A - S) + w * (S - C) + E * (C - A)) < Y) &&
                r.push(V, V + 1, V + 2);
}
function Y3(s, e, t, n) {
    const i = oC;
    if (s.length === 0) return;
    const r = s[0],
        a = s[1],
        o = s[s.length - 2],
        h = s[s.length - 1],
        l = e || (Math.abs(r - o) < i && Math.abs(a - h) < i),
        u = t,
        c = s.length / 2,
        d = u.length / 2;
    for (let f = 0; f < c; f++) u.push(s[f * 2]), u.push(s[f * 2 + 1]);
    for (let f = 0; f < c - 1; f++) n.push(d + f, d + f + 1);
    l && n.push(d + c - 1, d);
}
function lC(s, e, t, n, i, r, a) {
    const o = NM(s, e, 2);
    if (!o) return;
    for (let l = 0; l < o.length; l += 3)
        (r[a++] = o[l] + i), (r[a++] = o[l + 1] + i), (r[a++] = o[l + 2] + i);
    let h = i * n;
    for (let l = 0; l < s.length; l += 2)
        (t[h] = s[l]), (t[h + 1] = s[l + 1]), (h += n);
}
const G3 = [],
    j3 = {
        extension: { type: ee.ShapeBuilder, name: "polygon" },
        build(s, e) {
            for (let t = 0; t < s.points.length; t++) e[t] = s.points[t];
            return !0;
        },
        triangulate(s, e, t, n, i, r) {
            lC(s, G3, e, t, n, i, r);
        },
    },
    W3 = {
        extension: { type: ee.ShapeBuilder, name: "rectangle" },
        build(s, e) {
            const t = s,
                n = t.x,
                i = t.y,
                r = t.width,
                a = t.height;
            return r > 0 && a > 0
                ? ((e[0] = n),
                  (e[1] = i),
                  (e[2] = n + r),
                  (e[3] = i),
                  (e[4] = n + r),
                  (e[5] = i + a),
                  (e[6] = n),
                  (e[7] = i + a),
                  !0)
                : !1;
        },
        triangulate(s, e, t, n, i, r) {
            let a = 0;
            (n *= t),
                (e[n + a] = s[0]),
                (e[n + a + 1] = s[1]),
                (a += t),
                (e[n + a] = s[2]),
                (e[n + a + 1] = s[3]),
                (a += t),
                (e[n + a] = s[6]),
                (e[n + a + 1] = s[7]),
                (a += t),
                (e[n + a] = s[4]),
                (e[n + a + 1] = s[5]),
                (a += t);
            const o = n / t;
            (i[r++] = o),
                (i[r++] = o + 1),
                (i[r++] = o + 2),
                (i[r++] = o + 1),
                (i[r++] = o + 3),
                (i[r++] = o + 2);
        },
    },
    X3 = {
        extension: { type: ee.ShapeBuilder, name: "triangle" },
        build(s, e) {
            return (
                (e[0] = s.x),
                (e[1] = s.y),
                (e[2] = s.x2),
                (e[3] = s.y2),
                (e[4] = s.x3),
                (e[5] = s.y3),
                !0
            );
        },
        triangulate(s, e, t, n, i, r) {
            let a = 0;
            (n *= t),
                (e[n + a] = s[0]),
                (e[n + a + 1] = s[1]),
                (a += t),
                (e[n + a] = s[2]),
                (e[n + a + 1] = s[3]),
                (a += t),
                (e[n + a] = s[4]),
                (e[n + a + 1] = s[5]);
            const o = n / t;
            (i[r++] = o), (i[r++] = o + 1), (i[r++] = o + 2);
        },
    },
    q3 = new Ce(),
    H3 = new Lt();
function K3(s, e, t, n) {
    const i = e.matrix ? s.copyFrom(e.matrix).invert() : s.identity();
    if (e.textureSpace === "local") {
        const a = t.getBounds(H3);
        e.width && a.pad(e.width);
        const { x: o, y: h } = a,
            l = 1 / a.width,
            u = 1 / a.height,
            c = -o * l,
            d = -h * u,
            f = i.a,
            p = i.b,
            m = i.c,
            g = i.d;
        (i.a *= l),
            (i.b *= l),
            (i.c *= u),
            (i.d *= u),
            (i.tx = c * f + d * m + i.tx),
            (i.ty = c * p + d * g + i.ty);
    } else
        i.translate(e.texture.frame.x, e.texture.frame.y),
            i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
    const r = e.texture.source.style;
    return (
        !(e.fill instanceof rr) &&
            r.addressMode === "clamp-to-edge" &&
            ((r.addressMode = "repeat"), r.update()),
        n && i.append(q3.copyFrom(n).invert()),
        i
    );
}
const Pd = {};
Ot.handleByMap(ee.ShapeBuilder, Pd);
Ot.add(W3, j3, X3, Vh, N3, V3);
const Z3 = new Lt(),
    Q3 = new Ce();
function J3(s, e) {
    const { geometryData: t, batches: n } = e;
    (n.length = 0),
        (t.indices.length = 0),
        (t.vertices.length = 0),
        (t.uvs.length = 0);
    for (let i = 0; i < s.instructions.length; i++) {
        const r = s.instructions[i];
        if (r.action === "texture") e5(r.data, n, t);
        else if (r.action === "fill" || r.action === "stroke") {
            const a = r.action === "stroke",
                o = r.data.path.shapePath,
                h = r.data.style,
                l = r.data.hole;
            a && l && Nv(l.shapePath, h, !0, n, t),
                l &&
                    (o.shapePrimitives[o.shapePrimitives.length - 1].holes =
                        l.shapePath.shapePrimitives),
                Nv(o, h, a, n, t);
        }
    }
}
function e5(s, e, t) {
    const n = [],
        i = Pd.rectangle,
        r = Z3;
    (r.x = s.dx), (r.y = s.dy), (r.width = s.dw), (r.height = s.dh);
    const a = s.transform;
    if (!i.build(r, n)) return;
    const { vertices: o, uvs: h, indices: l } = t,
        u = l.length,
        c = o.length / 2;
    a && rC(n, a), i.triangulate(n, o, 2, c, l, u);
    const d = s.image,
        f = d.uvs;
    h.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2);
    const p = Ms.get(aC);
    (p.indexOffset = u),
        (p.indexSize = l.length - u),
        (p.attributeOffset = c),
        (p.attributeSize = o.length / 2 - c),
        (p.baseColor = s.style),
        (p.alpha = s.alpha),
        (p.texture = d),
        (p.geometryData = t),
        e.push(p);
}
function Nv(s, e, t, n, i) {
    const { vertices: r, uvs: a, indices: o } = i;
    s.shapePrimitives.forEach(({ shape: h, transform: l, holes: u }) => {
        const c = [],
            d = Pd[h.type];
        if (!d.build(h, c)) return;
        const f = o.length,
            p = r.length / 2;
        let m = "triangle-list";
        if ((l && rC(c, l), t)) {
            const b = h.closePath ?? !0,
                y = e;
            y.pixelLine
                ? (Y3(c, b, r, o), (m = "line-list"))
                : z3(c, y, !1, b, r, o);
        } else if (u) {
            const b = [],
                y = c.slice();
            t5(u).forEach((w) => {
                b.push(y.length / 2), y.push(...w);
            }),
                lC(y, b, r, 2, p, o, f);
        } else d.triangulate(c, r, 2, p, o, f);
        const g = a.length / 2,
            _ = e.texture;
        if (_ !== we.WHITE) {
            const b = K3(Q3, e, h, l);
            F3(r, 2, p, a, g, 2, r.length / 2 - p, b);
        } else $3(a, g, 2, r.length / 2 - p);
        const v = Ms.get(aC);
        (v.indexOffset = f),
            (v.indexSize = o.length - f),
            (v.attributeOffset = p),
            (v.attributeSize = r.length / 2 - p),
            (v.baseColor = e.color),
            (v.alpha = e.alpha),
            (v.texture = _),
            (v.geometryData = i),
            (v.topology = m),
            n.push(v);
    });
}
function t5(s) {
    const e = [];
    for (let t = 0; t < s.length; t++) {
        const n = s[t].shape,
            i = [];
        Pd[n.type].build(n, i) && e.push(i);
    }
    return e;
}
class n5 {
    constructor() {
        (this.batches = []),
            (this.geometryData = { vertices: [], uvs: [], indices: [] });
    }
}
class s5 {
    constructor() {
        this.instructions = new sx();
    }
    init(e) {
        (this.batcher = new B3({ maxTextures: e })), this.instructions.reset();
    }
    get geometry() {
        return (
            ae(
                lT,
                "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."
            ),
            this.batcher.geometry
        );
    }
    destroy() {
        this.batcher.destroy(),
            this.instructions.destroy(),
            (this.batcher = null),
            (this.instructions = null);
    }
}
const $g = class gm {
    constructor(e) {
        (this._gpuContextHash = {}),
            (this._graphicsDataContextHash = Object.create(null)),
            (this._renderer = e),
            e.renderableGC.addManagedHash(this, "_gpuContextHash"),
            e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(e) {
        gm.defaultOptions.bezierSmoothness =
            (e == null ? void 0 : e.bezierSmoothness) ??
            gm.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(e) {
        return (
            this._graphicsDataContextHash[e.uid] ||
            this._initContextRenderData(e)
        );
    }
    updateGpuContext(e) {
        let t = this._gpuContextHash[e.uid] || this._initContext(e);
        if (e.dirty) {
            t ? this._cleanGraphicsContextData(e) : (t = this._initContext(e)),
                J3(e, t);
            const n = e.batchMode;
            e.customShader || n === "no-batch"
                ? (t.isBatchable = !1)
                : n === "auto"
                ? (t.isBatchable = t.geometryData.vertices.length < 400)
                : (t.isBatchable = !0),
                (e.dirty = !1);
        }
        return t;
    }
    getGpuContext(e) {
        return this._gpuContextHash[e.uid] || this._initContext(e);
    }
    _initContextRenderData(e) {
        const t = Ms.get(s5, {
                maxTextures: this._renderer.limits.maxBatchableTextures,
            }),
            { batches: n, geometryData: i } = this._gpuContextHash[e.uid],
            r = i.vertices.length,
            a = i.indices.length;
        for (let u = 0; u < n.length; u++) n[u].applyTransform = !1;
        const o = t.batcher;
        o.ensureAttributeBuffer(r), o.ensureIndexBuffer(a), o.begin();
        for (let u = 0; u < n.length; u++) {
            const c = n[u];
            o.add(c);
        }
        o.finish(t.instructions);
        const h = o.geometry;
        h.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0),
            h.buffers[0].setDataWithSize(
                o.attributeBuffer.float32View,
                o.attributeSize,
                !0
            );
        const l = o.batches;
        for (let u = 0; u < l.length; u++) {
            const c = l[u];
            c.bindGroup = n3(
                c.textures.textures,
                c.textures.count,
                this._renderer.limits.maxBatchableTextures
            );
        }
        return (this._graphicsDataContextHash[e.uid] = t), t;
    }
    _initContext(e) {
        const t = new n5();
        return (
            (t.context = e),
            (this._gpuContextHash[e.uid] = t),
            e.on("destroy", this.onGraphicsContextDestroy, this),
            this._gpuContextHash[e.uid]
        );
    }
    onGraphicsContextDestroy(e) {
        this._cleanGraphicsContextData(e),
            e.off("destroy", this.onGraphicsContextDestroy, this),
            (this._gpuContextHash[e.uid] = null);
    }
    _cleanGraphicsContextData(e) {
        const t = this._gpuContextHash[e.uid];
        t.isBatchable ||
            (this._graphicsDataContextHash[e.uid] &&
                (Ms.return(this.getContextRenderData(e)),
                (this._graphicsDataContextHash[e.uid] = null))),
            t.batches &&
                t.batches.forEach((n) => {
                    Ms.return(n);
                });
    }
    destroy() {
        for (const e in this._gpuContextHash)
            this._gpuContextHash[e] &&
                this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    }
};
$g.extension = {
    type: [ee.WebGLSystem, ee.WebGPUSystem, ee.CanvasSystem],
    name: "graphicsContext",
};
$g.defaultOptions = { bezierSmoothness: 0.5 };
let hC = $g;
const i5 = 8,
    Vc = 11920929e-14,
    r5 = 1;
function cC(s, e, t, n, i, r, a, o, h, l) {
    const c = Math.min(
        0.99,
        Math.max(0, l ?? hC.defaultOptions.bezierSmoothness)
    );
    let d = (r5 - c) / 1;
    return (d *= d), a5(e, t, n, i, r, a, o, h, s, d), s;
}
function a5(s, e, t, n, i, r, a, o, h, l) {
    _m(s, e, t, n, i, r, a, o, h, l, 0), h.push(a, o);
}
function _m(s, e, t, n, i, r, a, o, h, l, u) {
    if (u > i5) return;
    const c = (s + t) / 2,
        d = (e + n) / 2,
        f = (t + i) / 2,
        p = (n + r) / 2,
        m = (i + a) / 2,
        g = (r + o) / 2,
        _ = (c + f) / 2,
        v = (d + p) / 2,
        b = (f + m) / 2,
        y = (p + g) / 2,
        C = (_ + b) / 2,
        w = (v + y) / 2;
    if (u > 0) {
        let A = a - s,
            E = o - e;
        const S = Math.abs((t - a) * E - (n - o) * A),
            P = Math.abs((i - a) * E - (r - o) * A);
        if (S > Vc && P > Vc) {
            if ((S + P) * (S + P) <= l * (A * A + E * E)) {
                h.push(C, w);
                return;
            }
        } else if (S > Vc) {
            if (S * S <= l * (A * A + E * E)) {
                h.push(C, w);
                return;
            }
        } else if (P > Vc) {
            if (P * P <= l * (A * A + E * E)) {
                h.push(C, w);
                return;
            }
        } else if (
            ((A = C - (s + a) / 2), (E = w - (e + o) / 2), A * A + E * E <= l)
        ) {
            h.push(C, w);
            return;
        }
    }
    _m(s, e, c, d, _, v, C, w, h, l, u + 1),
        _m(C, w, b, y, m, g, a, o, h, l, u + 1);
}
const o5 = 8,
    l5 = 11920929e-14,
    h5 = 1;
function c5(s, e, t, n, i, r, a, o) {
    const l = Math.min(
        0.99,
        Math.max(0, o ?? hC.defaultOptions.bezierSmoothness)
    );
    let u = (h5 - l) / 1;
    return (u *= u), u5(e, t, n, i, r, a, s, u), s;
}
function u5(s, e, t, n, i, r, a, o) {
    vm(a, s, e, t, n, i, r, o, 0), a.push(i, r);
}
function vm(s, e, t, n, i, r, a, o, h) {
    if (h > o5) return;
    const l = (e + n) / 2,
        u = (t + i) / 2,
        c = (n + r) / 2,
        d = (i + a) / 2,
        f = (l + c) / 2,
        p = (u + d) / 2;
    let m = r - e,
        g = a - t;
    const _ = Math.abs((n - r) * g - (i - a) * m);
    if (_ > l5) {
        if (_ * _ <= o * (m * m + g * g)) {
            s.push(f, p);
            return;
        }
    } else if (
        ((m = f - (e + r) / 2), (g = p - (t + a) / 2), m * m + g * g <= o)
    ) {
        s.push(f, p);
        return;
    }
    vm(s, e, t, l, u, f, p, o, h + 1), vm(s, f, p, c, d, r, a, o, h + 1);
}
function uC(s, e, t, n, i, r, a, o) {
    let h = Math.abs(i - r);
    ((!a && i > r) || (a && r > i)) && (h = 2 * Math.PI - h),
        o ||
            (o = Math.max(
                6,
                Math.floor(6 * Math.pow(n, 1 / 3) * (h / Math.PI))
            )),
        (o = Math.max(o, 3));
    let l = h / o,
        u = i;
    l *= a ? -1 : 1;
    for (let c = 0; c < o + 1; c++) {
        const d = Math.cos(u),
            f = Math.sin(u),
            p = e + d * n,
            m = t + f * n;
        s.push(p, m), (u += l);
    }
}
function d5(s, e, t, n, i, r) {
    const a = s[s.length - 2],
        h = s[s.length - 1] - t,
        l = a - e,
        u = i - t,
        c = n - e,
        d = Math.abs(h * c - l * u);
    if (d < 1e-8 || r === 0) {
        (s[s.length - 2] !== e || s[s.length - 1] !== t) && s.push(e, t);
        return;
    }
    const f = h * h + l * l,
        p = u * u + c * c,
        m = h * u + l * c,
        g = (r * Math.sqrt(f)) / d,
        _ = (r * Math.sqrt(p)) / d,
        v = (g * m) / f,
        b = (_ * m) / p,
        y = g * c + _ * l,
        C = g * u + _ * h,
        w = l * (_ + v),
        A = h * (_ + v),
        E = c * (g + b),
        S = u * (g + b),
        P = Math.atan2(A - C, w - y),
        k = Math.atan2(S - C, E - y);
    uC(s, y + e, C + t, r, P, k, l * u > c * h);
}
const gh = Math.PI * 2,
    jf = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 },
    Wf = ({ x: s, y: e }, t, n, i, r, a, o, h) => {
        (s *= t), (e *= n);
        const l = i * s - r * e,
            u = r * s + i * e;
        return (h.x = l + a), (h.y = u + o), h;
    };
function f5(s, e) {
    const t =
            e === -1.5707963267948966
                ? -0.551915024494
                : 1.3333333333333333 * Math.tan(e / 4),
        n = e === 1.5707963267948966 ? 0.551915024494 : t,
        i = Math.cos(s),
        r = Math.sin(s),
        a = Math.cos(s + e),
        o = Math.sin(s + e);
    return [
        { x: i - r * n, y: r + i * n },
        { x: a + o * n, y: o - a * n },
        { x: a, y: o },
    ];
}
const Vv = (s, e, t, n) => {
        const i = s * n - e * t < 0 ? -1 : 1;
        let r = s * t + e * n;
        return r > 1 && (r = 1), r < -1 && (r = -1), i * Math.acos(r);
    },
    p5 = (s, e, t, n, i, r, a, o, h, l, u, c, d) => {
        const f = Math.pow(i, 2),
            p = Math.pow(r, 2),
            m = Math.pow(u, 2),
            g = Math.pow(c, 2);
        let _ = f * p - f * g - p * m;
        _ < 0 && (_ = 0),
            (_ /= f * g + p * m),
            (_ = Math.sqrt(_) * (a === o ? -1 : 1));
        const v = ((_ * i) / r) * c,
            b = ((_ * -r) / i) * u,
            y = l * v - h * b + (s + t) / 2,
            C = h * v + l * b + (e + n) / 2,
            w = (u - v) / i,
            A = (c - b) / r,
            E = (-u - v) / i,
            S = (-c - b) / r,
            P = Vv(1, 0, w, A);
        let k = Vv(w, A, E, S);
        o === 0 && k > 0 && (k -= gh),
            o === 1 && k < 0 && (k += gh),
            (d.centerX = y),
            (d.centerY = C),
            (d.ang1 = P),
            (d.ang2 = k);
    };
function m5(s, e, t, n, i, r, a, o = 0, h = 0, l = 0) {
    if (r === 0 || a === 0) return;
    const u = Math.sin((o * gh) / 360),
        c = Math.cos((o * gh) / 360),
        d = (c * (e - n)) / 2 + (u * (t - i)) / 2,
        f = (-u * (e - n)) / 2 + (c * (t - i)) / 2;
    if (d === 0 && f === 0) return;
    (r = Math.abs(r)), (a = Math.abs(a));
    const p = Math.pow(d, 2) / Math.pow(r, 2) + Math.pow(f, 2) / Math.pow(a, 2);
    p > 1 && ((r *= Math.sqrt(p)), (a *= Math.sqrt(p))),
        p5(e, t, n, i, r, a, h, l, u, c, d, f, jf);
    let { ang1: m, ang2: g } = jf;
    const { centerX: _, centerY: v } = jf;
    let b = Math.abs(g) / (gh / 4);
    Math.abs(1 - b) < 1e-7 && (b = 1);
    const y = Math.max(Math.ceil(b), 1);
    g /= y;
    let C = s[s.length - 2],
        w = s[s.length - 1];
    const A = { x: 0, y: 0 };
    for (let E = 0; E < y; E++) {
        const S = f5(m, g),
            { x: P, y: k } = Wf(S[0], r, a, c, u, _, v, A),
            { x: R, y: M } = Wf(S[1], r, a, c, u, _, v, A),
            { x: T, y: O } = Wf(S[2], r, a, c, u, _, v, A);
        cC(s, C, w, P, k, R, M, T, O), (C = T), (w = O), (m += g);
    }
}
function g5(s, e, t) {
    const n = (a, o) => {
            const h = o.x - a.x,
                l = o.y - a.y,
                u = Math.sqrt(h * h + l * l),
                c = h / u,
                d = l / u;
            return { len: u, nx: c, ny: d };
        },
        i = (a, o) => {
            a === 0 ? s.moveTo(o.x, o.y) : s.lineTo(o.x, o.y);
        };
    let r = e[e.length - 1];
    for (let a = 0; a < e.length; a++) {
        const o = e[a % e.length],
            h = o.radius ?? t;
        if (h <= 0) {
            i(a, o), (r = o);
            continue;
        }
        const l = e[(a + 1) % e.length],
            u = n(o, r),
            c = n(o, l);
        if (u.len < 1e-4 || c.len < 1e-4) {
            i(a, o), (r = o);
            continue;
        }
        let d = Math.asin(u.nx * c.ny - u.ny * c.nx),
            f = 1,
            p = !1;
        u.nx * c.nx - u.ny * -c.ny < 0
            ? d < 0
                ? (d = Math.PI + d)
                : ((d = Math.PI - d), (f = -1), (p = !0))
            : d > 0 && ((f = -1), (p = !0));
        const m = d / 2;
        let g,
            _ = Math.abs((Math.cos(m) * h) / Math.sin(m));
        _ > Math.min(u.len / 2, c.len / 2)
            ? ((_ = Math.min(u.len / 2, c.len / 2)),
              (g = Math.abs((_ * Math.sin(m)) / Math.cos(m))))
            : (g = h);
        const v = o.x + c.nx * _ + -c.ny * g * f,
            b = o.y + c.ny * _ + c.nx * g * f,
            y = Math.atan2(u.ny, u.nx) + (Math.PI / 2) * f,
            C = Math.atan2(c.ny, c.nx) - (Math.PI / 2) * f;
        a === 0 && s.moveTo(v + Math.cos(y) * g, b + Math.sin(y) * g),
            s.arc(v, b, g, y, C, p),
            (r = o);
    }
}
function _5(s, e, t, n) {
    const i = (o, h) => Math.sqrt((o.x - h.x) ** 2 + (o.y - h.y) ** 2),
        r = (o, h, l) => ({
            x: o.x + (h.x - o.x) * l,
            y: o.y + (h.y - o.y) * l,
        }),
        a = e.length;
    for (let o = 0; o < a; o++) {
        const h = e[(o + 1) % a],
            l = h.radius ?? t;
        if (l <= 0) {
            o === 0 ? s.moveTo(h.x, h.y) : s.lineTo(h.x, h.y);
            continue;
        }
        const u = e[o],
            c = e[(o + 2) % a],
            d = i(u, h);
        let f;
        if (d < 1e-4) f = h;
        else {
            const g = Math.min(d / 2, l);
            f = r(h, u, g / d);
        }
        const p = i(c, h);
        let m;
        if (p < 1e-4) m = h;
        else {
            const g = Math.min(p / 2, l);
            m = r(h, c, g / p);
        }
        o === 0 ? s.moveTo(f.x, f.y) : s.lineTo(f.x, f.y),
            s.quadraticCurveTo(h.x, h.y, m.x, m.y, n);
    }
}
const v5 = new Lt();
class b5 {
    constructor(e) {
        (this.shapePrimitives = []),
            (this._currentPoly = null),
            (this._bounds = new Hs()),
            (this._graphicsPath2D = e),
            (this.signed = e.checkForHoles);
    }
    moveTo(e, t) {
        return this.startPoly(e, t), this;
    }
    lineTo(e, t) {
        this._ensurePoly();
        const n = this._currentPoly.points,
            i = n[n.length - 2],
            r = n[n.length - 1];
        return (i !== e || r !== t) && n.push(e, t), this;
    }
    arc(e, t, n, i, r, a) {
        this._ensurePoly(!1);
        const o = this._currentPoly.points;
        return uC(o, e, t, n, i, r, a), this;
    }
    arcTo(e, t, n, i, r) {
        this._ensurePoly();
        const a = this._currentPoly.points;
        return d5(a, e, t, n, i, r), this;
    }
    arcToSvg(e, t, n, i, r, a, o) {
        const h = this._currentPoly.points;
        return (
            m5(
                h,
                this._currentPoly.lastX,
                this._currentPoly.lastY,
                a,
                o,
                e,
                t,
                n,
                i,
                r
            ),
            this
        );
    }
    bezierCurveTo(e, t, n, i, r, a, o) {
        this._ensurePoly();
        const h = this._currentPoly;
        return (
            cC(this._currentPoly.points, h.lastX, h.lastY, e, t, n, i, r, a, o),
            this
        );
    }
    quadraticCurveTo(e, t, n, i, r) {
        this._ensurePoly();
        const a = this._currentPoly;
        return (
            c5(this._currentPoly.points, a.lastX, a.lastY, e, t, n, i, r), this
        );
    }
    closePath() {
        return this.endPoly(!0), this;
    }
    addPath(e, t) {
        this.endPoly(),
            t && !t.isIdentity() && ((e = e.clone(!0)), e.transform(t));
        const n = this.shapePrimitives,
            i = n.length;
        for (let r = 0; r < e.instructions.length; r++) {
            const a = e.instructions[r];
            this[a.action](...a.data);
        }
        if (e.checkForHoles && n.length - i > 1) {
            let r = null;
            for (let a = i; a < n.length; a++) {
                const o = n[a];
                if (o.shape.type === "polygon") {
                    const h = o.shape,
                        l = r == null ? void 0 : r.shape;
                    l && l.containsPolygon(h)
                        ? (r.holes || (r.holes = []),
                          r.holes.push(o),
                          n.copyWithin(a, a + 1),
                          n.length--,
                          a--)
                        : (r = o);
                }
            }
        }
        return this;
    }
    finish(e = !1) {
        this.endPoly(e);
    }
    rect(e, t, n, i, r) {
        return this.drawShape(new Lt(e, t, n, i), r), this;
    }
    circle(e, t, n, i) {
        return this.drawShape(new Og(e, t, n), i), this;
    }
    poly(e, t, n) {
        const i = new ph(e);
        return (i.closePath = t), this.drawShape(i, n), this;
    }
    regularPoly(e, t, n, i, r = 0, a) {
        i = Math.max(i | 0, 3);
        const o = (-1 * Math.PI) / 2 + r,
            h = (Math.PI * 2) / i,
            l = [];
        for (let u = 0; u < i; u++) {
            const c = o - u * h;
            l.push(e + n * Math.cos(c), t + n * Math.sin(c));
        }
        return this.poly(l, !0, a), this;
    }
    roundPoly(e, t, n, i, r, a = 0, o) {
        if (((i = Math.max(i | 0, 3)), r <= 0))
            return this.regularPoly(e, t, n, i, a);
        const h = n * Math.sin(Math.PI / i) - 0.001;
        r = Math.min(r, h);
        const l = (-1 * Math.PI) / 2 + a,
            u = (Math.PI * 2) / i,
            c = ((i - 2) * Math.PI) / i / 2;
        for (let d = 0; d < i; d++) {
            const f = d * u + l,
                p = e + n * Math.cos(f),
                m = t + n * Math.sin(f),
                g = f + Math.PI + c,
                _ = f - Math.PI - c,
                v = p + r * Math.cos(g),
                b = m + r * Math.sin(g),
                y = p + r * Math.cos(_),
                C = m + r * Math.sin(_);
            d === 0 ? this.moveTo(v, b) : this.lineTo(v, b),
                this.quadraticCurveTo(p, m, y, C, o);
        }
        return this.closePath();
    }
    roundShape(e, t, n = !1, i) {
        return e.length < 3
            ? this
            : (n ? _5(this, e, t, i) : g5(this, e, t), this.closePath());
    }
    filletRect(e, t, n, i, r) {
        if (r === 0) return this.rect(e, t, n, i);
        const a = Math.min(n, i) / 2,
            o = Math.min(a, Math.max(-a, r)),
            h = e + n,
            l = t + i,
            u = o < 0 ? -o : 0,
            c = Math.abs(o);
        return this.moveTo(e, t + c)
            .arcTo(e + u, t + u, e + c, t, c)
            .lineTo(h - c, t)
            .arcTo(h - u, t + u, h, t + c, c)
            .lineTo(h, l - c)
            .arcTo(h - u, l - u, e + n - c, l, c)
            .lineTo(e + c, l)
            .arcTo(e + u, l - u, e, l - c, c)
            .closePath();
    }
    chamferRect(e, t, n, i, r, a) {
        if (r <= 0) return this.rect(e, t, n, i);
        const o = Math.min(r, Math.min(n, i) / 2),
            h = e + n,
            l = t + i,
            u = [
                e + o,
                t,
                h - o,
                t,
                h,
                t + o,
                h,
                l - o,
                h - o,
                l,
                e + o,
                l,
                e,
                l - o,
                e,
                t + o,
            ];
        for (let c = u.length - 1; c >= 2; c -= 2)
            u[c] === u[c - 2] && u[c - 1] === u[c - 3] && u.splice(c - 1, 2);
        return this.poly(u, !0, a);
    }
    ellipse(e, t, n, i, r) {
        return this.drawShape(new Bg(e, t, n, i), r), this;
    }
    roundRect(e, t, n, i, r, a) {
        return this.drawShape(new Fg(e, t, n, i, r), a), this;
    }
    drawShape(e, t) {
        return (
            this.endPoly(),
            this.shapePrimitives.push({ shape: e, transform: t }),
            this
        );
    }
    startPoly(e, t) {
        let n = this._currentPoly;
        return (
            n && this.endPoly(),
            (n = new ph()),
            n.points.push(e, t),
            (this._currentPoly = n),
            this
        );
    }
    endPoly(e = !1) {
        const t = this._currentPoly;
        return (
            t &&
                t.points.length > 2 &&
                ((t.closePath = e), this.shapePrimitives.push({ shape: t })),
            (this._currentPoly = null),
            this
        );
    }
    _ensurePoly(e = !0) {
        if (!this._currentPoly && ((this._currentPoly = new ph()), e)) {
            const t = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (t) {
                let n = t.shape.x,
                    i = t.shape.y;
                if (t.transform && !t.transform.isIdentity()) {
                    const r = t.transform,
                        a = n;
                    (n = r.a * n + r.c * i + r.tx),
                        (i = r.b * a + r.d * i + r.ty);
                }
                this._currentPoly.points.push(n, i);
            } else this._currentPoly.points.push(0, 0);
        }
    }
    buildPath() {
        const e = this._graphicsPath2D;
        (this.shapePrimitives.length = 0), (this._currentPoly = null);
        for (let t = 0; t < e.instructions.length; t++) {
            const n = e.instructions[t];
            this[n.action](...n.data);
        }
        this.finish();
    }
    get bounds() {
        const e = this._bounds;
        e.clear();
        const t = this.shapePrimitives;
        for (let n = 0; n < t.length; n++) {
            const i = t[n],
                r = i.shape.getBounds(v5);
            i.transform ? e.addRect(r, i.transform) : e.addRect(r);
        }
        return e;
    }
}
class Qi {
    constructor(e, t = !1) {
        (this.instructions = []),
            (this.uid = Pt("graphicsPath")),
            (this._dirty = !0),
            (this.checkForHoles = t),
            typeof e == "string"
                ? QM(e, this)
                : (this.instructions = (e == null ? void 0 : e.slice()) ?? []);
    }
    get shapePath() {
        return (
            this._shapePath || (this._shapePath = new b5(this)),
            this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
            this._shapePath
        );
    }
    addPath(e, t) {
        return (
            (e = e.clone()),
            this.instructions.push({ action: "addPath", data: [e, t] }),
            (this._dirty = !0),
            this
        );
    }
    arc(...e) {
        return (
            this.instructions.push({ action: "arc", data: e }),
            (this._dirty = !0),
            this
        );
    }
    arcTo(...e) {
        return (
            this.instructions.push({ action: "arcTo", data: e }),
            (this._dirty = !0),
            this
        );
    }
    arcToSvg(...e) {
        return (
            this.instructions.push({ action: "arcToSvg", data: e }),
            (this._dirty = !0),
            this
        );
    }
    bezierCurveTo(...e) {
        return (
            this.instructions.push({ action: "bezierCurveTo", data: e }),
            (this._dirty = !0),
            this
        );
    }
    bezierCurveToShort(e, t, n, i, r) {
        const a = this.instructions[this.instructions.length - 1],
            o = this.getLastPoint(gn.shared);
        let h = 0,
            l = 0;
        if (!a || a.action !== "bezierCurveTo") (h = o.x), (l = o.y);
        else {
            (h = a.data[2]), (l = a.data[3]);
            const u = o.x,
                c = o.y;
            (h = u + (u - h)), (l = c + (c - l));
        }
        return (
            this.instructions.push({
                action: "bezierCurveTo",
                data: [h, l, e, t, n, i, r],
            }),
            (this._dirty = !0),
            this
        );
    }
    closePath() {
        return (
            this.instructions.push({ action: "closePath", data: [] }),
            (this._dirty = !0),
            this
        );
    }
    ellipse(...e) {
        return (
            this.instructions.push({ action: "ellipse", data: e }),
            (this._dirty = !0),
            this
        );
    }
    lineTo(...e) {
        return (
            this.instructions.push({ action: "lineTo", data: e }),
            (this._dirty = !0),
            this
        );
    }
    moveTo(...e) {
        return this.instructions.push({ action: "moveTo", data: e }), this;
    }
    quadraticCurveTo(...e) {
        return (
            this.instructions.push({ action: "quadraticCurveTo", data: e }),
            (this._dirty = !0),
            this
        );
    }
    quadraticCurveToShort(e, t, n) {
        const i = this.instructions[this.instructions.length - 1],
            r = this.getLastPoint(gn.shared);
        let a = 0,
            o = 0;
        if (!i || i.action !== "quadraticCurveTo") (a = r.x), (o = r.y);
        else {
            (a = i.data[0]), (o = i.data[1]);
            const h = r.x,
                l = r.y;
            (a = h + (h - a)), (o = l + (l - o));
        }
        return (
            this.instructions.push({
                action: "quadraticCurveTo",
                data: [a, o, e, t, n],
            }),
            (this._dirty = !0),
            this
        );
    }
    rect(e, t, n, i, r) {
        return (
            this.instructions.push({ action: "rect", data: [e, t, n, i, r] }),
            (this._dirty = !0),
            this
        );
    }
    circle(e, t, n, i) {
        return (
            this.instructions.push({ action: "circle", data: [e, t, n, i] }),
            (this._dirty = !0),
            this
        );
    }
    roundRect(...e) {
        return (
            this.instructions.push({ action: "roundRect", data: e }),
            (this._dirty = !0),
            this
        );
    }
    poly(...e) {
        return (
            this.instructions.push({ action: "poly", data: e }),
            (this._dirty = !0),
            this
        );
    }
    regularPoly(...e) {
        return (
            this.instructions.push({ action: "regularPoly", data: e }),
            (this._dirty = !0),
            this
        );
    }
    roundPoly(...e) {
        return (
            this.instructions.push({ action: "roundPoly", data: e }),
            (this._dirty = !0),
            this
        );
    }
    roundShape(...e) {
        return (
            this.instructions.push({ action: "roundShape", data: e }),
            (this._dirty = !0),
            this
        );
    }
    filletRect(...e) {
        return (
            this.instructions.push({ action: "filletRect", data: e }),
            (this._dirty = !0),
            this
        );
    }
    chamferRect(...e) {
        return (
            this.instructions.push({ action: "chamferRect", data: e }),
            (this._dirty = !0),
            this
        );
    }
    star(e, t, n, i, r, a, o) {
        r || (r = i / 2);
        const h = (-1 * Math.PI) / 2 + a,
            l = n * 2,
            u = (Math.PI * 2) / l,
            c = [];
        for (let d = 0; d < l; d++) {
            const f = d % 2 ? r : i,
                p = d * u + h;
            c.push(e + f * Math.cos(p), t + f * Math.sin(p));
        }
        return this.poly(c, !0, o), this;
    }
    clone(e = !1) {
        const t = new Qi();
        if (((t.checkForHoles = this.checkForHoles), !e))
            t.instructions = this.instructions.slice();
        else
            for (let n = 0; n < this.instructions.length; n++) {
                const i = this.instructions[n];
                t.instructions.push({ action: i.action, data: i.data.slice() });
            }
        return t;
    }
    clear() {
        return (this.instructions.length = 0), (this._dirty = !0), this;
    }
    transform(e) {
        if (e.isIdentity()) return this;
        const t = e.a,
            n = e.b,
            i = e.c,
            r = e.d,
            a = e.tx,
            o = e.ty;
        let h = 0,
            l = 0,
            u = 0,
            c = 0,
            d = 0,
            f = 0,
            p = 0,
            m = 0;
        for (let g = 0; g < this.instructions.length; g++) {
            const _ = this.instructions[g],
                v = _.data;
            switch (_.action) {
                case "moveTo":
                case "lineTo":
                    (h = v[0]),
                        (l = v[1]),
                        (v[0] = t * h + i * l + a),
                        (v[1] = n * h + r * l + o);
                    break;
                case "bezierCurveTo":
                    (u = v[0]),
                        (c = v[1]),
                        (d = v[2]),
                        (f = v[3]),
                        (h = v[4]),
                        (l = v[5]),
                        (v[0] = t * u + i * c + a),
                        (v[1] = n * u + r * c + o),
                        (v[2] = t * d + i * f + a),
                        (v[3] = n * d + r * f + o),
                        (v[4] = t * h + i * l + a),
                        (v[5] = n * h + r * l + o);
                    break;
                case "quadraticCurveTo":
                    (u = v[0]),
                        (c = v[1]),
                        (h = v[2]),
                        (l = v[3]),
                        (v[0] = t * u + i * c + a),
                        (v[1] = n * u + r * c + o),
                        (v[2] = t * h + i * l + a),
                        (v[3] = n * h + r * l + o);
                    break;
                case "arcToSvg":
                    (h = v[5]),
                        (l = v[6]),
                        (p = v[0]),
                        (m = v[1]),
                        (v[0] = t * p + i * m),
                        (v[1] = n * p + r * m),
                        (v[5] = t * h + i * l + a),
                        (v[6] = n * h + r * l + o);
                    break;
                case "circle":
                    v[4] = Fl(v[3], e);
                    break;
                case "rect":
                    v[4] = Fl(v[4], e);
                    break;
                case "ellipse":
                    v[8] = Fl(v[8], e);
                    break;
                case "roundRect":
                    v[5] = Fl(v[5], e);
                    break;
                case "addPath":
                    v[0].transform(e);
                    break;
                case "poly":
                    v[2] = Fl(v[2], e);
                    break;
                default:
                    it("unknown transform action", _.action);
                    break;
            }
        }
        return (this._dirty = !0), this;
    }
    get bounds() {
        return this.shapePath.bounds;
    }
    getLastPoint(e) {
        let t = this.instructions.length - 1,
            n = this.instructions[t];
        if (!n) return (e.x = 0), (e.y = 0), e;
        for (; n.action === "closePath"; ) {
            if ((t--, t < 0)) return (e.x = 0), (e.y = 0), e;
            n = this.instructions[t];
        }
        switch (n.action) {
            case "moveTo":
            case "lineTo":
                (e.x = n.data[0]), (e.y = n.data[1]);
                break;
            case "quadraticCurveTo":
                (e.x = n.data[2]), (e.y = n.data[3]);
                break;
            case "bezierCurveTo":
                (e.x = n.data[4]), (e.y = n.data[5]);
                break;
            case "arc":
            case "arcToSvg":
                (e.x = n.data[5]), (e.y = n.data[6]);
                break;
            case "addPath":
                n.data[0].getLastPoint(e);
                break;
        }
        return e;
    }
}
function Fl(s, e) {
    return s ? s.prepend(e) : e.clone();
}
function St(s, e, t) {
    const n = s.getAttribute(e);
    return n ? Number(n) : t;
}
function y5(s, e) {
    const t = s.querySelectorAll("defs");
    for (let n = 0; n < t.length; n++) {
        const i = t[n];
        for (let r = 0; r < i.children.length; r++) {
            const a = i.children[r];
            switch (a.nodeName.toLowerCase()) {
                case "lineargradient":
                    e.defs[a.id] = w5(a);
                    break;
                case "radialgradient":
                    e.defs[a.id] = x5();
                    break;
            }
        }
    }
}
function w5(s) {
    const e = St(s, "x1", 0),
        t = St(s, "y1", 0),
        n = St(s, "x2", 1),
        i = St(s, "y2", 0),
        r = s.getAttribute("gradientUnits") || "objectBoundingBox",
        a = new rr(e, t, n, i, r === "objectBoundingBox" ? "local" : "global");
    for (let o = 0; o < s.children.length; o++) {
        const h = s.children[o],
            l = St(h, "offset", 0),
            u = Vt.shared.setValue(h.getAttribute("stop-color")).toNumber();
        a.addColorStop(l, u);
    }
    return a;
}
function x5(s) {
    return (
        it("[SVG Parser] Radial gradients are not yet supported"),
        new rr(0, 0, 1, 0)
    );
}
function Uv(s) {
    const e = s.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : "";
}
const zv = {
    fill: { type: "paint", default: 0 },
    "fill-opacity": { type: "number", default: 1 },
    stroke: { type: "paint", default: 0 },
    "stroke-width": { type: "number", default: 1 },
    "stroke-opacity": { type: "number", default: 1 },
    "stroke-linecap": { type: "string", default: "butt" },
    "stroke-linejoin": { type: "string", default: "miter" },
    "stroke-miterlimit": { type: "number", default: 10 },
    "stroke-dasharray": { type: "string", default: "none" },
    "stroke-dashoffset": { type: "number", default: 0 },
    opacity: { type: "number", default: 1 },
};
function dC(s, e) {
    const t = s.getAttribute("style"),
        n = {},
        i = {},
        r = { strokeStyle: n, fillStyle: i, useFill: !1, useStroke: !1 };
    for (const a in zv) {
        const o = s.getAttribute(a);
        o && Yv(e, r, a, o.trim());
    }
    if (t) {
        const a = t.split(";");
        for (let o = 0; o < a.length; o++) {
            const h = a[o].trim(),
                [l, u] = h.split(":");
            zv[l] && Yv(e, r, l, u.trim());
        }
    }
    return {
        strokeStyle: r.useStroke ? n : null,
        fillStyle: r.useFill ? i : null,
        useFill: r.useFill,
        useStroke: r.useStroke,
    };
}
function Yv(s, e, t, n) {
    switch (t) {
        case "stroke":
            if (n !== "none") {
                if (n.startsWith("url(")) {
                    const i = Uv(n);
                    e.strokeStyle.fill = s.defs[i];
                } else e.strokeStyle.color = Vt.shared.setValue(n).toNumber();
                e.useStroke = !0;
            }
            break;
        case "stroke-width":
            e.strokeStyle.width = Number(n);
            break;
        case "fill":
            if (n !== "none") {
                if (n.startsWith("url(")) {
                    const i = Uv(n);
                    e.fillStyle.fill = s.defs[i];
                } else e.fillStyle.color = Vt.shared.setValue(n).toNumber();
                e.useFill = !0;
            }
            break;
        case "fill-opacity":
            e.fillStyle.alpha = Number(n);
            break;
        case "stroke-opacity":
            e.strokeStyle.alpha = Number(n);
            break;
        case "opacity":
            (e.fillStyle.alpha = Number(n)), (e.strokeStyle.alpha = Number(n));
            break;
    }
}
function C5(s) {
    if (s.length <= 2) return !0;
    const e = s.map((o) => o.area).sort((o, h) => h - o),
        [t, n] = e,
        i = e[e.length - 1],
        r = t / n,
        a = n / i;
    return !(r > 3 && a < 2);
}
function A5(s) {
    return s.split(/(?=[Mm])/).filter((n) => n.trim().length > 0);
}
function S5(s) {
    const e = s.match(/[-+]?[0-9]*\.?[0-9]+/g);
    if (!e || e.length < 4) return 0;
    const t = e.map(Number),
        n = [],
        i = [];
    for (let u = 0; u < t.length; u += 2)
        u + 1 < t.length && (n.push(t[u]), i.push(t[u + 1]));
    if (n.length === 0 || i.length === 0) return 0;
    const r = Math.min(...n),
        a = Math.max(...n),
        o = Math.min(...i),
        h = Math.max(...i);
    return (a - r) * (h - o);
}
function Gv(s, e) {
    const t = new Qi(s, !1);
    for (const n of t.instructions) e.instructions.push(n);
}
function E5(s, e) {
    if (typeof s == "string") {
        const a = document.createElement("div");
        (a.innerHTML = s.trim()), (s = a.querySelector("svg"));
    }
    const t = { context: e, defs: {}, path: new Qi() };
    y5(s, t);
    const n = s.children,
        { fillStyle: i, strokeStyle: r } = dC(s, t);
    for (let a = 0; a < n.length; a++) {
        const o = n[a];
        o.nodeName.toLowerCase() !== "defs" && fC(o, t, i, r);
    }
    return e;
}
function fC(s, e, t, n) {
    const i = s.children,
        { fillStyle: r, strokeStyle: a } = dC(s, e);
    r && t ? (t = { ...t, ...r }) : r && (t = r),
        a && n ? (n = { ...n, ...a }) : a && (n = a);
    const o = !t && !n;
    o && (t = { color: 0 });
    let h, l, u, c, d, f, p, m, g, _, v, b, y, C, w, A, E;
    switch (s.nodeName.toLowerCase()) {
        case "path": {
            C = s.getAttribute("d");
            const S = s.getAttribute("fill-rule"),
                P = A5(C),
                k = S === "evenodd",
                R = P.length > 1;
            if (k && R) {
                const T = P.map((L) => ({ path: L, area: S5(L) }));
                if ((T.sort((L, F) => F.area - L.area), P.length > 3 || !C5(T)))
                    for (let L = 0; L < T.length; L++) {
                        const F = T[L],
                            Y = L === 0;
                        e.context.beginPath();
                        const V = new Qi(void 0, !0);
                        Gv(F.path, V),
                            e.context.path(V),
                            Y
                                ? (t && e.context.fill(t),
                                  n && e.context.stroke(n))
                                : e.context.cut();
                    }
                else
                    for (let L = 0; L < T.length; L++) {
                        const F = T[L],
                            Y = L % 2 === 1;
                        e.context.beginPath();
                        const V = new Qi(void 0, !0);
                        Gv(F.path, V),
                            e.context.path(V),
                            Y
                                ? e.context.cut()
                                : (t && e.context.fill(t),
                                  n && e.context.stroke(n));
                    }
            } else {
                const T = S ? S === "evenodd" : !0;
                (w = new Qi(C, T)),
                    e.context.path(w),
                    t && e.context.fill(t),
                    n && e.context.stroke(n);
            }
            break;
        }
        case "circle":
            (p = St(s, "cx", 0)),
                (m = St(s, "cy", 0)),
                (g = St(s, "r", 0)),
                e.context.ellipse(p, m, g, g),
                t && e.context.fill(t),
                n && e.context.stroke(n);
            break;
        case "rect":
            (h = St(s, "x", 0)),
                (l = St(s, "y", 0)),
                (A = St(s, "width", 0)),
                (E = St(s, "height", 0)),
                (_ = St(s, "rx", 0)),
                (v = St(s, "ry", 0)),
                _ || v
                    ? e.context.roundRect(h, l, A, E, _ || v)
                    : e.context.rect(h, l, A, E),
                t && e.context.fill(t),
                n && e.context.stroke(n);
            break;
        case "ellipse":
            (p = St(s, "cx", 0)),
                (m = St(s, "cy", 0)),
                (_ = St(s, "rx", 0)),
                (v = St(s, "ry", 0)),
                e.context.beginPath(),
                e.context.ellipse(p, m, _, v),
                t && e.context.fill(t),
                n && e.context.stroke(n);
            break;
        case "line":
            (u = St(s, "x1", 0)),
                (c = St(s, "y1", 0)),
                (d = St(s, "x2", 0)),
                (f = St(s, "y2", 0)),
                e.context.beginPath(),
                e.context.moveTo(u, c),
                e.context.lineTo(d, f),
                n && e.context.stroke(n);
            break;
        case "polygon":
            (y = s.getAttribute("points")),
                (b = y.match(/\d+/g).map((S) => parseInt(S, 10))),
                e.context.poly(b, !0),
                t && e.context.fill(t),
                n && e.context.stroke(n);
            break;
        case "polyline":
            (y = s.getAttribute("points")),
                (b = y.match(/\d+/g).map((S) => parseInt(S, 10))),
                e.context.poly(b, !1),
                n && e.context.stroke(n);
            break;
        case "g":
        case "svg":
            break;
        default: {
            it(`[SVG parser] <${s.nodeName}> elements unsupported`);
            break;
        }
    }
    o && (t = null);
    for (let S = 0; S < i.length; S++) fC(i[S], e, t, n);
}
function P5(s) {
    return Vt.isColorLike(s);
}
function jv(s) {
    return s instanceof Ed;
}
function Wv(s) {
    return s instanceof rr;
}
function k5(s) {
    return s instanceof we;
}
function T5(s, e, t) {
    const n = Vt.shared.setValue(e ?? 0);
    return (
        (s.color = n.toNumber()),
        (s.alpha = n.alpha === 1 ? t.alpha : n.alpha),
        (s.texture = we.WHITE),
        { ...t, ...s }
    );
}
function M5(s, e, t) {
    return (s.texture = e), { ...t, ...s };
}
function Xv(s, e, t) {
    return (
        (s.fill = e),
        (s.color = 16777215),
        (s.texture = e.texture),
        (s.matrix = e.transform),
        { ...t, ...s }
    );
}
function qv(s, e, t) {
    return (
        e.buildGradient(),
        (s.fill = e),
        (s.color = 16777215),
        (s.texture = e.texture),
        (s.matrix = e.transform),
        (s.textureSpace = e.textureSpace),
        { ...t, ...s }
    );
}
function I5(s, e) {
    const t = { ...e, ...s },
        n = Vt.shared.setValue(t.color);
    return (t.alpha *= n.alpha), (t.color = n.toNumber()), t;
}
function pa(s, e) {
    if (s == null) return null;
    const t = {},
        n = s;
    return P5(s)
        ? T5(t, s, e)
        : k5(s)
        ? M5(t, s, e)
        : jv(s)
        ? Xv(t, s, e)
        : Wv(s)
        ? qv(t, s, e)
        : n.fill && jv(n.fill)
        ? Xv(n, n.fill, e)
        : n.fill && Wv(n.fill)
        ? qv(n, n.fill, e)
        : I5(n, e);
}
function Lu(s, e) {
    const {
            width: t,
            alignment: n,
            miterLimit: i,
            cap: r,
            join: a,
            pixelLine: o,
            ...h
        } = e,
        l = pa(s, h);
    return l
        ? {
              width: t,
              alignment: n,
              miterLimit: i,
              cap: r,
              join: a,
              pixelLine: o,
              ...l,
          }
        : null;
}
const R5 = new gn(),
    Hv = new Ce(),
    Dg = class hi extends ti {
        constructor() {
            super(...arguments),
                (this.uid = Pt("graphicsContext")),
                (this.dirty = !0),
                (this.batchMode = "auto"),
                (this.instructions = []),
                (this._activePath = new Qi()),
                (this._transform = new Ce()),
                (this._fillStyle = { ...hi.defaultFillStyle }),
                (this._strokeStyle = { ...hi.defaultStrokeStyle }),
                (this._stateStack = []),
                (this._tick = 0),
                (this._bounds = new Hs()),
                (this._boundsDirty = !0);
        }
        clone() {
            const e = new hi();
            return (
                (e.batchMode = this.batchMode),
                (e.instructions = this.instructions.slice()),
                (e._activePath = this._activePath.clone()),
                (e._transform = this._transform.clone()),
                (e._fillStyle = { ...this._fillStyle }),
                (e._strokeStyle = { ...this._strokeStyle }),
                (e._stateStack = this._stateStack.slice()),
                (e._bounds = this._bounds.clone()),
                (e._boundsDirty = !0),
                e
            );
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set fillStyle(e) {
            this._fillStyle = pa(e, hi.defaultFillStyle);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        set strokeStyle(e) {
            this._strokeStyle = Lu(e, hi.defaultStrokeStyle);
        }
        setFillStyle(e) {
            return (this._fillStyle = pa(e, hi.defaultFillStyle)), this;
        }
        setStrokeStyle(e) {
            return (this._strokeStyle = pa(e, hi.defaultStrokeStyle)), this;
        }
        texture(e, t, n, i, r, a) {
            return (
                this.instructions.push({
                    action: "texture",
                    data: {
                        image: e,
                        dx: n || 0,
                        dy: i || 0,
                        dw: r || e.frame.width,
                        dh: a || e.frame.height,
                        transform: this._transform.clone(),
                        alpha: this._fillStyle.alpha,
                        style: t ? Vt.shared.setValue(t).toNumber() : 16777215,
                    },
                }),
                this.onUpdate(),
                this
            );
        }
        beginPath() {
            return (this._activePath = new Qi()), this;
        }
        fill(e, t) {
            let n;
            const i = this.instructions[this.instructions.length - 1];
            return (
                this._tick === 0 && i && i.action === "stroke"
                    ? (n = i.data.path)
                    : (n = this._activePath.clone()),
                n
                    ? (e != null &&
                          (t !== void 0 &&
                              typeof e == "number" &&
                              (ae(
                                  Ge,
                                  "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"
                              ),
                              (e = { color: e, alpha: t })),
                          (this._fillStyle = pa(e, hi.defaultFillStyle))),
                      this.instructions.push({
                          action: "fill",
                          data: { style: this.fillStyle, path: n },
                      }),
                      this.onUpdate(),
                      this._initNextPathLocation(),
                      (this._tick = 0),
                      this)
                    : this
            );
        }
        _initNextPathLocation() {
            const { x: e, y: t } = this._activePath.getLastPoint(gn.shared);
            this._activePath.clear(), this._activePath.moveTo(e, t);
        }
        stroke(e) {
            let t;
            const n = this.instructions[this.instructions.length - 1];
            return (
                this._tick === 0 && n && n.action === "fill"
                    ? (t = n.data.path)
                    : (t = this._activePath.clone()),
                t
                    ? (e != null &&
                          (this._strokeStyle = Lu(e, hi.defaultStrokeStyle)),
                      this.instructions.push({
                          action: "stroke",
                          data: { style: this.strokeStyle, path: t },
                      }),
                      this.onUpdate(),
                      this._initNextPathLocation(),
                      (this._tick = 0),
                      this)
                    : this
            );
        }
        cut() {
            for (let e = 0; e < 2; e++) {
                const t = this.instructions[this.instructions.length - 1 - e],
                    n = this._activePath.clone();
                if (t && (t.action === "stroke" || t.action === "fill"))
                    if (t.data.hole) t.data.hole.addPath(n);
                    else {
                        t.data.hole = n;
                        break;
                    }
            }
            return this._initNextPathLocation(), this;
        }
        arc(e, t, n, i, r, a) {
            this._tick++;
            const o = this._transform;
            return (
                this._activePath.arc(
                    o.a * e + o.c * t + o.tx,
                    o.b * e + o.d * t + o.ty,
                    n,
                    i,
                    r,
                    a
                ),
                this
            );
        }
        arcTo(e, t, n, i, r) {
            this._tick++;
            const a = this._transform;
            return (
                this._activePath.arcTo(
                    a.a * e + a.c * t + a.tx,
                    a.b * e + a.d * t + a.ty,
                    a.a * n + a.c * i + a.tx,
                    a.b * n + a.d * i + a.ty,
                    r
                ),
                this
            );
        }
        arcToSvg(e, t, n, i, r, a, o) {
            this._tick++;
            const h = this._transform;
            return (
                this._activePath.arcToSvg(
                    e,
                    t,
                    n,
                    i,
                    r,
                    h.a * a + h.c * o + h.tx,
                    h.b * a + h.d * o + h.ty
                ),
                this
            );
        }
        bezierCurveTo(e, t, n, i, r, a, o) {
            this._tick++;
            const h = this._transform;
            return (
                this._activePath.bezierCurveTo(
                    h.a * e + h.c * t + h.tx,
                    h.b * e + h.d * t + h.ty,
                    h.a * n + h.c * i + h.tx,
                    h.b * n + h.d * i + h.ty,
                    h.a * r + h.c * a + h.tx,
                    h.b * r + h.d * a + h.ty,
                    o
                ),
                this
            );
        }
        closePath() {
            var e;
            return (
                this._tick++,
                (e = this._activePath) == null || e.closePath(),
                this
            );
        }
        ellipse(e, t, n, i) {
            return (
                this._tick++,
                this._activePath.ellipse(e, t, n, i, this._transform.clone()),
                this
            );
        }
        circle(e, t, n) {
            return (
                this._tick++,
                this._activePath.circle(e, t, n, this._transform.clone()),
                this
            );
        }
        path(e) {
            return (
                this._tick++,
                this._activePath.addPath(e, this._transform.clone()),
                this
            );
        }
        lineTo(e, t) {
            this._tick++;
            const n = this._transform;
            return (
                this._activePath.lineTo(
                    n.a * e + n.c * t + n.tx,
                    n.b * e + n.d * t + n.ty
                ),
                this
            );
        }
        moveTo(e, t) {
            this._tick++;
            const n = this._transform,
                i = this._activePath.instructions,
                r = n.a * e + n.c * t + n.tx,
                a = n.b * e + n.d * t + n.ty;
            return i.length === 1 && i[0].action === "moveTo"
                ? ((i[0].data[0] = r), (i[0].data[1] = a), this)
                : (this._activePath.moveTo(r, a), this);
        }
        quadraticCurveTo(e, t, n, i, r) {
            this._tick++;
            const a = this._transform;
            return (
                this._activePath.quadraticCurveTo(
                    a.a * e + a.c * t + a.tx,
                    a.b * e + a.d * t + a.ty,
                    a.a * n + a.c * i + a.tx,
                    a.b * n + a.d * i + a.ty,
                    r
                ),
                this
            );
        }
        rect(e, t, n, i) {
            return (
                this._tick++,
                this._activePath.rect(e, t, n, i, this._transform.clone()),
                this
            );
        }
        roundRect(e, t, n, i, r) {
            return (
                this._tick++,
                this._activePath.roundRect(
                    e,
                    t,
                    n,
                    i,
                    r,
                    this._transform.clone()
                ),
                this
            );
        }
        poly(e, t) {
            return (
                this._tick++,
                this._activePath.poly(e, t, this._transform.clone()),
                this
            );
        }
        regularPoly(e, t, n, i, r = 0, a) {
            return (
                this._tick++,
                this._activePath.regularPoly(e, t, n, i, r, a),
                this
            );
        }
        roundPoly(e, t, n, i, r, a) {
            return (
                this._tick++, this._activePath.roundPoly(e, t, n, i, r, a), this
            );
        }
        roundShape(e, t, n, i) {
            return this._tick++, this._activePath.roundShape(e, t, n, i), this;
        }
        filletRect(e, t, n, i, r) {
            return (
                this._tick++, this._activePath.filletRect(e, t, n, i, r), this
            );
        }
        chamferRect(e, t, n, i, r, a) {
            return (
                this._tick++,
                this._activePath.chamferRect(e, t, n, i, r, a),
                this
            );
        }
        star(e, t, n, i, r = 0, a = 0) {
            return (
                this._tick++,
                this._activePath.star(
                    e,
                    t,
                    n,
                    i,
                    r,
                    a,
                    this._transform.clone()
                ),
                this
            );
        }
        svg(e) {
            return this._tick++, E5(e, this), this;
        }
        restore() {
            const e = this._stateStack.pop();
            return (
                e &&
                    ((this._transform = e.transform),
                    (this._fillStyle = e.fillStyle),
                    (this._strokeStyle = e.strokeStyle)),
                this
            );
        }
        save() {
            return (
                this._stateStack.push({
                    transform: this._transform.clone(),
                    fillStyle: { ...this._fillStyle },
                    strokeStyle: { ...this._strokeStyle },
                }),
                this
            );
        }
        getTransform() {
            return this._transform;
        }
        resetTransform() {
            return this._transform.identity(), this;
        }
        rotate(e) {
            return this._transform.rotate(e), this;
        }
        scale(e, t = e) {
            return this._transform.scale(e, t), this;
        }
        setTransform(e, t, n, i, r, a) {
            return e instanceof Ce
                ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this)
                : (this._transform.set(e, t, n, i, r, a), this);
        }
        transform(e, t, n, i, r, a) {
            return e instanceof Ce
                ? (this._transform.append(e), this)
                : (Hv.set(e, t, n, i, r, a), this._transform.append(Hv), this);
        }
        translate(e, t = e) {
            return this._transform.translate(e, t), this;
        }
        clear() {
            return (
                this._activePath.clear(),
                (this.instructions.length = 0),
                this.resetTransform(),
                this.onUpdate(),
                this
            );
        }
        onUpdate() {
            (this._boundsDirty = !0),
                !this.dirty &&
                    (this.emit("update", this, 16), (this.dirty = !0));
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            this._boundsDirty = !1;
            const e = this._bounds;
            e.clear();
            for (let t = 0; t < this.instructions.length; t++) {
                const n = this.instructions[t],
                    i = n.action;
                if (i === "fill") {
                    const r = n.data;
                    e.addBounds(r.path.bounds);
                } else if (i === "texture") {
                    const r = n.data;
                    e.addFrame(
                        r.dx,
                        r.dy,
                        r.dx + r.dw,
                        r.dy + r.dh,
                        r.transform
                    );
                }
                if (i === "stroke") {
                    const r = n.data,
                        a = r.style.alignment,
                        o = r.style.width * (1 - a),
                        h = r.path.bounds;
                    e.addFrame(h.minX - o, h.minY - o, h.maxX + o, h.maxY + o);
                }
            }
            return e;
        }
        containsPoint(e) {
            var i;
            if (!this.bounds.containsPoint(e.x, e.y)) return !1;
            const t = this.instructions;
            let n = !1;
            for (let r = 0; r < t.length; r++) {
                const a = t[r],
                    o = a.data,
                    h = o.path;
                if (!a.action || !h) continue;
                const l = o.style,
                    u = h.shapePath.shapePrimitives;
                for (let c = 0; c < u.length; c++) {
                    const d = u[c].shape;
                    if (!l || !d) continue;
                    const f = u[c].transform,
                        p = f ? f.applyInverse(e, R5) : e;
                    if (a.action === "fill") n = d.contains(p.x, p.y);
                    else {
                        const g = l;
                        n = d.strokeContains(p.x, p.y, g.width, g.alignment);
                    }
                    const m = o.hole;
                    if (m) {
                        const g =
                            (i = m.shapePath) == null
                                ? void 0
                                : i.shapePrimitives;
                        if (g)
                            for (let _ = 0; _ < g.length; _++)
                                g[_].shape.contains(p.x, p.y) && (n = !1);
                    }
                    if (n) return !0;
                }
            }
            return n;
        }
        destroy(e = !1) {
            if (
                ((this._stateStack.length = 0),
                (this._transform = null),
                this.emit("destroy", this),
                this.removeAllListeners(),
                typeof e == "boolean" ? e : e == null ? void 0 : e.texture)
            ) {
                const n =
                    typeof e == "boolean"
                        ? e
                        : e == null
                        ? void 0
                        : e.textureSource;
                this._fillStyle.texture &&
                    (this._fillStyle.fill && "uid" in this._fillStyle.fill
                        ? this._fillStyle.fill.destroy()
                        : this._fillStyle.texture.destroy(n)),
                    this._strokeStyle.texture &&
                        (this._strokeStyle.fill &&
                        "uid" in this._strokeStyle.fill
                            ? this._strokeStyle.fill.destroy()
                            : this._strokeStyle.texture.destroy(n));
            }
            (this._fillStyle = null),
                (this._strokeStyle = null),
                (this.instructions = null),
                (this._activePath = null),
                (this._bounds = null),
                (this._stateStack = null),
                (this.customShader = null),
                (this._transform = null);
        }
    };
Dg.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
};
Dg.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: !1,
};
let xs = Dg;
const Ng = class _o extends ti {
    constructor(e = {}) {
        super(), (this.uid = Pt("textStyle")), (this._tick = 0), L5(e);
        const t = { ..._o.defaultTextStyle, ...e };
        for (const n in t) {
            const i = n;
            this[i] = t[n];
        }
        this.update(), (this._tick = 0);
    }
    get align() {
        return this._align;
    }
    set align(e) {
        (this._align = e), this.update();
    }
    get breakWords() {
        return this._breakWords;
    }
    set breakWords(e) {
        (this._breakWords = e), this.update();
    }
    get dropShadow() {
        return this._dropShadow;
    }
    set dropShadow(e) {
        e !== null && typeof e == "object"
            ? (this._dropShadow = this._createProxy({
                  ..._o.defaultDropShadow,
                  ...e,
              }))
            : (this._dropShadow = e
                  ? this._createProxy({ ..._o.defaultDropShadow })
                  : null),
            this.update();
    }
    get fontFamily() {
        return this._fontFamily;
    }
    set fontFamily(e) {
        (this._fontFamily = e), this.update();
    }
    get fontSize() {
        return this._fontSize;
    }
    set fontSize(e) {
        typeof e == "string"
            ? (this._fontSize = parseInt(e, 10))
            : (this._fontSize = e),
            this.update();
    }
    get fontStyle() {
        return this._fontStyle;
    }
    set fontStyle(e) {
        (this._fontStyle = e.toLowerCase()), this.update();
    }
    get fontVariant() {
        return this._fontVariant;
    }
    set fontVariant(e) {
        (this._fontVariant = e), this.update();
    }
    get fontWeight() {
        return this._fontWeight;
    }
    set fontWeight(e) {
        (this._fontWeight = e), this.update();
    }
    get leading() {
        return this._leading;
    }
    set leading(e) {
        (this._leading = e), this.update();
    }
    get letterSpacing() {
        return this._letterSpacing;
    }
    set letterSpacing(e) {
        (this._letterSpacing = e), this.update();
    }
    get lineHeight() {
        return this._lineHeight;
    }
    set lineHeight(e) {
        (this._lineHeight = e), this.update();
    }
    get padding() {
        return this._padding;
    }
    set padding(e) {
        (this._padding = e), this.update();
    }
    get filters() {
        return this._filters;
    }
    set filters(e) {
        (this._filters = Object.freeze(e)), this.update();
    }
    get trim() {
        return this._trim;
    }
    set trim(e) {
        (this._trim = e), this.update();
    }
    get textBaseline() {
        return this._textBaseline;
    }
    set textBaseline(e) {
        (this._textBaseline = e), this.update();
    }
    get whiteSpace() {
        return this._whiteSpace;
    }
    set whiteSpace(e) {
        (this._whiteSpace = e), this.update();
    }
    get wordWrap() {
        return this._wordWrap;
    }
    set wordWrap(e) {
        (this._wordWrap = e), this.update();
    }
    get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
        (this._wordWrapWidth = e), this.update();
    }
    get fill() {
        return this._originalFill;
    }
    set fill(e) {
        e !== this._originalFill &&
            ((this._originalFill = e),
            this._isFillStyle(e) &&
                (this._originalFill = this._createProxy(
                    { ...xs.defaultFillStyle, ...e },
                    () => {
                        this._fill = pa(
                            { ...this._originalFill },
                            xs.defaultFillStyle
                        );
                    }
                )),
            (this._fill = pa(e === 0 ? "black" : e, xs.defaultFillStyle)),
            this.update());
    }
    get stroke() {
        return this._originalStroke;
    }
    set stroke(e) {
        e !== this._originalStroke &&
            ((this._originalStroke = e),
            this._isFillStyle(e) &&
                (this._originalStroke = this._createProxy(
                    { ...xs.defaultStrokeStyle, ...e },
                    () => {
                        this._stroke = Lu(
                            { ...this._originalStroke },
                            xs.defaultStrokeStyle
                        );
                    }
                )),
            (this._stroke = Lu(e, xs.defaultStrokeStyle)),
            this.update());
    }
    update() {
        this._tick++, this.emit("update", this);
    }
    reset() {
        const e = _o.defaultTextStyle;
        for (const t in e) this[t] = e[t];
    }
    get styleKey() {
        return `${this.uid}-${this._tick}`;
    }
    clone() {
        return new _o({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            filters: this._filters ? [...this._filters] : void 0,
        });
    }
    _getFinalPadding() {
        let e = 0;
        if (this._filters)
            for (let t = 0; t < this._filters.length; t++)
                e += this._filters[t].padding;
        return Math.max(this._padding, e);
    }
    destroy(e = !1) {
        var n, i, r, a;
        if (
            (this.removeAllListeners(),
            typeof e == "boolean" ? e : e == null ? void 0 : e.texture)
        ) {
            const o =
                typeof e == "boolean"
                    ? e
                    : e == null
                    ? void 0
                    : e.textureSource;
            (n = this._fill) != null &&
                n.texture &&
                this._fill.texture.destroy(o),
                (i = this._originalFill) != null &&
                    i.texture &&
                    this._originalFill.texture.destroy(o),
                (r = this._stroke) != null &&
                    r.texture &&
                    this._stroke.texture.destroy(o),
                (a = this._originalStroke) != null &&
                    a.texture &&
                    this._originalStroke.texture.destroy(o);
        }
        (this._fill = null),
            (this._stroke = null),
            (this.dropShadow = null),
            (this._originalStroke = null),
            (this._originalFill = null);
    }
    _createProxy(e, t) {
        return new Proxy(e, {
            set: (n, i, r) => (
                (n[i] = r), t == null || t(i, r), this.update(), !0
            ),
        });
    }
    _isFillStyle(e) {
        return (
            (e ?? null) !== null &&
            !(Vt.isColorLike(e) || e instanceof rr || e instanceof Ed)
        );
    }
};
Ng.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5,
};
Ng.defaultTextStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100,
};
let Uh = Ng;
function L5(s) {
    const e = s;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
        const t = Uh.defaultDropShadow;
        s.dropShadow = {
            alpha: e.dropShadowAlpha ?? t.alpha,
            angle: e.dropShadowAngle ?? t.angle,
            blur: e.dropShadowBlur ?? t.blur,
            color: e.dropShadowColor ?? t.color,
            distance: e.dropShadowDistance ?? t.distance,
        };
    }
    if (e.strokeThickness !== void 0) {
        ae(Ge, "strokeThickness is now a part of stroke");
        const t = e.stroke;
        let n = {};
        if (Vt.isColorLike(t)) n.color = t;
        else if (t instanceof rr || t instanceof Ed) n.fill = t;
        else if (
            Object.hasOwnProperty.call(t, "color") ||
            Object.hasOwnProperty.call(t, "fill")
        )
            n = t;
        else throw new Error("Invalid stroke value.");
        s.stroke = { ...n, width: e.strokeThickness };
    }
    if (Array.isArray(e.fillGradientStops)) {
        if (
            (ae(
                Ge,
                "gradient fill is now a fill pattern: `new FillGradient(...)`"
            ),
            !Array.isArray(e.fill) || e.fill.length === 0)
        )
            throw new Error(
                "Invalid fill value. Expected an array of colors for gradient fill."
            );
        e.fill.length !== e.fillGradientStops.length &&
            it(
                "The number of fill colors must match the number of fill gradient stops."
            );
        const t = new rr({
                start: { x: 0, y: 0 },
                end: { x: 0, y: 1 },
                textureSpace: "local",
            }),
            n = e.fillGradientStops.slice(),
            i = e.fill.map((r) => Vt.shared.setValue(r).toNumber());
        n.forEach((r, a) => {
            t.addColorStop(r, i[a]);
        }),
            (s.fill = { fill: t });
    }
}
class O5 {
    constructor(e) {
        (this._canvasPool = Object.create(null)),
            (this.canvasOptions = e || {}),
            (this.enableFullScreen = !1);
    }
    _createCanvasAndContext(e, t) {
        const n = rt.get().createCanvas();
        (n.width = e), (n.height = t);
        const i = n.getContext("2d");
        return { canvas: n, context: i };
    }
    getOptimalCanvasAndContext(e, t, n = 1) {
        (e = Math.ceil(e * n - 1e-6)),
            (t = Math.ceil(t * n - 1e-6)),
            (e = ku(e)),
            (t = ku(t));
        const i = (e << 17) + (t << 1);
        this._canvasPool[i] || (this._canvasPool[i] = []);
        let r = this._canvasPool[i].pop();
        return r || (r = this._createCanvasAndContext(e, t)), r;
    }
    returnCanvasAndContext(e) {
        const t = e.canvas,
            { width: n, height: i } = t,
            r = (n << 17) + (i << 1);
        e.context.resetTransform(),
            e.context.clearRect(0, 0, n, i),
            this._canvasPool[r].push(e);
    }
    clear() {
        this._canvasPool = {};
    }
}
const bm = new O5();
cc.register(bm);
const Kv = 1e5;
function Zv(s, e, t, n = 0) {
    if (s.texture === we.WHITE && !s.fill)
        return Vt.shared
            .setValue(s.color)
            .setAlpha(s.alpha ?? 1)
            .toHexa();
    if (s.fill) {
        if (s.fill instanceof Ed) {
            const i = s.fill,
                r = e.createPattern(i.texture.source.resource, "repeat"),
                a = i.transform.copyTo(Ce.shared);
            return (
                a.scale(i.texture.frame.width, i.texture.frame.height),
                r.setTransform(a),
                r
            );
        } else if (s.fill instanceof rr) {
            const i = s.fill,
                r = i.type === "linear",
                a = i.textureSpace === "local";
            let o = 1,
                h = 1;
            a && t && ((o = t.width + n), (h = t.height + n));
            let l,
                u = !1;
            if (r) {
                const { start: c, end: d } = i;
                (l = e.createLinearGradient(
                    c.x * o,
                    c.y * h,
                    d.x * o,
                    d.y * h
                )),
                    (u = Math.abs(d.x - c.x) < Math.abs((d.y - c.y) * 0.1));
            } else {
                const {
                    center: c,
                    innerRadius: d,
                    outerCenter: f,
                    outerRadius: p,
                } = i;
                l = e.createRadialGradient(
                    c.x * o,
                    c.y * h,
                    d * o,
                    f.x * o,
                    f.y * h,
                    p * o
                );
            }
            if (u && a && t) {
                const c = t.lineHeight / h;
                for (let d = 0; d < t.lines.length; d++) {
                    const f = (d * t.lineHeight + n / 2) / h;
                    i.colorStops.forEach((p) => {
                        const m = f + p.offset * c;
                        l.addColorStop(
                            Math.floor(m * Kv) / Kv,
                            Vt.shared.setValue(p.color).toHex()
                        );
                    });
                }
            } else
                i.colorStops.forEach((c) => {
                    l.addColorStop(
                        c.offset,
                        Vt.shared.setValue(c.color).toHex()
                    );
                });
            return l;
        }
    } else {
        const i = e.createPattern(s.texture.source.resource, "repeat"),
            r = s.matrix.copyTo(Ce.shared);
        return (
            r.scale(s.texture.frame.width, s.texture.frame.height),
            i.setTransform(r),
            i
        );
    }
    return it("FillStyle not recognised", s), "red";
}
const pC = class mC extends Dx {
    constructor(e) {
        super(),
            (this.resolution = 1),
            (this.pages = []),
            (this._padding = 0),
            (this._measureCache = Object.create(null)),
            (this._currentChars = []),
            (this._currentX = 0),
            (this._currentY = 0),
            (this._currentMaxCharHeight = 0),
            (this._currentPageIndex = -1),
            (this._skipKerning = !1);
        const t = { ...mC.defaultOptions, ...e };
        (this._textureSize = t.textureSize), (this._mipmap = t.mipmap);
        const n = t.style.clone();
        t.overrideFill &&
            ((n._fill.color = 16777215),
            (n._fill.alpha = 1),
            (n._fill.texture = we.WHITE),
            (n._fill.fill = null)),
            (this.applyFillAsTint = t.overrideFill);
        const i = n.fontSize;
        n.fontSize = this.baseMeasurementFontSize;
        const r = fm(n);
        t.overrideSize
            ? n._stroke && (n._stroke.width *= this.baseRenderedFontSize / i)
            : (n.fontSize = this.baseRenderedFontSize = i),
            (this._style = n),
            (this._skipKerning = t.skipKerning ?? !1),
            (this.resolution = t.resolution ?? 1),
            (this._padding = t.padding ?? 4),
            t.textureStyle &&
                (this._textureStyle =
                    t.textureStyle instanceof Tu
                        ? t.textureStyle
                        : new Tu(t.textureStyle)),
            (this.fontMetrics = ru.measureFont(r)),
            (this.lineHeight =
                n.lineHeight || this.fontMetrics.fontSize || n.fontSize);
    }
    ensureCharacters(e) {
        var g, _;
        const t = ru
            .graphemeSegmenter(e)
            .filter((v) => !this._currentChars.includes(v))
            .filter((v, b, y) => y.indexOf(v) === b);
        if (!t.length) return;
        this._currentChars = [...this._currentChars, ...t];
        let n;
        this._currentPageIndex === -1
            ? (n = this._nextPage())
            : (n = this.pages[this._currentPageIndex]);
        let { canvas: i, context: r } = n.canvasAndContext,
            a = n.texture.source;
        const o = this._style;
        let h = this._currentX,
            l = this._currentY,
            u = this._currentMaxCharHeight;
        const c = this.baseRenderedFontSize / this.baseMeasurementFontSize,
            d = this._padding * c;
        let f = !1;
        const p = i.width / this.resolution,
            m = i.height / this.resolution;
        for (let v = 0; v < t.length; v++) {
            const b = t[v],
                y = ru.measureText(b, o, i, !1);
            y.lineHeight = y.height;
            const C = y.width * c,
                w = Math.ceil((o.fontStyle === "italic" ? 2 : 1) * C),
                A = y.height * c,
                E = w + d * 2,
                S = A + d * 2;
            if (
                ((f = !1),
                b !==
                    `
` &&
                    b !== "\r" &&
                    b !== "	" &&
                    b !== " " &&
                    ((f = !0), (u = Math.ceil(Math.max(S, u)))),
                h + E > p && ((l += u), (u = S), (h = 0), l + u > m))
            ) {
                a.update();
                const k = this._nextPage();
                (i = k.canvasAndContext.canvas),
                    (r = k.canvasAndContext.context),
                    (a = k.texture.source),
                    (h = 0),
                    (l = 0),
                    (u = 0);
            }
            const P =
                C / c -
                (((g = o.dropShadow) == null ? void 0 : g.distance) ?? 0) -
                (((_ = o._stroke) == null ? void 0 : _.width) ?? 0);
            if (
                ((this.chars[b] = {
                    id: b.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: P,
                    kerning: {},
                }),
                f)
            ) {
                this._drawGlyph(r, y, h + d, l + d, c, o);
                const k = a.width * c,
                    R = a.height * c,
                    M = new Lt(
                        (h / k) * a.width,
                        (l / R) * a.height,
                        (E / k) * a.width,
                        (S / R) * a.height
                    );
                (this.chars[b].texture = new we({ source: a, frame: M })),
                    (h += Math.ceil(E));
            }
        }
        a.update(),
            (this._currentX = h),
            (this._currentY = l),
            (this._currentMaxCharHeight = u),
            this._skipKerning && this._applyKerning(t, r);
    }
    get pageTextures() {
        return (
            ae(
                Ge,
                "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."
            ),
            this.pages
        );
    }
    _applyKerning(e, t) {
        const n = this._measureCache;
        for (let i = 0; i < e.length; i++) {
            const r = e[i];
            for (let a = 0; a < this._currentChars.length; a++) {
                const o = this._currentChars[a];
                let h = n[r];
                h || (h = n[r] = t.measureText(r).width);
                let l = n[o];
                l || (l = n[o] = t.measureText(o).width);
                let u = t.measureText(r + o).width,
                    c = u - (h + l);
                c && (this.chars[r].kerning[o] = c),
                    (u = t.measureText(r + o).width),
                    (c = u - (h + l)),
                    c && (this.chars[o].kerning[r] = c);
            }
        }
    }
    _nextPage() {
        this._currentPageIndex++;
        const e = this.resolution,
            t = bm.getOptimalCanvasAndContext(
                this._textureSize,
                this._textureSize,
                e
            );
        this._setupContext(t.context, this._style, e);
        const n =
                e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
            i = new we({
                source: new Ba({
                    resource: t.canvas,
                    resolution: n,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap,
                }),
            });
        this._textureStyle && (i.source.style = this._textureStyle);
        const r = { canvasAndContext: t, texture: i };
        return (this.pages[this._currentPageIndex] = r), r;
    }
    _setupContext(e, t, n) {
        (t.fontSize = this.baseRenderedFontSize),
            e.scale(n, n),
            (e.font = fm(t)),
            (t.fontSize = this.baseMeasurementFontSize),
            (e.textBaseline = t.textBaseline);
        const i = t._stroke,
            r = (i == null ? void 0 : i.width) ?? 0;
        if (
            (i &&
                ((e.lineWidth = r),
                (e.lineJoin = i.join),
                (e.miterLimit = i.miterLimit),
                (e.strokeStyle = Zv(i, e))),
            t._fill && (e.fillStyle = Zv(t._fill, e)),
            t.dropShadow)
        ) {
            const a = t.dropShadow,
                o = Vt.shared.setValue(a.color).toArray(),
                h = a.blur * n,
                l = a.distance * n;
            (e.shadowColor = `rgba(${o[0] * 255},${o[1] * 255},${o[2] * 255},${
                a.alpha
            })`),
                (e.shadowBlur = h),
                (e.shadowOffsetX = Math.cos(a.angle) * l),
                (e.shadowOffsetY = Math.sin(a.angle) * l);
        } else
            (e.shadowColor = "black"),
                (e.shadowBlur = 0),
                (e.shadowOffsetX = 0),
                (e.shadowOffsetY = 0);
    }
    _drawGlyph(e, t, n, i, r, a) {
        const o = t.text,
            h = t.fontProperties,
            l = a._stroke,
            u = ((l == null ? void 0 : l.width) ?? 0) * r,
            c = n + u / 2,
            d = i - u / 2,
            f = h.descent * r,
            p = t.lineHeight * r;
        let m = !1;
        a.stroke && u && ((m = !0), e.strokeText(o, c, d + p - f));
        const { shadowBlur: g, shadowOffsetX: _, shadowOffsetY: v } = e;
        a._fill &&
            (m &&
                ((e.shadowBlur = 0),
                (e.shadowOffsetX = 0),
                (e.shadowOffsetY = 0)),
            e.fillText(o, c, d + p - f)),
            m &&
                ((e.shadowBlur = g),
                (e.shadowOffsetX = _),
                (e.shadowOffsetY = v));
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const { canvasAndContext: t, texture: n } = this.pages[e];
            bm.returnCanvasAndContext(t), n.destroy(!0);
        }
        this.pages = null;
    }
};
pC.defaultOptions = { textureSize: 512, style: new Uh(), mipmap: !0 };
let Qv = pC;
function B5(s, e, t, n) {
    const i = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: e.fontSize / t.baseMeasurementFontSize,
        lines: [
            {
                width: 0,
                charPositions: [],
                spaceWidth: 0,
                spacesIndex: [],
                chars: [],
            },
        ],
    };
    i.offsetY = t.baseLineOffset;
    let r = i.lines[0],
        a = null,
        o = !0;
    const h = { width: 0, start: 0, index: 0, positions: [], chars: [] },
        l = t.baseMeasurementFontSize / e.fontSize,
        u = e.letterSpacing * l,
        c = e.wordWrapWidth * l,
        d = e.lineHeight ? e.lineHeight * l : t.lineHeight,
        f = e.wordWrap && e.breakWords,
        p = (_) => {
            const v = r.width;
            for (let b = 0; b < h.index; b++) {
                const y = _.positions[b];
                r.chars.push(_.chars[b]), r.charPositions.push(y + v);
            }
            (r.width += _.width),
                (o = !1),
                (h.width = 0),
                (h.index = 0),
                (h.chars.length = 0);
        },
        m = () => {
            let _ = r.chars.length - 1;
            if (n) {
                let v = r.chars[_];
                for (; v === " "; )
                    (r.width -= t.chars[v].xAdvance), (v = r.chars[--_]);
            }
            (i.width = Math.max(i.width, r.width)),
                (r = {
                    width: 0,
                    charPositions: [],
                    chars: [],
                    spaceWidth: 0,
                    spacesIndex: [],
                }),
                (o = !0),
                i.lines.push(r),
                (i.height += d);
        },
        g = (_) => _ - u > c;
    for (let _ = 0; _ < s.length + 1; _++) {
        let v;
        const b = _ === s.length;
        b || (v = s[_]);
        const y = t.chars[v] || t.chars[" "];
        if (
            /(?:\s)/.test(v) ||
            v === "\r" ||
            v ===
                `
` ||
            b
        ) {
            if (
                (!o && e.wordWrap && g(r.width + h.width)
                    ? (m(), p(h), b || r.charPositions.push(0))
                    : ((h.start = r.width), p(h), b || r.charPositions.push(0)),
                v === "\r" ||
                    v ===
                        `
`)
            )
                m();
            else if (!b) {
                const E = y.xAdvance + (y.kerning[a] || 0) + u;
                (r.width += E),
                    (r.spaceWidth = E),
                    r.spacesIndex.push(r.charPositions.length),
                    r.chars.push(v);
            }
        } else {
            const A = y.kerning[a] || 0,
                E = y.xAdvance + A + u;
            f && g(r.width + h.width + E) && (p(h), m()),
                (h.positions[h.index++] = h.width + A),
                h.chars.push(v),
                (h.width += E);
        }
        a = v;
    }
    return (
        m(),
        e.align === "center"
            ? F5(i)
            : e.align === "right"
            ? $5(i)
            : e.align === "justify" && D5(i),
        i
    );
}
function F5(s) {
    for (let e = 0; e < s.lines.length; e++) {
        const t = s.lines[e],
            n = s.width / 2 - t.width / 2;
        for (let i = 0; i < t.charPositions.length; i++)
            t.charPositions[i] += n;
    }
}
function $5(s) {
    for (let e = 0; e < s.lines.length; e++) {
        const t = s.lines[e],
            n = s.width - t.width;
        for (let i = 0; i < t.charPositions.length; i++)
            t.charPositions[i] += n;
    }
}
function D5(s) {
    const e = s.width;
    for (let t = 0; t < s.lines.length; t++) {
        const n = s.lines[t];
        let i = 0,
            r = n.spacesIndex[i++],
            a = 0;
        const o = n.spacesIndex.length,
            l = (e - n.width) / o;
        for (let u = 0; u < n.charPositions.length; u++)
            u === r && ((r = n.spacesIndex[i++]), (a += l)),
                (n.charPositions[u] += a);
    }
}
function N5(s) {
    if (s === "") return [];
    typeof s == "string" && (s = [s]);
    const e = [];
    for (let t = 0, n = s.length; t < n; t++) {
        const i = s[t];
        if (Array.isArray(i)) {
            if (i.length !== 2)
                throw new Error(
                    `[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`
                );
            if (i[0].length === 0 || i[1].length === 0)
                throw new Error("[BitmapFont]: Invalid character delimiter.");
            const r = i[0].charCodeAt(0),
                a = i[1].charCodeAt(0);
            if (a < r)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let o = r, h = a; o <= h; o++) e.push(String.fromCharCode(o));
        } else e.push(...Array.from(i));
    }
    if (e.length === 0)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e;
}
let Uc = 0;
class V5 {
    constructor() {
        (this.ALPHA = [["a", "z"], ["A", "Z"], " "]),
            (this.NUMERIC = [["0", "9"]]),
            (this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
            (this.ASCII = [[" ", "~"]]),
            (this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1,
                textureStyle: null,
            }),
            (this.measureCache = Nx(1e3));
    }
    getFont(e, t) {
        var a;
        let n = `${t.fontFamily}-bitmap`,
            i = !0;
        if (
            (t._fill.fill && !t._stroke
                ? ((n += t._fill.fill.styleKey), (i = !1))
                : (t._stroke || t.dropShadow) &&
                  ((n = `${t.styleKey}-bitmap`), (i = !1)),
            !et.has(n))
        ) {
            const o = Object.create(t);
            o.lineHeight = 0;
            const h = new Qv({
                style: o,
                overrideFill: i,
                overrideSize: !0,
                ...this.defaultOptions,
            });
            Uc++,
                Uc > 50 &&
                    it(
                        "BitmapText",
                        `You have dynamically created ${Uc} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``
                    ),
                h.once("destroy", () => {
                    Uc--, et.remove(n);
                }),
                et.set(n, h);
        }
        const r = et.get(n);
        return (a = r.ensureCharacters) == null || a.call(r, e), r;
    }
    getLayout(e, t, n = !0) {
        const i = this.getFont(e, t),
            r = `${e}-${t.styleKey}-${n}`;
        if (this.measureCache.has(r)) return this.measureCache.get(r);
        const a = ru.graphemeSegmenter(e),
            o = B5(a, t, i, n);
        return this.measureCache.set(r, o), o;
    }
    measureText(e, t, n = !0) {
        return this.getLayout(e, t, n);
    }
    install(...e) {
        var l, u, c, d;
        let t = e[0];
        typeof t == "string" &&
            ((t = {
                name: t,
                style: e[1],
                chars: (l = e[2]) == null ? void 0 : l.chars,
                resolution: (u = e[2]) == null ? void 0 : u.resolution,
                padding: (c = e[2]) == null ? void 0 : c.padding,
                skipKerning: (d = e[2]) == null ? void 0 : d.skipKerning,
            }),
            ae(
                Ge,
                "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"
            ));
        const n = t == null ? void 0 : t.name;
        if (!n)
            throw new Error("[BitmapFontManager] Property `name` is required.");
        t = { ...this.defaultOptions, ...t };
        const i = t.style,
            r = i instanceof Uh ? i : new Uh(i),
            a = t.dynamicFill ?? this._canUseTintForStyle(r),
            o = new Qv({
                style: r,
                overrideFill: a,
                skipKerning: t.skipKerning,
                padding: t.padding,
                resolution: t.resolution,
                overrideSize: !1,
                textureStyle: t.textureStyle,
            }),
            h = N5(t.chars);
        return (
            o.ensureCharacters(h.join("")),
            et.set(`${n}-bitmap`, o),
            o.once("destroy", () => et.remove(`${n}-bitmap`)),
            o
        );
    }
    uninstall(e) {
        const t = `${e}-bitmap`,
            n = et.get(t);
        n && n.destroy();
    }
    _canUseTintForStyle(e) {
        return (
            !e._stroke &&
            (!e.dropShadow || e.dropShadow.color === 0) &&
            !e._fill.fill &&
            e._fill.color === 16777215
        );
    }
}
const ym = new V5();
class gC extends Dx {
    constructor(e, t) {
        super();
        const { textures: n, data: i } = e;
        Object.keys(i.pages).forEach((r) => {
            const a = i.pages[parseInt(r, 10)],
                o = n[a.id];
            this.pages.push({ texture: o });
        }),
            Object.keys(i.chars).forEach((r) => {
                const a = i.chars[r],
                    { frame: o, source: h, rotate: l } = n[a.page],
                    u = Ze.transformRectCoords(a, o, l, new Lt()),
                    c = new we({
                        frame: u,
                        orig: new Lt(0, 0, a.width, a.height),
                        source: h,
                        rotate: l,
                    });
                this.chars[r] = {
                    id: r.codePointAt(0),
                    xOffset: a.xOffset,
                    yOffset: a.yOffset,
                    xAdvance: a.xAdvance,
                    kerning: a.kerning ?? {},
                    texture: c,
                };
            }),
            (this.baseRenderedFontSize = i.fontSize),
            (this.baseMeasurementFontSize = i.fontSize),
            (this.fontMetrics = {
                ascent: 0,
                descent: 0,
                fontSize: i.fontSize,
            }),
            (this.baseLineOffset = i.baseLineOffset),
            (this.lineHeight = i.lineHeight),
            (this.fontFamily = i.fontFamily),
            (this.distanceField = i.distanceField ?? {
                type: "none",
                range: 0,
            }),
            (this.url = t);
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const { texture: t } = this.pages[e];
            t.destroy(!0);
        }
        this.pages = null;
    }
    static install(e) {
        ym.install(e);
    }
    static uninstall(e) {
        ym.uninstall(e);
    }
}
const Xf = {
        test(s) {
            return typeof s == "string" && s.startsWith("info face=");
        },
        parse(s) {
            const e = s.match(/^[a-z]+\s+.+$/gm),
                t = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: [],
                };
            for (const c in e) {
                const d = e[c].match(/^[a-z]+/gm)[0],
                    f = e[c].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                    p = {};
                for (const m in f) {
                    const g = f[m].split("="),
                        _ = g[0],
                        v = g[1].replace(/"/gm, ""),
                        b = parseFloat(v),
                        y = isNaN(b) ? v : b;
                    p[_] = y;
                }
                t[d].push(p);
            }
            const n = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0,
                },
                [i] = t.info,
                [r] = t.common,
                [a] = t.distanceField ?? [];
            a &&
                (n.distanceField = {
                    range: parseInt(a.distanceRange, 10),
                    type: a.fieldType,
                }),
                (n.fontSize = parseInt(i.size, 10)),
                (n.fontFamily = i.face),
                (n.lineHeight = parseInt(r.lineHeight, 10));
            const o = t.page;
            for (let c = 0; c < o.length; c++)
                n.pages.push({
                    id: parseInt(o[c].id, 10) || 0,
                    file: o[c].file,
                });
            const h = {};
            n.baseLineOffset = n.lineHeight - parseInt(r.base, 10);
            const l = t.char;
            for (let c = 0; c < l.length; c++) {
                const d = l[c],
                    f = parseInt(d.id, 10);
                let p = d.letter ?? d.char ?? String.fromCharCode(f);
                p === "space" && (p = " "),
                    (h[f] = p),
                    (n.chars[p] = {
                        id: f,
                        page: parseInt(d.page, 10) || 0,
                        x: parseInt(d.x, 10),
                        y: parseInt(d.y, 10),
                        width: parseInt(d.width, 10),
                        height: parseInt(d.height, 10),
                        xOffset: parseInt(d.xoffset, 10),
                        yOffset: parseInt(d.yoffset, 10),
                        xAdvance: parseInt(d.xadvance, 10),
                        kerning: {},
                    });
            }
            const u = t.kerning || [];
            for (let c = 0; c < u.length; c++) {
                const d = parseInt(u[c].first, 10),
                    f = parseInt(u[c].second, 10),
                    p = parseInt(u[c].amount, 10);
                n.chars[h[f]].kerning[h[d]] = p;
            }
            return n;
        },
    },
    Jv = {
        test(s) {
            const e = s;
            return (
                typeof e != "string" &&
                "getElementsByTagName" in e &&
                e.getElementsByTagName("page").length &&
                e.getElementsByTagName("info")[0].getAttribute("face") !== null
            );
        },
        parse(s) {
            const e = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0,
                },
                t = s.getElementsByTagName("info")[0],
                n = s.getElementsByTagName("common")[0],
                i = s.getElementsByTagName("distanceField")[0];
            i &&
                (e.distanceField = {
                    type: i.getAttribute("fieldType"),
                    range: parseInt(i.getAttribute("distanceRange"), 10),
                });
            const r = s.getElementsByTagName("page"),
                a = s.getElementsByTagName("char"),
                o = s.getElementsByTagName("kerning");
            (e.fontSize = parseInt(t.getAttribute("size"), 10)),
                (e.fontFamily = t.getAttribute("face")),
                (e.lineHeight = parseInt(n.getAttribute("lineHeight"), 10));
            for (let l = 0; l < r.length; l++)
                e.pages.push({
                    id: parseInt(r[l].getAttribute("id"), 10) || 0,
                    file: r[l].getAttribute("file"),
                });
            const h = {};
            e.baseLineOffset =
                e.lineHeight - parseInt(n.getAttribute("base"), 10);
            for (let l = 0; l < a.length; l++) {
                const u = a[l],
                    c = parseInt(u.getAttribute("id"), 10);
                let d =
                    u.getAttribute("letter") ??
                    u.getAttribute("char") ??
                    String.fromCharCode(c);
                d === "space" && (d = " "),
                    (h[c] = d),
                    (e.chars[d] = {
                        id: c,
                        page: parseInt(u.getAttribute("page"), 10) || 0,
                        x: parseInt(u.getAttribute("x"), 10),
                        y: parseInt(u.getAttribute("y"), 10),
                        width: parseInt(u.getAttribute("width"), 10),
                        height: parseInt(u.getAttribute("height"), 10),
                        xOffset: parseInt(u.getAttribute("xoffset"), 10),
                        yOffset: parseInt(u.getAttribute("yoffset"), 10),
                        xAdvance: parseInt(u.getAttribute("xadvance"), 10),
                        kerning: {},
                    });
            }
            for (let l = 0; l < o.length; l++) {
                const u = parseInt(o[l].getAttribute("first"), 10),
                    c = parseInt(o[l].getAttribute("second"), 10),
                    d = parseInt(o[l].getAttribute("amount"), 10);
                e.chars[h[c]].kerning[h[u]] = d;
            }
            return e;
        },
    },
    eb = {
        test(s) {
            return typeof s == "string" && s.includes("<font>")
                ? Jv.test(rt.get().parseXML(s))
                : !1;
        },
        parse(s) {
            return Jv.parse(rt.get().parseXML(s));
        },
    },
    U5 = [".xml", ".fnt"],
    z5 = {
        extension: { type: ee.CacheParser, name: "cacheBitmapFont" },
        test: (s) => s instanceof gC,
        getCacheableAssets(s, e) {
            const t = {};
            return (
                s.forEach((n) => {
                    (t[n] = e), (t[`${n}-bitmap`] = e);
                }),
                (t[`${e.fontFamily}-bitmap`] = e),
                t
            );
        },
    },
    Y5 = {
        extension: { type: ee.LoadParser, priority: Ii.Normal },
        name: "loadBitmapFont",
        id: "bitmap-font",
        test(s) {
            return U5.includes(on.extname(s).toLowerCase());
        },
        async testParse(s) {
            return Xf.test(s) || eb.test(s);
        },
        async parse(s, e, t) {
            const n = Xf.test(s) ? Xf.parse(s) : eb.parse(s),
                { src: i } = e,
                { pages: r } = n,
                a = [],
                o = n.distanceField
                    ? {
                          scaleMode: "linear",
                          alphaMode: "premultiply-alpha-on-upload",
                          autoGenerateMipmaps: !1,
                          resolution: 1,
                      }
                    : {};
            for (let c = 0; c < r.length; ++c) {
                const d = r[c].file;
                let f = on.join(on.dirname(i), d);
                (f = Iu(f, i)), a.push({ src: f, data: o });
            }
            const h = await t.load(a),
                l = a.map((c) => h[c.src]);
            return new gC({ data: n, textures: l }, i);
        },
        async load(s, e) {
            return await (await rt.get().fetch(s)).text();
        },
        async unload(s, e, t) {
            await Promise.all(
                s.pages.map((n) => t.unload(n.texture.source._sourceOrigin))
            ),
                s.destroy();
        },
    };
class G5 {
    constructor(e, t = !1) {
        (this._loader = e),
            (this._assetList = []),
            (this._isLoading = !1),
            (this._maxConcurrent = 1),
            (this.verbose = t);
    }
    add(e) {
        e.forEach((t) => {
            this._assetList.push(t);
        }),
            this.verbose &&
                console.log("[BackgroundLoader] assets: ", this._assetList),
            this._isActive && !this._isLoading && this._next();
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const e = [],
                t = Math.min(this._assetList.length, this._maxConcurrent);
            for (let n = 0; n < t; n++) e.push(this._assetList.pop());
            await this._loader.load(e), (this._isLoading = !1), this._next();
        }
    }
    get active() {
        return this._isActive;
    }
    set active(e) {
        this._isActive !== e &&
            ((this._isActive = e), e && !this._isLoading && this._next());
    }
}
const j5 = {
    extension: { type: ee.CacheParser, name: "cacheTextureArray" },
    test: (s) => Array.isArray(s) && s.every((e) => e instanceof we),
    getCacheableAssets: (s, e) => {
        const t = {};
        return (
            s.forEach((n) => {
                e.forEach((i, r) => {
                    t[n + (r === 0 ? "" : r + 1)] = i;
                });
            }),
            t
        );
    },
};
async function _C(s) {
    if ("Image" in globalThis)
        return new Promise((e) => {
            const t = new Image();
            (t.onload = () => {
                e(!0);
            }),
                (t.onerror = () => {
                    e(!1);
                }),
                (t.src = s);
        });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
        try {
            const e = await (await fetch(s)).blob();
            await createImageBitmap(e);
        } catch {
            return !1;
        }
        return !0;
    }
    return !1;
}
const W5 = {
        extension: { type: ee.DetectionParser, priority: 1 },
        test: async () =>
            _C(
                "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
            ),
        add: async (s) => [...s, "avif"],
        remove: async (s) => s.filter((e) => e !== "avif"),
    },
    tb = ["png", "jpg", "jpeg"],
    X5 = {
        extension: { type: ee.DetectionParser, priority: -1 },
        test: () => Promise.resolve(!0),
        add: async (s) => [...s, ...tb],
        remove: async (s) => s.filter((e) => !tb.includes(e)),
    },
    q5 =
        "WorkerGlobalScope" in globalThis &&
        globalThis instanceof globalThis.WorkerGlobalScope;
function kd(s) {
    return q5 ? !1 : document.createElement("video").canPlayType(s) !== "";
}
const H5 = {
        extension: { type: ee.DetectionParser, priority: 0 },
        test: async () => kd("video/mp4"),
        add: async (s) => [...s, "mp4", "m4v"],
        remove: async (s) => s.filter((e) => e !== "mp4" && e !== "m4v"),
    },
    K5 = {
        extension: { type: ee.DetectionParser, priority: 0 },
        test: async () => kd("video/ogg"),
        add: async (s) => [...s, "ogv"],
        remove: async (s) => s.filter((e) => e !== "ogv"),
    },
    Z5 = {
        extension: { type: ee.DetectionParser, priority: 0 },
        test: async () => kd("video/webm"),
        add: async (s) => [...s, "webm"],
        remove: async (s) => s.filter((e) => e !== "webm"),
    },
    Q5 = {
        extension: { type: ee.DetectionParser, priority: 0 },
        test: async () =>
            _C(
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
            ),
        add: async (s) => [...s, "webp"],
        remove: async (s) => s.filter((e) => e !== "webp"),
    };
let J5 = class {
    constructor() {
        (this._parsers = []),
            (this._parsersValidated = !1),
            (this.parsers = new Proxy(this._parsers, {
                set: (e, t, n) => (
                    (this._parsersValidated = !1), (e[t] = n), !0
                ),
            })),
            (this.promiseCache = {});
    }
    reset() {
        (this._parsersValidated = !1), (this.promiseCache = {});
    }
    _getLoadPromiseAndParser(e, t) {
        const n = { promise: null, parser: null };
        return (
            (n.promise = (async () => {
                var a, o;
                let i = null,
                    r = null;
                if (
                    ((t.parser || t.loadParser) &&
                        ((r = this._parserHash[t.parser || t.loadParser]),
                        t.loadParser &&
                            it(
                                `[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`
                            ),
                        r ||
                            it(
                                `[Assets] specified load parser "${
                                    t.parser || t.loadParser
                                }" not found while loading ${e}`
                            )),
                    !r)
                ) {
                    for (let h = 0; h < this.parsers.length; h++) {
                        const l = this.parsers[h];
                        if (
                            l.load &&
                            (a = l.test) != null &&
                            a.call(l, e, t, this)
                        ) {
                            r = l;
                            break;
                        }
                    }
                    if (!r)
                        return (
                            it(
                                `[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`
                            ),
                            null
                        );
                }
                (i = await r.load(e, t, this)), (n.parser = r);
                for (let h = 0; h < this.parsers.length; h++) {
                    const l = this.parsers[h];
                    l.parse &&
                        l.parse &&
                        (await ((o = l.testParse) == null
                            ? void 0
                            : o.call(l, i, t, this))) &&
                        ((i = (await l.parse(i, t, this)) || i),
                        (n.parser = l));
                }
                return i;
            })()),
            n
        );
    }
    async load(e, t) {
        this._parsersValidated || this._validateParsers();
        let n = 0;
        const i = {},
            r = Mu(e),
            a = zs(e, (l) => ({ alias: [l], src: l, data: {} })),
            o = a.length,
            h = a.map(async (l) => {
                const u = on.toAbsolute(l.src);
                if (!i[l.src])
                    try {
                        this.promiseCache[u] ||
                            (this.promiseCache[u] =
                                this._getLoadPromiseAndParser(u, l)),
                            (i[l.src] = await this.promiseCache[u].promise),
                            t && t(++n / o);
                    } catch (c) {
                        throw (
                            (delete this.promiseCache[u],
                            delete i[l.src],
                            new Error(`[Loader.load] Failed to load ${u}.
${c}`))
                        );
                    }
            });
        return await Promise.all(h), r ? i[a[0].src] : i;
    }
    async unload(e) {
        const n = zs(e, (i) => ({ alias: [i], src: i })).map(async (i) => {
            var o, h;
            const r = on.toAbsolute(i.src),
                a = this.promiseCache[r];
            if (a) {
                const l = await a.promise;
                delete this.promiseCache[r],
                    await ((h = (o = a.parser) == null ? void 0 : o.unload) ==
                    null
                        ? void 0
                        : h.call(o, l, i, this));
            }
        });
        await Promise.all(n);
    }
    _validateParsers() {
        (this._parsersValidated = !0),
            (this._parserHash = this._parsers
                .filter((e) => e.name || e.id)
                .reduce(
                    (e, t) => (
                        !t.name && !t.id
                            ? it("[Assets] parser should have an id")
                            : (e[t.name] || e[t.id]) &&
                              it(`[Assets] parser id conflict "${t.id}"`),
                        (e[t.name] = t),
                        t.id && (e[t.id] = t),
                        e
                    ),
                    {}
                ));
    }
};
function bl(s, e) {
    if (Array.isArray(e)) {
        for (const t of e) if (s.startsWith(`data:${t}`)) return !0;
        return !1;
    }
    return s.startsWith(`data:${e}`);
}
function Is(s, e) {
    const t = s.split("?")[0],
        n = on.extname(t).toLowerCase();
    return Array.isArray(e) ? e.includes(n) : n === e;
}
const eI = ".json",
    tI = "application/json",
    nI = {
        extension: { type: ee.LoadParser, priority: Ii.Low },
        name: "loadJson",
        id: "json",
        test(s) {
            return bl(s, tI) || Is(s, eI);
        },
        async load(s) {
            return await (await rt.get().fetch(s)).json();
        },
    },
    sI = ".txt",
    iI = "text/plain",
    rI = {
        name: "loadTxt",
        id: "text",
        extension: { type: ee.LoadParser, priority: Ii.Low, name: "loadTxt" },
        test(s) {
            return bl(s, iI) || Is(s, sI);
        },
        async load(s) {
            return await (await rt.get().fetch(s)).text();
        },
    },
    aI = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
    ],
    oI = [".ttf", ".otf", ".woff", ".woff2"],
    lI = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    hI = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function cI(s) {
    const e = on.extname(s),
        i = on
            .basename(s, e)
            .replace(/(-|_)/g, " ")
            .toLowerCase()
            .split(" ")
            .map((o) => o.charAt(0).toUpperCase() + o.slice(1));
    let r = i.length > 0;
    for (const o of i)
        if (!o.match(hI)) {
            r = !1;
            break;
        }
    let a = i.join(" ");
    return r || (a = `"${a.replace(/[\\"]/g, "\\$&")}"`), a;
}
const uI = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function dI(s) {
    return uI.test(s) ? s : encodeURI(s);
}
const fI = {
    extension: { type: ee.LoadParser, priority: Ii.Low },
    name: "loadWebFont",
    id: "web-font",
    test(s) {
        return bl(s, lI) || Is(s, oI);
    },
    async load(s, e) {
        var n, i, r;
        const t = rt.get().getFontFaceSet();
        if (t) {
            const a = [],
                o = ((n = e.data) == null ? void 0 : n.family) ?? cI(s),
                h = ((r = (i = e.data) == null ? void 0 : i.weights) == null
                    ? void 0
                    : r.filter((u) => aI.includes(u))) ?? ["normal"],
                l = e.data ?? {};
            for (let u = 0; u < h.length; u++) {
                const c = h[u],
                    d = new FontFace(o, `url(${dI(s)})`, { ...l, weight: c });
                await d.load(), t.add(d), a.push(d);
            }
            return (
                et.has(`${o}-and-url`)
                    ? et.get(`${o}-and-url`).entries.push({ url: s, faces: a })
                    : et.set(`${o}-and-url`, {
                          entries: [{ url: s, faces: a }],
                      }),
                a.length === 1 ? a[0] : a
            );
        }
        return (
            it(
                "[loadWebFont] FontFace API is not supported. Skipping loading font"
            ),
            null
        );
    },
    unload(s) {
        const e = Array.isArray(s) ? s : [s],
            t = e[0].family,
            n = et.get(`${t}-and-url`),
            i = n.entries.find((r) => r.faces.some((a) => e.indexOf(a) !== -1));
        (i.faces = i.faces.filter((r) => e.indexOf(r) === -1)),
            i.faces.length === 0 &&
                (n.entries = n.entries.filter((r) => r !== i)),
            e.forEach((r) => {
                rt.get().getFontFaceSet().delete(r);
            }),
            n.entries.length === 0 && et.remove(`${t}-and-url`);
    },
};
function Vg(s, e = 1) {
    var n;
    const t = (n = Ha.RETINA_PREFIX) == null ? void 0 : n.exec(s);
    return t ? parseFloat(t[1]) : e;
}
function Ug(s, e, t) {
    (s.label = t), (s._sourceOrigin = t);
    const n = new we({ source: s, label: t }),
        i = () => {
            delete e.promiseCache[t], et.has(t) && et.remove(t);
        };
    return (
        n.source.once("destroy", () => {
            e.promiseCache[t] &&
                (it(
                    "[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."
                ),
                i());
        }),
        n.once("destroy", () => {
            s.destroyed ||
                (it(
                    "[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."
                ),
                i());
        }),
        n
    );
}
const pI = ".svg",
    mI = "image/svg+xml",
    gI = {
        extension: { type: ee.LoadParser, priority: Ii.Low, name: "loadSVG" },
        name: "loadSVG",
        id: "svg",
        config: { crossOrigin: "anonymous", parseAsGraphicsContext: !1 },
        test(s) {
            return bl(s, mI) || Is(s, pI);
        },
        async load(s, e, t) {
            var n;
            return ((n = e.data) == null ? void 0 : n.parseAsGraphicsContext) ??
                this.config.parseAsGraphicsContext
                ? vI(s)
                : _I(s, e, t, this.config.crossOrigin);
        },
        unload(s) {
            s.destroy(!0);
        },
    };
async function _I(s, e, t, n) {
    var g, _, v;
    const i = await rt.get().fetch(s),
        r = rt.get().createImage();
    (r.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
        await i.text()
    )}`),
        (r.crossOrigin = n),
        await r.decode();
    const a = ((g = e.data) == null ? void 0 : g.width) ?? r.width,
        o = ((_ = e.data) == null ? void 0 : _.height) ?? r.height,
        h = ((v = e.data) == null ? void 0 : v.resolution) || Vg(s),
        l = Math.ceil(a * h),
        u = Math.ceil(o * h),
        c = rt.get().createCanvas(l, u),
        d = c.getContext("2d");
    (d.imageSmoothingEnabled = !0),
        (d.imageSmoothingQuality = "high"),
        d.drawImage(r, 0, 0, a * h, o * h);
    const { parseAsGraphicsContext: f, ...p } = e.data ?? {},
        m = new Ba({
            resource: c,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: h,
            ...p,
        });
    return Ug(m, t, s);
}
async function vI(s) {
    const t = await (await rt.get().fetch(s)).text(),
        n = new xs();
    return n.svg(t), n;
}
const bI = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let Oo = null,
    wm = class {
        constructor() {
            Oo ||
                (Oo = URL.createObjectURL(
                    new Blob([bI], { type: "application/javascript" })
                )),
                (this.worker = new Worker(Oo));
        }
    };
wm.revokeObjectURL = function () {
    Oo && (URL.revokeObjectURL(Oo), (Oo = null));
};
const yI = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let Bo = null;
class vC {
    constructor() {
        Bo ||
            (Bo = URL.createObjectURL(
                new Blob([yI], { type: "application/javascript" })
            )),
            (this.worker = new Worker(Bo));
    }
}
vC.revokeObjectURL = function () {
    Bo && (URL.revokeObjectURL(Bo), (Bo = null));
};
let nb = 0,
    qf;
class wI {
    constructor() {
        (this._initialized = !1),
            (this._createdWorkers = 0),
            (this._workerPool = []),
            (this._queue = []),
            (this._resolveHash = {});
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0
            ? this._isImageBitmapSupported
            : ((this._isImageBitmapSupported = new Promise((e) => {
                  const { worker: t } = new wm();
                  t.addEventListener("message", (n) => {
                      t.terminate(), wm.revokeObjectURL(), e(n.data);
                  });
              })),
              this._isImageBitmapSupported);
    }
    loadImageBitmap(e, t) {
        var n;
        return this._run("loadImageBitmap", [
            e,
            (n = t == null ? void 0 : t.data) == null ? void 0 : n.alphaMode,
        ]);
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0);
    }
    _getWorker() {
        qf === void 0 && (qf = navigator.hardwareConcurrency || 4);
        let e = this._workerPool.pop();
        return (
            !e &&
                this._createdWorkers < qf &&
                (this._createdWorkers++,
                (e = new vC().worker),
                e.addEventListener("message", (t) => {
                    this._complete(t.data),
                        this._returnWorker(t.target),
                        this._next();
                })),
            e
        );
    }
    _returnWorker(e) {
        this._workerPool.push(e);
    }
    _complete(e) {
        e.error !== void 0
            ? this._resolveHash[e.uuid].reject(e.error)
            : this._resolveHash[e.uuid].resolve(e.data),
            (this._resolveHash[e.uuid] = null);
    }
    async _run(e, t) {
        await this._initWorkers();
        const n = new Promise((i, r) => {
            this._queue.push({ id: e, arguments: t, resolve: i, reject: r });
        });
        return this._next(), n;
    }
    _next() {
        if (!this._queue.length) return;
        const e = this._getWorker();
        if (!e) return;
        const t = this._queue.pop(),
            n = t.id;
        (this._resolveHash[nb] = { resolve: t.resolve, reject: t.reject }),
            e.postMessage({ data: t.arguments, uuid: nb++, id: n });
    }
    reset() {
        this._workerPool.forEach((e) => e.terminate()),
            (this._workerPool.length = 0),
            Object.values(this._resolveHash).forEach(({ reject: e }) => {
                e == null || e(new Error("WorkerManager destroyed"));
            }),
            (this._resolveHash = {}),
            (this._queue.length = 0),
            (this._initialized = !1),
            (this._createdWorkers = 0);
    }
}
const sb = new wI(),
    xI = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    CI = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function AI(s, e) {
    var i;
    const t = await rt.get().fetch(s);
    if (!t.ok)
        throw new Error(
            `[loadImageBitmap] Failed to fetch ${s}: ${t.status} ${t.statusText}`
        );
    const n = await t.blob();
    return ((i = e == null ? void 0 : e.data) == null
        ? void 0
        : i.alphaMode) === "premultiplied-alpha"
        ? createImageBitmap(n, { premultiplyAlpha: "none" })
        : createImageBitmap(n);
}
const bC = {
        name: "loadTextures",
        id: "texture",
        extension: {
            type: ee.LoadParser,
            priority: Ii.High,
            name: "loadTextures",
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous",
        },
        test(s) {
            return bl(s, CI) || Is(s, xI);
        },
        async load(s, e, t) {
            var r;
            let n = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap
                ? this.config.preferWorkers &&
                  (await sb.isImageBitmapSupported())
                    ? (n = await sb.loadImageBitmap(s, e))
                    : (n = await AI(s, e))
                : (n = await new Promise((a, o) => {
                      (n = rt.get().createImage()),
                          (n.crossOrigin = this.config.crossOrigin),
                          (n.src = s),
                          n.complete
                              ? a(n)
                              : ((n.onload = () => {
                                    a(n);
                                }),
                                (n.onerror = o));
                  }));
            const i = new Ba({
                resource: n,
                alphaMode: "premultiply-alpha-on-upload",
                resolution:
                    ((r = e.data) == null ? void 0 : r.resolution) || Vg(s),
                ...e.data,
            });
            return Ug(i, t, s);
        },
        unload(s) {
            s.destroy(!0);
        },
    },
    SI = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
let Hf, Kf;
function EI(s, e, t) {
    t === void 0 && !e.startsWith("data:")
        ? (s.crossOrigin = kI(e))
        : t !== !1 && (s.crossOrigin = typeof t == "string" ? t : "anonymous");
}
function PI(s) {
    return new Promise((e, t) => {
        s.addEventListener("canplaythrough", n),
            s.addEventListener("error", i),
            s.load();
        function n() {
            r(), e();
        }
        function i(a) {
            r(), t(a);
        }
        function r() {
            s.removeEventListener("canplaythrough", n),
                s.removeEventListener("error", i);
        }
    });
}
function kI(s, e = globalThis.location) {
    if (s.startsWith("data:")) return "";
    e || (e = globalThis.location);
    const t = new URL(s, document.baseURI);
    return t.hostname !== e.hostname ||
        t.port !== e.port ||
        t.protocol !== e.protocol
        ? "anonymous"
        : "";
}
function TI() {
    const s = [],
        e = [];
    for (const t of SI) {
        const n = fh.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
        kd(n) && (s.push(t), e.includes(n) || e.push(n));
    }
    return { validVideoExtensions: s, validVideoMime: e };
}
const MI = {
        name: "loadVideo",
        id: "video",
        extension: { type: ee.LoadParser, name: "loadVideo" },
        test(s) {
            if (!Hf || !Kf) {
                const { validVideoExtensions: n, validVideoMime: i } = TI();
                (Hf = n), (Kf = i);
            }
            const e = bl(s, Kf),
                t = Is(s, Hf);
            return e || t;
        },
        async load(s, e, t) {
            var h, l;
            const n = {
                    ...fh.defaultOptions,
                    resolution:
                        ((h = e.data) == null ? void 0 : h.resolution) || Vg(s),
                    alphaMode:
                        ((l = e.data) == null ? void 0 : l.alphaMode) ||
                        (await dx()),
                    ...e.data,
                },
                i = document.createElement("video"),
                r = {
                    preload: n.autoLoad !== !1 ? "auto" : void 0,
                    "webkit-playsinline": n.playsinline !== !1 ? "" : void 0,
                    playsinline: n.playsinline !== !1 ? "" : void 0,
                    muted: n.muted === !0 ? "" : void 0,
                    loop: n.loop === !0 ? "" : void 0,
                    autoplay: n.autoPlay !== !1 ? "" : void 0,
                };
            Object.keys(r).forEach((u) => {
                const c = r[u];
                c !== void 0 && i.setAttribute(u, c);
            }),
                n.muted === !0 && (i.muted = !0),
                EI(i, s, n.crossorigin);
            const a = document.createElement("source");
            let o;
            if (n.mime) o = n.mime;
            else if (s.startsWith("data:")) o = s.slice(5, s.indexOf(";"));
            else if (!s.startsWith("blob:")) {
                const u = s
                    .split("?")[0]
                    .slice(s.lastIndexOf(".") + 1)
                    .toLowerCase();
                o = fh.MIME_TYPES[u] || `video/${u}`;
            }
            return (
                (a.src = s),
                o && (a.type = o),
                new Promise((u) => {
                    const c = async () => {
                        const d = new fh({ ...n, resource: i });
                        i.removeEventListener("canplay", c),
                            e.data.preload && (await PI(i)),
                            u(Ug(d, t, s));
                    };
                    n.preload && !n.autoPlay && i.load(),
                        i.addEventListener("canplay", c),
                        i.appendChild(a);
                })
            );
        },
        unload(s) {
            s.destroy(!0);
        },
    },
    yC = {
        extension: { type: ee.ResolveParser, name: "resolveTexture" },
        test: bC.test,
        parse: (s) => {
            var e;
            return {
                resolution: parseFloat(
                    ((e = Ha.RETINA_PREFIX.exec(s)) == null ? void 0 : e[1]) ??
                        "1"
                ),
                format: s.split(".").pop(),
                src: s,
            };
        },
    },
    II = {
        extension: {
            type: ee.ResolveParser,
            priority: -2,
            name: "resolveJson",
        },
        test: (s) => Ha.RETINA_PREFIX.test(s) && s.endsWith(".json"),
        parse: yC.parse,
    };
class RI {
    constructor() {
        (this._detections = []),
            (this._initialized = !1),
            (this.resolver = new Ha()),
            (this.loader = new J5()),
            (this.cache = et),
            (this._backgroundLoader = new G5(this.loader)),
            (this._backgroundLoader.active = !0),
            this.reset();
    }
    async init(e = {}) {
        var r, a;
        if (this._initialized) {
            it(
                "[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"
            );
            return;
        }
        if (
            ((this._initialized = !0),
            e.defaultSearchParams &&
                this.resolver.setDefaultSearchParams(e.defaultSearchParams),
            e.basePath && (this.resolver.basePath = e.basePath),
            e.bundleIdentifier &&
                this.resolver.setBundleIdentifier(e.bundleIdentifier),
            e.manifest)
        ) {
            let o = e.manifest;
            typeof o == "string" && (o = await this.load(o)),
                this.resolver.addManifest(o);
        }
        const t =
                ((r = e.texturePreference) == null ? void 0 : r.resolution) ??
                1,
            n = typeof t == "number" ? [t] : t,
            i = await this._detectFormats({
                preferredFormats:
                    (a = e.texturePreference) == null ? void 0 : a.format,
                skipDetections: e.skipDetections,
                detections: this._detections,
            });
        this.resolver.prefer({ params: { format: i, resolution: n } }),
            e.preferences && this.setPreferences(e.preferences);
    }
    add(e) {
        this.resolver.add(e);
    }
    async load(e, t) {
        this._initialized || (await this.init());
        const n = Mu(e),
            i = zs(e).map((o) => {
                if (typeof o != "string") {
                    const h = this.resolver.getAlias(o);
                    return (
                        h.some((l) => !this.resolver.hasKey(l)) && this.add(o),
                        Array.isArray(h) ? h[0] : h
                    );
                }
                return (
                    this.resolver.hasKey(o) || this.add({ alias: o, src: o }), o
                );
            }),
            r = this.resolver.resolve(i),
            a = await this._mapLoadToResolve(r, t);
        return n ? a[i[0]] : a;
    }
    addBundle(e, t) {
        this.resolver.addBundle(e, t);
    }
    async loadBundle(e, t) {
        this._initialized || (await this.init());
        let n = !1;
        typeof e == "string" && ((n = !0), (e = [e]));
        const i = this.resolver.resolveBundle(e),
            r = {},
            a = Object.keys(i);
        let o = 0,
            h = 0;
        const l = () => {
                t == null || t(++o / h);
            },
            u = a.map((c) => {
                const d = i[c],
                    f = Object.values(d),
                    p = [...new Set(f.flat())];
                return (
                    (h += p.length),
                    this._mapLoadToResolve(d, l).then((m) => {
                        r[c] = m;
                    })
                );
            });
        return await Promise.all(u), n ? r[e[0]] : r;
    }
    async backgroundLoad(e) {
        this._initialized || (await this.init()),
            typeof e == "string" && (e = [e]);
        const t = this.resolver.resolve(e);
        this._backgroundLoader.add(Object.values(t));
    }
    async backgroundLoadBundle(e) {
        this._initialized || (await this.init()),
            typeof e == "string" && (e = [e]);
        const t = this.resolver.resolveBundle(e);
        Object.values(t).forEach((n) => {
            this._backgroundLoader.add(Object.values(n));
        });
    }
    reset() {
        this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            (this._initialized = !1);
    }
    get(e) {
        if (typeof e == "string") return et.get(e);
        const t = {};
        for (let n = 0; n < e.length; n++) t[n] = et.get(e[n]);
        return t;
    }
    async _mapLoadToResolve(e, t) {
        const n = [...new Set(Object.values(e))];
        this._backgroundLoader.active = !1;
        const i = await this.loader.load(n, t);
        this._backgroundLoader.active = !0;
        const r = {};
        return (
            n.forEach((a) => {
                const o = i[a.src],
                    h = [a.src];
                a.alias && h.push(...a.alias),
                    h.forEach((l) => {
                        r[l] = o;
                    }),
                    et.set(h, o);
            }),
            r
        );
    }
    async unload(e) {
        this._initialized || (await this.init());
        const t = zs(e).map((i) => (typeof i != "string" ? i.src : i)),
            n = this.resolver.resolve(t);
        await this._unloadFromResolved(n);
    }
    async unloadBundle(e) {
        this._initialized || (await this.init()), (e = zs(e));
        const t = this.resolver.resolveBundle(e),
            n = Object.keys(t).map((i) => this._unloadFromResolved(t[i]));
        await Promise.all(n);
    }
    async _unloadFromResolved(e) {
        const t = Object.values(e);
        t.forEach((n) => {
            et.remove(n.src);
        }),
            await this.loader.unload(t);
    }
    async _detectFormats(e) {
        let t = [];
        e.preferredFormats &&
            (t = Array.isArray(e.preferredFormats)
                ? e.preferredFormats
                : [e.preferredFormats]);
        for (const n of e.detections)
            e.skipDetections || (await n.test())
                ? (t = await n.add(t))
                : e.skipDetections || (t = await n.remove(t));
        return (t = t.filter((n, i) => t.indexOf(n) === i)), t;
    }
    get detections() {
        return this._detections;
    }
    setPreferences(e) {
        this.loader.parsers.forEach((t) => {
            t.config &&
                Object.keys(t.config)
                    .filter((n) => n in e)
                    .forEach((n) => {
                        t.config[n] = e[n];
                    });
        });
    }
}
const Xi = new RI();
Ot.handleByList(ee.LoadParser, Xi.loader.parsers)
    .handleByList(ee.ResolveParser, Xi.resolver.parsers)
    .handleByList(ee.CacheParser, Xi.cache.parsers)
    .handleByList(ee.DetectionParser, Xi.detections);
Ot.add(j5, X5, W5, Q5, H5, K5, Z5, nI, rI, fI, gI, bC, MI, Y5, z5, yC, II);
const ib = {
    loader: ee.LoadParser,
    resolver: ee.ResolveParser,
    cache: ee.CacheParser,
    detection: ee.DetectionParser,
};
Ot.handle(
    ee.Asset,
    (s) => {
        const e = s.ref;
        Object.entries(ib)
            .filter(([t]) => !!e[t])
            .forEach(([t, n]) =>
                Ot.add(Object.assign(e[t], { extension: e[t].extension ?? n }))
            );
    },
    (s) => {
        const e = s.ref;
        Object.keys(ib)
            .filter((t) => !!e[t])
            .forEach((t) => Ot.remove(e[t]));
    }
);
const wC = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [
            0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868,
            0.197641,
        ],
        15: [
            489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
            0.197448,
        ],
    },
    LI = [
        "in vec2 vBlurTexCoords[%size%];",
        "uniform sampler2D uTexture;",
        "out vec4 finalColor;",
        "void main(void)",
        "{",
        "    finalColor = vec4(0.0);",
        "    %blur%",
        "}",
    ].join(`
`);
function OI(s) {
    const e = wC[s],
        t = e.length;
    let n = LI,
        i = "";
    const r =
        "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let a;
    for (let o = 0; o < s; o++) {
        let h = r.replace("%index%", o.toString());
        (a = o),
            o >= t && (a = s - o - 1),
            (h = h.replace("%value%", e[a].toString())),
            (i += h),
            (i += `
`);
    }
    return (
        (n = n.replace("%blur%", i)), (n = n.replace("%size%", s.toString())), n
    );
}
const BI = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function FI(s, e) {
    const t = Math.ceil(s / 2);
    let n = BI,
        i = "",
        r;
    e
        ? (r =
              "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);")
        : (r =
              "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);");
    for (let a = 0; a < s; a++) {
        let o = r.replace("%index%", a.toString());
        (o = o.replace("%sampleIndex%", `${a - (t - 1)}.0`)),
            (i += o),
            (i += `
`);
    }
    return (
        (n = n.replace("%blur%", i)),
        (n = n.replace("%size%", s.toString())),
        (n = n.replace("%dimension%", e ? "z" : "w")),
        n
    );
}
function $I(s, e) {
    const t = FI(e, s),
        n = OI(e);
    return vl.from({
        vertex: t,
        fragment: n,
        name: `blur-${s ? "horizontal" : "vertical"}-pass-filter`,
    });
}
var DI = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
function NI(s, e) {
    const t = wC[e],
        n = t.length,
        i = [],
        r = [],
        a = [];
    for (let c = 0; c < e; c++) {
        (i[c] = `@location(${c}) offset${c}: vec2<f32>,`),
            s
                ? (r[c] = `filteredCord + vec2(${
                      c - n + 1
                  } * pixelStrength, 0.0),`)
                : (r[c] = `filteredCord + vec2(0.0, ${
                      c - n + 1
                  } * pixelStrength),`);
        const d = c < n ? c : e - c - 1,
            f = t[d].toString();
        a[
            c
        ] = `finalColor += textureSample(uTexture, uSampler, offset${c}) * ${f};`;
    }
    const o = i.join(`
`),
        h = r.join(`
`),
        l = a.join(`
`),
        u = DI.replace("%blur-struct%", o)
            .replace("%blur-vertex-out%", h)
            .replace("%blur-fragment-in%", o)
            .replace("%blur-sampling%", l)
            .replace("%dimension%", s ? "z" : "w");
    return Hr.from({
        vertex: { source: u, entryPoint: "mainVertex" },
        fragment: { source: u, entryPoint: "mainFragment" },
    });
}
const xC = class CC extends Sd {
    constructor(e) {
        e = { ...CC.defaultOptions, ...e };
        const t = $I(e.horizontal, e.kernelSize),
            n = NI(e.horizontal, e.kernelSize);
        super({
            glProgram: t,
            gpuProgram: n,
            resources: {
                blurUniforms: { uStrength: { value: 0, type: "f32" } },
            },
            ...e,
        }),
            (this.horizontal = e.horizontal),
            (this._quality = 0),
            (this.quality = e.quality),
            (this.blur = e.strength),
            (this._uniforms = this.resources.blurUniforms.uniforms);
    }
    apply(e, t, n, i) {
        if (
            ((this._uniforms.uStrength = this.strength / this.passes),
            this.passes === 1)
        )
            e.applyFilter(this, t, n, i);
        else {
            const r = Gr.getSameSizeTexture(t);
            let a = t,
                o = r;
            this._state.blend = !1;
            const h = e.renderer.type === Fh.WEBGPU;
            for (let l = 0; l < this.passes - 1; l++) {
                e.applyFilter(this, a, o, l === 0 ? !0 : h);
                const u = o;
                (o = a), (a = u);
            }
            (this._state.blend = !0),
                e.applyFilter(this, a, n, i),
                Gr.returnTexture(r);
        }
    }
    get blur() {
        return this.strength;
    }
    set blur(e) {
        (this.padding = 1 + Math.abs(e) * 2), (this.strength = e);
    }
    get quality() {
        return this._quality;
    }
    set quality(e) {
        (this._quality = e), (this.passes = e);
    }
};
xC.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 };
let Zf = xC;
class AC extends Sd {
    constructor(...e) {
        let t = e[0] ?? {};
        typeof t == "number" &&
            (ae(
                Ge,
                "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"
            ),
            (t = { strength: t }),
            e[1] !== void 0 && (t.quality = e[1]),
            e[2] !== void 0 && (t.resolution = e[2] || "inherit"),
            e[3] !== void 0 && (t.kernelSize = e[3])),
            (t = { ...Zf.defaultOptions, ...t });
        const { strength: n, strengthX: i, strengthY: r, quality: a, ...o } = t;
        super({ ...o, compatibleRenderers: Fh.BOTH, resources: {} }),
            (this._repeatEdgePixels = !1),
            (this.blurXFilter = new Zf({ horizontal: !0, ...t })),
            (this.blurYFilter = new Zf({ horizontal: !1, ...t })),
            (this.quality = a),
            (this.strengthX = i ?? n),
            (this.strengthY = r ?? n),
            (this.repeatEdgePixels = !1);
    }
    apply(e, t, n, i) {
        const r = Math.abs(this.blurXFilter.strength),
            a = Math.abs(this.blurYFilter.strength);
        if (r && a) {
            const o = Gr.getSameSizeTexture(t);
            (this.blurXFilter.blendMode = "normal"),
                this.blurXFilter.apply(e, t, o, !0),
                (this.blurYFilter.blendMode = this.blendMode),
                this.blurYFilter.apply(e, o, n, i),
                Gr.returnTexture(o);
        } else
            a
                ? ((this.blurYFilter.blendMode = this.blendMode),
                  this.blurYFilter.apply(e, t, n, i))
                : ((this.blurXFilter.blendMode = this.blendMode),
                  this.blurXFilter.apply(e, t, n, i));
    }
    updatePadding() {
        this._repeatEdgePixels
            ? (this.padding = 0)
            : (this.padding =
                  Math.max(
                      Math.abs(this.blurXFilter.blur),
                      Math.abs(this.blurYFilter.blur)
                  ) * 2);
    }
    get strength() {
        if (this.strengthX !== this.strengthY)
            throw new Error(
                "BlurFilter's strengthX and strengthY are different"
            );
        return this.strengthX;
    }
    set strength(e) {
        (this.blurXFilter.blur = this.blurYFilter.blur = e),
            this.updatePadding();
    }
    get quality() {
        return this.blurXFilter.quality;
    }
    set quality(e) {
        this.blurXFilter.quality = this.blurYFilter.quality = e;
    }
    get strengthX() {
        return this.blurXFilter.blur;
    }
    set strengthX(e) {
        (this.blurXFilter.blur = e), this.updatePadding();
    }
    get strengthY() {
        return this.blurYFilter.blur;
    }
    set strengthY(e) {
        (this.blurYFilter.blur = e), this.updatePadding();
    }
    get blur() {
        return (
            ae(
                "8.3.0",
                "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."
            ),
            this.strength
        );
    }
    set blur(e) {
        ae(
            "8.3.0",
            "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."
        ),
            (this.strength = e);
    }
    get blurX() {
        return (
            ae(
                "8.3.0",
                "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."
            ),
            this.strengthX
        );
    }
    set blurX(e) {
        ae(
            "8.3.0",
            "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."
        ),
            (this.strengthX = e);
    }
    get blurY() {
        return (
            ae(
                "8.3.0",
                "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."
            ),
            this.strengthY
        );
    }
    set blurY(e) {
        ae(
            "8.3.0",
            "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."
        ),
            (this.strengthY = e);
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels;
    }
    set repeatEdgePixels(e) {
        (this._repeatEdgePixels = e), this.updatePadding();
    }
}
AC.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 };
class rl extends Cd {
    constructor(e) {
        e instanceof xs && (e = { context: e });
        const { context: t, roundPixels: n, ...i } = e || {};
        super({ label: "Graphics", ...i }),
            (this.renderPipeId = "graphics"),
            t
                ? (this._context = t)
                : (this._context = this._ownedContext = new xs()),
            this._context.on("update", this.onViewUpdate, this),
            (this.didViewUpdate = !0),
            (this.allowChildren = !1),
            (this.roundPixels = n ?? !1);
    }
    set context(e) {
        e !== this._context &&
            (this._context.off("update", this.onViewUpdate, this),
            (this._context = e),
            this._context.on("update", this.onViewUpdate, this),
            this.onViewUpdate());
    }
    get context() {
        return this._context;
    }
    get bounds() {
        return this._context.bounds;
    }
    updateBounds() {}
    containsPoint(e) {
        return this._context.containsPoint(e);
    }
    destroy(e) {
        this._ownedContext && !e
            ? this._ownedContext.destroy(e)
            : (e === !0 || (e == null ? void 0 : e.context) === !0) &&
              this._context.destroy(e),
            (this._ownedContext = null),
            (this._context = null),
            super.destroy(e);
    }
    _callContextMethod(e, t) {
        return this.context[e](...t), this;
    }
    setFillStyle(...e) {
        return this._callContextMethod("setFillStyle", e);
    }
    setStrokeStyle(...e) {
        return this._callContextMethod("setStrokeStyle", e);
    }
    fill(...e) {
        return this._callContextMethod("fill", e);
    }
    stroke(...e) {
        return this._callContextMethod("stroke", e);
    }
    texture(...e) {
        return this._callContextMethod("texture", e);
    }
    beginPath() {
        return this._callContextMethod("beginPath", []);
    }
    cut() {
        return this._callContextMethod("cut", []);
    }
    arc(...e) {
        return this._callContextMethod("arc", e);
    }
    arcTo(...e) {
        return this._callContextMethod("arcTo", e);
    }
    arcToSvg(...e) {
        return this._callContextMethod("arcToSvg", e);
    }
    bezierCurveTo(...e) {
        return this._callContextMethod("bezierCurveTo", e);
    }
    closePath() {
        return this._callContextMethod("closePath", []);
    }
    ellipse(...e) {
        return this._callContextMethod("ellipse", e);
    }
    circle(...e) {
        return this._callContextMethod("circle", e);
    }
    path(...e) {
        return this._callContextMethod("path", e);
    }
    lineTo(...e) {
        return this._callContextMethod("lineTo", e);
    }
    moveTo(...e) {
        return this._callContextMethod("moveTo", e);
    }
    quadraticCurveTo(...e) {
        return this._callContextMethod("quadraticCurveTo", e);
    }
    rect(...e) {
        return this._callContextMethod("rect", e);
    }
    roundRect(...e) {
        return this._callContextMethod("roundRect", e);
    }
    poly(...e) {
        return this._callContextMethod("poly", e);
    }
    regularPoly(...e) {
        return this._callContextMethod("regularPoly", e);
    }
    roundPoly(...e) {
        return this._callContextMethod("roundPoly", e);
    }
    roundShape(...e) {
        return this._callContextMethod("roundShape", e);
    }
    filletRect(...e) {
        return this._callContextMethod("filletRect", e);
    }
    chamferRect(...e) {
        return this._callContextMethod("chamferRect", e);
    }
    star(...e) {
        return this._callContextMethod("star", e);
    }
    svg(...e) {
        return this._callContextMethod("svg", e);
    }
    restore(...e) {
        return this._callContextMethod("restore", e);
    }
    save() {
        return this._callContextMethod("save", []);
    }
    getTransform() {
        return this.context.getTransform();
    }
    resetTransform() {
        return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...e) {
        return this._callContextMethod("rotate", e);
    }
    scaleTransform(...e) {
        return this._callContextMethod("scale", e);
    }
    setTransform(...e) {
        return this._callContextMethod("setTransform", e);
    }
    transform(...e) {
        return this._callContextMethod("transform", e);
    }
    translateTransform(...e) {
        return this._callContextMethod("translate", e);
    }
    clear() {
        return this._callContextMethod("clear", []);
    }
    get fillStyle() {
        return this._context.fillStyle;
    }
    set fillStyle(e) {
        this._context.fillStyle = e;
    }
    get strokeStyle() {
        return this._context.strokeStyle;
    }
    set strokeStyle(e) {
        this._context.strokeStyle = e;
    }
    clone(e = !1) {
        return e
            ? new rl(this._context.clone())
            : ((this._ownedContext = null), new rl(this._context));
    }
    lineStyle(e, t, n) {
        ae(
            Ge,
            "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."
        );
        const i = {};
        return (
            e && (i.width = e),
            t && (i.color = t),
            n && (i.alpha = n),
            (this.context.strokeStyle = i),
            this
        );
    }
    beginFill(e, t) {
        ae(
            Ge,
            "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
        );
        const n = {};
        return (
            e !== void 0 && (n.color = e),
            t !== void 0 && (n.alpha = t),
            (this.context.fillStyle = n),
            this
        );
    }
    endFill() {
        ae(
            Ge,
            "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
        ),
            this.context.fill();
        const e = this.context.strokeStyle;
        return (
            (e.width !== xs.defaultStrokeStyle.width ||
                e.color !== xs.defaultStrokeStyle.color ||
                e.alpha !== xs.defaultStrokeStyle.alpha) &&
                this.context.stroke(),
            this
        );
    }
    drawCircle(...e) {
        return (
            ae(Ge, "Graphics#drawCircle has been renamed to Graphics#circle"),
            this._callContextMethod("circle", e)
        );
    }
    drawEllipse(...e) {
        return (
            ae(Ge, "Graphics#drawEllipse has been renamed to Graphics#ellipse"),
            this._callContextMethod("ellipse", e)
        );
    }
    drawPolygon(...e) {
        return (
            ae(Ge, "Graphics#drawPolygon has been renamed to Graphics#poly"),
            this._callContextMethod("poly", e)
        );
    }
    drawRect(...e) {
        return (
            ae(Ge, "Graphics#drawRect has been renamed to Graphics#rect"),
            this._callContextMethod("rect", e)
        );
    }
    drawRoundedRect(...e) {
        return (
            ae(
                Ge,
                "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"
            ),
            this._callContextMethod("roundRect", e)
        );
    }
    drawStar(...e) {
        return (
            ae(Ge, "Graphics#drawStar has been renamed to Graphics#star"),
            this._callContextMethod("star", e)
        );
    }
}
class VI extends Cd {
    constructor(e, t) {
        const {
            text: n,
            resolution: i,
            style: r,
            anchor: a,
            width: o,
            height: h,
            roundPixels: l,
            ...u
        } = e;
        super({ ...u }),
            (this.batched = !0),
            (this._resolution = null),
            (this._autoResolution = !0),
            (this._didTextUpdate = !0),
            (this._styleClass = t),
            (this.text = n ?? ""),
            (this.style = r),
            (this.resolution = i ?? null),
            (this.allowChildren = !1),
            (this._anchor = new Wt({
                _onUpdate: () => {
                    this.onViewUpdate();
                },
            })),
            a && (this.anchor = a),
            (this.roundPixels = l ?? !1),
            o !== void 0 && (this.width = o),
            h !== void 0 && (this.height = h);
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    set text(e) {
        (e = e.toString()),
            this._text !== e && ((this._text = e), this.onViewUpdate());
    }
    get text() {
        return this._text;
    }
    set resolution(e) {
        (this._autoResolution = e === null),
            (this._resolution = e),
            this.onViewUpdate();
    }
    get resolution() {
        return this._resolution;
    }
    get style() {
        return this._style;
    }
    set style(e) {
        var t;
        e || (e = {}),
            (t = this._style) == null ||
                t.off("update", this.onViewUpdate, this),
            e instanceof this._styleClass
                ? (this._style = e)
                : (this._style = new this._styleClass(e)),
            this._style.on("update", this.onViewUpdate, this),
            this.onViewUpdate();
    }
    get width() {
        return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(e) {
        this._setWidth(e, this.bounds.width);
    }
    get height() {
        return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(e) {
        this._setHeight(e, this.bounds.height);
    }
    getSize(e) {
        return (
            e || (e = {}),
            (e.width = Math.abs(this.scale.x) * this.bounds.width),
            (e.height = Math.abs(this.scale.y) * this.bounds.height),
            e
        );
    }
    setSize(e, t) {
        typeof e == "object"
            ? ((t = e.height ?? e.width), (e = e.width))
            : t ?? (t = e),
            e !== void 0 && this._setWidth(e, this.bounds.width),
            t !== void 0 && this._setHeight(t, this.bounds.height);
    }
    containsPoint(e) {
        const t = this.bounds.width,
            n = this.bounds.height,
            i = -t * this.anchor.x;
        let r = 0;
        return (
            e.x >= i &&
            e.x <= i + t &&
            ((r = -n * this.anchor.y), e.y >= r && e.y <= r + n)
        );
    }
    onViewUpdate() {
        this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
    }
    destroy(e = !1) {
        super.destroy(e),
            (this.owner = null),
            (this._bounds = null),
            (this._anchor = null),
            (typeof e == "boolean" ? e : e != null && e.style) &&
                this._style.destroy(e),
            (this._style = null),
            (this._text = null);
    }
    get styleKey() {
        return `${this._text}:${this._style.styleKey}:${this._resolution}`;
    }
}
function UI(s, e) {
    let t = s[0] ?? {};
    return (
        (typeof t == "string" || s[1]) &&
            (ae(Ge, `use new ${e}({ text: "hi!", style }) instead`),
            (t = { text: t, style: s[1] })),
        t
    );
}
class SC extends VI {
    constructor(...e) {
        var t;
        const n = UI(e, "BitmapText");
        n.style ?? (n.style = n.style || {}),
            (t = n.style).fill ?? (t.fill = 16777215),
            super(n, Uh),
            (this.renderPipeId = "bitmapText");
    }
    updateBounds() {
        const e = this._bounds,
            t = this._anchor,
            n = ym.measureText(this.text, this._style),
            i = n.scale,
            r = n.offsetY * i;
        let a = n.width * i,
            o = n.height * i;
        const h = this._style._stroke;
        h && ((a += h.width), (o += h.width)),
            (e.minX = -t._x * a),
            (e.maxX = e.minX + a),
            (e.minY = -t._y * (o + r)),
            (e.maxY = e.minY + o);
    }
    set resolution(e) {
        e !== null &&
            it(
                "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
            );
    }
    get resolution() {
        return this._resolution;
    }
}
function zI(s, e, t) {
    ae("8.7.0", "Please use container.collectRenderables instead.");
    const n = t.renderPipes ? t : t.batch.renderer;
    return s.collectRenderables(e, n, null);
}
const EC = class PC extends hn {
    constructor(e = {}) {
        (e = { ...PC.defaultOptions, ...e }),
            super(),
            (this.renderLayerChildren = []),
            (this.sortableChildren = e.sortableChildren),
            (this.sortFunction = e.sortFunction);
    }
    attach(...e) {
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            if (n.parentRenderLayer) {
                if (n.parentRenderLayer === this) continue;
                n.parentRenderLayer.detach(n);
            }
            this.renderLayerChildren.push(n), (n.parentRenderLayer = this);
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0);
        }
        return e[0];
    }
    detach(...e) {
        for (let t = 0; t < e.length; t++) {
            const n = e[t],
                i = this.renderLayerChildren.indexOf(n);
            i !== -1 && this.renderLayerChildren.splice(i, 1),
                (n.parentRenderLayer = null);
            const r = this.renderGroup || this.parentRenderGroup;
            r && (r.structureDidChange = !0);
        }
        return e[0];
    }
    detachAll() {
        const e = this.renderLayerChildren;
        for (let t = 0; t < e.length; t++) e[t].parentRenderLayer = null;
        this.renderLayerChildren.length = 0;
    }
    collectRenderables(e, t, n) {
        const i = this.renderLayerChildren,
            r = i.length;
        this.sortableChildren && this.sortRenderLayerChildren();
        for (let a = 0; a < r; a++)
            i[a].parent ||
                it(
                    "Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)",
                    i[a]
                ),
                i[a].collectRenderables(e, t, this);
    }
    sortRenderLayerChildren() {
        this.renderLayerChildren.sort(this.sortFunction);
    }
    _getGlobalBoundsRecursive(e, t, n) {
        if (!e) return;
        const i = this.renderLayerChildren;
        for (let r = 0; r < i.length; r++)
            i[r]._getGlobalBoundsRecursive(!0, t, this);
    }
};
EC.defaultOptions = {
    sortableChildren: !1,
    sortFunction: (s, e) => s.zIndex - e.zIndex,
};
let YI = EC;
const zc = YI;
Ot.add(Qk, Jk);
if (typeof window < "u" && window.PIXI) {
    const s = window.require;
    window.require = (e) => {
        if (s) return s(e);
        if (e.startsWith("@pixi/") || e.startsWith("pixi.js"))
            return window.PIXI;
    };
}
class kC {
    constructor() {
        x(this, "entries", {});
        x(this, "size", 0);
    }
    add(e) {
        let t = this.entries[e];
        return (this.entries[e] = !0), t ? !1 : (this.size++, !0);
    }
    addAll(e) {
        let t = this.size;
        for (var n = 0, i = e.length; n < i; n++) this.add(e[n]);
        return t != this.size;
    }
    contains(e) {
        return this.entries[e];
    }
    clear() {
        (this.entries = {}), (this.size = 0);
    }
}
const Zn = class Zn {
    constructor(e = 0, t = 0, n = 0, i = 0) {
        x(this, "r");
        x(this, "g");
        x(this, "b");
        x(this, "a");
        (this.r = e), (this.g = t), (this.b = n), (this.a = i);
    }
    set(e, t, n, i) {
        return (
            (this.r = e), (this.g = t), (this.b = n), (this.a = i), this.clamp()
        );
    }
    setFromColor(e) {
        return (
            (this.r = e.r), (this.g = e.g), (this.b = e.b), (this.a = e.a), this
        );
    }
    setFromString(e) {
        return (
            (e = e.charAt(0) == "#" ? e.substr(1) : e),
            (this.r = parseInt(e.substr(0, 2), 16) / 255),
            (this.g = parseInt(e.substr(2, 2), 16) / 255),
            (this.b = parseInt(e.substr(4, 2), 16) / 255),
            (this.a = e.length != 8 ? 1 : parseInt(e.substr(6, 2), 16) / 255),
            this
        );
    }
    add(e, t, n, i) {
        return (
            (this.r += e),
            (this.g += t),
            (this.b += n),
            (this.a += i),
            this.clamp()
        );
    }
    clamp() {
        return (
            this.r < 0 ? (this.r = 0) : this.r > 1 && (this.r = 1),
            this.g < 0 ? (this.g = 0) : this.g > 1 && (this.g = 1),
            this.b < 0 ? (this.b = 0) : this.b > 1 && (this.b = 1),
            this.a < 0 ? (this.a = 0) : this.a > 1 && (this.a = 1),
            this
        );
    }
    static rgba8888ToColor(e, t) {
        (e.r = ((t & 4278190080) >>> 24) / 255),
            (e.g = ((t & 16711680) >>> 16) / 255),
            (e.b = ((t & 65280) >>> 8) / 255),
            (e.a = (t & 255) / 255);
    }
    static rgb888ToColor(e, t) {
        (e.r = ((t & 16711680) >>> 16) / 255),
            (e.g = ((t & 65280) >>> 8) / 255),
            (e.b = (t & 255) / 255);
    }
    toRgb888() {
        const e = (t) => ("0" + (t * 255).toString(16)).slice(-2);
        return +("0x" + e(this.r) + e(this.g) + e(this.b));
    }
    static fromString(e, t = new Zn()) {
        return t.setFromString(e);
    }
};
x(Zn, "WHITE", new Zn(1, 1, 1, 1)),
    x(Zn, "RED", new Zn(1, 0, 0, 1)),
    x(Zn, "GREEN", new Zn(0, 1, 0, 1)),
    x(Zn, "BLUE", new Zn(0, 0, 1, 1)),
    x(Zn, "MAGENTA", new Zn(1, 0, 1, 1));
let he = Zn;
const Ut = class Ut {
    static clamp(e, t, n) {
        return e < t ? t : e > n ? n : e;
    }
    static cosDeg(e) {
        return Math.cos(e * Ut.degRad);
    }
    static sinDeg(e) {
        return Math.sin(e * Ut.degRad);
    }
    static atan2Deg(e, t) {
        return Math.atan2(e, t) * Ut.degRad;
    }
    static signum(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    static toInt(e) {
        return e > 0 ? Math.floor(e) : Math.ceil(e);
    }
    static cbrt(e) {
        let t = Math.pow(Math.abs(e), 0.3333333333333333);
        return e < 0 ? -t : t;
    }
    static randomTriangular(e, t) {
        return Ut.randomTriangularWith(e, t, (e + t) * 0.5);
    }
    static randomTriangularWith(e, t, n) {
        let i = Math.random(),
            r = t - e;
        return i <= (n - e) / r
            ? e + Math.sqrt(i * r * (n - e))
            : t - Math.sqrt((1 - i) * r * (t - n));
    }
    static isPowerOfTwo(e) {
        return e && (e & (e - 1)) === 0;
    }
};
x(Ut, "PI", 3.1415927),
    x(Ut, "PI2", Ut.PI * 2),
    x(Ut, "invPI2", 1 / Ut.PI2),
    x(Ut, "radiansToDegrees", 180 / Ut.PI),
    x(Ut, "radDeg", Ut.radiansToDegrees),
    x(Ut, "degreesToRadians", Ut.PI / 180),
    x(Ut, "degRad", Ut.degreesToRadians);
let q = Ut;
const yr = class yr {
    static arrayCopy(e, t, n, i, r) {
        for (let a = t, o = i; a < t + r; a++, o++) n[o] = e[a];
    }
    static arrayFill(e, t, n, i) {
        for (let r = t; r < n; r++) e[r] = i;
    }
    static setArraySize(e, t, n = 0) {
        let i = e.length;
        if (i == t) return e;
        if (((e.length = t), i < t)) for (let r = i; r < t; r++) e[r] = n;
        return e;
    }
    static ensureArrayCapacity(e, t, n = 0) {
        return e.length >= t ? e : yr.setArraySize(e, t, n);
    }
    static newArray(e, t) {
        let n = new Array(e);
        for (let i = 0; i < e; i++) n[i] = t;
        return n;
    }
    static newFloatArray(e) {
        if (yr.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
        {
            let t = new Array(e);
            for (let n = 0; n < t.length; n++) t[n] = 0;
            return t;
        }
    }
    static newShortArray(e) {
        if (yr.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
        {
            let t = new Array(e);
            for (let n = 0; n < t.length; n++) t[n] = 0;
            return t;
        }
    }
    static toFloatArray(e) {
        return yr.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
    }
    static toSinglePrecision(e) {
        return yr.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
    }
    static webkit602BugfixHelper(e, t) {}
    static contains(e, t, n = !0) {
        for (var i = 0; i < e.length; i++) if (e[i] == t) return !0;
        return !1;
    }
    static enumValue(e, t) {
        return e[t[0].toUpperCase() + t.slice(1)];
    }
};
x(yr, "SUPPORTS_TYPED_ARRAYS", typeof Float32Array < "u");
let K = yr;
class zh {
    constructor(e) {
        x(this, "items", new Array());
        x(this, "instantiator");
        this.instantiator = e;
    }
    obtain() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator();
    }
    free(e) {
        e.reset && e.reset(), this.items.push(e);
    }
    freeAll(e) {
        for (let t = 0; t < e.length; t++) this.free(e[t]);
    }
    clear() {
        this.items.length = 0;
    }
}
class Ou {
    constructor(e = 0, t = 0) {
        x(this, "x");
        x(this, "y");
        (this.x = e), (this.y = t);
    }
    set(e, t) {
        return (this.x = e), (this.y = t), this;
    }
    length() {
        let e = this.x,
            t = this.y;
        return Math.sqrt(e * e + t * t);
    }
    normalize() {
        let e = this.length();
        return e != 0 && ((this.x /= e), (this.y /= e)), this;
    }
}
class TC {
    constructor(e) {
        x(this, "name");
        if (!e) throw new Error("name cannot be null.");
        this.name = e;
    }
}
const sd = class sd extends TC {
    constructor(t) {
        super(t);
        x(this, "id", sd.nextID++);
        x(this, "bones", null);
        x(this, "vertices", []);
        x(this, "worldVerticesLength", 0);
        x(this, "timelineAttachment", this);
    }
    computeWorldVertices(t, n, i, r, a, o) {
        i = a + (i >> 1) * o;
        let h = t.bone.skeleton,
            l = t.deform,
            u = this.vertices,
            c = this.bones;
        if (!c) {
            l.length > 0 && (u = l);
            let m = t.bone,
                g = m.worldX,
                _ = m.worldY,
                v = m.a,
                b = m.b,
                y = m.c,
                C = m.d;
            for (let w = n, A = a; A < i; w += 2, A += o) {
                let E = u[w],
                    S = u[w + 1];
                (r[A] = E * v + S * b + g), (r[A + 1] = E * y + S * C + _);
            }
            return;
        }
        let d = 0,
            f = 0;
        for (let m = 0; m < n; m += 2) {
            let g = c[d];
            (d += g + 1), (f += g);
        }
        let p = h.bones;
        if (l.length == 0)
            for (let m = a, g = f * 3; m < i; m += o) {
                let _ = 0,
                    v = 0,
                    b = c[d++];
                for (b += d; d < b; d++, g += 3) {
                    let y = p[c[d]],
                        C = u[g],
                        w = u[g + 1],
                        A = u[g + 2];
                    (_ += (C * y.a + w * y.b + y.worldX) * A),
                        (v += (C * y.c + w * y.d + y.worldY) * A);
                }
                (r[m] = _), (r[m + 1] = v);
            }
        else {
            let m = l;
            for (let g = a, _ = f * 3, v = f << 1; g < i; g += o) {
                let b = 0,
                    y = 0,
                    C = c[d++];
                for (C += d; d < C; d++, _ += 3, v += 2) {
                    let w = p[c[d]],
                        A = u[_] + m[v],
                        E = u[_ + 1] + m[v + 1],
                        S = u[_ + 2];
                    (b += (A * w.a + E * w.b + w.worldX) * S),
                        (y += (A * w.c + E * w.d + w.worldY) * S);
                }
                (r[g] = b), (r[g + 1] = y);
            }
        }
    }
    copyTo(t) {
        this.bones
            ? ((t.bones = new Array(this.bones.length)),
              K.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length))
            : (t.bones = null),
            this.vertices &&
                ((t.vertices = K.newFloatArray(this.vertices.length)),
                K.arrayCopy(
                    this.vertices,
                    0,
                    t.vertices,
                    0,
                    this.vertices.length
                )),
            (t.worldVerticesLength = this.worldVerticesLength),
            (t.timelineAttachment = this.timelineAttachment);
    }
};
x(sd, "nextID", 0);
let Ks = sd;
const Co = class Co {
    constructor(e) {
        x(this, "id", Co.nextID());
        x(this, "regions");
        x(this, "start", 0);
        x(this, "digits", 0);
        x(this, "setupIndex", 0);
        this.regions = new Array(e);
    }
    copy() {
        let e = new Co(this.regions.length);
        return (
            K.arrayCopy(this.regions, 0, e.regions, 0, this.regions.length),
            (e.start = this.start),
            (e.digits = this.digits),
            (e.setupIndex = this.setupIndex),
            e
        );
    }
    apply(e, t) {
        let n = e.sequenceIndex;
        n == -1 && (n = this.setupIndex),
            n >= this.regions.length && (n = this.regions.length - 1);
        let i = this.regions[n];
        t.region != i && ((t.region = i), t.updateRegion());
    }
    getPath(e, t) {
        let n = e,
            i = (this.start + t).toString();
        for (let r = this.digits - i.length; r > 0; r--) n += "0";
        return (n += i), n;
    }
    static nextID() {
        return Co._nextID++;
    }
};
x(Co, "_nextID", 0);
let Bu = Co;
var sn;
(function (s) {
    (s[(s.hold = 0)] = "hold"),
        (s[(s.once = 1)] = "once"),
        (s[(s.loop = 2)] = "loop"),
        (s[(s.pingpong = 3)] = "pingpong"),
        (s[(s.onceReverse = 4)] = "onceReverse"),
        (s[(s.loopReverse = 5)] = "loopReverse"),
        (s[(s.pingpongReverse = 6)] = "pingpongReverse");
})(sn || (sn = {}));
const MC = [
    sn.hold,
    sn.once,
    sn.loop,
    sn.pingpong,
    sn.onceReverse,
    sn.loopReverse,
    sn.pingpongReverse,
];
class zg {
    constructor(e, t, n) {
        x(this, "name");
        x(this, "timelines", []);
        x(this, "timelineIds", new kC());
        x(this, "duration");
        if (!e) throw new Error("name cannot be null.");
        (this.name = e), this.setTimelines(t), (this.duration = n);
    }
    setTimelines(e) {
        if (!e) throw new Error("timelines cannot be null.");
        (this.timelines = e), this.timelineIds.clear();
        for (var t = 0; t < e.length; t++)
            this.timelineIds.addAll(e[t].getPropertyIds());
    }
    hasTimeline(e) {
        for (let t = 0; t < e.length; t++)
            if (this.timelineIds.contains(e[t])) return !0;
        return !1;
    }
    apply(e, t, n, i, r, a, o, h) {
        if (!e) throw new Error("skeleton cannot be null.");
        i &&
            this.duration != 0 &&
            ((n %= this.duration), t > 0 && (t %= this.duration));
        let l = this.timelines;
        for (let u = 0, c = l.length; u < c; u++)
            l[u].apply(e, t, n, r, a, o, h);
    }
}
var z;
(function (s) {
    (s[(s.setup = 0)] = "setup"),
        (s[(s.first = 1)] = "first"),
        (s[(s.replace = 2)] = "replace"),
        (s[(s.add = 3)] = "add");
})(z || (z = {}));
var fn;
(function (s) {
    (s[(s.mixIn = 0)] = "mixIn"), (s[(s.mixOut = 1)] = "mixOut");
})(fn || (fn = {}));
const ge = {
    rotate: 0,
    x: 1,
    y: 2,
    scaleX: 3,
    scaleY: 4,
    shearX: 5,
    shearY: 6,
    inherit: 7,
    rgb: 8,
    alpha: 9,
    rgb2: 10,
    attachment: 11,
    deform: 12,
    event: 13,
    drawOrder: 14,
    ikConstraint: 15,
    transformConstraint: 16,
    pathConstraintPosition: 17,
    pathConstraintSpacing: 18,
    pathConstraintMix: 19,
    physicsConstraintInertia: 20,
    physicsConstraintStrength: 21,
    physicsConstraintDamping: 22,
    physicsConstraintMass: 23,
    physicsConstraintWind: 24,
    physicsConstraintGravity: 25,
    physicsConstraintMix: 26,
    physicsConstraintReset: 27,
    sequence: 28,
};
class dt {
    constructor(e, t) {
        x(this, "propertyIds");
        x(this, "frames");
        (this.propertyIds = t),
            (this.frames = K.newFloatArray(e * this.getFrameEntries()));
    }
    getPropertyIds() {
        return this.propertyIds;
    }
    getFrameEntries() {
        return 1;
    }
    getFrameCount() {
        return this.frames.length / this.getFrameEntries();
    }
    getDuration() {
        return this.frames[this.frames.length - this.getFrameEntries()];
    }
    static search1(e, t) {
        let n = e.length;
        for (let i = 1; i < n; i++) if (e[i] > t) return i - 1;
        return n - 1;
    }
    static search(e, t, n) {
        let i = e.length;
        for (let r = n; r < i; r += n) if (e[r] > t) return r - n;
        return i - n;
    }
}
class Ri extends dt {
    constructor(t, n, i) {
        super(t, i);
        x(this, "curves");
        (this.curves = K.newFloatArray(t + n * 18)), (this.curves[t - 1] = 1);
    }
    setLinear(t) {
        this.curves[t] = 0;
    }
    setStepped(t) {
        this.curves[t] = 1;
    }
    shrink(t) {
        let n = this.getFrameCount() + t * 18;
        if (this.curves.length > n) {
            let i = K.newFloatArray(n);
            K.arrayCopy(this.curves, 0, i, 0, n), (this.curves = i);
        }
    }
    setBezier(t, n, i, r, a, o, h, l, u, c, d) {
        let f = this.curves,
            p = this.getFrameCount() + t * 18;
        i == 0 && (f[n] = 2 + p);
        let m = (r - o * 2 + l) * 0.03,
            g = (a - h * 2 + u) * 0.03,
            _ = ((o - l) * 3 - r + c) * 0.006,
            v = ((h - u) * 3 - a + d) * 0.006,
            b = m * 2 + _,
            y = g * 2 + v,
            C = (o - r) * 0.3 + m + _ * 0.16666667,
            w = (h - a) * 0.3 + g + v * 0.16666667,
            A = r + C,
            E = a + w;
        for (let S = p + 18; p < S; p += 2)
            (f[p] = A),
                (f[p + 1] = E),
                (C += b),
                (w += y),
                (b += _),
                (y += v),
                (A += C),
                (E += w);
    }
    getBezierValue(t, n, i, r) {
        let a = this.curves;
        if (a[r] > t) {
            let u = this.frames[n],
                c = this.frames[n + i];
            return c + ((t - u) / (a[r] - u)) * (a[r + 1] - c);
        }
        let o = r + 18;
        for (r += 2; r < o; r += 2)
            if (a[r] >= t) {
                let u = a[r - 2],
                    c = a[r - 1];
                return c + ((t - u) / (a[r] - u)) * (a[r + 1] - c);
            }
        n += this.getFrameEntries();
        let h = a[o - 2],
            l = a[o - 1];
        return l + ((t - h) / (this.frames[n] - h)) * (this.frames[n + i] - l);
    }
}
class si extends Ri {
    constructor(e, t, n) {
        super(e, t, [n]);
    }
    getFrameEntries() {
        return 2;
    }
    setFrame(e, t, n) {
        (e <<= 1), (this.frames[e] = t), (this.frames[e + 1] = n);
    }
    getCurveValue(e) {
        let t = this.frames,
            n = t.length - 2;
        for (let r = 2; r <= n; r += 2)
            if (t[r] > e) {
                n = r - 2;
                break;
            }
        let i = this.curves[n >> 1];
        switch (i) {
            case 0:
                let r = t[n],
                    a = t[n + 1];
                return a + ((e - r) / (t[n + 2] - r)) * (t[n + 2 + 1] - a);
            case 1:
                return t[n + 1];
        }
        return this.getBezierValue(e, n, 1, i - 2);
    }
    getRelativeValue(e, t, n, i, r) {
        if (e < this.frames[0]) {
            switch (n) {
                case z.setup:
                    return r;
                case z.first:
                    return i + (r - i) * t;
            }
            return i;
        }
        let a = this.getCurveValue(e);
        switch (n) {
            case z.setup:
                return r + a * t;
            case z.first:
            case z.replace:
                a += r - i;
        }
        return i + a * t;
    }
    getAbsoluteValue(e, t, n, i, r) {
        if (e < this.frames[0]) {
            switch (n) {
                case z.setup:
                    return r;
                case z.first:
                    return i + (r - i) * t;
            }
            return i;
        }
        let a = this.getCurveValue(e);
        return n == z.setup ? r + (a - r) * t : i + (a - i) * t;
    }
    getAbsoluteValue2(e, t, n, i, r, a) {
        if (e < this.frames[0]) {
            switch (n) {
                case z.setup:
                    return r;
                case z.first:
                    return i + (r - i) * t;
            }
            return i;
        }
        return n == z.setup ? r + (a - r) * t : i + (a - i) * t;
    }
    getScaleValue(e, t, n, i, r, a) {
        const o = this.frames;
        if (e < o[0]) {
            switch (n) {
                case z.setup:
                    return a;
                case z.first:
                    return r + (a - r) * t;
            }
            return r;
        }
        let h = this.getCurveValue(e) * a;
        if (t == 1) return n == z.add ? r + h - a : h;
        if (i == fn.mixOut)
            switch (n) {
                case z.setup:
                    return a + (Math.abs(h) * q.signum(a) - a) * t;
                case z.first:
                case z.replace:
                    return r + (Math.abs(h) * q.signum(r) - r) * t;
            }
        else {
            let l = 0;
            switch (n) {
                case z.setup:
                    return (l = Math.abs(a) * q.signum(h)), l + (h - l) * t;
                case z.first:
                case z.replace:
                    return (l = Math.abs(r) * q.signum(h)), l + (h - l) * t;
            }
        }
        return r + (h - a) * t;
    }
}
class Yg extends Ri {
    constructor(e, t, n, i) {
        super(e, t, [n, i]);
    }
    getFrameEntries() {
        return 3;
    }
    setFrame(e, t, n, i) {
        (e *= 3),
            (this.frames[e] = t),
            (this.frames[e + 1] = n),
            (this.frames[e + 2] = i);
    }
}
class Fu extends si {
    constructor(t, n, i) {
        super(t, n, ge.rotate + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active &&
            (l.rotation = this.getRelativeValue(
                i,
                a,
                o,
                l.rotation,
                l.data.rotation
            ));
    }
}
class IC extends Yg {
    constructor(t, n, i) {
        super(t, n, ge.x + "|" + i, ge.y + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            switch (o) {
                case z.setup:
                    (l.x = l.data.x), (l.y = l.data.y);
                    return;
                case z.first:
                    (l.x += (l.data.x - l.x) * a),
                        (l.y += (l.data.y - l.y) * a);
            }
            return;
        }
        let c = 0,
            d = 0,
            f = dt.search(u, i, 3),
            p = this.curves[f / 3];
        switch (p) {
            case 0:
                let m = u[f];
                (c = u[f + 1]), (d = u[f + 2]);
                let g = (i - m) / (u[f + 3] - m);
                (c += (u[f + 3 + 1] - c) * g), (d += (u[f + 3 + 2] - d) * g);
                break;
            case 1:
                (c = u[f + 1]), (d = u[f + 2]);
                break;
            default:
                (c = this.getBezierValue(i, f, 1, p - 2)),
                    (d = this.getBezierValue(i, f, 2, p + 18 - 2));
        }
        switch (o) {
            case z.setup:
                (l.x = l.data.x + c * a), (l.y = l.data.y + d * a);
                break;
            case z.first:
            case z.replace:
                (l.x += (l.data.x + c - l.x) * a),
                    (l.y += (l.data.y + d - l.y) * a);
                break;
            case z.add:
                (l.x += c * a), (l.y += d * a);
        }
    }
}
class RC extends si {
    constructor(t, n, i) {
        super(t, n, ge.x + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active && (l.x = this.getRelativeValue(i, a, o, l.x, l.data.x));
    }
}
class LC extends si {
    constructor(t, n, i) {
        super(t, n, ge.y + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active && (l.y = this.getRelativeValue(i, a, o, l.y, l.data.y));
    }
}
class OC extends Yg {
    constructor(t, n, i) {
        super(t, n, ge.scaleX + "|" + i, ge.scaleY + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            switch (o) {
                case z.setup:
                    (l.scaleX = l.data.scaleX), (l.scaleY = l.data.scaleY);
                    return;
                case z.first:
                    (l.scaleX += (l.data.scaleX - l.scaleX) * a),
                        (l.scaleY += (l.data.scaleY - l.scaleY) * a);
            }
            return;
        }
        let c,
            d,
            f = dt.search(u, i, 3),
            p = this.curves[f / 3];
        switch (p) {
            case 0:
                let m = u[f];
                (c = u[f + 1]), (d = u[f + 2]);
                let g = (i - m) / (u[f + 3] - m);
                (c += (u[f + 3 + 1] - c) * g), (d += (u[f + 3 + 2] - d) * g);
                break;
            case 1:
                (c = u[f + 1]), (d = u[f + 2]);
                break;
            default:
                (c = this.getBezierValue(i, f, 1, p - 2)),
                    (d = this.getBezierValue(i, f, 2, p + 18 - 2));
        }
        if (((c *= l.data.scaleX), (d *= l.data.scaleY), a == 1))
            o == z.add
                ? ((l.scaleX += c - l.data.scaleX),
                  (l.scaleY += d - l.data.scaleY))
                : ((l.scaleX = c), (l.scaleY = d));
        else {
            let m = 0,
                g = 0;
            if (h == fn.mixOut)
                switch (o) {
                    case z.setup:
                        (m = l.data.scaleX),
                            (g = l.data.scaleY),
                            (l.scaleX =
                                m + (Math.abs(c) * q.signum(m) - m) * a),
                            (l.scaleY =
                                g + (Math.abs(d) * q.signum(g) - g) * a);
                        break;
                    case z.first:
                    case z.replace:
                        (m = l.scaleX),
                            (g = l.scaleY),
                            (l.scaleX =
                                m + (Math.abs(c) * q.signum(m) - m) * a),
                            (l.scaleY =
                                g + (Math.abs(d) * q.signum(g) - g) * a);
                        break;
                    case z.add:
                        (l.scaleX += (c - l.data.scaleX) * a),
                            (l.scaleY += (d - l.data.scaleY) * a);
                }
            else
                switch (o) {
                    case z.setup:
                        (m = Math.abs(l.data.scaleX) * q.signum(c)),
                            (g = Math.abs(l.data.scaleY) * q.signum(d)),
                            (l.scaleX = m + (c - m) * a),
                            (l.scaleY = g + (d - g) * a);
                        break;
                    case z.first:
                    case z.replace:
                        (m = Math.abs(l.scaleX) * q.signum(c)),
                            (g = Math.abs(l.scaleY) * q.signum(d)),
                            (l.scaleX = m + (c - m) * a),
                            (l.scaleY = g + (d - g) * a);
                        break;
                    case z.add:
                        (l.scaleX += (c - l.data.scaleX) * a),
                            (l.scaleY += (d - l.data.scaleY) * a);
                }
        }
    }
}
class BC extends si {
    constructor(t, n, i) {
        super(t, n, ge.scaleX + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active &&
            (l.scaleX = this.getScaleValue(
                i,
                a,
                o,
                h,
                l.scaleX,
                l.data.scaleX
            ));
    }
}
class FC extends si {
    constructor(t, n, i) {
        super(t, n, ge.scaleY + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active &&
            (l.scaleY = this.getScaleValue(
                i,
                a,
                o,
                h,
                l.scaleY,
                l.data.scaleY
            ));
    }
}
class $C extends Yg {
    constructor(t, n, i) {
        super(t, n, ge.shearX + "|" + i, ge.shearY + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            switch (o) {
                case z.setup:
                    (l.shearX = l.data.shearX), (l.shearY = l.data.shearY);
                    return;
                case z.first:
                    (l.shearX += (l.data.shearX - l.shearX) * a),
                        (l.shearY += (l.data.shearY - l.shearY) * a);
            }
            return;
        }
        let c = 0,
            d = 0,
            f = dt.search(u, i, 3),
            p = this.curves[f / 3];
        switch (p) {
            case 0:
                let m = u[f];
                (c = u[f + 1]), (d = u[f + 2]);
                let g = (i - m) / (u[f + 3] - m);
                (c += (u[f + 3 + 1] - c) * g), (d += (u[f + 3 + 2] - d) * g);
                break;
            case 1:
                (c = u[f + 1]), (d = u[f + 2]);
                break;
            default:
                (c = this.getBezierValue(i, f, 1, p - 2)),
                    (d = this.getBezierValue(i, f, 2, p + 18 - 2));
        }
        switch (o) {
            case z.setup:
                (l.shearX = l.data.shearX + c * a),
                    (l.shearY = l.data.shearY + d * a);
                break;
            case z.first:
            case z.replace:
                (l.shearX += (l.data.shearX + c - l.shearX) * a),
                    (l.shearY += (l.data.shearY + d - l.shearY) * a);
                break;
            case z.add:
                (l.shearX += c * a), (l.shearY += d * a);
        }
    }
}
class DC extends si {
    constructor(t, n, i) {
        super(t, n, ge.shearX + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active &&
            (l.shearX = this.getRelativeValue(
                i,
                a,
                o,
                l.shearX,
                l.data.shearX
            ));
    }
}
class NC extends si {
    constructor(t, n, i) {
        super(t, n, ge.shearY + "|" + i);
        x(this, "boneIndex", 0);
        this.boneIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        l.active &&
            (l.shearY = this.getRelativeValue(
                i,
                a,
                o,
                l.shearY,
                l.data.shearY
            ));
    }
}
class VC extends dt {
    constructor(t, n) {
        super(t, [ge.inherit + "|" + n]);
        x(this, "boneIndex", 0);
        this.boneIndex = n;
    }
    getFrameEntries() {
        return 2;
    }
    setFrame(t, n, i) {
        (t *= 2), (this.frames[t] = n), (this.frames[t + 1] = i);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.bones[this.boneIndex];
        if (!l.active) return;
        if (h == fn.mixOut) {
            o == z.setup && (l.inherit = l.data.inherit);
            return;
        }
        let u = this.frames;
        if (i < u[0]) {
            (o == z.setup || o == z.first) && (l.inherit = l.data.inherit);
            return;
        }
        l.inherit = this.frames[dt.search(u, i, 2) + 1];
    }
}
class UC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.rgb + "|" + i, ge.alpha + "|" + i]);
        x(this, "slotIndex", 0);
        this.slotIndex = i;
    }
    getFrameEntries() {
        return 5;
    }
    setFrame(t, n, i, r, a, o) {
        (t *= 5),
            (this.frames[t] = n),
            (this.frames[t + 1] = i),
            (this.frames[t + 2] = r),
            (this.frames[t + 3] = a),
            (this.frames[t + 4] = o);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = this.frames,
            c = l.color;
        if (i < u[0]) {
            let v = l.data.color;
            switch (o) {
                case z.setup:
                    c.setFromColor(v);
                    return;
                case z.first:
                    c.add(
                        (v.r - c.r) * a,
                        (v.g - c.g) * a,
                        (v.b - c.b) * a,
                        (v.a - c.a) * a
                    );
            }
            return;
        }
        let d = 0,
            f = 0,
            p = 0,
            m = 0,
            g = dt.search(u, i, 5),
            _ = this.curves[g / 5];
        switch (_) {
            case 0:
                let v = u[g];
                (d = u[g + 1]), (f = u[g + 2]), (p = u[g + 3]), (m = u[g + 4]);
                let b = (i - v) / (u[g + 5] - v);
                (d += (u[g + 5 + 1] - d) * b),
                    (f += (u[g + 5 + 2] - f) * b),
                    (p += (u[g + 5 + 3] - p) * b),
                    (m += (u[g + 5 + 4] - m) * b);
                break;
            case 1:
                (d = u[g + 1]), (f = u[g + 2]), (p = u[g + 3]), (m = u[g + 4]);
                break;
            default:
                (d = this.getBezierValue(i, g, 1, _ - 2)),
                    (f = this.getBezierValue(i, g, 2, _ + 18 - 2)),
                    (p = this.getBezierValue(i, g, 3, _ + 36 - 2)),
                    (m = this.getBezierValue(i, g, 4, _ + 54 - 2));
        }
        a == 1
            ? c.set(d, f, p, m)
            : (o == z.setup && c.setFromColor(l.data.color),
              c.add(
                  (d - c.r) * a,
                  (f - c.g) * a,
                  (p - c.b) * a,
                  (m - c.a) * a
              ));
    }
}
class zC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.rgb + "|" + i]);
        x(this, "slotIndex", 0);
        this.slotIndex = i;
    }
    getFrameEntries() {
        return 4;
    }
    setFrame(t, n, i, r, a) {
        (t <<= 2),
            (this.frames[t] = n),
            (this.frames[t + 1] = i),
            (this.frames[t + 2] = r),
            (this.frames[t + 3] = a);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = this.frames,
            c = l.color;
        if (i < u[0]) {
            let _ = l.data.color;
            switch (o) {
                case z.setup:
                    (c.r = _.r), (c.g = _.g), (c.b = _.b);
                    return;
                case z.first:
                    (c.r += (_.r - c.r) * a),
                        (c.g += (_.g - c.g) * a),
                        (c.b += (_.b - c.b) * a);
            }
            return;
        }
        let d = 0,
            f = 0,
            p = 0,
            m = dt.search(u, i, 4),
            g = this.curves[m >> 2];
        switch (g) {
            case 0:
                let _ = u[m];
                (d = u[m + 1]), (f = u[m + 2]), (p = u[m + 3]);
                let v = (i - _) / (u[m + 4] - _);
                (d += (u[m + 4 + 1] - d) * v),
                    (f += (u[m + 4 + 2] - f) * v),
                    (p += (u[m + 4 + 3] - p) * v);
                break;
            case 1:
                (d = u[m + 1]), (f = u[m + 2]), (p = u[m + 3]);
                break;
            default:
                (d = this.getBezierValue(i, m, 1, g - 2)),
                    (f = this.getBezierValue(i, m, 2, g + 18 - 2)),
                    (p = this.getBezierValue(i, m, 3, g + 36 - 2));
        }
        if (a == 1) (c.r = d), (c.g = f), (c.b = p);
        else {
            if (o == z.setup) {
                let _ = l.data.color;
                (c.r = _.r), (c.g = _.g), (c.b = _.b);
            }
            (c.r += (d - c.r) * a),
                (c.g += (f - c.g) * a),
                (c.b += (p - c.b) * a);
        }
    }
}
class YC extends si {
    constructor(t, n, i) {
        super(t, n, ge.alpha + "|" + i);
        x(this, "slotIndex", 0);
        this.slotIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = l.color;
        if (i < this.frames[0]) {
            let d = l.data.color;
            switch (o) {
                case z.setup:
                    u.a = d.a;
                    return;
                case z.first:
                    u.a += (d.a - u.a) * a;
            }
            return;
        }
        let c = this.getCurveValue(i);
        a == 1
            ? (u.a = c)
            : (o == z.setup && (u.a = l.data.color.a), (u.a += (c - u.a) * a));
    }
}
class GC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.rgb + "|" + i, ge.alpha + "|" + i, ge.rgb2 + "|" + i]);
        x(this, "slotIndex", 0);
        this.slotIndex = i;
    }
    getFrameEntries() {
        return 8;
    }
    setFrame(t, n, i, r, a, o, h, l, u) {
        (t <<= 3),
            (this.frames[t] = n),
            (this.frames[t + 1] = i),
            (this.frames[t + 2] = r),
            (this.frames[t + 3] = a),
            (this.frames[t + 4] = o),
            (this.frames[t + 5] = h),
            (this.frames[t + 6] = l),
            (this.frames[t + 7] = u);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = this.frames,
            c = l.color,
            d = l.darkColor;
        if (i < u[0]) {
            let w = l.data.color,
                A = l.data.darkColor;
            switch (o) {
                case z.setup:
                    c.setFromColor(w), (d.r = A.r), (d.g = A.g), (d.b = A.b);
                    return;
                case z.first:
                    c.add(
                        (w.r - c.r) * a,
                        (w.g - c.g) * a,
                        (w.b - c.b) * a,
                        (w.a - c.a) * a
                    ),
                        (d.r += (A.r - d.r) * a),
                        (d.g += (A.g - d.g) * a),
                        (d.b += (A.b - d.b) * a);
            }
            return;
        }
        let f = 0,
            p = 0,
            m = 0,
            g = 0,
            _ = 0,
            v = 0,
            b = 0,
            y = dt.search(u, i, 8),
            C = this.curves[y >> 3];
        switch (C) {
            case 0:
                let w = u[y];
                (f = u[y + 1]),
                    (p = u[y + 2]),
                    (m = u[y + 3]),
                    (g = u[y + 4]),
                    (_ = u[y + 5]),
                    (v = u[y + 6]),
                    (b = u[y + 7]);
                let A = (i - w) / (u[y + 8] - w);
                (f += (u[y + 8 + 1] - f) * A),
                    (p += (u[y + 8 + 2] - p) * A),
                    (m += (u[y + 8 + 3] - m) * A),
                    (g += (u[y + 8 + 4] - g) * A),
                    (_ += (u[y + 8 + 5] - _) * A),
                    (v += (u[y + 8 + 6] - v) * A),
                    (b += (u[y + 8 + 7] - b) * A);
                break;
            case 1:
                (f = u[y + 1]),
                    (p = u[y + 2]),
                    (m = u[y + 3]),
                    (g = u[y + 4]),
                    (_ = u[y + 5]),
                    (v = u[y + 6]),
                    (b = u[y + 7]);
                break;
            default:
                (f = this.getBezierValue(i, y, 1, C - 2)),
                    (p = this.getBezierValue(i, y, 2, C + 18 - 2)),
                    (m = this.getBezierValue(i, y, 3, C + 36 - 2)),
                    (g = this.getBezierValue(i, y, 4, C + 54 - 2)),
                    (_ = this.getBezierValue(i, y, 5, C + 72 - 2)),
                    (v = this.getBezierValue(i, y, 6, C + 90 - 2)),
                    (b = this.getBezierValue(i, y, 7, C + 108 - 2));
        }
        if (a == 1) c.set(f, p, m, g), (d.r = _), (d.g = v), (d.b = b);
        else {
            if (o == z.setup) {
                c.setFromColor(l.data.color);
                let w = l.data.darkColor;
                (d.r = w.r), (d.g = w.g), (d.b = w.b);
            }
            c.add((f - c.r) * a, (p - c.g) * a, (m - c.b) * a, (g - c.a) * a),
                (d.r += (_ - d.r) * a),
                (d.g += (v - d.g) * a),
                (d.b += (b - d.b) * a);
        }
    }
}
class jC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.rgb + "|" + i, ge.rgb2 + "|" + i]);
        x(this, "slotIndex", 0);
        this.slotIndex = i;
    }
    getFrameEntries() {
        return 7;
    }
    setFrame(t, n, i, r, a, o, h, l) {
        (t *= 7),
            (this.frames[t] = n),
            (this.frames[t + 1] = i),
            (this.frames[t + 2] = r),
            (this.frames[t + 3] = a),
            (this.frames[t + 4] = o),
            (this.frames[t + 5] = h),
            (this.frames[t + 6] = l);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = this.frames,
            c = l.color,
            d = l.darkColor;
        if (i < u[0]) {
            let C = l.data.color,
                w = l.data.darkColor;
            switch (o) {
                case z.setup:
                    (c.r = C.r),
                        (c.g = C.g),
                        (c.b = C.b),
                        (d.r = w.r),
                        (d.g = w.g),
                        (d.b = w.b);
                    return;
                case z.first:
                    (c.r += (C.r - c.r) * a),
                        (c.g += (C.g - c.g) * a),
                        (c.b += (C.b - c.b) * a),
                        (d.r += (w.r - d.r) * a),
                        (d.g += (w.g - d.g) * a),
                        (d.b += (w.b - d.b) * a);
            }
            return;
        }
        let f = 0,
            p = 0,
            m = 0,
            g = 0,
            _ = 0,
            v = 0,
            b = dt.search(u, i, 7),
            y = this.curves[b / 7];
        switch (y) {
            case 0:
                let C = u[b];
                (f = u[b + 1]),
                    (p = u[b + 2]),
                    (m = u[b + 3]),
                    (g = u[b + 4]),
                    (_ = u[b + 5]),
                    (v = u[b + 6]);
                let w = (i - C) / (u[b + 7] - C);
                (f += (u[b + 7 + 1] - f) * w),
                    (p += (u[b + 7 + 2] - p) * w),
                    (m += (u[b + 7 + 3] - m) * w),
                    (g += (u[b + 7 + 4] - g) * w),
                    (_ += (u[b + 7 + 5] - _) * w),
                    (v += (u[b + 7 + 6] - v) * w);
                break;
            case 1:
                (f = u[b + 1]),
                    (p = u[b + 2]),
                    (m = u[b + 3]),
                    (g = u[b + 4]),
                    (_ = u[b + 5]),
                    (v = u[b + 6]);
                break;
            default:
                (f = this.getBezierValue(i, b, 1, y - 2)),
                    (p = this.getBezierValue(i, b, 2, y + 18 - 2)),
                    (m = this.getBezierValue(i, b, 3, y + 36 - 2)),
                    (g = this.getBezierValue(i, b, 4, y + 54 - 2)),
                    (_ = this.getBezierValue(i, b, 5, y + 72 - 2)),
                    (v = this.getBezierValue(i, b, 6, y + 90 - 2));
        }
        if (a == 1)
            (c.r = f), (c.g = p), (c.b = m), (d.r = g), (d.g = _), (d.b = v);
        else {
            if (o == z.setup) {
                let C = l.data.color,
                    w = l.data.darkColor;
                (c.r = C.r),
                    (c.g = C.g),
                    (c.b = C.b),
                    (d.r = w.r),
                    (d.g = w.g),
                    (d.b = w.b);
            }
            (c.r += (f - c.r) * a),
                (c.g += (p - c.g) * a),
                (c.b += (m - c.b) * a),
                (d.r += (g - d.r) * a),
                (d.g += (_ - d.g) * a),
                (d.b += (v - d.b) * a);
        }
    }
}
class xo extends dt {
    constructor(t, n) {
        super(t, [ge.attachment + "|" + n]);
        x(this, "slotIndex", 0);
        x(this, "attachmentNames");
        (this.slotIndex = n), (this.attachmentNames = new Array(t));
    }
    getFrameCount() {
        return this.frames.length;
    }
    setFrame(t, n, i) {
        (this.frames[t] = n), (this.attachmentNames[t] = i);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (l.bone.active) {
            if (h == fn.mixOut) {
                o == z.setup && this.setAttachment(t, l, l.data.attachmentName);
                return;
            }
            if (i < this.frames[0]) {
                (o == z.setup || o == z.first) &&
                    this.setAttachment(t, l, l.data.attachmentName);
                return;
            }
            this.setAttachment(
                t,
                l,
                this.attachmentNames[dt.search1(this.frames, i)]
            );
        }
    }
    setAttachment(t, n, i) {
        n.setAttachment(i ? t.getAttachment(this.slotIndex, i) : null);
    }
}
class WC extends Ri {
    constructor(t, n, i, r) {
        super(t, n, [ge.deform + "|" + i + "|" + r.id]);
        x(this, "slotIndex", 0);
        x(this, "attachment");
        x(this, "vertices");
        (this.slotIndex = i),
            (this.attachment = r),
            (this.vertices = new Array(t));
    }
    getFrameCount() {
        return this.frames.length;
    }
    setFrame(t, n, i) {
        (this.frames[t] = n), (this.vertices[t] = i);
    }
    setBezier(t, n, i, r, a, o, h, l, u, c, d) {
        let f = this.curves,
            p = this.getFrameCount() + t * 18;
        i == 0 && (f[n] = 2 + p);
        let m = (r - o * 2 + l) * 0.03,
            g = u * 0.03 - h * 0.06,
            _ = ((o - l) * 3 - r + c) * 0.006,
            v = (h - u + 0.33333333) * 0.018,
            b = m * 2 + _,
            y = g * 2 + v,
            C = (o - r) * 0.3 + m + _ * 0.16666667,
            w = h * 0.3 + g + v * 0.16666667,
            A = r + C,
            E = w;
        for (let S = p + 18; p < S; p += 2)
            (f[p] = A),
                (f[p + 1] = E),
                (C += b),
                (w += y),
                (b += _),
                (y += v),
                (A += C),
                (E += w);
    }
    getCurvePercent(t, n) {
        let i = this.curves,
            r = i[n];
        switch (r) {
            case 0:
                let l = this.frames[n];
                return (t - l) / (this.frames[n + this.getFrameEntries()] - l);
            case 1:
                return 0;
        }
        if (((r -= 2), i[r] > t)) {
            let l = this.frames[n];
            return (i[r + 1] * (t - l)) / (i[r] - l);
        }
        let a = r + 18;
        for (r += 2; r < a; r += 2)
            if (i[r] >= t) {
                let l = i[r - 2],
                    u = i[r - 1];
                return u + ((t - l) / (i[r] - l)) * (i[r + 1] - u);
            }
        let o = i[a - 2],
            h = i[a - 1];
        return (
            h +
            ((1 - h) * (t - o)) / (this.frames[n + this.getFrameEntries()] - o)
        );
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = l.getAttachment();
        if (!u || !(u instanceof Ks) || u.timelineAttachment != this.attachment)
            return;
        let c = l.deform;
        c.length == 0 && (o = z.setup);
        let d = this.vertices,
            f = d[0].length,
            p = this.frames;
        if (i < p[0]) {
            switch (o) {
                case z.setup:
                    c.length = 0;
                    return;
                case z.first:
                    if (a == 1) {
                        c.length = 0;
                        return;
                    }
                    c.length = f;
                    let y = u;
                    if (y.bones) {
                        a = 1 - a;
                        for (var m = 0; m < f; m++) c[m] *= a;
                    } else {
                        let C = y.vertices;
                        for (var m = 0; m < f; m++) c[m] += (C[m] - c[m]) * a;
                    }
            }
            return;
        }
        if (((c.length = f), i >= p[p.length - 1])) {
            let y = d[p.length - 1];
            if (a == 1)
                if (o == z.add) {
                    let C = u;
                    if (C.bones) for (let w = 0; w < f; w++) c[w] += y[w];
                    else {
                        let w = C.vertices;
                        for (let A = 0; A < f; A++) c[A] += y[A] - w[A];
                    }
                } else K.arrayCopy(y, 0, c, 0, f);
            else
                switch (o) {
                    case z.setup: {
                        let w = u;
                        if (w.bones)
                            for (let A = 0; A < f; A++) c[A] = y[A] * a;
                        else {
                            let A = w.vertices;
                            for (let E = 0; E < f; E++) {
                                let S = A[E];
                                c[E] = S + (y[E] - S) * a;
                            }
                        }
                        break;
                    }
                    case z.first:
                    case z.replace:
                        for (let w = 0; w < f; w++) c[w] += (y[w] - c[w]) * a;
                        break;
                    case z.add:
                        let C = u;
                        if (C.bones)
                            for (let w = 0; w < f; w++) c[w] += y[w] * a;
                        else {
                            let w = C.vertices;
                            for (let A = 0; A < f; A++)
                                c[A] += (y[A] - w[A]) * a;
                        }
                }
            return;
        }
        let g = dt.search1(p, i),
            _ = this.getCurvePercent(i, g),
            v = d[g],
            b = d[g + 1];
        if (a == 1)
            if (o == z.add) {
                let y = u;
                if (y.bones)
                    for (let C = 0; C < f; C++) {
                        let w = v[C];
                        c[C] += w + (b[C] - w) * _;
                    }
                else {
                    let C = y.vertices;
                    for (let w = 0; w < f; w++) {
                        let A = v[w];
                        c[w] += A + (b[w] - A) * _ - C[w];
                    }
                }
            } else
                for (let y = 0; y < f; y++) {
                    let C = v[y];
                    c[y] = C + (b[y] - C) * _;
                }
        else
            switch (o) {
                case z.setup: {
                    let C = u;
                    if (C.bones)
                        for (let w = 0; w < f; w++) {
                            let A = v[w];
                            c[w] = (A + (b[w] - A) * _) * a;
                        }
                    else {
                        let w = C.vertices;
                        for (let A = 0; A < f; A++) {
                            let E = v[A],
                                S = w[A];
                            c[A] = S + (E + (b[A] - E) * _ - S) * a;
                        }
                    }
                    break;
                }
                case z.first:
                case z.replace:
                    for (let C = 0; C < f; C++) {
                        let w = v[C];
                        c[C] += (w + (b[C] - w) * _ - c[C]) * a;
                    }
                    break;
                case z.add:
                    let y = u;
                    if (y.bones)
                        for (let C = 0; C < f; C++) {
                            let w = v[C];
                            c[C] += (w + (b[C] - w) * _) * a;
                        }
                    else {
                        let C = y.vertices;
                        for (let w = 0; w < f; w++) {
                            let A = v[w];
                            c[w] += (A + (b[w] - A) * _ - C[w]) * a;
                        }
                    }
            }
    }
}
const id = class id extends dt {
    constructor(t) {
        super(t, id.propertyIds);
        x(this, "events");
        this.events = new Array(t);
    }
    getFrameCount() {
        return this.frames.length;
    }
    setFrame(t, n) {
        (this.frames[t] = n.time), (this.events[t] = n);
    }
    apply(t, n, i, r, a, o, h) {
        if (!r) return;
        let l = this.frames,
            u = this.frames.length;
        if (n > i) this.apply(t, n, Number.MAX_VALUE, r, a, o, h), (n = -1);
        else if (n >= l[u - 1]) return;
        if (i < l[0]) return;
        let c = 0;
        if (n < l[0]) c = 0;
        else {
            c = dt.search1(l, n) + 1;
            let d = l[c];
            for (; c > 0 && l[c - 1] == d; ) c--;
        }
        for (; c < u && i >= l[c]; c++) r.push(this.events[c]);
    }
};
x(id, "propertyIds", ["" + ge.event]);
let Yh = id;
const rd = class rd extends dt {
    constructor(t) {
        super(t, rd.propertyIds);
        x(this, "drawOrders");
        this.drawOrders = new Array(t);
    }
    getFrameCount() {
        return this.frames.length;
    }
    setFrame(t, n, i) {
        (this.frames[t] = n), (this.drawOrders[t] = i);
    }
    apply(t, n, i, r, a, o, h) {
        if (h == fn.mixOut) {
            o == z.setup &&
                K.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
            return;
        }
        if (i < this.frames[0]) {
            (o == z.setup || o == z.first) &&
                K.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
            return;
        }
        let l = dt.search1(this.frames, i),
            u = this.drawOrders[l];
        if (!u) K.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        else {
            let c = t.drawOrder,
                d = t.slots;
            for (let f = 0, p = u.length; f < p; f++) c[f] = d[u[f]];
        }
    }
};
x(rd, "propertyIds", ["" + ge.drawOrder]);
let Sa = rd;
class XC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.ikConstraint + "|" + i]);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    getFrameEntries() {
        return 6;
    }
    setFrame(t, n, i, r, a, o, h) {
        (t *= 6),
            (this.frames[t] = n),
            (this.frames[t + 1] = i),
            (this.frames[t + 2] = r),
            (this.frames[t + 3] = a),
            (this.frames[t + 4] = o ? 1 : 0),
            (this.frames[t + 5] = h ? 1 : 0);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.ikConstraints[this.constraintIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            switch (o) {
                case z.setup:
                    (l.mix = l.data.mix),
                        (l.softness = l.data.softness),
                        (l.bendDirection = l.data.bendDirection),
                        (l.compress = l.data.compress),
                        (l.stretch = l.data.stretch);
                    return;
                case z.first:
                    (l.mix += (l.data.mix - l.mix) * a),
                        (l.softness += (l.data.softness - l.softness) * a),
                        (l.bendDirection = l.data.bendDirection),
                        (l.compress = l.data.compress),
                        (l.stretch = l.data.stretch);
            }
            return;
        }
        let c = 0,
            d = 0,
            f = dt.search(u, i, 6),
            p = this.curves[f / 6];
        switch (p) {
            case 0:
                let m = u[f];
                (c = u[f + 1]), (d = u[f + 2]);
                let g = (i - m) / (u[f + 6] - m);
                (c += (u[f + 6 + 1] - c) * g), (d += (u[f + 6 + 2] - d) * g);
                break;
            case 1:
                (c = u[f + 1]), (d = u[f + 2]);
                break;
            default:
                (c = this.getBezierValue(i, f, 1, p - 2)),
                    (d = this.getBezierValue(i, f, 2, p + 18 - 2));
        }
        o == z.setup
            ? ((l.mix = l.data.mix + (c - l.data.mix) * a),
              (l.softness = l.data.softness + (d - l.data.softness) * a),
              h == fn.mixOut
                  ? ((l.bendDirection = l.data.bendDirection),
                    (l.compress = l.data.compress),
                    (l.stretch = l.data.stretch))
                  : ((l.bendDirection = u[f + 3]),
                    (l.compress = u[f + 4] != 0),
                    (l.stretch = u[f + 5] != 0)))
            : ((l.mix += (c - l.mix) * a),
              (l.softness += (d - l.softness) * a),
              h == fn.mixIn &&
                  ((l.bendDirection = u[f + 3]),
                  (l.compress = u[f + 4] != 0),
                  (l.stretch = u[f + 5] != 0)));
    }
}
class qC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.transformConstraint + "|" + i]);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    getFrameEntries() {
        return 7;
    }
    setFrame(t, n, i, r, a, o, h, l) {
        let u = this.frames;
        (t *= 7),
            (u[t] = n),
            (u[t + 1] = i),
            (u[t + 2] = r),
            (u[t + 3] = a),
            (u[t + 4] = o),
            (u[t + 5] = h),
            (u[t + 6] = l);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.transformConstraints[this.constraintIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            let b = l.data;
            switch (o) {
                case z.setup:
                    (l.mixRotate = b.mixRotate),
                        (l.mixX = b.mixX),
                        (l.mixY = b.mixY),
                        (l.mixScaleX = b.mixScaleX),
                        (l.mixScaleY = b.mixScaleY),
                        (l.mixShearY = b.mixShearY);
                    return;
                case z.first:
                    (l.mixRotate += (b.mixRotate - l.mixRotate) * a),
                        (l.mixX += (b.mixX - l.mixX) * a),
                        (l.mixY += (b.mixY - l.mixY) * a),
                        (l.mixScaleX += (b.mixScaleX - l.mixScaleX) * a),
                        (l.mixScaleY += (b.mixScaleY - l.mixScaleY) * a),
                        (l.mixShearY += (b.mixShearY - l.mixShearY) * a);
            }
            return;
        }
        let c,
            d,
            f,
            p,
            m,
            g,
            _ = dt.search(u, i, 7),
            v = this.curves[_ / 7];
        switch (v) {
            case 0:
                let b = u[_];
                (c = u[_ + 1]),
                    (d = u[_ + 2]),
                    (f = u[_ + 3]),
                    (p = u[_ + 4]),
                    (m = u[_ + 5]),
                    (g = u[_ + 6]);
                let y = (i - b) / (u[_ + 7] - b);
                (c += (u[_ + 7 + 1] - c) * y),
                    (d += (u[_ + 7 + 2] - d) * y),
                    (f += (u[_ + 7 + 3] - f) * y),
                    (p += (u[_ + 7 + 4] - p) * y),
                    (m += (u[_ + 7 + 5] - m) * y),
                    (g += (u[_ + 7 + 6] - g) * y);
                break;
            case 1:
                (c = u[_ + 1]),
                    (d = u[_ + 2]),
                    (f = u[_ + 3]),
                    (p = u[_ + 4]),
                    (m = u[_ + 5]),
                    (g = u[_ + 6]);
                break;
            default:
                (c = this.getBezierValue(i, _, 1, v - 2)),
                    (d = this.getBezierValue(i, _, 2, v + 18 - 2)),
                    (f = this.getBezierValue(i, _, 3, v + 36 - 2)),
                    (p = this.getBezierValue(i, _, 4, v + 54 - 2)),
                    (m = this.getBezierValue(i, _, 5, v + 72 - 2)),
                    (g = this.getBezierValue(i, _, 6, v + 90 - 2));
        }
        if (o == z.setup) {
            let b = l.data;
            (l.mixRotate = b.mixRotate + (c - b.mixRotate) * a),
                (l.mixX = b.mixX + (d - b.mixX) * a),
                (l.mixY = b.mixY + (f - b.mixY) * a),
                (l.mixScaleX = b.mixScaleX + (p - b.mixScaleX) * a),
                (l.mixScaleY = b.mixScaleY + (m - b.mixScaleY) * a),
                (l.mixShearY = b.mixShearY + (g - b.mixShearY) * a);
        } else
            (l.mixRotate += (c - l.mixRotate) * a),
                (l.mixX += (d - l.mixX) * a),
                (l.mixY += (f - l.mixY) * a),
                (l.mixScaleX += (p - l.mixScaleX) * a),
                (l.mixScaleY += (m - l.mixScaleY) * a),
                (l.mixShearY += (g - l.mixShearY) * a);
    }
}
class HC extends si {
    constructor(t, n, i) {
        super(t, n, ge.pathConstraintPosition + "|" + i);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.pathConstraints[this.constraintIndex];
        l.active &&
            (l.position = this.getAbsoluteValue(
                i,
                a,
                o,
                l.position,
                l.data.position
            ));
    }
}
class KC extends si {
    constructor(t, n, i) {
        super(t, n, ge.pathConstraintSpacing + "|" + i);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.pathConstraints[this.constraintIndex];
        l.active &&
            (l.spacing = this.getAbsoluteValue(
                i,
                a,
                o,
                l.spacing,
                l.data.spacing
            ));
    }
}
class ZC extends Ri {
    constructor(t, n, i) {
        super(t, n, [ge.pathConstraintMix + "|" + i]);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    getFrameEntries() {
        return 4;
    }
    setFrame(t, n, i, r, a) {
        let o = this.frames;
        (t <<= 2), (o[t] = n), (o[t + 1] = i), (o[t + 2] = r), (o[t + 3] = a);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.pathConstraints[this.constraintIndex];
        if (!l.active) return;
        let u = this.frames;
        if (i < u[0]) {
            switch (o) {
                case z.setup:
                    (l.mixRotate = l.data.mixRotate),
                        (l.mixX = l.data.mixX),
                        (l.mixY = l.data.mixY);
                    return;
                case z.first:
                    (l.mixRotate += (l.data.mixRotate - l.mixRotate) * a),
                        (l.mixX += (l.data.mixX - l.mixX) * a),
                        (l.mixY += (l.data.mixY - l.mixY) * a);
            }
            return;
        }
        let c,
            d,
            f,
            p = dt.search(u, i, 4),
            m = this.curves[p >> 2];
        switch (m) {
            case 0:
                let g = u[p];
                (c = u[p + 1]), (d = u[p + 2]), (f = u[p + 3]);
                let _ = (i - g) / (u[p + 4] - g);
                (c += (u[p + 4 + 1] - c) * _),
                    (d += (u[p + 4 + 2] - d) * _),
                    (f += (u[p + 4 + 3] - f) * _);
                break;
            case 1:
                (c = u[p + 1]), (d = u[p + 2]), (f = u[p + 3]);
                break;
            default:
                (c = this.getBezierValue(i, p, 1, m - 2)),
                    (d = this.getBezierValue(i, p, 2, m + 18 - 2)),
                    (f = this.getBezierValue(i, p, 3, m + 36 - 2));
        }
        if (o == z.setup) {
            let g = l.data;
            (l.mixRotate = g.mixRotate + (c - g.mixRotate) * a),
                (l.mixX = g.mixX + (d - g.mixX) * a),
                (l.mixY = g.mixY + (f - g.mixY) * a);
        } else
            (l.mixRotate += (c - l.mixRotate) * a),
                (l.mixX += (d - l.mixX) * a),
                (l.mixY += (f - l.mixY) * a);
    }
}
class Ka extends si {
    constructor(t, n, i, r) {
        super(t, n, r + "|" + i);
        x(this, "constraintIndex", 0);
        this.constraintIndex = i;
    }
    apply(t, n, i, r, a, o, h) {
        let l;
        if (this.constraintIndex == -1) {
            const u = i >= this.frames[0] ? this.getCurveValue(i) : 0;
            for (const c of t.physicsConstraints)
                c.active &&
                    this.global(c.data) &&
                    this.set(
                        c,
                        this.getAbsoluteValue2(
                            i,
                            a,
                            o,
                            this.get(c),
                            this.setup(c),
                            u
                        )
                    );
        } else
            (l = t.physicsConstraints[this.constraintIndex]),
                l.active &&
                    this.set(
                        l,
                        this.getAbsoluteValue(
                            i,
                            a,
                            o,
                            this.get(l),
                            this.setup(l)
                        )
                    );
    }
}
class QC extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintInertia);
    }
    setup(e) {
        return e.data.inertia;
    }
    get(e) {
        return e.inertia;
    }
    set(e, t) {
        e.inertia = t;
    }
    global(e) {
        return e.inertiaGlobal;
    }
}
class JC extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintStrength);
    }
    setup(e) {
        return e.data.strength;
    }
    get(e) {
        return e.strength;
    }
    set(e, t) {
        e.strength = t;
    }
    global(e) {
        return e.strengthGlobal;
    }
}
class e2 extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintDamping);
    }
    setup(e) {
        return e.data.damping;
    }
    get(e) {
        return e.damping;
    }
    set(e, t) {
        e.damping = t;
    }
    global(e) {
        return e.dampingGlobal;
    }
}
class t2 extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintMass);
    }
    setup(e) {
        return 1 / e.data.massInverse;
    }
    get(e) {
        return 1 / e.massInverse;
    }
    set(e, t) {
        e.massInverse = 1 / t;
    }
    global(e) {
        return e.massGlobal;
    }
}
class n2 extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintWind);
    }
    setup(e) {
        return e.data.wind;
    }
    get(e) {
        return e.wind;
    }
    set(e, t) {
        e.wind = t;
    }
    global(e) {
        return e.windGlobal;
    }
}
class s2 extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintGravity);
    }
    setup(e) {
        return e.data.gravity;
    }
    get(e) {
        return e.gravity;
    }
    set(e, t) {
        e.gravity = t;
    }
    global(e) {
        return e.gravityGlobal;
    }
}
class i2 extends Ka {
    constructor(e, t, n) {
        super(e, t, n, ge.physicsConstraintMix);
    }
    setup(e) {
        return e.data.mix;
    }
    get(e) {
        return e.mix;
    }
    set(e, t) {
        e.mix = t;
    }
    global(e) {
        return e.mixGlobal;
    }
}
const ad = class ad extends dt {
    constructor(t, n) {
        super(t, ad.propertyIds);
        x(this, "constraintIndex");
        this.constraintIndex = n;
    }
    getFrameCount() {
        return this.frames.length;
    }
    setFrame(t, n) {
        this.frames[t] = n;
    }
    apply(t, n, i, r, a, o, h) {
        let l;
        if (
            this.constraintIndex != -1 &&
            ((l = t.physicsConstraints[this.constraintIndex]), !l.active)
        )
            return;
        const u = this.frames;
        if (n > i) this.apply(t, n, Number.MAX_VALUE, [], a, o, h), (n = -1);
        else if (n >= u[u.length - 1]) return;
        if (!(i < u[0]) && (n < u[0] || i >= u[dt.search1(u, n) + 1]))
            if (l != null) l.reset();
            else for (const c of t.physicsConstraints) c.active && c.reset();
    }
};
x(ad, "propertyIds", [ge.physicsConstraintReset.toString()]);
let $u = ad;
const ys = class ys extends dt {
    constructor(t, n, i) {
        super(t, [ge.sequence + "|" + n + "|" + i.sequence.id]);
        x(this, "slotIndex");
        x(this, "attachment");
        (this.slotIndex = n), (this.attachment = i);
    }
    getFrameEntries() {
        return ys.ENTRIES;
    }
    getSlotIndex() {
        return this.slotIndex;
    }
    getAttachment() {
        return this.attachment;
    }
    setFrame(t, n, i, r, a) {
        let o = this.frames;
        (t *= ys.ENTRIES),
            (o[t] = n),
            (o[t + ys.MODE] = i | (r << 4)),
            (o[t + ys.DELAY] = a);
    }
    apply(t, n, i, r, a, o, h) {
        let l = t.slots[this.slotIndex];
        if (!l.bone.active) return;
        let u = l.attachment,
            c = this.attachment;
        if (u != c && (!(u instanceof Ks) || u.timelineAttachment != c)) return;
        if (h == fn.mixOut) {
            o == z.setup && (l.sequenceIndex = -1);
            return;
        }
        let d = this.frames;
        if (i < d[0]) {
            (o == z.setup || o == z.first) && (l.sequenceIndex = -1);
            return;
        }
        let f = dt.search(d, i, ys.ENTRIES),
            p = d[f],
            m = d[f + ys.MODE],
            g = d[f + ys.DELAY];
        if (!this.attachment.sequence) return;
        let _ = m >> 4,
            v = this.attachment.sequence.regions.length,
            b = MC[m & 15];
        if (b != sn.hold)
            switch (((_ += ((i - p) / g + 1e-5) | 0), b)) {
                case sn.once:
                    _ = Math.min(v - 1, _);
                    break;
                case sn.loop:
                    _ %= v;
                    break;
                case sn.pingpong: {
                    let y = (v << 1) - 2;
                    (_ = y == 0 ? 0 : _ % y), _ >= v && (_ = y - _);
                    break;
                }
                case sn.onceReverse:
                    _ = Math.max(v - 1 - _, 0);
                    break;
                case sn.loopReverse:
                    _ = v - 1 - (_ % v);
                    break;
                case sn.pingpongReverse: {
                    let y = (v << 1) - 2;
                    (_ = y == 0 ? 0 : (_ + v - 1) % y), _ >= v && (_ = y - _);
                }
            }
        l.sequenceIndex = _;
    }
};
x(ys, "ENTRIES", 3), x(ys, "MODE", 1), x(ys, "DELAY", 2);
let Du = ys;
const Ao = class Ao {
    constructor(e) {
        x(this, "data");
        x(this, "tracks", new Array());
        x(this, "timeScale", 1);
        x(this, "unkeyedState", 0);
        x(this, "events", new Array());
        x(this, "listeners", new Array());
        x(this, "queue", new jI(this));
        x(this, "propertyIDs", new kC());
        x(this, "animationsChanged", !1);
        x(this, "trackEntryPool", new zh(() => new GI()));
        this.data = e;
    }
    static emptyAnimation() {
        return Ao._emptyAnimation;
    }
    update(e) {
        e *= this.timeScale;
        let t = this.tracks;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (!r) continue;
            (r.animationLast = r.nextAnimationLast),
                (r.trackLast = r.nextTrackLast);
            let a = e * r.timeScale;
            if (r.delay > 0) {
                if (((r.delay -= a), r.delay > 0)) continue;
                (a = -r.delay), (r.delay = 0);
            }
            let o = r.next;
            if (o) {
                let h = r.trackLast - o.delay;
                if (h >= 0) {
                    for (
                        o.delay = 0,
                            o.trackTime +=
                                r.timeScale == 0
                                    ? 0
                                    : (h / r.timeScale + e) * o.timeScale,
                            r.trackTime += a,
                            this.setCurrent(n, o, !0);
                        o.mixingFrom;

                    )
                        (o.mixTime += e), (o = o.mixingFrom);
                    continue;
                }
            } else if (r.trackLast >= r.trackEnd && !r.mixingFrom) {
                (t[n] = null), this.queue.end(r), this.clearNext(r);
                continue;
            }
            if (r.mixingFrom && this.updateMixingFrom(r, e)) {
                let h = r.mixingFrom;
                for (r.mixingFrom = null, h && (h.mixingTo = null); h; )
                    this.queue.end(h), (h = h.mixingFrom);
            }
            r.trackTime += a;
        }
        this.queue.drain();
    }
    updateMixingFrom(e, t) {
        let n = e.mixingFrom;
        if (!n) return !0;
        let i = this.updateMixingFrom(n, t);
        return (
            (n.animationLast = n.nextAnimationLast),
            (n.trackLast = n.nextTrackLast),
            e.nextTrackLast != -1 && e.mixTime >= e.mixDuration
                ? ((n.totalAlpha == 0 || e.mixDuration == 0) &&
                      ((e.mixingFrom = n.mixingFrom),
                      n.mixingFrom != null && (n.mixingFrom.mixingTo = e),
                      (e.interruptAlpha = n.interruptAlpha),
                      this.queue.end(n)),
                  i)
                : ((n.trackTime += t * n.timeScale), (e.mixTime += t), !1)
        );
    }
    apply(e) {
        if (!e) throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        let t = this.events,
            n = this.tracks,
            i = !1;
        for (let d = 0, f = n.length; d < f; d++) {
            let p = n[d];
            if (!p || p.delay > 0) continue;
            i = !0;
            let m = d == 0 ? z.first : p.mixBlend,
                g = p.alpha;
            p.mixingFrom
                ? (g *= this.applyMixingFrom(p, e, m))
                : p.trackTime >= p.trackEnd && !p.next && (g = 0);
            let _ = g >= p.alphaAttachmentThreshold,
                v = p.animationLast,
                b = p.getAnimationTime(),
                y = b,
                C = t;
            p.reverse && ((y = p.animation.duration - y), (C = null));
            let w = p.animation.timelines,
                A = w.length;
            if ((d == 0 && g == 1) || m == z.add) {
                d == 0 && (_ = !0);
                for (let E = 0; E < A; E++) {
                    var r = w[E];
                    r instanceof xo
                        ? this.applyAttachmentTimeline(r, e, y, m, _)
                        : r.apply(e, v, y, C, g, m, fn.mixIn);
                }
            } else {
                let E = p.timelineMode,
                    S = p.shortestRotation,
                    P = !S && p.timelinesRotation.length != A << 1;
                P && (p.timelinesRotation.length = A << 1);
                for (let k = 0; k < A; k++) {
                    let R = w[k],
                        M = E[k] == Qf ? m : z.setup;
                    !S && R instanceof Fu
                        ? this.applyRotateTimeline(
                              R,
                              e,
                              y,
                              g,
                              M,
                              p.timelinesRotation,
                              k << 1,
                              P
                          )
                        : R instanceof xo
                        ? this.applyAttachmentTimeline(R, e, y, m, _)
                        : R.apply(e, v, y, C, g, M, fn.mixIn);
                }
            }
            this.queueEvents(p, b),
                (t.length = 0),
                (p.nextAnimationLast = b),
                (p.nextTrackLast = p.trackTime);
        }
        for (
            var a = this.unkeyedState + ob,
                o = e.slots,
                h = 0,
                l = e.slots.length;
            h < l;
            h++
        ) {
            var u = o[h];
            if (u.attachmentState == a) {
                var c = u.data.attachmentName;
                u.setAttachment(c ? e.getAttachment(u.data.index, c) : null);
            }
        }
        return (this.unkeyedState += 2), this.queue.drain(), i;
    }
    applyMixingFrom(e, t, n) {
        let i = e.mixingFrom;
        i.mixingFrom && this.applyMixingFrom(i, t, n);
        let r = 0;
        e.mixDuration == 0
            ? ((r = 1), n == z.first && (n = z.setup))
            : ((r = e.mixTime / e.mixDuration),
              r > 1 && (r = 1),
              n != z.first && (n = i.mixBlend));
        let a = r < i.mixAttachmentThreshold,
            o = r < i.mixDrawOrderThreshold,
            h = i.animation.timelines,
            l = h.length,
            u = i.alpha * e.interruptAlpha,
            c = u * (1 - r),
            d = i.animationLast,
            f = i.getAnimationTime(),
            p = f,
            m = null;
        if (
            (i.reverse
                ? (p = i.animation.duration - p)
                : r < i.eventThreshold && (m = this.events),
            n == z.add)
        )
            for (let g = 0; g < l; g++) h[g].apply(t, d, p, m, c, n, fn.mixOut);
        else {
            let g = i.timelineMode,
                _ = i.timelineHoldMix,
                v = i.shortestRotation,
                b = !v && i.timelinesRotation.length != l << 1;
            b && (i.timelinesRotation.length = l << 1), (i.totalAlpha = 0);
            for (let y = 0; y < l; y++) {
                let C = h[y],
                    w = fn.mixOut,
                    A,
                    E = 0;
                switch (g[y]) {
                    case Qf:
                        if (!o && C instanceof Sa) continue;
                        (A = n), (E = c);
                        break;
                    case rb:
                        (A = z.setup), (E = c);
                        break;
                    case ab:
                        (A = n), (E = u);
                        break;
                    case Jf:
                        (A = z.setup), (E = u);
                        break;
                    default:
                        A = z.setup;
                        let S = _[y];
                        E = u * Math.max(0, 1 - S.mixTime / S.mixDuration);
                        break;
                }
                (i.totalAlpha += E),
                    !v && C instanceof Fu
                        ? this.applyRotateTimeline(
                              C,
                              t,
                              p,
                              E,
                              A,
                              i.timelinesRotation,
                              y << 1,
                              b
                          )
                        : C instanceof xo
                        ? this.applyAttachmentTimeline(
                              C,
                              t,
                              p,
                              A,
                              a && E >= i.alphaAttachmentThreshold
                          )
                        : (o &&
                              C instanceof Sa &&
                              A == z.setup &&
                              (w = fn.mixIn),
                          C.apply(t, d, p, m, E, A, w));
            }
        }
        return (
            e.mixDuration > 0 && this.queueEvents(i, f),
            (this.events.length = 0),
            (i.nextAnimationLast = f),
            (i.nextTrackLast = i.trackTime),
            r
        );
    }
    applyAttachmentTimeline(e, t, n, i, r) {
        var a = t.slots[e.slotIndex];
        a.bone.active &&
            (n < e.frames[0]
                ? (i == z.setup || i == z.first) &&
                  this.setAttachment(t, a, a.data.attachmentName, r)
                : this.setAttachment(
                      t,
                      a,
                      e.attachmentNames[dt.search1(e.frames, n)],
                      r
                  ),
            a.attachmentState <= this.unkeyedState &&
                (a.attachmentState = this.unkeyedState + ob));
    }
    setAttachment(e, t, n, i) {
        t.setAttachment(n ? e.getAttachment(t.data.index, n) : null),
            i && (t.attachmentState = this.unkeyedState + XI);
    }
    applyRotateTimeline(e, t, n, i, r, a, o, h) {
        if ((h && (a[o] = 0), i == 1)) {
            e.apply(t, 0, n, null, 1, r, fn.mixIn);
            return;
        }
        let l = t.bones[e.boneIndex];
        if (!l.active) return;
        let u = e.frames,
            c = 0,
            d = 0;
        if (n < u[0])
            switch (r) {
                case z.setup:
                    l.rotation = l.data.rotation;
                default:
                    return;
                case z.first:
                    (c = l.rotation), (d = l.data.rotation);
            }
        else
            (c = r == z.setup ? l.data.rotation : l.rotation),
                (d = l.data.rotation + e.getCurveValue(n));
        let f = 0,
            p = d - c;
        if (((p -= Math.ceil(p / 360 - 0.5) * 360), p == 0)) f = a[o];
        else {
            let m = 0,
                g = 0;
            h ? ((m = 0), (g = p)) : ((m = a[o]), (g = a[o + 1]));
            let _ = m - (m % 360);
            f = p + _;
            let v = p >= 0,
                b = m >= 0;
            Math.abs(g) <= 90 &&
                q.signum(g) != q.signum(p) &&
                (Math.abs(m - _) > 180
                    ? ((f += 360 * q.signum(m)), (b = v))
                    : _ != 0
                    ? (f -= 360 * q.signum(m))
                    : (b = v)),
                b != v && (f += 360 * q.signum(m)),
                (a[o] = f);
        }
        (a[o + 1] = p), (l.rotation = c + f * i);
    }
    queueEvents(e, t) {
        let n = e.animationStart,
            i = e.animationEnd,
            r = i - n,
            a = e.trackLast % r,
            o = this.events,
            h = 0,
            l = o.length;
        for (; h < l; h++) {
            let c = o[h];
            if (c.time < a) break;
            c.time > i || this.queue.event(e, c);
        }
        let u = !1;
        if (e.loop)
            if (r == 0) u = !0;
            else {
                const c = Math.floor(e.trackTime / r);
                u = c > 0 && c > Math.floor(e.trackLast / r);
            }
        else u = t >= i && e.animationLast < i;
        for (u && this.queue.complete(e); h < l; h++) {
            let c = o[h];
            c.time < n || this.queue.event(e, c);
        }
    }
    clearTracks() {
        let e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let t = 0, n = this.tracks.length; t < n; t++) this.clearTrack(t);
        (this.tracks.length = 0),
            (this.queue.drainDisabled = e),
            this.queue.drain();
    }
    clearTrack(e) {
        if (e >= this.tracks.length) return;
        let t = this.tracks[e];
        if (!t) return;
        this.queue.end(t), this.clearNext(t);
        let n = t;
        for (;;) {
            let i = n.mixingFrom;
            if (!i) break;
            this.queue.end(i),
                (n.mixingFrom = null),
                (n.mixingTo = null),
                (n = i);
        }
        (this.tracks[t.trackIndex] = null), this.queue.drain();
    }
    setCurrent(e, t, n) {
        let i = this.expandToIndex(e);
        (this.tracks[e] = t),
            (t.previous = null),
            i &&
                (n && this.queue.interrupt(i),
                (t.mixingFrom = i),
                (i.mixingTo = t),
                (t.mixTime = 0),
                i.mixingFrom &&
                    i.mixDuration > 0 &&
                    (t.interruptAlpha *= Math.min(
                        1,
                        i.mixTime / i.mixDuration
                    )),
                (i.timelinesRotation.length = 0)),
            this.queue.start(t);
    }
    setAnimation(e, t, n = !1) {
        let i = this.data.skeletonData.findAnimation(t);
        if (!i) throw new Error("Animation not found: " + t);
        return this.setAnimationWith(e, i, n);
    }
    setAnimationWith(e, t, n = !1) {
        if (!t) throw new Error("animation cannot be null.");
        let i = !0,
            r = this.expandToIndex(e);
        r &&
            (r.nextTrackLast == -1
                ? ((this.tracks[e] = r.mixingFrom),
                  this.queue.interrupt(r),
                  this.queue.end(r),
                  this.clearNext(r),
                  (r = r.mixingFrom),
                  (i = !1))
                : this.clearNext(r));
        let a = this.trackEntry(e, t, n, r);
        return this.setCurrent(e, a, i), this.queue.drain(), a;
    }
    addAnimation(e, t, n = !1, i = 0) {
        let r = this.data.skeletonData.findAnimation(t);
        if (!r) throw new Error("Animation not found: " + t);
        return this.addAnimationWith(e, r, n, i);
    }
    addAnimationWith(e, t, n = !1, i = 0) {
        if (!t) throw new Error("animation cannot be null.");
        let r = this.expandToIndex(e);
        if (r) for (; r.next; ) r = r.next;
        let a = this.trackEntry(e, t, n, r);
        return (
            r
                ? ((r.next = a),
                  (a.previous = r),
                  i <= 0 &&
                      (i = Math.max(
                          i + r.getTrackComplete() - a.mixDuration,
                          0
                      )))
                : (this.setCurrent(e, a, !0),
                  this.queue.drain(),
                  i < 0 && (i = 0)),
            (a.delay = i),
            a
        );
    }
    setEmptyAnimation(e, t = 0) {
        let n = this.setAnimationWith(e, Ao.emptyAnimation(), !1);
        return (n.mixDuration = t), (n.trackEnd = t), n;
    }
    addEmptyAnimation(e, t = 0, n = 0) {
        let i = this.addAnimationWith(e, Ao.emptyAnimation(), !1, n);
        return (
            n <= 0 && (i.delay = Math.max(i.delay + i.mixDuration - t, 0)),
            (i.mixDuration = t),
            (i.trackEnd = t),
            i
        );
    }
    setEmptyAnimations(e = 0) {
        let t = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let n = 0, i = this.tracks.length; n < i; n++) {
            let r = this.tracks[n];
            r && this.setEmptyAnimation(r.trackIndex, e);
        }
        (this.queue.drainDisabled = t), this.queue.drain();
    }
    expandToIndex(e) {
        return e < this.tracks.length
            ? this.tracks[e]
            : (K.ensureArrayCapacity(this.tracks, e + 1, null),
              (this.tracks.length = e + 1),
              null);
    }
    trackEntry(e, t, n, i) {
        let r = this.trackEntryPool.obtain();
        return (
            r.reset(),
            (r.trackIndex = e),
            (r.animation = t),
            (r.loop = n),
            (r.holdPrevious = !1),
            (r.reverse = !1),
            (r.shortestRotation = !1),
            (r.eventThreshold = 0),
            (r.alphaAttachmentThreshold = 0),
            (r.mixAttachmentThreshold = 0),
            (r.mixDrawOrderThreshold = 0),
            (r.animationStart = 0),
            (r.animationEnd = t.duration),
            (r.animationLast = -1),
            (r.nextAnimationLast = -1),
            (r.delay = 0),
            (r.trackTime = 0),
            (r.trackLast = -1),
            (r.nextTrackLast = -1),
            (r.trackEnd = Number.MAX_VALUE),
            (r.timeScale = 1),
            (r.alpha = 1),
            (r.mixTime = 0),
            (r.mixDuration = i ? this.data.getMix(i.animation, t) : 0),
            (r.interruptAlpha = 1),
            (r.totalAlpha = 0),
            (r.mixBlend = z.replace),
            r
        );
    }
    clearNext(e) {
        let t = e.next;
        for (; t; ) this.queue.dispose(t), (t = t.next);
        e.next = null;
    }
    _animationsChanged() {
        (this.animationsChanged = !1), this.propertyIDs.clear();
        let e = this.tracks;
        for (let t = 0, n = e.length; t < n; t++) {
            let i = e[t];
            if (i) {
                for (; i.mixingFrom; ) i = i.mixingFrom;
                do
                    (!i.mixingTo || i.mixBlend != z.add) && this.computeHold(i),
                        (i = i.mixingTo);
                while (i);
            }
        }
    }
    computeHold(e) {
        let t = e.mixingTo,
            n = e.animation.timelines,
            i = e.animation.timelines.length,
            r = e.timelineMode;
        r.length = i;
        let a = e.timelineHoldMix;
        a.length = 0;
        let o = this.propertyIDs;
        if (t && t.holdPrevious) {
            for (let h = 0; h < i; h++)
                r[h] = o.addAll(n[h].getPropertyIds()) ? Jf : ab;
            return;
        }
        e: for (let h = 0; h < i; h++) {
            let l = n[h],
                u = l.getPropertyIds();
            if (!o.addAll(u)) r[h] = Qf;
            else if (
                !t ||
                l instanceof xo ||
                l instanceof Sa ||
                l instanceof Yh ||
                !t.animation.hasTimeline(u)
            )
                r[h] = rb;
            else {
                for (let c = t.mixingTo; c; c = c.mixingTo)
                    if (!c.animation.hasTimeline(u)) {
                        if (e.mixDuration > 0) {
                            (r[h] = WI), (a[h] = c);
                            continue e;
                        }
                        break;
                    }
                r[h] = Jf;
            }
        }
    }
    getCurrent(e) {
        return e >= this.tracks.length ? null : this.tracks[e];
    }
    addListener(e) {
        if (!e) throw new Error("listener cannot be null.");
        this.listeners.push(e);
    }
    removeListener(e) {
        let t = this.listeners.indexOf(e);
        t >= 0 && this.listeners.splice(t, 1);
    }
    clearListeners() {
        this.listeners.length = 0;
    }
    clearListenerNotifications() {
        this.queue.clear();
    }
};
x(Ao, "_emptyAnimation", new zg("<empty>", [], 0));
let xm = Ao;
class GI {
    constructor() {
        x(this, "animation", null);
        x(this, "previous", null);
        x(this, "next", null);
        x(this, "mixingFrom", null);
        x(this, "mixingTo", null);
        x(this, "listener", null);
        x(this, "trackIndex", 0);
        x(this, "loop", !1);
        x(this, "holdPrevious", !1);
        x(this, "reverse", !1);
        x(this, "shortestRotation", !1);
        x(this, "eventThreshold", 0);
        x(this, "mixAttachmentThreshold", 0);
        x(this, "alphaAttachmentThreshold", 0);
        x(this, "mixDrawOrderThreshold", 0);
        x(this, "animationStart", 0);
        x(this, "animationEnd", 0);
        x(this, "animationLast", 0);
        x(this, "nextAnimationLast", 0);
        x(this, "delay", 0);
        x(this, "trackTime", 0);
        x(this, "trackLast", 0);
        x(this, "nextTrackLast", 0);
        x(this, "trackEnd", 0);
        x(this, "timeScale", 0);
        x(this, "alpha", 0);
        x(this, "mixTime", 0);
        x(this, "_mixDuration", 0);
        x(this, "interruptAlpha", 0);
        x(this, "totalAlpha", 0);
        x(this, "mixBlend", z.replace);
        x(this, "timelineMode", new Array());
        x(this, "timelineHoldMix", new Array());
        x(this, "timelinesRotation", new Array());
    }
    get mixDuration() {
        return this._mixDuration;
    }
    set mixDuration(e) {
        this._mixDuration = e;
    }
    setMixDurationWithDelay(e, t) {
        (this._mixDuration = e),
            t <= 0 &&
                (this.previous != null
                    ? (t = Math.max(
                          t + this.previous.getTrackComplete() - e,
                          0
                      ))
                    : (t = 0)),
            (this.delay = t);
    }
    reset() {
        (this.next = null),
            (this.previous = null),
            (this.mixingFrom = null),
            (this.mixingTo = null),
            (this.animation = null),
            (this.listener = null),
            (this.timelineMode.length = 0),
            (this.timelineHoldMix.length = 0),
            (this.timelinesRotation.length = 0);
    }
    getAnimationTime() {
        if (this.loop) {
            let e = this.animationEnd - this.animationStart;
            return e == 0
                ? this.animationStart
                : (this.trackTime % e) + this.animationStart;
        }
        return Math.min(
            this.trackTime + this.animationStart,
            this.animationEnd
        );
    }
    setAnimationLast(e) {
        (this.animationLast = e), (this.nextAnimationLast = e);
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart;
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0;
    }
    getTrackComplete() {
        let e = this.animationEnd - this.animationStart;
        if (e != 0) {
            if (this.loop) return e * (1 + ((this.trackTime / e) | 0));
            if (this.trackTime < e) return e;
        }
        return this.trackTime;
    }
    wasApplied() {
        return this.nextTrackLast != -1;
    }
    isNextReady() {
        return this.next != null && this.nextTrackLast - this.next.delay >= 0;
    }
}
class jI {
    constructor(e) {
        x(this, "objects", []);
        x(this, "drainDisabled", !1);
        x(this, "animState");
        this.animState = e;
    }
    start(e) {
        this.objects.push(Fn.start),
            this.objects.push(e),
            (this.animState.animationsChanged = !0);
    }
    interrupt(e) {
        this.objects.push(Fn.interrupt), this.objects.push(e);
    }
    end(e) {
        this.objects.push(Fn.end),
            this.objects.push(e),
            (this.animState.animationsChanged = !0);
    }
    dispose(e) {
        this.objects.push(Fn.dispose), this.objects.push(e);
    }
    complete(e) {
        this.objects.push(Fn.complete), this.objects.push(e);
    }
    event(e, t) {
        this.objects.push(Fn.event), this.objects.push(e), this.objects.push(t);
    }
    drain() {
        if (this.drainDisabled) return;
        this.drainDisabled = !0;
        let e = this.objects,
            t = this.animState.listeners;
        for (let n = 0; n < e.length; n += 2) {
            let i = e[n],
                r = e[n + 1];
            switch (i) {
                case Fn.start:
                    r.listener && r.listener.start && r.listener.start(r);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.start && h.start(r);
                    }
                    break;
                case Fn.interrupt:
                    r.listener &&
                        r.listener.interrupt &&
                        r.listener.interrupt(r);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.interrupt && h.interrupt(r);
                    }
                    break;
                case Fn.end:
                    r.listener && r.listener.end && r.listener.end(r);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.end && h.end(r);
                    }
                case Fn.dispose:
                    r.listener && r.listener.dispose && r.listener.dispose(r);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.dispose && h.dispose(r);
                    }
                    this.animState.trackEntryPool.free(r);
                    break;
                case Fn.complete:
                    r.listener && r.listener.complete && r.listener.complete(r);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.complete && h.complete(r);
                    }
                    break;
                case Fn.event:
                    let a = e[n++ + 2];
                    r.listener && r.listener.event && r.listener.event(r, a);
                    for (let o = 0; o < t.length; o++) {
                        let h = t[o];
                        h.event && h.event(r, a);
                    }
                    break;
            }
        }
        this.clear(), (this.drainDisabled = !1);
    }
    clear() {
        this.objects.length = 0;
    }
}
var Fn;
(function (s) {
    (s[(s.start = 0)] = "start"),
        (s[(s.interrupt = 1)] = "interrupt"),
        (s[(s.end = 2)] = "end"),
        (s[(s.dispose = 3)] = "dispose"),
        (s[(s.complete = 4)] = "complete"),
        (s[(s.event = 5)] = "event");
})(Fn || (Fn = {}));
const Qf = 0,
    rb = 1,
    ab = 2,
    Jf = 3,
    WI = 4,
    ob = 1,
    XI = 2;
class qI {
    constructor(e) {
        x(this, "skeletonData");
        x(this, "animationToMixTime", {});
        x(this, "defaultMix", 0);
        if (!e) throw new Error("skeletonData cannot be null.");
        this.skeletonData = e;
    }
    setMix(e, t, n) {
        let i = this.skeletonData.findAnimation(e);
        if (!i) throw new Error("Animation not found: " + e);
        let r = this.skeletonData.findAnimation(t);
        if (!r) throw new Error("Animation not found: " + t);
        this.setMixWith(i, r, n);
    }
    setMixWith(e, t, n) {
        if (!e) throw new Error("from cannot be null.");
        if (!t) throw new Error("to cannot be null.");
        let i = e.name + "." + t.name;
        this.animationToMixTime[i] = n;
    }
    getMix(e, t) {
        let n = e.name + "." + t.name,
            i = this.animationToMixTime[n];
        return i === void 0 ? this.defaultMix : i;
    }
}
class Td extends Ks {
    constructor(t) {
        super(t);
        x(this, "color", new he(1, 1, 1, 1));
    }
    copy() {
        let t = new Td(this.name);
        return this.copyTo(t), t.color.setFromColor(this.color), t;
    }
}
class Ea extends Ks {
    constructor(t) {
        super(t);
        x(this, "endSlot", null);
        x(this, "color", new he(0.2275, 0.2275, 0.8078, 1));
    }
    copy() {
        let t = new Ea(this.name);
        return (
            this.copyTo(t),
            (t.endSlot = this.endSlot),
            t.color.setFromColor(this.color),
            t
        );
    }
}
class HI {
    constructor(e) {
        x(this, "_image");
        this._image = e;
    }
    getImage() {
        return this._image;
    }
}
var jt;
(function (s) {
    (s[(s.Nearest = 9728)] = "Nearest"),
        (s[(s.Linear = 9729)] = "Linear"),
        (s[(s.MipMap = 9987)] = "MipMap"),
        (s[(s.MipMapNearestNearest = 9984)] = "MipMapNearestNearest"),
        (s[(s.MipMapLinearNearest = 9985)] = "MipMapLinearNearest"),
        (s[(s.MipMapNearestLinear = 9986)] = "MipMapNearestLinear"),
        (s[(s.MipMapLinearLinear = 9987)] = "MipMapLinearLinear");
})(jt || (jt = {}));
var Ji;
(function (s) {
    (s[(s.MirroredRepeat = 33648)] = "MirroredRepeat"),
        (s[(s.ClampToEdge = 33071)] = "ClampToEdge"),
        (s[(s.Repeat = 10497)] = "Repeat");
})(Ji || (Ji = {}));
class KI {
    constructor() {
        x(this, "texture");
        x(this, "u", 0);
        x(this, "v", 0);
        x(this, "u2", 0);
        x(this, "v2", 0);
        x(this, "width", 0);
        x(this, "height", 0);
        x(this, "degrees", 0);
        x(this, "offsetX", 0);
        x(this, "offsetY", 0);
        x(this, "originalWidth", 0);
        x(this, "originalHeight", 0);
    }
}
class ZI {
    constructor(e) {
        x(this, "pages", new Array());
        x(this, "regions", new Array());
        let t = new QI(e),
            n = new Array(4),
            i = {};
        (i.size = (u) => {
            (u.width = parseInt(n[1])), (u.height = parseInt(n[2]));
        }),
            (i.format = () => {}),
            (i.filter = (u) => {
                (u.minFilter = K.enumValue(jt, n[1])),
                    (u.magFilter = K.enumValue(jt, n[2]));
            }),
            (i.repeat = (u) => {
                n[1].indexOf("x") != -1 && (u.uWrap = Ji.Repeat),
                    n[1].indexOf("y") != -1 && (u.vWrap = Ji.Repeat);
            }),
            (i.pma = (u) => {
                u.pma = n[1] == "true";
            });
        var r = {};
        (r.xy = (u) => {
            (u.x = parseInt(n[1])), (u.y = parseInt(n[2]));
        }),
            (r.size = (u) => {
                (u.width = parseInt(n[1])), (u.height = parseInt(n[2]));
            }),
            (r.bounds = (u) => {
                (u.x = parseInt(n[1])),
                    (u.y = parseInt(n[2])),
                    (u.width = parseInt(n[3])),
                    (u.height = parseInt(n[4]));
            }),
            (r.offset = (u) => {
                (u.offsetX = parseInt(n[1])), (u.offsetY = parseInt(n[2]));
            }),
            (r.orig = (u) => {
                (u.originalWidth = parseInt(n[1])),
                    (u.originalHeight = parseInt(n[2]));
            }),
            (r.offsets = (u) => {
                (u.offsetX = parseInt(n[1])),
                    (u.offsetY = parseInt(n[2])),
                    (u.originalWidth = parseInt(n[3])),
                    (u.originalHeight = parseInt(n[4]));
            }),
            (r.rotate = (u) => {
                let c = n[1];
                c == "true"
                    ? (u.degrees = 90)
                    : c != "false" && (u.degrees = parseInt(c));
            }),
            (r.index = (u) => {
                u.index = parseInt(n[1]);
            });
        let a = t.readLine();
        for (; a && a.trim().length == 0; ) a = t.readLine();
        for (; !(!a || a.trim().length == 0 || t.readEntry(n, a) == 0); )
            a = t.readLine();
        let o = null,
            h = null,
            l = null;
        for (; a !== null; )
            if (a.trim().length == 0) (o = null), (a = t.readLine());
            else if (o) {
                let u = new r2(o, a);
                for (;;) {
                    let c = t.readEntry(n, (a = t.readLine()));
                    if (c == 0) break;
                    let d = r[n[0]];
                    if (d) d(u);
                    else {
                        h || (h = []), l || (l = []), h.push(n[0]);
                        let f = [];
                        for (let p = 0; p < c; p++) f.push(parseInt(n[p + 1]));
                        l.push(f);
                    }
                }
                u.originalWidth == 0 &&
                    u.originalHeight == 0 &&
                    ((u.originalWidth = u.width),
                    (u.originalHeight = u.height)),
                    h &&
                        h.length > 0 &&
                        l &&
                        l.length > 0 &&
                        ((u.names = h), (u.values = l), (h = null), (l = null)),
                    (u.u = u.x / o.width),
                    (u.v = u.y / o.height),
                    u.degrees == 90
                        ? ((u.u2 = (u.x + u.height) / o.width),
                          (u.v2 = (u.y + u.width) / o.height))
                        : ((u.u2 = (u.x + u.width) / o.width),
                          (u.v2 = (u.y + u.height) / o.height)),
                    this.regions.push(u);
            } else {
                for (
                    o = new JI(a.trim());
                    t.readEntry(n, (a = t.readLine())) != 0;

                ) {
                    let u = i[n[0]];
                    u && u(o);
                }
                this.pages.push(o);
            }
    }
    findRegion(e) {
        for (let t = 0; t < this.regions.length; t++)
            if (this.regions[t].name == e) return this.regions[t];
        return null;
    }
    setTextures(e, t = "") {
        for (let n of this.pages) n.setTexture(e.get(t + n.name));
    }
    dispose() {
        var e;
        for (let t = 0; t < this.pages.length; t++)
            (e = this.pages[t].texture) == null || e.dispose();
    }
}
class QI {
    constructor(e) {
        x(this, "lines");
        x(this, "index", 0);
        this.lines = e.split(/\r\n|\r|\n/);
    }
    readLine() {
        return this.index >= this.lines.length
            ? null
            : this.lines[this.index++];
    }
    readEntry(e, t) {
        if (!t || ((t = t.trim()), t.length == 0)) return 0;
        let n = t.indexOf(":");
        if (n == -1) return 0;
        e[0] = t.substr(0, n).trim();
        for (let i = 1, r = n + 1; ; i++) {
            let a = t.indexOf(",", r);
            if (a == -1) return (e[i] = t.substr(r).trim()), i;
            if (((e[i] = t.substr(r, a - r).trim()), (r = a + 1), i == 4))
                return 4;
        }
    }
}
class JI {
    constructor(e) {
        x(this, "name");
        x(this, "minFilter", jt.Nearest);
        x(this, "magFilter", jt.Nearest);
        x(this, "uWrap", Ji.ClampToEdge);
        x(this, "vWrap", Ji.ClampToEdge);
        x(this, "texture", null);
        x(this, "width", 0);
        x(this, "height", 0);
        x(this, "pma", !1);
        x(this, "regions", new Array());
        this.name = e;
    }
    setTexture(e) {
        (this.texture = e),
            e.setFilters(this.minFilter, this.magFilter),
            e.setWraps(this.uWrap, this.vWrap);
        for (let t of this.regions) t.texture = e;
    }
}
class r2 extends KI {
    constructor(t, n) {
        super();
        x(this, "page");
        x(this, "name");
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "offsetX", 0);
        x(this, "offsetY", 0);
        x(this, "originalWidth", 0);
        x(this, "originalHeight", 0);
        x(this, "index", 0);
        x(this, "degrees", 0);
        x(this, "names", null);
        x(this, "values", null);
        (this.page = t), (this.name = n), t.regions.push(this);
    }
}
class Xs extends Ks {
    constructor(t, n) {
        super(t);
        x(this, "region", null);
        x(this, "path");
        x(this, "regionUVs", []);
        x(this, "uvs", []);
        x(this, "triangles", []);
        x(this, "color", new he(1, 1, 1, 1));
        x(this, "width", 0);
        x(this, "height", 0);
        x(this, "hullLength", 0);
        x(this, "edges", []);
        x(this, "parentMesh", null);
        x(this, "sequence", null);
        x(this, "tempColor", new he(0, 0, 0, 0));
        this.path = n;
    }
    updateRegion() {
        if (!this.region) throw new Error("Region not set.");
        let t = this.regionUVs;
        (!this.uvs || this.uvs.length != t.length) &&
            (this.uvs = K.newFloatArray(t.length));
        let n = this.uvs,
            i = this.uvs.length,
            r = this.region.u,
            a = this.region.v,
            o = 0,
            h = 0;
        if (this.region instanceof r2) {
            let l = this.region,
                u = l.page,
                c = u.width,
                d = u.height;
            switch (l.degrees) {
                case 90:
                    (r -= (l.originalHeight - l.offsetY - l.height) / c),
                        (a -= (l.originalWidth - l.offsetX - l.width) / d),
                        (o = l.originalHeight / c),
                        (h = l.originalWidth / d);
                    for (let f = 0; f < i; f += 2)
                        (n[f] = r + t[f + 1] * o),
                            (n[f + 1] = a + (1 - t[f]) * h);
                    return;
                case 180:
                    (r -= (l.originalWidth - l.offsetX - l.width) / c),
                        (a -= l.offsetY / d),
                        (o = l.originalWidth / c),
                        (h = l.originalHeight / d);
                    for (let f = 0; f < i; f += 2)
                        (n[f] = r + (1 - t[f]) * o),
                            (n[f + 1] = a + (1 - t[f + 1]) * h);
                    return;
                case 270:
                    (r -= l.offsetY / c),
                        (a -= l.offsetX / d),
                        (o = l.originalHeight / c),
                        (h = l.originalWidth / d);
                    for (let f = 0; f < i; f += 2)
                        (n[f] = r + (1 - t[f + 1]) * o),
                            (n[f + 1] = a + t[f] * h);
                    return;
            }
            (r -= l.offsetX / c),
                (a -= (l.originalHeight - l.offsetY - l.height) / d),
                (o = l.originalWidth / c),
                (h = l.originalHeight / d);
        } else
            this.region
                ? ((o = this.region.u2 - r), (h = this.region.v2 - a))
                : ((r = a = 0), (o = h = 1));
        for (let l = 0; l < i; l += 2)
            (n[l] = r + t[l] * o), (n[l + 1] = a + t[l + 1] * h);
    }
    getParentMesh() {
        return this.parentMesh;
    }
    setParentMesh(t) {
        (this.parentMesh = t),
            t &&
                ((this.bones = t.bones),
                (this.vertices = t.vertices),
                (this.worldVerticesLength = t.worldVerticesLength),
                (this.regionUVs = t.regionUVs),
                (this.triangles = t.triangles),
                (this.hullLength = t.hullLength),
                (this.worldVerticesLength = t.worldVerticesLength));
    }
    copy() {
        if (this.parentMesh) return this.newLinkedMesh();
        let t = new Xs(this.name, this.path);
        return (
            (t.region = this.region),
            t.color.setFromColor(this.color),
            this.copyTo(t),
            (t.regionUVs = new Array(this.regionUVs.length)),
            K.arrayCopy(
                this.regionUVs,
                0,
                t.regionUVs,
                0,
                this.regionUVs.length
            ),
            (t.uvs =
                this.uvs instanceof Float32Array
                    ? K.newFloatArray(this.uvs.length)
                    : new Array(this.uvs.length)),
            K.arrayCopy(this.uvs, 0, t.uvs, 0, this.uvs.length),
            (t.triangles = new Array(this.triangles.length)),
            K.arrayCopy(
                this.triangles,
                0,
                t.triangles,
                0,
                this.triangles.length
            ),
            (t.hullLength = this.hullLength),
            (t.sequence = this.sequence != null ? this.sequence.copy() : null),
            this.edges &&
                ((t.edges = new Array(this.edges.length)),
                K.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)),
            (t.width = this.width),
            (t.height = this.height),
            t
        );
    }
    computeWorldVertices(t, n, i, r, a, o) {
        this.sequence != null && this.sequence.apply(t, this),
            super.computeWorldVertices(t, n, i, r, a, o);
    }
    newLinkedMesh() {
        let t = new Xs(this.name, this.path);
        return (
            (t.region = this.region),
            t.color.setFromColor(this.color),
            (t.timelineAttachment = this.timelineAttachment),
            t.setParentMesh(this.parentMesh ? this.parentMesh : this),
            t.region != null && t.updateRegion(),
            t
        );
    }
}
class al extends Ks {
    constructor(t) {
        super(t);
        x(this, "lengths", []);
        x(this, "closed", !1);
        x(this, "constantSpeed", !1);
        x(this, "color", new he(1, 1, 1, 1));
    }
    copy() {
        let t = new al(this.name);
        return (
            this.copyTo(t),
            (t.lengths = new Array(this.lengths.length)),
            K.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length),
            (t.closed = closed),
            (t.constantSpeed = this.constantSpeed),
            t.color.setFromColor(this.color),
            t
        );
    }
}
class Gg extends Ks {
    constructor(t) {
        super(t);
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "rotation", 0);
        x(this, "color", new he(0.38, 0.94, 0, 1));
    }
    computeWorldPosition(t, n) {
        return (
            (n.x = this.x * t.a + this.y * t.b + t.worldX),
            (n.y = this.x * t.c + this.y * t.d + t.worldY),
            n
        );
    }
    computeWorldRotation(t) {
        const n = this.rotation * q.degRad,
            i = Math.cos(n),
            r = Math.sin(n),
            a = i * t.a + r * t.b,
            o = i * t.c + r * t.d;
        return q.atan2Deg(o, a);
    }
    copy() {
        let t = new Gg(this.name);
        return (
            (t.x = this.x),
            (t.y = this.y),
            (t.rotation = this.rotation),
            t.color.setFromColor(this.color),
            t
        );
    }
}
const Se = class Se extends TC {
    constructor(t, n) {
        super(t);
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "scaleX", 1);
        x(this, "scaleY", 1);
        x(this, "rotation", 0);
        x(this, "width", 0);
        x(this, "height", 0);
        x(this, "color", new he(1, 1, 1, 1));
        x(this, "path");
        x(this, "region", null);
        x(this, "sequence", null);
        x(this, "offset", K.newFloatArray(8));
        x(this, "uvs", K.newFloatArray(8));
        x(this, "tempColor", new he(1, 1, 1, 1));
        this.path = n;
    }
    updateRegion() {
        if (!this.region) throw new Error("Region not set.");
        let t = this.region,
            n = this.uvs;
        if (t == null) {
            (n[0] = 0),
                (n[1] = 0),
                (n[2] = 0),
                (n[3] = 1),
                (n[4] = 1),
                (n[5] = 1),
                (n[6] = 1),
                (n[7] = 0);
            return;
        }
        let i = (this.width / this.region.originalWidth) * this.scaleX,
            r = (this.height / this.region.originalHeight) * this.scaleY,
            a = (-this.width / 2) * this.scaleX + this.region.offsetX * i,
            o = (-this.height / 2) * this.scaleY + this.region.offsetY * r,
            h = a + this.region.width * i,
            l = o + this.region.height * r,
            u = this.rotation * q.degRad,
            c = Math.cos(u),
            d = Math.sin(u),
            f = this.x,
            p = this.y,
            m = a * c + f,
            g = a * d,
            _ = o * c + p,
            v = o * d,
            b = h * c + f,
            y = h * d,
            C = l * c + p,
            w = l * d,
            A = this.offset;
        (A[0] = m - v),
            (A[1] = _ + g),
            (A[2] = m - w),
            (A[3] = C + g),
            (A[4] = b - w),
            (A[5] = C + y),
            (A[6] = b - v),
            (A[7] = _ + y),
            t.degrees == 90
                ? ((n[0] = t.u2),
                  (n[1] = t.v2),
                  (n[2] = t.u),
                  (n[3] = t.v2),
                  (n[4] = t.u),
                  (n[5] = t.v),
                  (n[6] = t.u2),
                  (n[7] = t.v))
                : ((n[0] = t.u),
                  (n[1] = t.v2),
                  (n[2] = t.u),
                  (n[3] = t.v),
                  (n[4] = t.u2),
                  (n[5] = t.v),
                  (n[6] = t.u2),
                  (n[7] = t.v2));
    }
    computeWorldVertices(t, n, i, r) {
        this.sequence != null && this.sequence.apply(t, this);
        let a = t.bone,
            o = this.offset,
            h = a.worldX,
            l = a.worldY,
            u = a.a,
            c = a.b,
            d = a.c,
            f = a.d,
            p = 0,
            m = 0;
        (p = o[0]),
            (m = o[1]),
            (n[i] = p * u + m * c + h),
            (n[i + 1] = p * d + m * f + l),
            (i += r),
            (p = o[2]),
            (m = o[3]),
            (n[i] = p * u + m * c + h),
            (n[i + 1] = p * d + m * f + l),
            (i += r),
            (p = o[4]),
            (m = o[5]),
            (n[i] = p * u + m * c + h),
            (n[i + 1] = p * d + m * f + l),
            (i += r),
            (p = o[6]),
            (m = o[7]),
            (n[i] = p * u + m * c + h),
            (n[i + 1] = p * d + m * f + l);
    }
    copy() {
        let t = new Se(this.name, this.path);
        return (
            (t.region = this.region),
            (t.x = this.x),
            (t.y = this.y),
            (t.scaleX = this.scaleX),
            (t.scaleY = this.scaleY),
            (t.rotation = this.rotation),
            (t.width = this.width),
            (t.height = this.height),
            K.arrayCopy(this.uvs, 0, t.uvs, 0, 8),
            K.arrayCopy(this.offset, 0, t.offset, 0, 8),
            t.color.setFromColor(this.color),
            (t.sequence = this.sequence != null ? this.sequence.copy() : null),
            t
        );
    }
};
x(Se, "X1", 0),
    x(Se, "Y1", 1),
    x(Se, "C1R", 2),
    x(Se, "C1G", 3),
    x(Se, "C1B", 4),
    x(Se, "C1A", 5),
    x(Se, "U1", 6),
    x(Se, "V1", 7),
    x(Se, "X2", 8),
    x(Se, "Y2", 9),
    x(Se, "C2R", 10),
    x(Se, "C2G", 11),
    x(Se, "C2B", 12),
    x(Se, "C2A", 13),
    x(Se, "U2", 14),
    x(Se, "V2", 15),
    x(Se, "X3", 16),
    x(Se, "Y3", 17),
    x(Se, "C3R", 18),
    x(Se, "C3G", 19),
    x(Se, "C3B", 20),
    x(Se, "C3A", 21),
    x(Se, "U3", 22),
    x(Se, "V3", 23),
    x(Se, "X4", 24),
    x(Se, "Y4", 25),
    x(Se, "C4R", 26),
    x(Se, "C4G", 27),
    x(Se, "C4B", 28),
    x(Se, "C4A", 29),
    x(Se, "U4", 30),
    x(Se, "V4", 31);
let Gs = Se;
class eR {
    constructor(e) {
        x(this, "atlas");
        this.atlas = e;
    }
    loadSequence(e, t, n) {
        let i = n.regions;
        for (let r = 0, a = i.length; r < a; r++) {
            let o = n.getPath(t, r),
                h = this.atlas.findRegion(o);
            if (h == null)
                throw new Error(
                    "Region not found in atlas: " + o + " (sequence: " + e + ")"
                );
            i[r] = h;
        }
    }
    newRegionAttachment(e, t, n, i) {
        let r = new Gs(t, n);
        if (i != null) this.loadSequence(t, n, i);
        else {
            let a = this.atlas.findRegion(n);
            if (!a)
                throw new Error(
                    "Region not found in atlas: " +
                        n +
                        " (region attachment: " +
                        t +
                        ")"
                );
            r.region = a;
        }
        return r;
    }
    newMeshAttachment(e, t, n, i) {
        let r = new Xs(t, n);
        if (i != null) this.loadSequence(t, n, i);
        else {
            let a = this.atlas.findRegion(n);
            if (!a)
                throw new Error(
                    "Region not found in atlas: " +
                        n +
                        " (mesh attachment: " +
                        t +
                        ")"
                );
            r.region = a;
        }
        return r;
    }
    newBoundingBoxAttachment(e, t) {
        return new Td(t);
    }
    newPathAttachment(e, t) {
        return new al(t);
    }
    newPointAttachment(e, t) {
        return new Gg(t);
    }
    newClippingAttachment(e, t) {
        return new Ea(t);
    }
}
class a2 {
    constructor(e, t, n) {
        x(this, "index", 0);
        x(this, "name");
        x(this, "parent", null);
        x(this, "length", 0);
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "rotation", 0);
        x(this, "scaleX", 1);
        x(this, "scaleY", 1);
        x(this, "shearX", 0);
        x(this, "shearY", 0);
        x(this, "inherit", bt.Normal);
        x(this, "skinRequired", !1);
        x(this, "color", new he());
        x(this, "icon");
        x(this, "visible", !1);
        if (e < 0) throw new Error("index must be >= 0.");
        if (!t) throw new Error("name cannot be null.");
        (this.index = e), (this.name = t), (this.parent = n);
    }
}
var bt;
(function (s) {
    (s[(s.Normal = 0)] = "Normal"),
        (s[(s.OnlyTranslation = 1)] = "OnlyTranslation"),
        (s[(s.NoRotationOrReflection = 2)] = "NoRotationOrReflection"),
        (s[(s.NoScale = 3)] = "NoScale"),
        (s[(s.NoScaleOrReflection = 4)] = "NoScaleOrReflection");
})(bt || (bt = {}));
class lb {
    constructor(e, t, n) {
        x(this, "data");
        x(this, "skeleton");
        x(this, "parent", null);
        x(this, "children", new Array());
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "rotation", 0);
        x(this, "scaleX", 0);
        x(this, "scaleY", 0);
        x(this, "shearX", 0);
        x(this, "shearY", 0);
        x(this, "ax", 0);
        x(this, "ay", 0);
        x(this, "arotation", 0);
        x(this, "ascaleX", 0);
        x(this, "ascaleY", 0);
        x(this, "ashearX", 0);
        x(this, "ashearY", 0);
        x(this, "a", 0);
        x(this, "b", 0);
        x(this, "c", 0);
        x(this, "d", 0);
        x(this, "worldY", 0);
        x(this, "worldX", 0);
        x(this, "inherit", bt.Normal);
        x(this, "sorted", !1);
        x(this, "active", !1);
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        (this.data = e),
            (this.skeleton = t),
            (this.parent = n),
            this.setToSetupPose();
    }
    isActive() {
        return this.active;
    }
    update(e) {
        this.updateWorldTransformWith(
            this.ax,
            this.ay,
            this.arotation,
            this.ascaleX,
            this.ascaleY,
            this.ashearX,
            this.ashearY
        );
    }
    updateWorldTransform() {
        this.updateWorldTransformWith(
            this.x,
            this.y,
            this.rotation,
            this.scaleX,
            this.scaleY,
            this.shearX,
            this.shearY
        );
    }
    updateWorldTransformWith(e, t, n, i, r, a, o) {
        (this.ax = e),
            (this.ay = t),
            (this.arotation = n),
            (this.ascaleX = i),
            (this.ascaleY = r),
            (this.ashearX = a),
            (this.ashearY = o);
        let h = this.parent;
        if (!h) {
            let f = this.skeleton;
            const p = f.scaleX,
                m = f.scaleY,
                g = (n + a) * q.degRad,
                _ = (n + 90 + o) * q.degRad;
            (this.a = Math.cos(g) * i * p),
                (this.b = Math.cos(_) * r * p),
                (this.c = Math.sin(g) * i * m),
                (this.d = Math.sin(_) * r * m),
                (this.worldX = e * p + f.x),
                (this.worldY = t * m + f.y);
            return;
        }
        let l = h.a,
            u = h.b,
            c = h.c,
            d = h.d;
        switch (
            ((this.worldX = l * e + u * t + h.worldX),
            (this.worldY = c * e + d * t + h.worldY),
            this.inherit)
        ) {
            case bt.Normal: {
                const f = (n + a) * q.degRad,
                    p = (n + 90 + o) * q.degRad,
                    m = Math.cos(f) * i,
                    g = Math.cos(p) * r,
                    _ = Math.sin(f) * i,
                    v = Math.sin(p) * r;
                (this.a = l * m + u * _),
                    (this.b = l * g + u * v),
                    (this.c = c * m + d * _),
                    (this.d = c * g + d * v);
                return;
            }
            case bt.OnlyTranslation: {
                const f = (n + a) * q.degRad,
                    p = (n + 90 + o) * q.degRad;
                (this.a = Math.cos(f) * i),
                    (this.b = Math.cos(p) * r),
                    (this.c = Math.sin(f) * i),
                    (this.d = Math.sin(p) * r);
                break;
            }
            case bt.NoRotationOrReflection: {
                let f = 1 / this.skeleton.scaleX,
                    p = 1 / this.skeleton.scaleY;
                (l *= f), (c *= p);
                let m = l * l + c * c,
                    g = 0;
                m > 1e-4
                    ? ((m = Math.abs(l * d * p - u * f * c) / m),
                      (u = c * m),
                      (d = l * m),
                      (g = Math.atan2(c, l) * q.radDeg))
                    : ((l = 0),
                      (c = 0),
                      (g = 90 - Math.atan2(d, u) * q.radDeg));
                const _ = (n + a - g) * q.degRad,
                    v = (n + o - g + 90) * q.degRad,
                    b = Math.cos(_) * i,
                    y = Math.cos(v) * r,
                    C = Math.sin(_) * i,
                    w = Math.sin(v) * r;
                (this.a = l * b - u * C),
                    (this.b = l * y - u * w),
                    (this.c = c * b + d * C),
                    (this.d = c * y + d * w);
                break;
            }
            case bt.NoScale:
            case bt.NoScaleOrReflection: {
                n *= q.degRad;
                const f = Math.cos(n),
                    p = Math.sin(n);
                let m = (l * f + u * p) / this.skeleton.scaleX,
                    g = (c * f + d * p) / this.skeleton.scaleY,
                    _ = Math.sqrt(m * m + g * g);
                _ > 1e-5 && (_ = 1 / _),
                    (m *= _),
                    (g *= _),
                    (_ = Math.sqrt(m * m + g * g)),
                    this.inherit == bt.NoScale &&
                        l * d - u * c < 0 !=
                            (this.skeleton.scaleX < 0 !=
                                this.skeleton.scaleY < 0) &&
                        (_ = -_),
                    (n = Math.PI / 2 + Math.atan2(g, m));
                const v = Math.cos(n) * _,
                    b = Math.sin(n) * _;
                (a *= q.degRad), (o = (90 + o) * q.degRad);
                const y = Math.cos(a) * i,
                    C = Math.cos(o) * r,
                    w = Math.sin(a) * i,
                    A = Math.sin(o) * r;
                (this.a = m * y + v * w),
                    (this.b = m * C + v * A),
                    (this.c = g * y + b * w),
                    (this.d = g * C + b * A);
                break;
            }
        }
        (this.a *= this.skeleton.scaleX),
            (this.b *= this.skeleton.scaleX),
            (this.c *= this.skeleton.scaleY),
            (this.d *= this.skeleton.scaleY);
    }
    setToSetupPose() {
        let e = this.data;
        (this.x = e.x),
            (this.y = e.y),
            (this.rotation = e.rotation),
            (this.scaleX = e.scaleX),
            (this.scaleY = e.scaleY),
            (this.shearX = e.shearX),
            (this.shearY = e.shearY),
            (this.inherit = e.inherit);
    }
    updateAppliedTransform() {
        let e = this.parent;
        if (!e) {
            (this.ax = this.worldX - this.skeleton.x),
                (this.ay = this.worldY - this.skeleton.y),
                (this.arotation = Math.atan2(this.c, this.a) * q.radDeg),
                (this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c)),
                (this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d)),
                (this.ashearX = 0),
                (this.ashearY =
                    Math.atan2(
                        this.a * this.b + this.c * this.d,
                        this.a * this.d - this.b * this.c
                    ) * q.radDeg);
            return;
        }
        let t = e.a,
            n = e.b,
            i = e.c,
            r = e.d,
            a = 1 / (t * r - n * i),
            o = r * a,
            h = n * a,
            l = i * a,
            u = t * a,
            c = this.worldX - e.worldX,
            d = this.worldY - e.worldY;
        (this.ax = c * o - d * h), (this.ay = d * u - c * l);
        let f, p, m, g;
        if (this.inherit == bt.OnlyTranslation)
            (f = this.a), (p = this.b), (m = this.c), (g = this.d);
        else {
            switch (this.inherit) {
                case bt.NoRotationOrReflection: {
                    let C = Math.abs(t * r - n * i) / (t * t + i * i);
                    (n =
                        (-i * this.skeleton.scaleX * C) / this.skeleton.scaleY),
                        (r =
                            (t * this.skeleton.scaleY * C) /
                            this.skeleton.scaleX),
                        (a = 1 / (t * r - n * i)),
                        (o = r * a),
                        (h = n * a);
                    break;
                }
                case bt.NoScale:
                case bt.NoScaleOrReflection:
                    let _ = q.cosDeg(this.rotation),
                        v = q.sinDeg(this.rotation);
                    (t = (t * _ + n * v) / this.skeleton.scaleX),
                        (i = (i * _ + r * v) / this.skeleton.scaleY);
                    let b = Math.sqrt(t * t + i * i);
                    b > 1e-5 && (b = 1 / b),
                        (t *= b),
                        (i *= b),
                        (b = Math.sqrt(t * t + i * i)),
                        this.inherit == bt.NoScale &&
                            a < 0 !=
                                (this.skeleton.scaleX < 0 !=
                                    this.skeleton.scaleY < 0) &&
                            (b = -b);
                    let y = q.PI / 2 + Math.atan2(i, t);
                    (n = Math.cos(y) * b),
                        (r = Math.sin(y) * b),
                        (a = 1 / (t * r - n * i)),
                        (o = r * a),
                        (h = n * a),
                        (l = i * a),
                        (u = t * a);
            }
            (f = o * this.a - h * this.c),
                (p = o * this.b - h * this.d),
                (m = u * this.c - l * this.a),
                (g = u * this.d - l * this.b);
        }
        if (
            ((this.ashearX = 0),
            (this.ascaleX = Math.sqrt(f * f + m * m)),
            this.ascaleX > 1e-4)
        ) {
            let _ = f * g - p * m;
            (this.ascaleY = _ / this.ascaleX),
                (this.ashearY = -Math.atan2(f * p + m * g, _) * q.radDeg),
                (this.arotation = Math.atan2(m, f) * q.radDeg);
        } else
            (this.ascaleX = 0),
                (this.ascaleY = Math.sqrt(p * p + g * g)),
                (this.ashearY = 0),
                (this.arotation = 90 - Math.atan2(g, p) * q.radDeg);
    }
    getWorldRotationX() {
        return Math.atan2(this.c, this.a) * q.radDeg;
    }
    getWorldRotationY() {
        return Math.atan2(this.d, this.b) * q.radDeg;
    }
    getWorldScaleX() {
        return Math.sqrt(this.a * this.a + this.c * this.c);
    }
    getWorldScaleY() {
        return Math.sqrt(this.b * this.b + this.d * this.d);
    }
    worldToLocal(e) {
        let t = 1 / (this.a * this.d - this.b * this.c),
            n = e.x - this.worldX,
            i = e.y - this.worldY;
        return (
            (e.x = n * this.d * t - i * this.b * t),
            (e.y = i * this.a * t - n * this.c * t),
            e
        );
    }
    localToWorld(e) {
        let t = e.x,
            n = e.y;
        return (
            (e.x = t * this.a + n * this.b + this.worldX),
            (e.y = t * this.c + n * this.d + this.worldY),
            e
        );
    }
    worldToParent(e) {
        if (e == null) throw new Error("world cannot be null.");
        return this.parent == null ? e : this.parent.worldToLocal(e);
    }
    parentToWorld(e) {
        if (e == null) throw new Error("world cannot be null.");
        return this.parent == null ? e : this.parent.localToWorld(e);
    }
    worldToLocalRotation(e) {
        let t = q.sinDeg(e),
            n = q.cosDeg(e);
        return (
            Math.atan2(this.a * t - this.c * n, this.d * n - this.b * t) *
                q.radDeg +
            this.rotation -
            this.shearX
        );
    }
    localToWorldRotation(e) {
        e -= this.rotation - this.shearX;
        let t = q.sinDeg(e),
            n = q.cosDeg(e);
        return (
            Math.atan2(n * this.c + t * this.d, n * this.a + t * this.b) *
            q.radDeg
        );
    }
    rotateWorld(e) {
        e *= q.degRad;
        const t = Math.sin(e),
            n = Math.cos(e),
            i = this.a,
            r = this.b;
        (this.a = n * i - t * this.c),
            (this.b = n * r - t * this.d),
            (this.c = t * i + n * this.c),
            (this.d = t * r + n * this.d);
    }
}
class Md {
    constructor(e, t, n) {
        x(this, "name");
        x(this, "order");
        x(this, "skinRequired");
        (this.name = e), (this.order = t), (this.skinRequired = n);
    }
}
let o2 = class {
    constructor(e, t) {
        x(this, "data");
        x(this, "intValue", 0);
        x(this, "floatValue", 0);
        x(this, "stringValue", null);
        x(this, "time", 0);
        x(this, "volume", 0);
        x(this, "balance", 0);
        if (!t) throw new Error("data cannot be null.");
        (this.time = e), (this.data = t);
    }
};
class l2 {
    constructor(e) {
        x(this, "name");
        x(this, "intValue", 0);
        x(this, "floatValue", 0);
        x(this, "stringValue", null);
        x(this, "audioPath", null);
        x(this, "volume", 0);
        x(this, "balance", 0);
        this.name = e;
    }
}
class tR {
    constructor(e, t) {
        x(this, "data");
        x(this, "bones");
        x(this, "target");
        x(this, "bendDirection", 0);
        x(this, "compress", !1);
        x(this, "stretch", !1);
        x(this, "mix", 1);
        x(this, "softness", 0);
        x(this, "active", !1);
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        (this.data = e), (this.bones = new Array());
        for (let i = 0; i < e.bones.length; i++) {
            let r = t.findBone(e.bones[i].name);
            if (!r) throw new Error(`Couldn't find bone ${e.bones[i].name}`);
            this.bones.push(r);
        }
        let n = t.findBone(e.target.name);
        if (!n) throw new Error(`Couldn't find bone ${e.target.name}`);
        (this.target = n),
            (this.mix = e.mix),
            (this.softness = e.softness),
            (this.bendDirection = e.bendDirection),
            (this.compress = e.compress),
            (this.stretch = e.stretch);
    }
    isActive() {
        return this.active;
    }
    setToSetupPose() {
        const e = this.data;
        (this.mix = e.mix),
            (this.softness = e.softness),
            (this.bendDirection = e.bendDirection),
            (this.compress = e.compress),
            (this.stretch = e.stretch);
    }
    update(e) {
        if (this.mix == 0) return;
        let t = this.target,
            n = this.bones;
        switch (n.length) {
            case 1:
                this.apply1(
                    n[0],
                    t.worldX,
                    t.worldY,
                    this.compress,
                    this.stretch,
                    this.data.uniform,
                    this.mix
                );
                break;
            case 2:
                this.apply2(
                    n[0],
                    n[1],
                    t.worldX,
                    t.worldY,
                    this.bendDirection,
                    this.stretch,
                    this.data.uniform,
                    this.softness,
                    this.mix
                );
                break;
        }
    }
    apply1(e, t, n, i, r, a, o) {
        let h = e.parent;
        if (!h) throw new Error("IK bone must have parent.");
        let l = h.a,
            u = h.b,
            c = h.c,
            d = h.d,
            f = -e.ashearX - e.arotation,
            p = 0,
            m = 0;
        switch (e.inherit) {
            case bt.OnlyTranslation:
                (p = (t - e.worldX) * q.signum(e.skeleton.scaleX)),
                    (m = (n - e.worldY) * q.signum(e.skeleton.scaleY));
                break;
            case bt.NoRotationOrReflection:
                let v = Math.abs(l * d - u * c) / Math.max(1e-4, l * l + c * c),
                    b = l / e.skeleton.scaleX,
                    y = c / e.skeleton.scaleY;
                (u = -y * v * e.skeleton.scaleX),
                    (d = b * v * e.skeleton.scaleY),
                    (f += Math.atan2(y, b) * q.radDeg);
            default:
                let C = t - h.worldX,
                    w = n - h.worldY,
                    A = l * d - u * c;
                Math.abs(A) <= 1e-4
                    ? ((p = 0), (m = 0))
                    : ((p = (C * d - w * u) / A - e.ax),
                      (m = (w * l - C * c) / A - e.ay));
        }
        (f += Math.atan2(m, p) * q.radDeg),
            e.ascaleX < 0 && (f += 180),
            f > 180 ? (f -= 360) : f < -180 && (f += 360);
        let g = e.ascaleX,
            _ = e.ascaleY;
        if (i || r) {
            switch (e.inherit) {
                case bt.NoScale:
                case bt.NoScaleOrReflection:
                    (p = t - e.worldX), (m = n - e.worldY);
            }
            const v = e.data.length * g;
            if (v > 1e-4) {
                const b = p * p + m * m;
                if ((i && b < v * v) || (r && b > v * v)) {
                    const y = (Math.sqrt(b) / v - 1) * o + 1;
                    (g *= y), a && (_ *= y);
                }
            }
        }
        e.updateWorldTransformWith(
            e.ax,
            e.ay,
            e.arotation + f * o,
            g,
            _,
            e.ashearX,
            e.ashearY
        );
    }
    apply2(e, t, n, i, r, a, o, h, l) {
        if (e.inherit != bt.Normal || t.inherit != bt.Normal) return;
        let u = e.ax,
            c = e.ay,
            d = e.ascaleX,
            f = e.ascaleY,
            p = d,
            m = f,
            g = t.ascaleX,
            _ = 0,
            v = 0,
            b = 0;
        d < 0 ? ((d = -d), (_ = 180), (b = -1)) : ((_ = 0), (b = 1)),
            f < 0 && ((f = -f), (b = -b)),
            g < 0 ? ((g = -g), (v = 180)) : (v = 0);
        let y = t.ax,
            C = 0,
            w = 0,
            A = 0,
            E = e.a,
            S = e.b,
            P = e.c,
            k = e.d,
            R = Math.abs(d - f) <= 1e-4;
        !R || a
            ? ((C = 0), (w = E * y + e.worldX), (A = P * y + e.worldY))
            : ((C = t.ay),
              (w = E * y + S * C + e.worldX),
              (A = P * y + k * C + e.worldY));
        let M = e.parent;
        if (!M) throw new Error("IK parent must itself have a parent.");
        (E = M.a), (S = M.b), (P = M.c), (k = M.d);
        let T = E * k - S * P,
            O = w - M.worldX,
            L = A - M.worldY;
        T = Math.abs(T) <= 1e-4 ? 0 : 1 / T;
        let F = (O * k - L * S) * T - u,
            Y = (L * E - O * P) * T - c,
            V = Math.sqrt(F * F + Y * Y),
            W = t.data.length * g,
            Z,
            J;
        if (V < 1e-4) {
            this.apply1(e, n, i, !1, a, !1, l),
                t.updateWorldTransformWith(
                    y,
                    C,
                    0,
                    t.ascaleX,
                    t.ascaleY,
                    t.ashearX,
                    t.ashearY
                );
            return;
        }
        (O = n - M.worldX), (L = i - M.worldY);
        let G = (O * k - L * S) * T - u,
            j = (L * E - O * P) * T - c,
            H = G * G + j * j;
        if (h != 0) {
            h *= d * (g + 1) * 0.5;
            let ve = Math.sqrt(H),
                re = ve - V - W * d + h;
            if (re > 0) {
                let le = Math.min(1, re / (h * 2)) - 1;
                (le = (re - h * (1 - le * le)) / ve),
                    (G -= le * G),
                    (j -= le * j),
                    (H = G * G + j * j);
            }
        }
        e: if (R) {
            W *= d;
            let ve = (H - V * V - W * W) / (2 * V * W);
            ve < -1
                ? ((ve = -1), (J = Math.PI * r))
                : ve > 1
                ? ((ve = 1),
                  (J = 0),
                  a &&
                      ((E = (Math.sqrt(H) / (V + W) - 1) * l + 1),
                      (p *= E),
                      o && (m *= E)))
                : (J = Math.acos(ve) * r),
                (E = V + W * ve),
                (S = W * Math.sin(J)),
                (Z = Math.atan2(j * E - G * S, G * E + j * S));
        } else {
            (E = d * W), (S = f * W);
            let ve = E * E,
                re = S * S,
                le = Math.atan2(j, G);
            P = re * V * V + ve * H - ve * re;
            let at = -2 * re * V,
                Ft = re - ve;
            if (((k = at * at - 4 * Ft * P), k >= 0)) {
                let fs = Math.sqrt(k);
                at < 0 && (fs = -fs), (fs = -(at + fs) * 0.5);
                let Bi = fs / Ft,
                    Sl = P / fs,
                    to = Math.abs(Bi) < Math.abs(Sl) ? Bi : Sl;
                if (((Bi = H - to * to), Bi >= 0)) {
                    (L = Math.sqrt(Bi) * r),
                        (Z = le - Math.atan2(L, to)),
                        (J = Math.atan2(L / f, (to - V) / d));
                    break e;
                }
            }
            let Ae = q.PI,
                Fe = V - E,
                $e = Fe * Fe,
                Gt = 0,
                ct = 0,
                Xe = V + E,
                ft = Xe * Xe,
                pt = 0;
            (P = (-E * V) / (ve - re)),
                P >= -1 &&
                    P <= 1 &&
                    ((P = Math.acos(P)),
                    (O = E * Math.cos(P) + V),
                    (L = S * Math.sin(P)),
                    (k = O * O + L * L),
                    k < $e && ((Ae = P), ($e = k), (Fe = O), (Gt = L)),
                    k > ft && ((ct = P), (ft = k), (Xe = O), (pt = L))),
                H <= ($e + ft) * 0.5
                    ? ((Z = le - Math.atan2(Gt * r, Fe)), (J = Ae * r))
                    : ((Z = le - Math.atan2(pt * r, Xe)), (J = ct * r));
        }
        let pe = Math.atan2(C, y) * b,
            _e = e.arotation;
        (Z = (Z - pe) * q.radDeg + _ - _e),
            Z > 180 ? (Z -= 360) : Z < -180 && (Z += 360),
            e.updateWorldTransformWith(u, c, _e + Z * l, p, m, 0, 0),
            (_e = t.arotation),
            (J = ((J + pe) * q.radDeg - t.ashearX) * b + v - _e),
            J > 180 ? (J -= 360) : J < -180 && (J += 360),
            t.updateWorldTransformWith(
                y,
                C,
                _e + J * l,
                t.ascaleX,
                t.ascaleY,
                t.ashearX,
                t.ashearY
            );
    }
}
class h2 extends Md {
    constructor(t) {
        super(t, 0, !1);
        x(this, "bones", new Array());
        x(this, "_target", null);
        x(this, "bendDirection", 0);
        x(this, "compress", !1);
        x(this, "stretch", !1);
        x(this, "uniform", !1);
        x(this, "mix", 0);
        x(this, "softness", 0);
    }
    set target(t) {
        this._target = t;
    }
    get target() {
        if (this._target) return this._target;
        throw new Error("BoneData not set.");
    }
}
class c2 extends Md {
    constructor(t) {
        super(t, 0, !1);
        x(this, "bones", new Array());
        x(this, "_target", null);
        x(this, "positionMode", Ci.Fixed);
        x(this, "spacingMode", zt.Fixed);
        x(this, "rotateMode", Pa.Chain);
        x(this, "offsetRotation", 0);
        x(this, "position", 0);
        x(this, "spacing", 0);
        x(this, "mixRotate", 0);
        x(this, "mixX", 0);
        x(this, "mixY", 0);
    }
    set target(t) {
        this._target = t;
    }
    get target() {
        if (this._target) return this._target;
        throw new Error("SlotData not set.");
    }
}
var Ci;
(function (s) {
    (s[(s.Fixed = 0)] = "Fixed"), (s[(s.Percent = 1)] = "Percent");
})(Ci || (Ci = {}));
var zt;
(function (s) {
    (s[(s.Length = 0)] = "Length"),
        (s[(s.Fixed = 1)] = "Fixed"),
        (s[(s.Percent = 2)] = "Percent"),
        (s[(s.Proportional = 3)] = "Proportional");
})(zt || (zt = {}));
var Pa;
(function (s) {
    (s[(s.Tangent = 0)] = "Tangent"),
        (s[(s.Chain = 1)] = "Chain"),
        (s[(s.ChainScale = 2)] = "ChainScale");
})(Pa || (Pa = {}));
const Qn = class Qn {
    constructor(e, t) {
        x(this, "data");
        x(this, "bones");
        x(this, "target");
        x(this, "position", 0);
        x(this, "spacing", 0);
        x(this, "mixRotate", 0);
        x(this, "mixX", 0);
        x(this, "mixY", 0);
        x(this, "spaces", new Array());
        x(this, "positions", new Array());
        x(this, "world", new Array());
        x(this, "curves", new Array());
        x(this, "lengths", new Array());
        x(this, "segments", new Array());
        x(this, "active", !1);
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        (this.data = e), (this.bones = new Array());
        for (let i = 0, r = e.bones.length; i < r; i++) {
            let a = t.findBone(e.bones[i].name);
            if (!a) throw new Error(`Couldn't find bone ${e.bones[i].name}.`);
            this.bones.push(a);
        }
        let n = t.findSlot(e.target.name);
        if (!n) throw new Error(`Couldn't find target bone ${e.target.name}`);
        (this.target = n),
            (this.position = e.position),
            (this.spacing = e.spacing),
            (this.mixRotate = e.mixRotate),
            (this.mixX = e.mixX),
            (this.mixY = e.mixY);
    }
    isActive() {
        return this.active;
    }
    setToSetupPose() {
        const e = this.data;
        (this.position = e.position),
            (this.spacing = e.spacing),
            (this.mixRotate = e.mixRotate),
            (this.mixX = e.mixX),
            (this.mixY = e.mixY);
    }
    update(e) {
        let t = this.target.getAttachment();
        if (!(t instanceof al)) return;
        let n = this.mixRotate,
            i = this.mixX,
            r = this.mixY;
        if (n == 0 && i == 0 && r == 0) return;
        let a = this.data,
            o = a.rotateMode == Pa.Tangent,
            h = a.rotateMode == Pa.ChainScale,
            l = this.bones,
            u = l.length,
            c = o ? u : u + 1,
            d = K.setArraySize(this.spaces, c),
            f = h ? (this.lengths = K.setArraySize(this.lengths, u)) : [],
            p = this.spacing;
        switch (a.spacingMode) {
            case zt.Percent:
                if (h)
                    for (let w = 0, A = c - 1; w < A; w++) {
                        let E = l[w],
                            S = E.data.length,
                            P = S * E.a,
                            k = S * E.c;
                        f[w] = Math.sqrt(P * P + k * k);
                    }
                K.arrayFill(d, 1, c, p);
                break;
            case zt.Proportional:
                let y = 0;
                for (let w = 0, A = c - 1; w < A; ) {
                    let E = l[w],
                        S = E.data.length;
                    if (S < Qn.epsilon) h && (f[w] = 0), (d[++w] = p);
                    else {
                        let P = S * E.a,
                            k = S * E.c,
                            R = Math.sqrt(P * P + k * k);
                        h && (f[w] = R), (d[++w] = R), (y += R);
                    }
                }
                if (y > 0) {
                    y = (c / y) * p;
                    for (let w = 1; w < c; w++) d[w] *= y;
                }
                break;
            default:
                let C = a.spacingMode == zt.Length;
                for (let w = 0, A = c - 1; w < A; ) {
                    let E = l[w],
                        S = E.data.length;
                    if (S < Qn.epsilon) h && (f[w] = 0), (d[++w] = p);
                    else {
                        let P = S * E.a,
                            k = S * E.c,
                            R = Math.sqrt(P * P + k * k);
                        h && (f[w] = R), (d[++w] = ((C ? S + p : p) * R) / S);
                    }
                }
        }
        let m = this.computeWorldPositions(t, c, o),
            g = m[0],
            _ = m[1],
            v = a.offsetRotation,
            b = !1;
        if (v == 0) b = a.rotateMode == Pa.Chain;
        else {
            b = !1;
            let y = this.target.bone;
            v *= y.a * y.d - y.b * y.c > 0 ? q.degRad : -0.01745329277777778;
        }
        for (let y = 0, C = 3; y < u; y++, C += 3) {
            let w = l[y];
            (w.worldX += (g - w.worldX) * i), (w.worldY += (_ - w.worldY) * r);
            let A = m[C],
                E = m[C + 1],
                S = A - g,
                P = E - _;
            if (h) {
                let k = f[y];
                if (k != 0) {
                    let R = (Math.sqrt(S * S + P * P) / k - 1) * n + 1;
                    (w.a *= R), (w.c *= R);
                }
            }
            if (((g = A), (_ = E), n > 0)) {
                let k = w.a,
                    R = w.b,
                    M = w.c,
                    T = w.d,
                    O = 0,
                    L = 0,
                    F = 0;
                if (
                    (o
                        ? (O = m[C - 1])
                        : d[y + 1] == 0
                        ? (O = m[C + 2])
                        : (O = Math.atan2(P, S)),
                    (O -= Math.atan2(M, k)),
                    b)
                ) {
                    (L = Math.cos(O)), (F = Math.sin(O));
                    let Y = w.data.length;
                    (g += (Y * (L * k - F * M) - S) * n),
                        (_ += (Y * (F * k + L * M) - P) * n);
                } else O += v;
                O > q.PI ? (O -= q.PI2) : O < -3.1415927 && (O += q.PI2),
                    (O *= n),
                    (L = Math.cos(O)),
                    (F = Math.sin(O)),
                    (w.a = L * k - F * M),
                    (w.b = L * R - F * T),
                    (w.c = F * k + L * M),
                    (w.d = F * R + L * T);
            }
            w.updateAppliedTransform();
        }
    }
    computeWorldPositions(e, t, n) {
        let i = this.target,
            r = this.position,
            a = this.spaces,
            o = K.setArraySize(this.positions, t * 3 + 2),
            h = this.world,
            l = e.closed,
            u = e.worldVerticesLength,
            c = u / 6,
            d = Qn.NONE;
        if (!e.constantSpeed) {
            let Y = e.lengths;
            c -= l ? 1 : 2;
            let V = Y[c];
            this.data.positionMode == Ci.Percent && (r *= V);
            let W;
            switch (this.data.spacingMode) {
                case zt.Percent:
                    W = V;
                    break;
                case zt.Proportional:
                    W = V / t;
                    break;
                default:
                    W = 1;
            }
            h = K.setArraySize(this.world, 8);
            for (let Z = 0, J = 0, G = 0; Z < t; Z++, J += 3) {
                let j = a[Z] * W;
                r += j;
                let H = r;
                if (l) (H %= V), H < 0 && (H += V), (G = 0);
                else if (H < 0) {
                    d != Qn.BEFORE &&
                        ((d = Qn.BEFORE),
                        e.computeWorldVertices(i, 2, 4, h, 0, 2)),
                        this.addBeforePosition(H, h, 0, o, J);
                    continue;
                } else if (H > V) {
                    d != Qn.AFTER &&
                        ((d = Qn.AFTER),
                        e.computeWorldVertices(i, u - 6, 4, h, 0, 2)),
                        this.addAfterPosition(H - V, h, 0, o, J);
                    continue;
                }
                for (; ; G++) {
                    let pe = Y[G];
                    if (!(H > pe)) {
                        if (G == 0) H /= pe;
                        else {
                            let _e = Y[G - 1];
                            H = (H - _e) / (pe - _e);
                        }
                        break;
                    }
                }
                G != d &&
                    ((d = G),
                    l && G == c
                        ? (e.computeWorldVertices(i, u - 4, 4, h, 0, 2),
                          e.computeWorldVertices(i, 0, 4, h, 4, 2))
                        : e.computeWorldVertices(i, G * 6 + 2, 8, h, 0, 2)),
                    this.addCurvePosition(
                        H,
                        h[0],
                        h[1],
                        h[2],
                        h[3],
                        h[4],
                        h[5],
                        h[6],
                        h[7],
                        o,
                        J,
                        n || (Z > 0 && j == 0)
                    );
            }
            return o;
        }
        l
            ? ((u += 2),
              (h = K.setArraySize(this.world, u)),
              e.computeWorldVertices(i, 2, u - 4, h, 0, 2),
              e.computeWorldVertices(i, 0, 2, h, u - 4, 2),
              (h[u - 2] = h[0]),
              (h[u - 1] = h[1]))
            : (c--,
              (u -= 4),
              (h = K.setArraySize(this.world, u)),
              e.computeWorldVertices(i, 2, u, h, 0, 2));
        let f = K.setArraySize(this.curves, c),
            p = 0,
            m = h[0],
            g = h[1],
            _ = 0,
            v = 0,
            b = 0,
            y = 0,
            C = 0,
            w = 0,
            A = 0,
            E = 0,
            S = 0,
            P = 0,
            k = 0,
            R = 0,
            M = 0,
            T = 0;
        for (let Y = 0, V = 2; Y < c; Y++, V += 6)
            (_ = h[V]),
                (v = h[V + 1]),
                (b = h[V + 2]),
                (y = h[V + 3]),
                (C = h[V + 4]),
                (w = h[V + 5]),
                (A = (m - _ * 2 + b) * 0.1875),
                (E = (g - v * 2 + y) * 0.1875),
                (S = ((_ - b) * 3 - m + C) * 0.09375),
                (P = ((v - y) * 3 - g + w) * 0.09375),
                (k = A * 2 + S),
                (R = E * 2 + P),
                (M = (_ - m) * 0.75 + A + S * 0.16666667),
                (T = (v - g) * 0.75 + E + P * 0.16666667),
                (p += Math.sqrt(M * M + T * T)),
                (M += k),
                (T += R),
                (k += S),
                (R += P),
                (p += Math.sqrt(M * M + T * T)),
                (M += k),
                (T += R),
                (p += Math.sqrt(M * M + T * T)),
                (M += k + S),
                (T += R + P),
                (p += Math.sqrt(M * M + T * T)),
                (f[Y] = p),
                (m = C),
                (g = w);
        this.data.positionMode == Ci.Percent && (r *= p);
        let O;
        switch (this.data.spacingMode) {
            case zt.Percent:
                O = p;
                break;
            case zt.Proportional:
                O = p / t;
                break;
            default:
                O = 1;
        }
        let L = this.segments,
            F = 0;
        for (let Y = 0, V = 0, W = 0, Z = 0; Y < t; Y++, V += 3) {
            let J = a[Y] * O;
            r += J;
            let G = r;
            if (l) (G %= p), G < 0 && (G += p), (W = 0);
            else if (G < 0) {
                this.addBeforePosition(G, h, 0, o, V);
                continue;
            } else if (G > p) {
                this.addAfterPosition(G - p, h, u - 4, o, V);
                continue;
            }
            for (; ; W++) {
                let j = f[W];
                if (!(G > j)) {
                    if (W == 0) G /= j;
                    else {
                        let H = f[W - 1];
                        G = (G - H) / (j - H);
                    }
                    break;
                }
            }
            if (W != d) {
                d = W;
                let j = W * 6;
                for (
                    m = h[j],
                        g = h[j + 1],
                        _ = h[j + 2],
                        v = h[j + 3],
                        b = h[j + 4],
                        y = h[j + 5],
                        C = h[j + 6],
                        w = h[j + 7],
                        A = (m - _ * 2 + b) * 0.03,
                        E = (g - v * 2 + y) * 0.03,
                        S = ((_ - b) * 3 - m + C) * 0.006,
                        P = ((v - y) * 3 - g + w) * 0.006,
                        k = A * 2 + S,
                        R = E * 2 + P,
                        M = (_ - m) * 0.3 + A + S * 0.16666667,
                        T = (v - g) * 0.3 + E + P * 0.16666667,
                        F = Math.sqrt(M * M + T * T),
                        L[0] = F,
                        j = 1;
                    j < 8;
                    j++
                )
                    (M += k),
                        (T += R),
                        (k += S),
                        (R += P),
                        (F += Math.sqrt(M * M + T * T)),
                        (L[j] = F);
                (M += k),
                    (T += R),
                    (F += Math.sqrt(M * M + T * T)),
                    (L[8] = F),
                    (M += k + S),
                    (T += R + P),
                    (F += Math.sqrt(M * M + T * T)),
                    (L[9] = F),
                    (Z = 0);
            }
            for (G *= F; ; Z++) {
                let j = L[Z];
                if (!(G > j)) {
                    if (Z == 0) G /= j;
                    else {
                        let H = L[Z - 1];
                        G = Z + (G - H) / (j - H);
                    }
                    break;
                }
            }
            this.addCurvePosition(
                G * 0.1,
                m,
                g,
                _,
                v,
                b,
                y,
                C,
                w,
                o,
                V,
                n || (Y > 0 && J == 0)
            );
        }
        return o;
    }
    addBeforePosition(e, t, n, i, r) {
        let a = t[n],
            o = t[n + 1],
            h = t[n + 2] - a,
            l = t[n + 3] - o,
            u = Math.atan2(l, h);
        (i[r] = a + e * Math.cos(u)),
            (i[r + 1] = o + e * Math.sin(u)),
            (i[r + 2] = u);
    }
    addAfterPosition(e, t, n, i, r) {
        let a = t[n + 2],
            o = t[n + 3],
            h = a - t[n],
            l = o - t[n + 1],
            u = Math.atan2(l, h);
        (i[r] = a + e * Math.cos(u)),
            (i[r + 1] = o + e * Math.sin(u)),
            (i[r + 2] = u);
    }
    addCurvePosition(e, t, n, i, r, a, o, h, l, u, c, d) {
        if (e == 0 || isNaN(e)) {
            (u[c] = t), (u[c + 1] = n), (u[c + 2] = Math.atan2(r - n, i - t));
            return;
        }
        let f = e * e,
            p = f * e,
            m = 1 - e,
            g = m * m,
            _ = g * m,
            v = m * e,
            b = v * 3,
            y = m * b,
            C = b * e,
            w = t * _ + i * y + a * C + h * p,
            A = n * _ + r * y + o * C + l * p;
        (u[c] = w),
            (u[c + 1] = A),
            d &&
                (e < 0.001
                    ? (u[c + 2] = Math.atan2(r - n, i - t))
                    : (u[c + 2] = Math.atan2(
                          A - (n * g + r * v * 2 + o * f),
                          w - (t * g + i * v * 2 + a * f)
                      )));
    }
};
x(Qn, "NONE", -1),
    x(Qn, "BEFORE", -2),
    x(Qn, "AFTER", -3),
    x(Qn, "epsilon", 1e-5);
let Cm = Qn;
class nR {
    constructor(e, t) {
        x(this, "data");
        x(this, "_bone", null);
        x(this, "inertia", 0);
        x(this, "strength", 0);
        x(this, "damping", 0);
        x(this, "massInverse", 0);
        x(this, "wind", 0);
        x(this, "gravity", 0);
        x(this, "mix", 0);
        x(this, "_reset", !0);
        x(this, "ux", 0);
        x(this, "uy", 0);
        x(this, "cx", 0);
        x(this, "cy", 0);
        x(this, "tx", 0);
        x(this, "ty", 0);
        x(this, "xOffset", 0);
        x(this, "xVelocity", 0);
        x(this, "yOffset", 0);
        x(this, "yVelocity", 0);
        x(this, "rotateOffset", 0);
        x(this, "rotateVelocity", 0);
        x(this, "scaleOffset", 0);
        x(this, "scaleVelocity", 0);
        x(this, "active", !1);
        x(this, "skeleton");
        x(this, "remaining", 0);
        x(this, "lastTime", 0);
        (this.data = e),
            (this.skeleton = t),
            (this.bone = t.bones[e.bone.index]),
            (this.inertia = e.inertia),
            (this.strength = e.strength),
            (this.damping = e.damping),
            (this.massInverse = e.massInverse),
            (this.wind = e.wind),
            (this.gravity = e.gravity),
            (this.mix = e.mix);
    }
    set bone(e) {
        this._bone = e;
    }
    get bone() {
        if (this._bone) return this._bone;
        throw new Error("Bone not set.");
    }
    reset() {
        (this.remaining = 0),
            (this.lastTime = this.skeleton.time),
            (this._reset = !0),
            (this.xOffset = 0),
            (this.xVelocity = 0),
            (this.yOffset = 0),
            (this.yVelocity = 0),
            (this.rotateOffset = 0),
            (this.rotateVelocity = 0),
            (this.scaleOffset = 0),
            (this.scaleVelocity = 0);
    }
    setToSetupPose() {
        const e = this.data;
        (this.inertia = e.inertia),
            (this.strength = e.strength),
            (this.damping = e.damping),
            (this.massInverse = e.massInverse),
            (this.wind = e.wind),
            (this.gravity = e.gravity),
            (this.mix = e.mix);
    }
    isActive() {
        return this.active;
    }
    update(e) {
        const t = this.mix;
        if (t == 0) return;
        const n = this.data.x > 0,
            i = this.data.y > 0,
            r = this.data.rotate > 0 || this.data.shearX > 0,
            a = this.data.scaleX > 0,
            o = this.bone,
            h = o.data.length;
        switch (e) {
            case xr.none:
                return;
            case xr.reset:
                this.reset();
            case xr.update:
                const l = this.skeleton,
                    u = Math.max(this.skeleton.time - this.lastTime, 0);
                (this.remaining += u), (this.lastTime = l.time);
                const c = o.worldX,
                    d = o.worldY;
                if (this._reset)
                    (this._reset = !1), (this.ux = c), (this.uy = d);
                else {
                    let f = this.remaining,
                        p = this.inertia,
                        m = this.data.step,
                        g = this.skeleton.data.referenceScale,
                        _ = -1,
                        v = this.data.limit * u,
                        b = v * Math.abs(l.scaleY);
                    if (((v *= Math.abs(l.scaleX)), n || i)) {
                        if (n) {
                            const y = (this.ux - c) * p;
                            (this.xOffset += y > v ? v : y < -v ? -v : y),
                                (this.ux = c);
                        }
                        if (i) {
                            const y = (this.uy - d) * p;
                            (this.yOffset += y > b ? b : y < -b ? -b : y),
                                (this.uy = d);
                        }
                        if (f >= m) {
                            _ = Math.pow(this.damping, 60 * m);
                            const y = this.massInverse * m,
                                C = this.strength,
                                w = this.wind * g * l.scaleX,
                                A = this.gravity * g * l.scaleY;
                            do
                                n &&
                                    ((this.xVelocity +=
                                        (w - this.xOffset * C) * y),
                                    (this.xOffset += this.xVelocity * m),
                                    (this.xVelocity *= _)),
                                    i &&
                                        ((this.yVelocity -=
                                            (A + this.yOffset * C) * y),
                                        (this.yOffset += this.yVelocity * m),
                                        (this.yVelocity *= _)),
                                    (f -= m);
                            while (f >= m);
                        }
                        n && (o.worldX += this.xOffset * t * this.data.x),
                            i && (o.worldY += this.yOffset * t * this.data.y);
                    }
                    if (r || a) {
                        let y = Math.atan2(o.c, o.a),
                            C = 0,
                            w = 0,
                            A = 0,
                            E = this.cx - o.worldX,
                            S = this.cy - o.worldY;
                        if (
                            (E > v ? (E = v) : E < -v && (E = -v),
                            S > b ? (S = b) : S < -b && (S = -b),
                            r)
                        ) {
                            A = (this.data.rotate + this.data.shearX) * t;
                            let P =
                                Math.atan2(S + this.ty, E + this.tx) -
                                y -
                                this.rotateOffset * A;
                            (this.rotateOffset +=
                                (P - Math.ceil(P * q.invPI2 - 0.5) * q.PI2) *
                                p),
                                (P = this.rotateOffset * A + y),
                                (C = Math.cos(P)),
                                (w = Math.sin(P)),
                                a &&
                                    ((P = h * o.getWorldScaleX()),
                                    P > 0 &&
                                        (this.scaleOffset +=
                                            ((E * C + S * w) * p) / P));
                        } else {
                            (C = Math.cos(y)), (w = Math.sin(y));
                            const P = h * o.getWorldScaleX();
                            P > 0 &&
                                (this.scaleOffset += ((E * C + S * w) * p) / P);
                        }
                        if (((f = this.remaining), f >= m)) {
                            _ == -1 && (_ = Math.pow(this.damping, 60 * m));
                            const P = this.massInverse * m,
                                k = this.strength,
                                R = this.wind,
                                M = Gh.yDown ? -this.gravity : this.gravity,
                                T = h / g;
                            for (;;)
                                if (
                                    ((f -= m),
                                    a &&
                                        ((this.scaleVelocity +=
                                            (R * C -
                                                M * w -
                                                this.scaleOffset * k) *
                                            P),
                                        (this.scaleOffset +=
                                            this.scaleVelocity * m),
                                        (this.scaleVelocity *= _)),
                                    r)
                                ) {
                                    if (
                                        ((this.rotateVelocity -=
                                            ((R * w + M * C) * T +
                                                this.rotateOffset * k) *
                                            P),
                                        (this.rotateOffset +=
                                            this.rotateVelocity * m),
                                        (this.rotateVelocity *= _),
                                        f < m)
                                    )
                                        break;
                                    const O = this.rotateOffset * A + y;
                                    (C = Math.cos(O)), (w = Math.sin(O));
                                } else if (f < m) break;
                        }
                    }
                    this.remaining = f;
                }
                (this.cx = o.worldX), (this.cy = o.worldY);
                break;
            case xr.pose:
                n && (o.worldX += this.xOffset * t * this.data.x),
                    i && (o.worldY += this.yOffset * t * this.data.y);
        }
        if (r) {
            let l = this.rotateOffset * t,
                u = 0,
                c = 0,
                d = 0;
            if (this.data.shearX > 0) {
                let f = 0;
                this.data.rotate > 0 &&
                    ((f = l * this.data.rotate),
                    (u = Math.sin(f)),
                    (c = Math.cos(f)),
                    (d = o.b),
                    (o.b = c * d - u * o.d),
                    (o.d = u * d + c * o.d)),
                    (f += l * this.data.shearX),
                    (u = Math.sin(f)),
                    (c = Math.cos(f)),
                    (d = o.a),
                    (o.a = c * d - u * o.c),
                    (o.c = u * d + c * o.c);
            } else
                (l *= this.data.rotate),
                    (u = Math.sin(l)),
                    (c = Math.cos(l)),
                    (d = o.a),
                    (o.a = c * d - u * o.c),
                    (o.c = u * d + c * o.c),
                    (d = o.b),
                    (o.b = c * d - u * o.d),
                    (o.d = u * d + c * o.d);
        }
        if (a) {
            const l = 1 + this.scaleOffset * t * this.data.scaleX;
            (o.a *= l), (o.c *= l);
        }
        e != xr.pose && ((this.tx = h * o.a), (this.ty = h * o.c)),
            o.updateAppliedTransform();
    }
    translate(e, t) {
        (this.ux -= e), (this.uy -= t), (this.cx -= e), (this.cy -= t);
    }
    rotate(e, t, n) {
        const i = n * q.degRad,
            r = Math.cos(i),
            a = Math.sin(i),
            o = this.cx - e,
            h = this.cy - t;
        this.translate(o * r - h * a - o, o * a + h * r - h);
    }
}
class sR {
    constructor(e, t) {
        x(this, "data");
        x(this, "bone");
        x(this, "color");
        x(this, "darkColor", null);
        x(this, "attachment", null);
        x(this, "attachmentState", 0);
        x(this, "sequenceIndex", -1);
        x(this, "deform", new Array());
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("bone cannot be null.");
        (this.data = e),
            (this.bone = t),
            (this.color = new he()),
            (this.darkColor = e.darkColor ? new he() : null),
            this.setToSetupPose();
    }
    getSkeleton() {
        return this.bone.skeleton;
    }
    getAttachment() {
        return this.attachment;
    }
    setAttachment(e) {
        this.attachment != e &&
            ((!(e instanceof Ks) ||
                !(this.attachment instanceof Ks) ||
                e.timelineAttachment != this.attachment.timelineAttachment) &&
                (this.deform.length = 0),
            (this.attachment = e),
            (this.sequenceIndex = -1));
    }
    setToSetupPose() {
        this.color.setFromColor(this.data.color),
            this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
            this.data.attachmentName
                ? ((this.attachment = null),
                  this.setAttachment(
                      this.bone.skeleton.getAttachment(
                          this.data.index,
                          this.data.attachmentName
                      )
                  ))
                : (this.attachment = null);
    }
}
class iR {
    constructor(e, t) {
        x(this, "data");
        x(this, "bones");
        x(this, "target");
        x(this, "mixRotate", 0);
        x(this, "mixX", 0);
        x(this, "mixY", 0);
        x(this, "mixScaleX", 0);
        x(this, "mixScaleY", 0);
        x(this, "mixShearY", 0);
        x(this, "temp", new Ou());
        x(this, "active", !1);
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        (this.data = e), (this.bones = new Array());
        for (let i = 0; i < e.bones.length; i++) {
            let r = t.findBone(e.bones[i].name);
            if (!r) throw new Error(`Couldn't find bone ${e.bones[i].name}.`);
            this.bones.push(r);
        }
        let n = t.findBone(e.target.name);
        if (!n) throw new Error(`Couldn't find target bone ${e.target.name}.`);
        (this.target = n),
            (this.mixRotate = e.mixRotate),
            (this.mixX = e.mixX),
            (this.mixY = e.mixY),
            (this.mixScaleX = e.mixScaleX),
            (this.mixScaleY = e.mixScaleY),
            (this.mixShearY = e.mixShearY);
    }
    isActive() {
        return this.active;
    }
    setToSetupPose() {
        const e = this.data;
        (this.mixRotate = e.mixRotate),
            (this.mixX = e.mixX),
            (this.mixY = e.mixY),
            (this.mixScaleX = e.mixScaleX),
            (this.mixScaleY = e.mixScaleY),
            (this.mixShearY = e.mixShearY);
    }
    update(e) {
        (this.mixRotate == 0 &&
            this.mixX == 0 &&
            this.mixY == 0 &&
            this.mixScaleX == 0 &&
            this.mixScaleY == 0 &&
            this.mixShearY == 0) ||
            (this.data.local
                ? this.data.relative
                    ? this.applyRelativeLocal()
                    : this.applyAbsoluteLocal()
                : this.data.relative
                ? this.applyRelativeWorld()
                : this.applyAbsoluteWorld());
    }
    applyAbsoluteWorld() {
        let e = this.mixRotate,
            t = this.mixX,
            n = this.mixY,
            i = this.mixScaleX,
            r = this.mixScaleY,
            a = this.mixShearY,
            o = t != 0 || n != 0,
            h = this.target,
            l = h.a,
            u = h.b,
            c = h.c,
            d = h.d,
            f = l * d - u * c > 0 ? q.degRad : -0.01745329277777778,
            p = this.data.offsetRotation * f,
            m = this.data.offsetShearY * f,
            g = this.bones;
        for (let _ = 0, v = g.length; _ < v; _++) {
            let b = g[_];
            if (e != 0) {
                let y = b.a,
                    C = b.b,
                    w = b.c,
                    A = b.d,
                    E = Math.atan2(c, l) - Math.atan2(w, y) + p;
                E > q.PI ? (E -= q.PI2) : E < -3.1415927 && (E += q.PI2),
                    (E *= e);
                let S = Math.cos(E),
                    P = Math.sin(E);
                (b.a = S * y - P * w),
                    (b.b = S * C - P * A),
                    (b.c = P * y + S * w),
                    (b.d = P * C + S * A);
            }
            if (o) {
                let y = this.temp;
                h.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    (b.worldX += (y.x - b.worldX) * t),
                    (b.worldY += (y.y - b.worldY) * n);
            }
            if (i != 0) {
                let y = Math.sqrt(b.a * b.a + b.c * b.c);
                y != 0 &&
                    (y =
                        (y +
                            (Math.sqrt(l * l + c * c) -
                                y +
                                this.data.offsetScaleX) *
                                i) /
                        y),
                    (b.a *= y),
                    (b.c *= y);
            }
            if (r != 0) {
                let y = Math.sqrt(b.b * b.b + b.d * b.d);
                y != 0 &&
                    (y =
                        (y +
                            (Math.sqrt(u * u + d * d) -
                                y +
                                this.data.offsetScaleY) *
                                r) /
                        y),
                    (b.b *= y),
                    (b.d *= y);
            }
            if (a > 0) {
                let y = b.b,
                    C = b.d,
                    w = Math.atan2(C, y),
                    A =
                        Math.atan2(d, u) -
                        Math.atan2(c, l) -
                        (w - Math.atan2(b.c, b.a));
                A > q.PI ? (A -= q.PI2) : A < -3.1415927 && (A += q.PI2),
                    (A = w + (A + m) * a);
                let E = Math.sqrt(y * y + C * C);
                (b.b = Math.cos(A) * E), (b.d = Math.sin(A) * E);
            }
            b.updateAppliedTransform();
        }
    }
    applyRelativeWorld() {
        let e = this.mixRotate,
            t = this.mixX,
            n = this.mixY,
            i = this.mixScaleX,
            r = this.mixScaleY,
            a = this.mixShearY,
            o = t != 0 || n != 0,
            h = this.target,
            l = h.a,
            u = h.b,
            c = h.c,
            d = h.d,
            f = l * d - u * c > 0 ? q.degRad : -0.01745329277777778,
            p = this.data.offsetRotation * f,
            m = this.data.offsetShearY * f,
            g = this.bones;
        for (let _ = 0, v = g.length; _ < v; _++) {
            let b = g[_];
            if (e != 0) {
                let y = b.a,
                    C = b.b,
                    w = b.c,
                    A = b.d,
                    E = Math.atan2(c, l) + p;
                E > q.PI ? (E -= q.PI2) : E < -3.1415927 && (E += q.PI2),
                    (E *= e);
                let S = Math.cos(E),
                    P = Math.sin(E);
                (b.a = S * y - P * w),
                    (b.b = S * C - P * A),
                    (b.c = P * y + S * w),
                    (b.d = P * C + S * A);
            }
            if (o) {
                let y = this.temp;
                h.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    (b.worldX += y.x * t),
                    (b.worldY += y.y * n);
            }
            if (i != 0) {
                let y =
                    (Math.sqrt(l * l + c * c) - 1 + this.data.offsetScaleX) *
                        i +
                    1;
                (b.a *= y), (b.c *= y);
            }
            if (r != 0) {
                let y =
                    (Math.sqrt(u * u + d * d) - 1 + this.data.offsetScaleY) *
                        r +
                    1;
                (b.b *= y), (b.d *= y);
            }
            if (a > 0) {
                let y = Math.atan2(d, u) - Math.atan2(c, l);
                y > q.PI ? (y -= q.PI2) : y < -3.1415927 && (y += q.PI2);
                let C = b.b,
                    w = b.d;
                y = Math.atan2(w, C) + (y - q.PI / 2 + m) * a;
                let A = Math.sqrt(C * C + w * w);
                (b.b = Math.cos(y) * A), (b.d = Math.sin(y) * A);
            }
            b.updateAppliedTransform();
        }
    }
    applyAbsoluteLocal() {
        let e = this.mixRotate,
            t = this.mixX,
            n = this.mixY,
            i = this.mixScaleX,
            r = this.mixScaleY,
            a = this.mixShearY,
            o = this.target,
            h = this.bones;
        for (let l = 0, u = h.length; l < u; l++) {
            let c = h[l],
                d = c.arotation;
            e != 0 && (d += (o.arotation - d + this.data.offsetRotation) * e);
            let f = c.ax,
                p = c.ay;
            (f += (o.ax - f + this.data.offsetX) * t),
                (p += (o.ay - p + this.data.offsetY) * n);
            let m = c.ascaleX,
                g = c.ascaleY;
            i != 0 &&
                m != 0 &&
                (m = (m + (o.ascaleX - m + this.data.offsetScaleX) * i) / m),
                r != 0 &&
                    g != 0 &&
                    (g =
                        (g + (o.ascaleY - g + this.data.offsetScaleY) * r) / g);
            let _ = c.ashearY;
            a != 0 && (_ += (o.ashearY - _ + this.data.offsetShearY) * a),
                c.updateWorldTransformWith(f, p, d, m, g, c.ashearX, _);
        }
    }
    applyRelativeLocal() {
        let e = this.mixRotate,
            t = this.mixX,
            n = this.mixY,
            i = this.mixScaleX,
            r = this.mixScaleY,
            a = this.mixShearY,
            o = this.target,
            h = this.bones;
        for (let l = 0, u = h.length; l < u; l++) {
            let c = h[l],
                d = c.arotation + (o.arotation + this.data.offsetRotation) * e,
                f = c.ax + (o.ax + this.data.offsetX) * t,
                p = c.ay + (o.ay + this.data.offsetY) * n,
                m =
                    c.ascaleX *
                    ((o.ascaleX - 1 + this.data.offsetScaleX) * i + 1),
                g =
                    c.ascaleY *
                    ((o.ascaleY - 1 + this.data.offsetScaleY) * r + 1),
                _ = c.ashearY + (o.ashearY + this.data.offsetShearY) * a;
            c.updateWorldTransformWith(f, p, d, m, g, c.ashearX, _);
        }
    }
}
const So = class So {
    constructor(e) {
        x(this, "data");
        x(this, "bones");
        x(this, "slots");
        x(this, "drawOrder");
        x(this, "ikConstraints");
        x(this, "transformConstraints");
        x(this, "pathConstraints");
        x(this, "physicsConstraints");
        x(this, "_updateCache", new Array());
        x(this, "skin", null);
        x(this, "color");
        x(this, "scaleX", 1);
        x(this, "_scaleY", 1);
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "time", 0);
        if (!e) throw new Error("data cannot be null.");
        (this.data = e), (this.bones = new Array());
        for (let t = 0; t < e.bones.length; t++) {
            let n = e.bones[t],
                i;
            if (!n.parent) i = new lb(n, this, null);
            else {
                let r = this.bones[n.parent.index];
                (i = new lb(n, this, r)), r.children.push(i);
            }
            this.bones.push(i);
        }
        (this.slots = new Array()), (this.drawOrder = new Array());
        for (let t = 0; t < e.slots.length; t++) {
            let n = e.slots[t],
                i = this.bones[n.boneData.index],
                r = new sR(n, i);
            this.slots.push(r), this.drawOrder.push(r);
        }
        this.ikConstraints = new Array();
        for (let t = 0; t < e.ikConstraints.length; t++) {
            let n = e.ikConstraints[t];
            this.ikConstraints.push(new tR(n, this));
        }
        this.transformConstraints = new Array();
        for (let t = 0; t < e.transformConstraints.length; t++) {
            let n = e.transformConstraints[t];
            this.transformConstraints.push(new iR(n, this));
        }
        this.pathConstraints = new Array();
        for (let t = 0; t < e.pathConstraints.length; t++) {
            let n = e.pathConstraints[t];
            this.pathConstraints.push(new Cm(n, this));
        }
        this.physicsConstraints = new Array();
        for (let t = 0; t < e.physicsConstraints.length; t++) {
            let n = e.physicsConstraints[t];
            this.physicsConstraints.push(new nR(n, this));
        }
        (this.color = new he(1, 1, 1, 1)), this.updateCache();
    }
    get scaleY() {
        return So.yDown ? -this._scaleY : this._scaleY;
    }
    set scaleY(e) {
        this._scaleY = e;
    }
    updateCache() {
        let e = this._updateCache;
        e.length = 0;
        let t = this.bones;
        for (let d = 0, f = t.length; d < f; d++) {
            let p = t[d];
            (p.sorted = p.data.skinRequired), (p.active = !p.sorted);
        }
        if (this.skin) {
            let d = this.skin.bones;
            for (let f = 0, p = this.skin.bones.length; f < p; f++) {
                let m = this.bones[d[f].index];
                do (m.sorted = !1), (m.active = !0), (m = m.parent);
                while (m);
            }
        }
        let n = this.ikConstraints,
            i = this.transformConstraints,
            r = this.pathConstraints,
            a = this.physicsConstraints,
            o = n.length,
            h = i.length,
            l = r.length,
            u = this.physicsConstraints.length,
            c = o + h + l + u;
        e: for (let d = 0; d < c; d++) {
            for (let f = 0; f < o; f++) {
                let p = n[f];
                if (p.data.order == d) {
                    this.sortIkConstraint(p);
                    continue e;
                }
            }
            for (let f = 0; f < h; f++) {
                let p = i[f];
                if (p.data.order == d) {
                    this.sortTransformConstraint(p);
                    continue e;
                }
            }
            for (let f = 0; f < l; f++) {
                let p = r[f];
                if (p.data.order == d) {
                    this.sortPathConstraint(p);
                    continue e;
                }
            }
            for (let f = 0; f < u; f++) {
                const p = a[f];
                if (p.data.order == d) {
                    this.sortPhysicsConstraint(p);
                    continue e;
                }
            }
        }
        for (let d = 0, f = t.length; d < f; d++) this.sortBone(t[d]);
    }
    sortIkConstraint(e) {
        if (
            ((e.active =
                e.target.isActive() &&
                (!e.data.skinRequired ||
                    (this.skin &&
                        K.contains(this.skin.constraints, e.data, !0)))),
            !e.active)
        )
            return;
        let t = e.target;
        this.sortBone(t);
        let n = e.bones,
            i = n[0];
        if ((this.sortBone(i), n.length == 1))
            this._updateCache.push(e), this.sortReset(i.children);
        else {
            let r = n[n.length - 1];
            this.sortBone(r),
                this._updateCache.push(e),
                this.sortReset(i.children),
                (r.sorted = !0);
        }
    }
    sortPathConstraint(e) {
        if (
            ((e.active =
                e.target.bone.isActive() &&
                (!e.data.skinRequired ||
                    (this.skin &&
                        K.contains(this.skin.constraints, e.data, !0)))),
            !e.active)
        )
            return;
        let t = e.target,
            n = t.data.index,
            i = t.bone;
        this.skin && this.sortPathConstraintAttachment(this.skin, n, i),
            this.data.defaultSkin &&
                this.data.defaultSkin != this.skin &&
                this.sortPathConstraintAttachment(this.data.defaultSkin, n, i);
        for (let h = 0, l = this.data.skins.length; h < l; h++)
            this.sortPathConstraintAttachment(this.data.skins[h], n, i);
        let r = t.getAttachment();
        r instanceof al && this.sortPathConstraintAttachmentWith(r, i);
        let a = e.bones,
            o = a.length;
        for (let h = 0; h < o; h++) this.sortBone(a[h]);
        this._updateCache.push(e);
        for (let h = 0; h < o; h++) this.sortReset(a[h].children);
        for (let h = 0; h < o; h++) a[h].sorted = !0;
    }
    sortTransformConstraint(e) {
        if (
            ((e.active =
                e.target.isActive() &&
                (!e.data.skinRequired ||
                    (this.skin &&
                        K.contains(this.skin.constraints, e.data, !0)))),
            !e.active)
        )
            return;
        this.sortBone(e.target);
        let t = e.bones,
            n = t.length;
        if (e.data.local)
            for (let i = 0; i < n; i++) {
                let r = t[i];
                this.sortBone(r.parent), this.sortBone(r);
            }
        else for (let i = 0; i < n; i++) this.sortBone(t[i]);
        this._updateCache.push(e);
        for (let i = 0; i < n; i++) this.sortReset(t[i].children);
        for (let i = 0; i < n; i++) t[i].sorted = !0;
    }
    sortPathConstraintAttachment(e, t, n) {
        let i = e.attachments[t];
        if (i) for (let r in i) this.sortPathConstraintAttachmentWith(i[r], n);
    }
    sortPathConstraintAttachmentWith(e, t) {
        if (!(e instanceof al)) return;
        let n = e.bones;
        if (!n) this.sortBone(t);
        else {
            let i = this.bones;
            for (let r = 0, a = n.length; r < a; ) {
                let o = n[r++];
                for (o += r; r < o; ) this.sortBone(i[n[r++]]);
            }
        }
    }
    sortPhysicsConstraint(e) {
        const t = e.bone;
        (e.active =
            t.active &&
            (!e.data.skinRequired ||
                (this.skin != null &&
                    K.contains(this.skin.constraints, e.data, !0)))),
            e.active &&
                (this.sortBone(t),
                this._updateCache.push(e),
                this.sortReset(t.children),
                (t.sorted = !0));
    }
    sortBone(e) {
        if (!e || e.sorted) return;
        let t = e.parent;
        t && this.sortBone(t), (e.sorted = !0), this._updateCache.push(e);
    }
    sortReset(e) {
        for (let t = 0, n = e.length; t < n; t++) {
            let i = e[t];
            i.active &&
                (i.sorted && this.sortReset(i.children), (i.sorted = !1));
        }
    }
    updateWorldTransform(e) {
        if (e == null) throw new Error("physics is undefined");
        let t = this.bones;
        for (let i = 0, r = t.length; i < r; i++) {
            let a = t[i];
            (a.ax = a.x),
                (a.ay = a.y),
                (a.arotation = a.rotation),
                (a.ascaleX = a.scaleX),
                (a.ascaleY = a.scaleY),
                (a.ashearX = a.shearX),
                (a.ashearY = a.shearY);
        }
        let n = this._updateCache;
        for (let i = 0, r = n.length; i < r; i++) n[i].update(e);
    }
    updateWorldTransformWith(e, t) {
        if (!t) throw new Error("parent cannot be null.");
        let n = this.bones;
        for (let g = 1, _ = n.length; g < _; g++) {
            let v = n[g];
            (v.ax = v.x),
                (v.ay = v.y),
                (v.arotation = v.rotation),
                (v.ascaleX = v.scaleX),
                (v.ascaleY = v.scaleY),
                (v.ashearX = v.shearX),
                (v.ashearY = v.shearY);
        }
        let i = this.getRootBone();
        if (!i) throw new Error("Root bone must not be null.");
        let r = t.a,
            a = t.b,
            o = t.c,
            h = t.d;
        (i.worldX = r * this.x + a * this.y + t.worldX),
            (i.worldY = o * this.x + h * this.y + t.worldY);
        const l = (i.rotation + i.shearX) * q.degRad,
            u = (i.rotation + 90 + i.shearY) * q.degRad,
            c = Math.cos(l) * i.scaleX,
            d = Math.cos(u) * i.scaleY,
            f = Math.sin(l) * i.scaleX,
            p = Math.sin(u) * i.scaleY;
        (i.a = (r * c + a * f) * this.scaleX),
            (i.b = (r * d + a * p) * this.scaleX),
            (i.c = (o * c + h * f) * this.scaleY),
            (i.d = (o * d + h * p) * this.scaleY);
        let m = this._updateCache;
        for (let g = 0, _ = m.length; g < _; g++) {
            let v = m[g];
            v != i && v.update(e);
        }
    }
    setToSetupPose() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose();
    }
    setBonesToSetupPose() {
        for (const e of this.bones) e.setToSetupPose();
        for (const e of this.ikConstraints) e.setToSetupPose();
        for (const e of this.transformConstraints) e.setToSetupPose();
        for (const e of this.pathConstraints) e.setToSetupPose();
        for (const e of this.physicsConstraints) e.setToSetupPose();
    }
    setSlotsToSetupPose() {
        let e = this.slots;
        K.arrayCopy(e, 0, this.drawOrder, 0, e.length);
        for (let t = 0, n = e.length; t < n; t++) e[t].setToSetupPose();
    }
    getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0];
    }
    findBone(e) {
        if (!e) throw new Error("boneName cannot be null.");
        let t = this.bones;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.data.name == e) return r;
        }
        return null;
    }
    findSlot(e) {
        if (!e) throw new Error("slotName cannot be null.");
        let t = this.slots;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.data.name == e) return r;
        }
        return null;
    }
    setSkinByName(e) {
        let t = this.data.findSkin(e);
        if (!t) throw new Error("Skin not found: " + e);
        this.setSkin(t);
    }
    setSkin(e) {
        if (e != this.skin) {
            if (e)
                if (this.skin) e.attachAll(this, this.skin);
                else {
                    let t = this.slots;
                    for (let n = 0, i = t.length; n < i; n++) {
                        let r = t[n],
                            a = r.data.attachmentName;
                        if (a) {
                            let o = e.getAttachment(n, a);
                            o && r.setAttachment(o);
                        }
                    }
                }
            (this.skin = e), this.updateCache();
        }
    }
    getAttachmentByName(e, t) {
        let n = this.data.findSlot(e);
        if (!n) throw new Error(`Can't find slot with name ${e}`);
        return this.getAttachment(n.index, t);
    }
    getAttachment(e, t) {
        if (!t) throw new Error("attachmentName cannot be null.");
        if (this.skin) {
            let n = this.skin.getAttachment(e, t);
            if (n) return n;
        }
        return this.data.defaultSkin
            ? this.data.defaultSkin.getAttachment(e, t)
            : null;
    }
    setAttachment(e, t) {
        if (!e) throw new Error("slotName cannot be null.");
        let n = this.slots;
        for (let i = 0, r = n.length; i < r; i++) {
            let a = n[i];
            if (a.data.name == e) {
                let o = null;
                if (t && ((o = this.getAttachment(i, t)), !o))
                    throw new Error(
                        "Attachment not found: " + t + ", for slot: " + e
                    );
                a.setAttachment(o);
                return;
            }
        }
        throw new Error("Slot not found: " + e);
    }
    findIkConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        return this.ikConstraints.find((t) => t.data.name == e) ?? null;
    }
    findTransformConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        return this.transformConstraints.find((t) => t.data.name == e) ?? null;
    }
    findPathConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        return this.pathConstraints.find((t) => t.data.name == e) ?? null;
    }
    findPhysicsConstraint(e) {
        if (e == null) throw new Error("constraintName cannot be null.");
        return this.physicsConstraints.find((t) => t.data.name == e) ?? null;
    }
    getBoundsRect(e) {
        let t = new Ou(),
            n = new Ou();
        return (
            this.getBounds(t, n, void 0, e),
            { x: t.x, y: t.y, width: n.x, height: n.y }
        );
    }
    getBounds(e, t, n = new Array(2), i = null) {
        if (!e) throw new Error("offset cannot be null.");
        if (!t) throw new Error("size cannot be null.");
        let r = this.drawOrder,
            a = Number.POSITIVE_INFINITY,
            o = Number.POSITIVE_INFINITY,
            h = Number.NEGATIVE_INFINITY,
            l = Number.NEGATIVE_INFINITY;
        for (let u = 0, c = r.length; u < c; u++) {
            let d = r[u];
            if (!d.bone.active) continue;
            let f = 0,
                p = null,
                m = null,
                g = d.getAttachment();
            if (g instanceof Gs)
                (f = 8),
                    (p = K.setArraySize(n, f, 0)),
                    g.computeWorldVertices(d, p, 0, 2),
                    (m = So.quadTriangles);
            else if (g instanceof Xs) {
                let _ = g;
                (f = _.worldVerticesLength),
                    (p = K.setArraySize(n, f, 0)),
                    _.computeWorldVertices(d, 0, f, p, 0, 2),
                    (m = _.triangles);
            } else if (g instanceof Ea && i != null) {
                i.clipStart(d, g);
                continue;
            }
            if (p && m) {
                i != null &&
                    i.isClipping() &&
                    (i.clipTriangles(p, m, m.length),
                    (p = i.clippedVertices),
                    (f = i.clippedVertices.length));
                for (let _ = 0, v = p.length; _ < v; _ += 2) {
                    let b = p[_],
                        y = p[_ + 1];
                    (a = Math.min(a, b)),
                        (o = Math.min(o, y)),
                        (h = Math.max(h, b)),
                        (l = Math.max(l, y));
                }
            }
            i != null && i.clipEndWithSlot(d);
        }
        i != null && i.clipEnd(), e.set(a, o), t.set(h - a, l - o);
    }
    update(e) {
        this.time += e;
    }
    physicsTranslate(e, t) {
        const n = this.physicsConstraints;
        for (let i = 0, r = n.length; i < r; i++) n[i].translate(e, t);
    }
    physicsRotate(e, t, n) {
        const i = this.physicsConstraints;
        for (let r = 0, a = i.length; r < a; r++) i[r].rotate(e, t, n);
    }
};
x(So, "quadTriangles", [0, 1, 2, 2, 3, 0]), x(So, "yDown", !1);
let Gh = So;
var xr;
(function (s) {
    (s[(s.none = 0)] = "none"),
        (s[(s.reset = 1)] = "reset"),
        (s[(s.update = 2)] = "update"),
        (s[(s.pose = 3)] = "pose");
})(xr || (xr = {}));
class u2 extends Md {
    constructor(t) {
        super(t, 0, !1);
        x(this, "_bone", null);
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "rotate", 0);
        x(this, "scaleX", 0);
        x(this, "shearX", 0);
        x(this, "limit", 0);
        x(this, "step", 0);
        x(this, "inertia", 0);
        x(this, "strength", 0);
        x(this, "damping", 0);
        x(this, "massInverse", 0);
        x(this, "wind", 0);
        x(this, "gravity", 0);
        x(this, "mix", 0);
        x(this, "inertiaGlobal", !1);
        x(this, "strengthGlobal", !1);
        x(this, "dampingGlobal", !1);
        x(this, "massGlobal", !1);
        x(this, "windGlobal", !1);
        x(this, "gravityGlobal", !1);
        x(this, "mixGlobal", !1);
    }
    set bone(t) {
        this._bone = t;
    }
    get bone() {
        if (this._bone) return this._bone;
        throw new Error("BoneData not set.");
    }
}
class Nu {
    constructor() {
        x(this, "name", null);
        x(this, "bones", new Array());
        x(this, "slots", new Array());
        x(this, "skins", new Array());
        x(this, "defaultSkin", null);
        x(this, "events", new Array());
        x(this, "animations", new Array());
        x(this, "ikConstraints", new Array());
        x(this, "transformConstraints", new Array());
        x(this, "pathConstraints", new Array());
        x(this, "physicsConstraints", new Array());
        x(this, "x", 0);
        x(this, "y", 0);
        x(this, "width", 0);
        x(this, "height", 0);
        x(this, "referenceScale", 100);
        x(this, "version", null);
        x(this, "hash", null);
        x(this, "fps", 0);
        x(this, "imagesPath", null);
        x(this, "audioPath", null);
    }
    findBone(e) {
        if (!e) throw new Error("boneName cannot be null.");
        let t = this.bones;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findSlot(e) {
        if (!e) throw new Error("slotName cannot be null.");
        let t = this.slots;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findSkin(e) {
        if (!e) throw new Error("skinName cannot be null.");
        let t = this.skins;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findEvent(e) {
        if (!e) throw new Error("eventDataName cannot be null.");
        let t = this.events;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findAnimation(e) {
        if (!e) throw new Error("animationName cannot be null.");
        let t = this.animations;
        for (let n = 0, i = t.length; n < i; n++) {
            let r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findIkConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.ikConstraints;
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findTransformConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.transformConstraints;
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findPathConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.pathConstraints;
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
    findPhysicsConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.physicsConstraints;
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            if (r.name == e) return r;
        }
        return null;
    }
}
class hb {
    constructor(e = 0, t, n) {
        x(this, "slotIndex");
        x(this, "name");
        x(this, "attachment");
        (this.slotIndex = e), (this.name = t), (this.attachment = n);
    }
}
class Am {
    constructor(e) {
        x(this, "name");
        x(this, "attachments", new Array());
        x(this, "bones", Array());
        x(this, "constraints", new Array());
        x(this, "color", new he(0.99607843, 0.61960787, 0.30980393, 1));
        if (!e) throw new Error("name cannot be null.");
        this.name = e;
    }
    setAttachment(e, t, n) {
        if (!n) throw new Error("attachment cannot be null.");
        let i = this.attachments;
        e >= i.length && (i.length = e + 1), i[e] || (i[e] = {}), (i[e][t] = n);
    }
    addSkin(e) {
        for (let i = 0; i < e.bones.length; i++) {
            let r = e.bones[i],
                a = !1;
            for (let o = 0; o < this.bones.length; o++)
                if (this.bones[o] == r) {
                    a = !0;
                    break;
                }
            a || this.bones.push(r);
        }
        for (let i = 0; i < e.constraints.length; i++) {
            let r = e.constraints[i],
                a = !1;
            for (let o = 0; o < this.constraints.length; o++)
                if (this.constraints[o] == r) {
                    a = !0;
                    break;
                }
            a || this.constraints.push(r);
        }
        let t = e.getAttachments();
        for (let i = 0; i < t.length; i++) {
            var n = t[i];
            this.setAttachment(n.slotIndex, n.name, n.attachment);
        }
    }
    copySkin(e) {
        for (let i = 0; i < e.bones.length; i++) {
            let r = e.bones[i],
                a = !1;
            for (let o = 0; o < this.bones.length; o++)
                if (this.bones[o] == r) {
                    a = !0;
                    break;
                }
            a || this.bones.push(r);
        }
        for (let i = 0; i < e.constraints.length; i++) {
            let r = e.constraints[i],
                a = !1;
            for (let o = 0; o < this.constraints.length; o++)
                if (this.constraints[o] == r) {
                    a = !0;
                    break;
                }
            a || this.constraints.push(r);
        }
        let t = e.getAttachments();
        for (let i = 0; i < t.length; i++) {
            var n = t[i];
            n.attachment &&
                (n.attachment instanceof Xs
                    ? ((n.attachment = n.attachment.newLinkedMesh()),
                      this.setAttachment(n.slotIndex, n.name, n.attachment))
                    : ((n.attachment = n.attachment.copy()),
                      this.setAttachment(n.slotIndex, n.name, n.attachment)));
        }
    }
    getAttachment(e, t) {
        let n = this.attachments[e];
        return n ? n[t] : null;
    }
    removeAttachment(e, t) {
        let n = this.attachments[e];
        n && delete n[t];
    }
    getAttachments() {
        let e = new Array();
        for (var t = 0; t < this.attachments.length; t++) {
            let n = this.attachments[t];
            if (n)
                for (let i in n) {
                    let r = n[i];
                    r && e.push(new hb(t, i, r));
                }
        }
        return e;
    }
    getAttachmentsForSlot(e, t) {
        let n = this.attachments[e];
        if (n)
            for (let i in n) {
                let r = n[i];
                r && t.push(new hb(e, i, r));
            }
    }
    clear() {
        (this.attachments.length = 0),
            (this.bones.length = 0),
            (this.constraints.length = 0);
    }
    attachAll(e, t) {
        let n = 0;
        for (let i = 0; i < e.slots.length; i++) {
            let r = e.slots[i],
                a = r.getAttachment();
            if (a && n < t.attachments.length) {
                let o = t.attachments[n];
                for (let h in o) {
                    let l = o[h];
                    if (a == l) {
                        let u = this.getAttachment(n, h);
                        u && r.setAttachment(u);
                        break;
                    }
                }
            }
            n++;
        }
    }
}
class d2 {
    constructor(e, t, n) {
        x(this, "index", 0);
        x(this, "name");
        x(this, "boneData");
        x(this, "color", new he(1, 1, 1, 1));
        x(this, "darkColor", null);
        x(this, "attachmentName", null);
        x(this, "blendMode", Lr.Normal);
        x(this, "visible", !0);
        if (e < 0) throw new Error("index must be >= 0.");
        if (!t) throw new Error("name cannot be null.");
        if (!n) throw new Error("boneData cannot be null.");
        (this.index = e), (this.name = t), (this.boneData = n);
    }
}
var Lr;
(function (s) {
    (s[(s.Normal = 0)] = "Normal"),
        (s[(s.Additive = 1)] = "Additive"),
        (s[(s.Multiply = 2)] = "Multiply"),
        (s[(s.Screen = 3)] = "Screen");
})(Lr || (Lr = {}));
class f2 extends Md {
    constructor(t) {
        super(t, 0, !1);
        x(this, "bones", new Array());
        x(this, "_target", null);
        x(this, "mixRotate", 0);
        x(this, "mixX", 0);
        x(this, "mixY", 0);
        x(this, "mixScaleX", 0);
        x(this, "mixScaleY", 0);
        x(this, "mixShearY", 0);
        x(this, "offsetRotation", 0);
        x(this, "offsetX", 0);
        x(this, "offsetY", 0);
        x(this, "offsetScaleX", 0);
        x(this, "offsetScaleY", 0);
        x(this, "offsetShearY", 0);
        x(this, "relative", !1);
        x(this, "local", !1);
    }
    set target(t) {
        this._target = t;
    }
    get target() {
        if (this._target) return this._target;
        throw new Error("BoneData not set.");
    }
}
class rR {
    constructor(e) {
        x(this, "scale", 1);
        x(this, "attachmentLoader");
        x(this, "linkedMeshes", new Array());
        this.attachmentLoader = e;
    }
    readSkeletonData(e) {
        let t = this.scale,
            n = new Nu();
        n.name = "";
        let i = new aR(e),
            r = i.readInt32(),
            a = i.readInt32();
        (n.hash = a == 0 && r == 0 ? null : a.toString(16) + r.toString(16)),
            (n.version = i.readString()),
            (n.x = i.readFloat()),
            (n.y = i.readFloat()),
            (n.width = i.readFloat()),
            (n.height = i.readFloat()),
            (n.referenceScale = i.readFloat() * t);
        let o = i.readBoolean();
        o &&
            ((n.fps = i.readFloat()),
            (n.imagesPath = i.readString()),
            (n.audioPath = i.readString()));
        let h = 0;
        h = i.readInt(!0);
        for (let u = 0; u < h; u++) {
            let c = i.readString();
            if (!c) throw new Error("String in string table must not be null.");
            i.strings.push(c);
        }
        h = i.readInt(!0);
        for (let u = 0; u < h; u++) {
            let c = i.readString();
            if (!c) throw new Error("Bone name must not be null.");
            let d = u == 0 ? null : n.bones[i.readInt(!0)],
                f = new a2(u, c, d);
            (f.rotation = i.readFloat()),
                (f.x = i.readFloat() * t),
                (f.y = i.readFloat() * t),
                (f.scaleX = i.readFloat()),
                (f.scaleY = i.readFloat()),
                (f.shearX = i.readFloat()),
                (f.shearY = i.readFloat()),
                (f.length = i.readFloat() * t),
                (f.inherit = i.readByte()),
                (f.skinRequired = i.readBoolean()),
                o &&
                    (he.rgba8888ToColor(f.color, i.readInt32()),
                    (f.icon = i.readString() ?? void 0),
                    (f.visible = i.readBoolean())),
                n.bones.push(f);
        }
        h = i.readInt(!0);
        for (let u = 0; u < h; u++) {
            let c = i.readString();
            if (!c) throw new Error("Slot name must not be null.");
            let d = n.bones[i.readInt(!0)],
                f = new d2(u, c, d);
            he.rgba8888ToColor(f.color, i.readInt32());
            let p = i.readInt32();
            p != -1 && he.rgb888ToColor((f.darkColor = new he()), p),
                (f.attachmentName = i.readStringRef()),
                (f.blendMode = i.readInt(!0)),
                o && (f.visible = i.readBoolean()),
                n.slots.push(f);
        }
        h = i.readInt(!0);
        for (let u = 0, c; u < h; u++) {
            let d = i.readString();
            if (!d)
                throw new Error("IK constraint data name must not be null.");
            let f = new h2(d);
            (f.order = i.readInt(!0)), (c = i.readInt(!0));
            for (let m = 0; m < c; m++) f.bones.push(n.bones[i.readInt(!0)]);
            f.target = n.bones[i.readInt(!0)];
            let p = i.readByte();
            (f.skinRequired = (p & 1) != 0),
                (f.bendDirection = (p & 2) != 0 ? 1 : -1),
                (f.compress = (p & 4) != 0),
                (f.stretch = (p & 8) != 0),
                (f.uniform = (p & 16) != 0),
                (p & 32) != 0 && (f.mix = (p & 64) != 0 ? i.readFloat() : 1),
                (p & 128) != 0 && (f.softness = i.readFloat() * t),
                n.ikConstraints.push(f);
        }
        h = i.readInt(!0);
        for (let u = 0, c; u < h; u++) {
            let d = i.readString();
            if (!d)
                throw new Error(
                    "Transform constraint data name must not be null."
                );
            let f = new f2(d);
            (f.order = i.readInt(!0)), (c = i.readInt(!0));
            for (let m = 0; m < c; m++) f.bones.push(n.bones[i.readInt(!0)]);
            f.target = n.bones[i.readInt(!0)];
            let p = i.readByte();
            (f.skinRequired = (p & 1) != 0),
                (f.local = (p & 2) != 0),
                (f.relative = (p & 4) != 0),
                (p & 8) != 0 && (f.offsetRotation = i.readFloat()),
                (p & 16) != 0 && (f.offsetX = i.readFloat() * t),
                (p & 32) != 0 && (f.offsetY = i.readFloat() * t),
                (p & 64) != 0 && (f.offsetScaleX = i.readFloat()),
                (p & 128) != 0 && (f.offsetScaleY = i.readFloat()),
                (p = i.readByte()),
                (p & 1) != 0 && (f.offsetShearY = i.readFloat()),
                (p & 2) != 0 && (f.mixRotate = i.readFloat()),
                (p & 4) != 0 && (f.mixX = i.readFloat()),
                (p & 8) != 0 && (f.mixY = i.readFloat()),
                (p & 16) != 0 && (f.mixScaleX = i.readFloat()),
                (p & 32) != 0 && (f.mixScaleY = i.readFloat()),
                (p & 64) != 0 && (f.mixShearY = i.readFloat()),
                n.transformConstraints.push(f);
        }
        h = i.readInt(!0);
        for (let u = 0, c; u < h; u++) {
            let d = i.readString();
            if (!d)
                throw new Error("Path constraint data name must not be null.");
            let f = new c2(d);
            (f.order = i.readInt(!0)),
                (f.skinRequired = i.readBoolean()),
                (c = i.readInt(!0));
            for (let m = 0; m < c; m++) f.bones.push(n.bones[i.readInt(!0)]);
            f.target = n.slots[i.readInt(!0)];
            const p = i.readByte();
            (f.positionMode = p & 1),
                (f.spacingMode = (p >> 1) & 3),
                (f.rotateMode = (p >> 3) & 3),
                (p & 128) != 0 && (f.offsetRotation = i.readFloat()),
                (f.position = i.readFloat()),
                f.positionMode == Ci.Fixed && (f.position *= t),
                (f.spacing = i.readFloat()),
                (f.spacingMode == zt.Length || f.spacingMode == zt.Fixed) &&
                    (f.spacing *= t),
                (f.mixRotate = i.readFloat()),
                (f.mixX = i.readFloat()),
                (f.mixY = i.readFloat()),
                n.pathConstraints.push(f);
        }
        h = i.readInt(!0);
        for (let u = 0, c; u < h; u++) {
            const d = i.readString();
            if (!d)
                throw new Error(
                    "Physics constraint data name must not be null."
                );
            const f = new u2(d);
            (f.order = i.readInt(!0)), (f.bone = n.bones[i.readInt(!0)]);
            let p = i.readByte();
            (f.skinRequired = (p & 1) != 0),
                (p & 2) != 0 && (f.x = i.readFloat()),
                (p & 4) != 0 && (f.y = i.readFloat()),
                (p & 8) != 0 && (f.rotate = i.readFloat()),
                (p & 16) != 0 && (f.scaleX = i.readFloat()),
                (p & 32) != 0 && (f.shearX = i.readFloat()),
                (f.limit = ((p & 64) != 0 ? i.readFloat() : 5e3) * t),
                (f.step = 1 / i.readUnsignedByte()),
                (f.inertia = i.readFloat()),
                (f.strength = i.readFloat()),
                (f.damping = i.readFloat()),
                (f.massInverse = (p & 128) != 0 ? i.readFloat() : 1),
                (f.wind = i.readFloat()),
                (f.gravity = i.readFloat()),
                (p = i.readByte()),
                (p & 1) != 0 && (f.inertiaGlobal = !0),
                (p & 2) != 0 && (f.strengthGlobal = !0),
                (p & 4) != 0 && (f.dampingGlobal = !0),
                (p & 8) != 0 && (f.massGlobal = !0),
                (p & 16) != 0 && (f.windGlobal = !0),
                (p & 32) != 0 && (f.gravityGlobal = !0),
                (p & 64) != 0 && (f.mixGlobal = !0),
                (f.mix = (p & 128) != 0 ? i.readFloat() : 1),
                n.physicsConstraints.push(f);
        }
        let l = this.readSkin(i, n, !0, o);
        l && ((n.defaultSkin = l), n.skins.push(l));
        {
            let u = n.skins.length;
            for (K.setArraySize(n.skins, (h = u + i.readInt(!0))); u < h; u++) {
                let c = this.readSkin(i, n, !1, o);
                if (!c)
                    throw new Error(
                        "readSkin() should not have returned null."
                    );
                n.skins[u] = c;
            }
        }
        h = this.linkedMeshes.length;
        for (let u = 0; u < h; u++) {
            let c = this.linkedMeshes[u];
            const d = n.skins[c.skinIndex];
            if (!c.parent)
                throw new Error("Linked mesh parent must not be null");
            let f = d.getAttachment(c.slotIndex, c.parent);
            if (!f) throw new Error(`Parent mesh not found: ${c.parent}`);
            (c.mesh.timelineAttachment = c.inheritTimeline ? f : c.mesh),
                c.mesh.setParentMesh(f),
                c.mesh.region != null && c.mesh.updateRegion();
        }
        (this.linkedMeshes.length = 0), (h = i.readInt(!0));
        for (let u = 0; u < h; u++) {
            let c = i.readString();
            if (!c) throw new Error("Event data name must not be null");
            let d = new l2(c);
            (d.intValue = i.readInt(!1)),
                (d.floatValue = i.readFloat()),
                (d.stringValue = i.readString()),
                (d.audioPath = i.readString()),
                d.audioPath &&
                    ((d.volume = i.readFloat()), (d.balance = i.readFloat())),
                n.events.push(d);
        }
        h = i.readInt(!0);
        for (let u = 0; u < h; u++) {
            let c = i.readString();
            if (!c) throw new Error("Animatio name must not be null.");
            n.animations.push(this.readAnimation(i, c, n));
        }
        return n;
    }
    readSkin(e, t, n, i) {
        let r = null,
            a = 0;
        if (n) {
            if (((a = e.readInt(!0)), a == 0)) return null;
            r = new Am("default");
        } else {
            let o = e.readString();
            if (!o) throw new Error("Skin name must not be null.");
            (r = new Am(o)),
                i && he.rgba8888ToColor(r.color, e.readInt32()),
                (r.bones.length = e.readInt(!0));
            for (let h = 0, l = r.bones.length; h < l; h++)
                r.bones[h] = t.bones[e.readInt(!0)];
            for (let h = 0, l = e.readInt(!0); h < l; h++)
                r.constraints.push(t.ikConstraints[e.readInt(!0)]);
            for (let h = 0, l = e.readInt(!0); h < l; h++)
                r.constraints.push(t.transformConstraints[e.readInt(!0)]);
            for (let h = 0, l = e.readInt(!0); h < l; h++)
                r.constraints.push(t.pathConstraints[e.readInt(!0)]);
            for (let h = 0, l = e.readInt(!0); h < l; h++)
                r.constraints.push(t.physicsConstraints[e.readInt(!0)]);
            a = e.readInt(!0);
        }
        for (let o = 0; o < a; o++) {
            let h = e.readInt(!0);
            for (let l = 0, u = e.readInt(!0); l < u; l++) {
                let c = e.readStringRef();
                if (!c) throw new Error("Attachment name must not be null");
                let d = this.readAttachment(e, t, r, h, c, i);
                d && r.setAttachment(h, c, d);
            }
        }
        return r;
    }
    readAttachment(e, t, n, i, r, a) {
        let o = this.scale,
            h = e.readByte();
        const l = (h & 8) != 0 ? e.readStringRef() : r;
        if (!l) throw new Error("Attachment name must not be null");
        switch (h & 7) {
            case Gi.Region: {
                let u = (h & 16) != 0 ? e.readStringRef() : null;
                const c = (h & 32) != 0 ? e.readInt32() : 4294967295,
                    d = (h & 64) != 0 ? this.readSequence(e) : null;
                let f = (h & 128) != 0 ? e.readFloat() : 0,
                    p = e.readFloat(),
                    m = e.readFloat(),
                    g = e.readFloat(),
                    _ = e.readFloat(),
                    v = e.readFloat(),
                    b = e.readFloat();
                u || (u = l);
                let y = this.attachmentLoader.newRegionAttachment(n, l, u, d);
                return y
                    ? ((y.path = u),
                      (y.x = p * o),
                      (y.y = m * o),
                      (y.scaleX = g),
                      (y.scaleY = _),
                      (y.rotation = f),
                      (y.width = v * o),
                      (y.height = b * o),
                      he.rgba8888ToColor(y.color, c),
                      (y.sequence = d),
                      d == null && y.updateRegion(),
                      y)
                    : null;
            }
            case Gi.BoundingBox: {
                let u = this.readVertices(e, (h & 16) != 0),
                    c = a ? e.readInt32() : 0,
                    d = this.attachmentLoader.newBoundingBoxAttachment(n, l);
                return d
                    ? ((d.worldVerticesLength = u.length),
                      (d.vertices = u.vertices),
                      (d.bones = u.bones),
                      a && he.rgba8888ToColor(d.color, c),
                      d)
                    : null;
            }
            case Gi.Mesh: {
                let u = (h & 16) != 0 ? e.readStringRef() : l;
                const c = (h & 32) != 0 ? e.readInt32() : 4294967295,
                    d = (h & 64) != 0 ? this.readSequence(e) : null,
                    f = e.readInt(!0),
                    p = this.readVertices(e, (h & 128) != 0),
                    m = this.readFloatArray(e, p.length, 1),
                    g = this.readShortArray(e, (p.length - f - 2) * 3);
                let _ = [],
                    v = 0,
                    b = 0;
                a &&
                    ((_ = this.readShortArray(e, e.readInt(!0))),
                    (v = e.readFloat()),
                    (b = e.readFloat())),
                    u || (u = l);
                let y = this.attachmentLoader.newMeshAttachment(n, l, u, d);
                return y
                    ? ((y.path = u),
                      he.rgba8888ToColor(y.color, c),
                      (y.bones = p.bones),
                      (y.vertices = p.vertices),
                      (y.worldVerticesLength = p.length),
                      (y.triangles = g),
                      (y.regionUVs = m),
                      d == null && y.updateRegion(),
                      (y.hullLength = f << 1),
                      (y.sequence = d),
                      a &&
                          ((y.edges = _),
                          (y.width = v * o),
                          (y.height = b * o)),
                      y)
                    : null;
            }
            case Gi.LinkedMesh: {
                const u = (h & 16) != 0 ? e.readStringRef() : l;
                if (u == null)
                    throw new Error("Path of linked mesh must not be null");
                const c = (h & 32) != 0 ? e.readInt32() : 4294967295,
                    d = (h & 64) != 0 ? this.readSequence(e) : null,
                    f = (h & 128) != 0,
                    p = e.readInt(!0),
                    m = e.readStringRef();
                let g = 0,
                    _ = 0;
                a && ((g = e.readFloat()), (_ = e.readFloat()));
                let v = this.attachmentLoader.newMeshAttachment(n, l, u, d);
                return v
                    ? ((v.path = u),
                      he.rgba8888ToColor(v.color, c),
                      (v.sequence = d),
                      a && ((v.width = g * o), (v.height = _ * o)),
                      this.linkedMeshes.push(new oR(v, p, i, m, f)),
                      v)
                    : null;
            }
            case Gi.Path: {
                const u = (h & 16) != 0,
                    c = (h & 32) != 0,
                    d = this.readVertices(e, (h & 64) != 0),
                    f = K.newArray(d.length / 6, 0);
                for (let g = 0, _ = f.length; g < _; g++)
                    f[g] = e.readFloat() * o;
                const p = a ? e.readInt32() : 0,
                    m = this.attachmentLoader.newPathAttachment(n, l);
                return m
                    ? ((m.closed = u),
                      (m.constantSpeed = c),
                      (m.worldVerticesLength = d.length),
                      (m.vertices = d.vertices),
                      (m.bones = d.bones),
                      (m.lengths = f),
                      a && he.rgba8888ToColor(m.color, p),
                      m)
                    : null;
            }
            case Gi.Point: {
                const u = e.readFloat(),
                    c = e.readFloat(),
                    d = e.readFloat(),
                    f = a ? e.readInt32() : 0,
                    p = this.attachmentLoader.newPointAttachment(n, l);
                return p
                    ? ((p.x = c * o),
                      (p.y = d * o),
                      (p.rotation = u),
                      a && he.rgba8888ToColor(p.color, f),
                      p)
                    : null;
            }
            case Gi.Clipping: {
                const u = e.readInt(!0),
                    c = this.readVertices(e, (h & 16) != 0);
                let d = a ? e.readInt32() : 0,
                    f = this.attachmentLoader.newClippingAttachment(n, l);
                return f
                    ? ((f.endSlot = t.slots[u]),
                      (f.worldVerticesLength = c.length),
                      (f.vertices = c.vertices),
                      (f.bones = c.bones),
                      a && he.rgba8888ToColor(f.color, d),
                      f)
                    : null;
            }
        }
        return null;
    }
    readSequence(e) {
        let t = new Bu(e.readInt(!0));
        return (
            (t.start = e.readInt(!0)),
            (t.digits = e.readInt(!0)),
            (t.setupIndex = e.readInt(!0)),
            t
        );
    }
    readVertices(e, t) {
        const n = this.scale,
            i = e.readInt(!0),
            r = new lR();
        if (((r.length = i << 1), !t))
            return (r.vertices = this.readFloatArray(e, r.length, n)), r;
        let a = new Array(),
            o = new Array();
        for (let h = 0; h < i; h++) {
            let l = e.readInt(!0);
            o.push(l);
            for (let u = 0; u < l; u++)
                o.push(e.readInt(!0)),
                    a.push(e.readFloat() * n),
                    a.push(e.readFloat() * n),
                    a.push(e.readFloat());
        }
        return (r.vertices = K.toFloatArray(a)), (r.bones = o), r;
    }
    readFloatArray(e, t, n) {
        let i = new Array(t);
        if (n == 1) for (let r = 0; r < t; r++) i[r] = e.readFloat();
        else for (let r = 0; r < t; r++) i[r] = e.readFloat() * n;
        return i;
    }
    readShortArray(e, t) {
        let n = new Array(t);
        for (let i = 0; i < t; i++) n[i] = e.readInt(!0);
        return n;
    }
    readAnimation(e, t, n) {
        e.readInt(!0);
        let i = new Array(),
            r = this.scale;
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = e.readInt(!0);
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                let p = e.readByte(),
                    m = e.readInt(!0),
                    g = m - 1;
                switch (p) {
                    case yR: {
                        let _ = new xo(m, c);
                        for (let v = 0; v < m; v++)
                            _.setFrame(v, e.readFloat(), e.readStringRef());
                        i.push(_);
                        break;
                    }
                    case wR: {
                        let _ = e.readInt(!0),
                            v = new UC(m, _, c),
                            b = e.readFloat(),
                            y = e.readUnsignedByte() / 255,
                            C = e.readUnsignedByte() / 255,
                            w = e.readUnsignedByte() / 255,
                            A = e.readUnsignedByte() / 255;
                        for (
                            let E = 0, S = 0;
                            v.setFrame(E, b, y, C, w, A), E != g;
                            E++
                        ) {
                            let P = e.readFloat(),
                                k = e.readUnsignedByte() / 255,
                                R = e.readUnsignedByte() / 255,
                                M = e.readUnsignedByte() / 255,
                                T = e.readUnsignedByte() / 255;
                            switch (e.readByte()) {
                                case ui:
                                    v.setStepped(E);
                                    break;
                                case di:
                                    xe(e, v, S++, E, 0, b, P, y, k, 1),
                                        xe(e, v, S++, E, 1, b, P, C, R, 1),
                                        xe(e, v, S++, E, 2, b, P, w, M, 1),
                                        xe(e, v, S++, E, 3, b, P, A, T, 1);
                            }
                            (b = P), (y = k), (C = R), (w = M), (A = T);
                        }
                        i.push(v);
                        break;
                    }
                    case xR: {
                        let _ = e.readInt(!0),
                            v = new zC(m, _, c),
                            b = e.readFloat(),
                            y = e.readUnsignedByte() / 255,
                            C = e.readUnsignedByte() / 255,
                            w = e.readUnsignedByte() / 255;
                        for (
                            let A = 0, E = 0;
                            v.setFrame(A, b, y, C, w), A != g;
                            A++
                        ) {
                            let S = e.readFloat(),
                                P = e.readUnsignedByte() / 255,
                                k = e.readUnsignedByte() / 255,
                                R = e.readUnsignedByte() / 255;
                            switch (e.readByte()) {
                                case ui:
                                    v.setStepped(A);
                                    break;
                                case di:
                                    xe(e, v, E++, A, 0, b, S, y, P, 1),
                                        xe(e, v, E++, A, 1, b, S, C, k, 1),
                                        xe(e, v, E++, A, 2, b, S, w, R, 1);
                            }
                            (b = S), (y = P), (C = k), (w = R);
                        }
                        i.push(v);
                        break;
                    }
                    case CR: {
                        let _ = e.readInt(!0),
                            v = new GC(m, _, c),
                            b = e.readFloat(),
                            y = e.readUnsignedByte() / 255,
                            C = e.readUnsignedByte() / 255,
                            w = e.readUnsignedByte() / 255,
                            A = e.readUnsignedByte() / 255,
                            E = e.readUnsignedByte() / 255,
                            S = e.readUnsignedByte() / 255,
                            P = e.readUnsignedByte() / 255;
                        for (
                            let k = 0, R = 0;
                            v.setFrame(k, b, y, C, w, A, E, S, P), k != g;
                            k++
                        ) {
                            let M = e.readFloat(),
                                T = e.readUnsignedByte() / 255,
                                O = e.readUnsignedByte() / 255,
                                L = e.readUnsignedByte() / 255,
                                F = e.readUnsignedByte() / 255,
                                Y = e.readUnsignedByte() / 255,
                                V = e.readUnsignedByte() / 255,
                                W = e.readUnsignedByte() / 255;
                            switch (e.readByte()) {
                                case ui:
                                    v.setStepped(k);
                                    break;
                                case di:
                                    xe(e, v, R++, k, 0, b, M, y, T, 1),
                                        xe(e, v, R++, k, 1, b, M, C, O, 1),
                                        xe(e, v, R++, k, 2, b, M, w, L, 1),
                                        xe(e, v, R++, k, 3, b, M, A, F, 1),
                                        xe(e, v, R++, k, 4, b, M, E, Y, 1),
                                        xe(e, v, R++, k, 5, b, M, S, V, 1),
                                        xe(e, v, R++, k, 6, b, M, P, W, 1);
                            }
                            (b = M),
                                (y = T),
                                (C = O),
                                (w = L),
                                (A = F),
                                (E = Y),
                                (S = V),
                                (P = W);
                        }
                        i.push(v);
                        break;
                    }
                    case AR: {
                        let _ = e.readInt(!0),
                            v = new jC(m, _, c),
                            b = e.readFloat(),
                            y = e.readUnsignedByte() / 255,
                            C = e.readUnsignedByte() / 255,
                            w = e.readUnsignedByte() / 255,
                            A = e.readUnsignedByte() / 255,
                            E = e.readUnsignedByte() / 255,
                            S = e.readUnsignedByte() / 255;
                        for (
                            let P = 0, k = 0;
                            v.setFrame(P, b, y, C, w, A, E, S), P != g;
                            P++
                        ) {
                            let R = e.readFloat(),
                                M = e.readUnsignedByte() / 255,
                                T = e.readUnsignedByte() / 255,
                                O = e.readUnsignedByte() / 255,
                                L = e.readUnsignedByte() / 255,
                                F = e.readUnsignedByte() / 255,
                                Y = e.readUnsignedByte() / 255;
                            switch (e.readByte()) {
                                case ui:
                                    v.setStepped(P);
                                    break;
                                case di:
                                    xe(e, v, k++, P, 0, b, R, y, M, 1),
                                        xe(e, v, k++, P, 1, b, R, C, T, 1),
                                        xe(e, v, k++, P, 2, b, R, w, O, 1),
                                        xe(e, v, k++, P, 3, b, R, A, L, 1),
                                        xe(e, v, k++, P, 4, b, R, E, F, 1),
                                        xe(e, v, k++, P, 5, b, R, S, Y, 1);
                            }
                            (b = R),
                                (y = M),
                                (C = T),
                                (w = O),
                                (A = L),
                                (E = F),
                                (S = Y);
                        }
                        i.push(v);
                        break;
                    }
                    case SR: {
                        let _ = new YC(m, e.readInt(!0), c),
                            v = e.readFloat(),
                            b = e.readUnsignedByte() / 255;
                        for (
                            let y = 0, C = 0;
                            _.setFrame(y, v, b), y != g;
                            y++
                        ) {
                            let w = e.readFloat(),
                                A = e.readUnsignedByte() / 255;
                            switch (e.readByte()) {
                                case ui:
                                    _.setStepped(y);
                                    break;
                                case di:
                                    xe(e, _, C++, y, 0, v, w, b, A, 1);
                            }
                            (v = w), (b = A);
                        }
                        i.push(_);
                    }
                }
            }
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = e.readInt(!0);
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                let p = e.readByte(),
                    m = e.readInt(!0);
                if (p == bR) {
                    let _ = new VC(m, c);
                    for (let v = 0; v < m; v++)
                        _.setFrame(v, e.readFloat(), e.readByte());
                    i.push(_);
                    continue;
                }
                let g = e.readInt(!0);
                switch (p) {
                    case hR:
                        i.push(un(e, new Fu(m, g, c), 1));
                        break;
                    case cR:
                        i.push(ep(e, new IC(m, g, c), r));
                        break;
                    case uR:
                        i.push(un(e, new RC(m, g, c), r));
                        break;
                    case dR:
                        i.push(un(e, new LC(m, g, c), r));
                        break;
                    case fR:
                        i.push(ep(e, new OC(m, g, c), 1));
                        break;
                    case pR:
                        i.push(un(e, new BC(m, g, c), 1));
                        break;
                    case mR:
                        i.push(un(e, new FC(m, g, c), 1));
                        break;
                    case gR:
                        i.push(ep(e, new $C(m, g, c), 1));
                        break;
                    case _R:
                        i.push(un(e, new DC(m, g, c), 1));
                        break;
                    case vR:
                        i.push(un(e, new NC(m, g, c), 1));
                }
            }
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = e.readInt(!0),
                d = e.readInt(!0),
                f = d - 1,
                p = new XC(d, e.readInt(!0), c),
                m = e.readByte(),
                g = e.readFloat(),
                _ = (m & 1) != 0 ? ((m & 2) != 0 ? e.readFloat() : 1) : 0,
                v = (m & 4) != 0 ? e.readFloat() * r : 0;
            for (
                let b = 0, y = 0;
                p.setFrame(
                    b,
                    g,
                    _,
                    v,
                    (m & 8) != 0 ? 1 : -1,
                    (m & 16) != 0,
                    (m & 32) != 0
                ),
                    b != f;
                b++
            ) {
                m = e.readByte();
                const C = e.readFloat(),
                    w = (m & 1) != 0 ? ((m & 2) != 0 ? e.readFloat() : 1) : 0,
                    A = (m & 4) != 0 ? e.readFloat() * r : 0;
                (m & 64) != 0
                    ? p.setStepped(b)
                    : (m & 128) != 0 &&
                      (xe(e, p, y++, b, 0, g, C, _, w, 1),
                      xe(e, p, y++, b, 1, g, C, v, A, r)),
                    (g = C),
                    (_ = w),
                    (v = A);
            }
            i.push(p);
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = e.readInt(!0),
                d = e.readInt(!0),
                f = d - 1,
                p = new qC(d, e.readInt(!0), c),
                m = e.readFloat(),
                g = e.readFloat(),
                _ = e.readFloat(),
                v = e.readFloat(),
                b = e.readFloat(),
                y = e.readFloat(),
                C = e.readFloat();
            for (
                let w = 0, A = 0;
                p.setFrame(w, m, g, _, v, b, y, C), w != f;
                w++
            ) {
                let E = e.readFloat(),
                    S = e.readFloat(),
                    P = e.readFloat(),
                    k = e.readFloat(),
                    R = e.readFloat(),
                    M = e.readFloat(),
                    T = e.readFloat();
                switch (e.readByte()) {
                    case ui:
                        p.setStepped(w);
                        break;
                    case di:
                        xe(e, p, A++, w, 0, m, E, g, S, 1),
                            xe(e, p, A++, w, 1, m, E, _, P, 1),
                            xe(e, p, A++, w, 2, m, E, v, k, 1),
                            xe(e, p, A++, w, 3, m, E, b, R, 1),
                            xe(e, p, A++, w, 4, m, E, y, M, 1),
                            xe(e, p, A++, w, 5, m, E, C, T, 1);
                }
                (m = E), (g = S), (_ = P), (v = k), (b = R), (y = M), (C = T);
            }
            i.push(p);
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = e.readInt(!0),
                d = n.pathConstraints[c];
            for (let f = 0, p = e.readInt(!0); f < p; f++) {
                const m = e.readByte(),
                    g = e.readInt(!0),
                    _ = e.readInt(!0);
                switch (m) {
                    case kR:
                        i.push(
                            un(
                                e,
                                new HC(g, _, c),
                                d.positionMode == Ci.Fixed ? r : 1
                            )
                        );
                        break;
                    case TR:
                        i.push(
                            un(
                                e,
                                new KC(g, _, c),
                                d.spacingMode == zt.Length ||
                                    d.spacingMode == zt.Fixed
                                    ? r
                                    : 1
                            )
                        );
                        break;
                    case MR:
                        let v = new ZC(g, _, c),
                            b = e.readFloat(),
                            y = e.readFloat(),
                            C = e.readFloat(),
                            w = e.readFloat();
                        for (
                            let A = 0, E = 0, S = v.getFrameCount() - 1;
                            v.setFrame(A, b, y, C, w), A != S;
                            A++
                        ) {
                            let P = e.readFloat(),
                                k = e.readFloat(),
                                R = e.readFloat(),
                                M = e.readFloat();
                            switch (e.readByte()) {
                                case ui:
                                    v.setStepped(A);
                                    break;
                                case di:
                                    xe(e, v, E++, A, 0, b, P, y, k, 1),
                                        xe(e, v, E++, A, 1, b, P, C, R, 1),
                                        xe(e, v, E++, A, 2, b, P, w, M, 1);
                            }
                            (b = P), (y = k), (C = R), (w = M);
                        }
                        i.push(v);
                }
            }
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            const c = e.readInt(!0) - 1;
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                const p = e.readByte(),
                    m = e.readInt(!0);
                if (p == DR) {
                    const _ = new $u(m, c);
                    for (let v = 0; v < m; v++) _.setFrame(v, e.readFloat());
                    i.push(_);
                    continue;
                }
                const g = e.readInt(!0);
                switch (p) {
                    case IR:
                        i.push(un(e, new QC(m, g, c), 1));
                        break;
                    case RR:
                        i.push(un(e, new JC(m, g, c), 1));
                        break;
                    case LR:
                        i.push(un(e, new e2(m, g, c), 1));
                        break;
                    case OR:
                        i.push(un(e, new t2(m, g, c), 1));
                        break;
                    case BR:
                        i.push(un(e, new n2(m, g, c), 1));
                        break;
                    case FR:
                        i.push(un(e, new s2(m, g, c), 1));
                        break;
                    case $R:
                        i.push(un(e, new i2(m, g, c), 1));
                }
            }
        }
        for (let l = 0, u = e.readInt(!0); l < u; l++) {
            let c = n.skins[e.readInt(!0)];
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                let p = e.readInt(!0);
                for (let m = 0, g = e.readInt(!0); m < g; m++) {
                    let _ = e.readStringRef();
                    if (!_) throw new Error("attachmentName must not be null.");
                    let v = c.getAttachment(p, _),
                        b = e.readByte(),
                        y = e.readInt(!0),
                        C = y - 1;
                    switch (b) {
                        case ER: {
                            let w = v,
                                A = w.bones,
                                E = w.vertices,
                                S = A ? (E.length / 3) * 2 : E.length,
                                P = e.readInt(!0),
                                k = new WC(y, P, p, w),
                                R = e.readFloat();
                            for (let M = 0, T = 0; ; M++) {
                                let O,
                                    L = e.readInt(!0);
                                if (L == 0) O = A ? K.newFloatArray(S) : E;
                                else {
                                    O = K.newFloatArray(S);
                                    let Y = e.readInt(!0);
                                    if (((L += Y), r == 1))
                                        for (let V = Y; V < L; V++)
                                            O[V] = e.readFloat();
                                    else
                                        for (let V = Y; V < L; V++)
                                            O[V] = e.readFloat() * r;
                                    if (!A)
                                        for (
                                            let V = 0, W = O.length;
                                            V < W;
                                            V++
                                        )
                                            O[V] += E[V];
                                }
                                if ((k.setFrame(M, R, O), M == C)) break;
                                let F = e.readFloat();
                                switch (e.readByte()) {
                                    case ui:
                                        k.setStepped(M);
                                        break;
                                    case di:
                                        xe(e, k, T++, M, 0, R, F, 0, 1, 1);
                                }
                                R = F;
                            }
                            i.push(k);
                            break;
                        }
                        case PR: {
                            let w = new Du(y, p, v);
                            for (let A = 0; A < y; A++) {
                                let E = e.readFloat(),
                                    S = e.readInt32();
                                w.setFrame(
                                    A,
                                    E,
                                    MC[S & 15],
                                    S >> 4,
                                    e.readFloat()
                                );
                            }
                            i.push(w);
                            break;
                        }
                    }
                }
            }
        }
        let a = e.readInt(!0);
        if (a > 0) {
            let l = new Sa(a),
                u = n.slots.length;
            for (let c = 0; c < a; c++) {
                let d = e.readFloat(),
                    f = e.readInt(!0),
                    p = K.newArray(u, 0);
                for (let v = u - 1; v >= 0; v--) p[v] = -1;
                let m = K.newArray(u - f, 0),
                    g = 0,
                    _ = 0;
                for (let v = 0; v < f; v++) {
                    let b = e.readInt(!0);
                    for (; g != b; ) m[_++] = g++;
                    p[g + e.readInt(!0)] = g++;
                }
                for (; g < u; ) m[_++] = g++;
                for (let v = u - 1; v >= 0; v--) p[v] == -1 && (p[v] = m[--_]);
                l.setFrame(c, d, p);
            }
            i.push(l);
        }
        let o = e.readInt(!0);
        if (o > 0) {
            let l = new Yh(o);
            for (let u = 0; u < o; u++) {
                let c = e.readFloat(),
                    d = n.events[e.readInt(!0)],
                    f = new o2(c, d);
                (f.intValue = e.readInt(!1)),
                    (f.floatValue = e.readFloat()),
                    (f.stringValue = e.readString()),
                    f.stringValue == null && (f.stringValue = d.stringValue),
                    f.data.audioPath &&
                        ((f.volume = e.readFloat()),
                        (f.balance = e.readFloat())),
                    l.setFrame(u, f);
            }
            i.push(l);
        }
        let h = 0;
        for (let l = 0, u = i.length; l < u; l++)
            h = Math.max(h, i[l].getDuration());
        return new zg(t, i, h);
    }
}
class aR {
    constructor(
        e,
        t = new Array(),
        n = 0,
        i = new DataView(e instanceof ArrayBuffer ? e : e.buffer)
    ) {
        x(this, "strings");
        x(this, "index");
        x(this, "buffer");
        (this.strings = t), (this.index = n), (this.buffer = i);
    }
    readByte() {
        return this.buffer.getInt8(this.index++);
    }
    readUnsignedByte() {
        return this.buffer.getUint8(this.index++);
    }
    readShort() {
        let e = this.buffer.getInt16(this.index);
        return (this.index += 2), e;
    }
    readInt32() {
        let e = this.buffer.getInt32(this.index);
        return (this.index += 4), e;
    }
    readInt(e) {
        let t = this.readByte(),
            n = t & 127;
        return (
            (t & 128) != 0 &&
                ((t = this.readByte()),
                (n |= (t & 127) << 7),
                (t & 128) != 0 &&
                    ((t = this.readByte()),
                    (n |= (t & 127) << 14),
                    (t & 128) != 0 &&
                        ((t = this.readByte()),
                        (n |= (t & 127) << 21),
                        (t & 128) != 0 &&
                            ((t = this.readByte()), (n |= (t & 127) << 28))))),
            e ? n : (n >>> 1) ^ -(n & 1)
        );
    }
    readStringRef() {
        let e = this.readInt(!0);
        return e == 0 ? null : this.strings[e - 1];
    }
    readString() {
        let e = this.readInt(!0);
        switch (e) {
            case 0:
                return null;
            case 1:
                return "";
        }
        e--;
        let t = "";
        for (let n = 0; n < e; ) {
            let i = this.readUnsignedByte();
            switch (i >> 4) {
                case 12:
                case 13:
                    (t += String.fromCharCode(
                        ((i & 31) << 6) | (this.readByte() & 63)
                    )),
                        (n += 2);
                    break;
                case 14:
                    (t += String.fromCharCode(
                        ((i & 15) << 12) |
                            ((this.readByte() & 63) << 6) |
                            (this.readByte() & 63)
                    )),
                        (n += 3);
                    break;
                default:
                    (t += String.fromCharCode(i)), n++;
            }
        }
        return t;
    }
    readFloat() {
        let e = this.buffer.getFloat32(this.index);
        return (this.index += 4), e;
    }
    readBoolean() {
        return this.readByte() != 0;
    }
}
let oR = class {
    constructor(e, t, n, i, r) {
        x(this, "parent");
        x(this, "skinIndex");
        x(this, "slotIndex");
        x(this, "mesh");
        x(this, "inheritTimeline");
        (this.mesh = e),
            (this.skinIndex = t),
            (this.slotIndex = n),
            (this.parent = i),
            (this.inheritTimeline = r);
    }
};
class lR {
    constructor(e = null, t = null, n = 0) {
        x(this, "bones");
        x(this, "vertices");
        x(this, "length");
        (this.bones = e), (this.vertices = t), (this.length = n);
    }
}
var Gi;
(function (s) {
    (s[(s.Region = 0)] = "Region"),
        (s[(s.BoundingBox = 1)] = "BoundingBox"),
        (s[(s.Mesh = 2)] = "Mesh"),
        (s[(s.LinkedMesh = 3)] = "LinkedMesh"),
        (s[(s.Path = 4)] = "Path"),
        (s[(s.Point = 5)] = "Point"),
        (s[(s.Clipping = 6)] = "Clipping");
})(Gi || (Gi = {}));
function un(s, e, t) {
    let n = s.readFloat(),
        i = s.readFloat() * t;
    for (
        let r = 0, a = 0, o = e.getFrameCount() - 1;
        e.setFrame(r, n, i), r != o;
        r++
    ) {
        let h = s.readFloat(),
            l = s.readFloat() * t;
        switch (s.readByte()) {
            case ui:
                e.setStepped(r);
                break;
            case di:
                xe(s, e, a++, r, 0, n, h, i, l, t);
        }
        (n = h), (i = l);
    }
    return e;
}
function ep(s, e, t) {
    let n = s.readFloat(),
        i = s.readFloat() * t,
        r = s.readFloat() * t;
    for (
        let a = 0, o = 0, h = e.getFrameCount() - 1;
        e.setFrame(a, n, i, r), a != h;
        a++
    ) {
        let l = s.readFloat(),
            u = s.readFloat() * t,
            c = s.readFloat() * t;
        switch (s.readByte()) {
            case ui:
                e.setStepped(a);
                break;
            case di:
                xe(s, e, o++, a, 0, n, l, i, u, t),
                    xe(s, e, o++, a, 1, n, l, r, c, t);
        }
        (n = l), (i = u), (r = c);
    }
    return e;
}
function xe(s, e, t, n, i, r, a, o, h, l) {
    e.setBezier(
        t,
        n,
        i,
        r,
        o,
        s.readFloat(),
        s.readFloat() * l,
        s.readFloat(),
        s.readFloat() * l,
        a,
        h
    );
}
const hR = 0,
    cR = 1,
    uR = 2,
    dR = 3,
    fR = 4,
    pR = 5,
    mR = 6,
    gR = 7,
    _R = 8,
    vR = 9,
    bR = 10,
    yR = 0,
    wR = 1,
    xR = 2,
    CR = 3,
    AR = 4,
    SR = 5,
    ER = 0,
    PR = 1,
    kR = 0,
    TR = 1,
    MR = 2,
    IR = 0,
    RR = 1,
    LR = 2,
    OR = 4,
    BR = 5,
    FR = 6,
    $R = 7,
    DR = 8,
    ui = 1,
    di = 2;
class NR {
    constructor() {
        x(this, "minX", 0);
        x(this, "minY", 0);
        x(this, "maxX", 0);
        x(this, "maxY", 0);
        x(this, "boundingBoxes", new Array());
        x(this, "polygons", new Array());
        x(this, "polygonPool", new zh(() => K.newFloatArray(16)));
    }
    update(e, t) {
        if (!e) throw new Error("skeleton cannot be null.");
        let n = this.boundingBoxes,
            i = this.polygons,
            r = this.polygonPool,
            a = e.slots,
            o = a.length;
        (n.length = 0), r.freeAll(i), (i.length = 0);
        for (let h = 0; h < o; h++) {
            let l = a[h];
            if (!l.bone.active) continue;
            let u = l.getAttachment();
            if (u instanceof Td) {
                let c = u;
                n.push(c);
                let d = r.obtain();
                d.length != c.worldVerticesLength &&
                    (d = K.newFloatArray(c.worldVerticesLength)),
                    i.push(d),
                    c.computeWorldVertices(
                        l,
                        0,
                        c.worldVerticesLength,
                        d,
                        0,
                        2
                    );
            }
        }
        t
            ? this.aabbCompute()
            : ((this.minX = Number.POSITIVE_INFINITY),
              (this.minY = Number.POSITIVE_INFINITY),
              (this.maxX = Number.NEGATIVE_INFINITY),
              (this.maxY = Number.NEGATIVE_INFINITY));
    }
    aabbCompute() {
        let e = Number.POSITIVE_INFINITY,
            t = Number.POSITIVE_INFINITY,
            n = Number.NEGATIVE_INFINITY,
            i = Number.NEGATIVE_INFINITY,
            r = this.polygons;
        for (let a = 0, o = r.length; a < o; a++) {
            let h = r[a],
                l = h;
            for (let u = 0, c = h.length; u < c; u += 2) {
                let d = l[u],
                    f = l[u + 1];
                (e = Math.min(e, d)),
                    (t = Math.min(t, f)),
                    (n = Math.max(n, d)),
                    (i = Math.max(i, f));
            }
        }
        (this.minX = e), (this.minY = t), (this.maxX = n), (this.maxY = i);
    }
    aabbContainsPoint(e, t) {
        return (
            e >= this.minX && e <= this.maxX && t >= this.minY && t <= this.maxY
        );
    }
    aabbIntersectsSegment(e, t, n, i) {
        let r = this.minX,
            a = this.minY,
            o = this.maxX,
            h = this.maxY;
        if (
            (e <= r && n <= r) ||
            (t <= a && i <= a) ||
            (e >= o && n >= o) ||
            (t >= h && i >= h)
        )
            return !1;
        let l = (i - t) / (n - e),
            u = l * (r - e) + t;
        if ((u > a && u < h) || ((u = l * (o - e) + t), u > a && u < h))
            return !0;
        let c = (a - t) / l + e;
        return (c > r && c < o) || ((c = (h - t) / l + e), c > r && c < o);
    }
    aabbIntersectsSkeleton(e) {
        return (
            this.minX < e.maxX &&
            this.maxX > e.minX &&
            this.minY < e.maxY &&
            this.maxY > e.minY
        );
    }
    containsPoint(e, t) {
        let n = this.polygons;
        for (let i = 0, r = n.length; i < r; i++)
            if (this.containsPointPolygon(n[i], e, t))
                return this.boundingBoxes[i];
        return null;
    }
    containsPointPolygon(e, t, n) {
        let i = e,
            r = e.length,
            a = r - 2,
            o = !1;
        for (let h = 0; h < r; h += 2) {
            let l = i[h + 1],
                u = i[a + 1];
            if ((l < n && u >= n) || (u < n && l >= n)) {
                let c = i[h];
                c + ((n - l) / (u - l)) * (i[a] - c) < t && (o = !o);
            }
            a = h;
        }
        return o;
    }
    intersectsSegment(e, t, n, i) {
        let r = this.polygons;
        for (let a = 0, o = r.length; a < o; a++)
            if (this.intersectsSegmentPolygon(r[a], e, t, n, i))
                return this.boundingBoxes[a];
        return null;
    }
    intersectsSegmentPolygon(e, t, n, i, r) {
        let a = e,
            o = e.length,
            h = t - i,
            l = n - r,
            u = t * r - n * i,
            c = a[o - 2],
            d = a[o - 1];
        for (let f = 0; f < o; f += 2) {
            let p = a[f],
                m = a[f + 1],
                g = c * m - d * p,
                _ = c - p,
                v = d - m,
                b = h * v - l * _,
                y = (u * _ - h * g) / b;
            if (
                ((y >= c && y <= p) || (y >= p && y <= c)) &&
                ((y >= t && y <= i) || (y >= i && y <= t))
            ) {
                let C = (u * v - l * g) / b;
                if (
                    ((C >= d && C <= m) || (C >= m && C <= d)) &&
                    ((C >= n && C <= r) || (C >= r && C <= n))
                )
                    return !0;
            }
            (c = p), (d = m);
        }
        return !1;
    }
    getPolygon(e) {
        if (!e) throw new Error("boundingBox cannot be null.");
        let t = this.boundingBoxes.indexOf(e);
        return t == -1 ? null : this.polygons[t];
    }
    getWidth() {
        return this.maxX - this.minX;
    }
    getHeight() {
        return this.maxY - this.minY;
    }
}
class $n {
    constructor() {
        x(this, "convexPolygons", new Array());
        x(this, "convexPolygonsIndices", new Array());
        x(this, "indicesArray", new Array());
        x(this, "isConcaveArray", new Array());
        x(this, "triangles", new Array());
        x(this, "polygonPool", new zh(() => new Array()));
        x(this, "polygonIndicesPool", new zh(() => new Array()));
    }
    triangulate(e) {
        let t = e,
            n = e.length >> 1,
            i = this.indicesArray;
        i.length = 0;
        for (let o = 0; o < n; o++) i[o] = o;
        let r = this.isConcaveArray;
        r.length = 0;
        for (let o = 0, h = n; o < h; ++o) r[o] = $n.isConcave(o, n, t, i);
        let a = this.triangles;
        for (a.length = 0; n > 3; ) {
            let o = n - 1,
                h = 0,
                l = 1;
            for (;;) {
                e: if (!r[h]) {
                    let d = i[o] << 1,
                        f = i[h] << 1,
                        p = i[l] << 1,
                        m = t[d],
                        g = t[d + 1],
                        _ = t[f],
                        v = t[f + 1],
                        b = t[p],
                        y = t[p + 1];
                    for (let C = (l + 1) % n; C != o; C = (C + 1) % n) {
                        if (!r[C]) continue;
                        let w = i[C] << 1,
                            A = t[w],
                            E = t[w + 1];
                        if (
                            $n.positiveArea(b, y, m, g, A, E) &&
                            $n.positiveArea(m, g, _, v, A, E) &&
                            $n.positiveArea(_, v, b, y, A, E)
                        )
                            break e;
                    }
                    break;
                }
                if (l == 0) {
                    do {
                        if (!r[h]) break;
                        h--;
                    } while (h > 0);
                    break;
                }
                (o = h), (h = l), (l = (l + 1) % n);
            }
            a.push(i[(n + h - 1) % n]),
                a.push(i[h]),
                a.push(i[(h + 1) % n]),
                i.splice(h, 1),
                r.splice(h, 1),
                n--;
            let u = (n + h - 1) % n,
                c = h == n ? 0 : h;
            (r[u] = $n.isConcave(u, n, t, i)),
                (r[c] = $n.isConcave(c, n, t, i));
        }
        return n == 3 && (a.push(i[2]), a.push(i[0]), a.push(i[1])), a;
    }
    decompose(e, t) {
        let n = e,
            i = this.convexPolygons;
        this.polygonPool.freeAll(i), (i.length = 0);
        let r = this.convexPolygonsIndices;
        this.polygonIndicesPool.freeAll(r), (r.length = 0);
        let a = this.polygonIndicesPool.obtain();
        a.length = 0;
        let o = this.polygonPool.obtain();
        o.length = 0;
        let h = -1,
            l = 0;
        for (let u = 0, c = t.length; u < c; u += 3) {
            let d = t[u] << 1,
                f = t[u + 1] << 1,
                p = t[u + 2] << 1,
                m = n[d],
                g = n[d + 1],
                _ = n[f],
                v = n[f + 1],
                b = n[p],
                y = n[p + 1],
                C = !1;
            if (h == d) {
                let w = o.length - 4,
                    A = $n.winding(o[w], o[w + 1], o[w + 2], o[w + 3], b, y),
                    E = $n.winding(b, y, o[0], o[1], o[2], o[3]);
                A == l && E == l && (o.push(b), o.push(y), a.push(p), (C = !0));
            }
            C ||
                (o.length > 0
                    ? (i.push(o), r.push(a))
                    : (this.polygonPool.free(o),
                      this.polygonIndicesPool.free(a)),
                (o = this.polygonPool.obtain()),
                (o.length = 0),
                o.push(m),
                o.push(g),
                o.push(_),
                o.push(v),
                o.push(b),
                o.push(y),
                (a = this.polygonIndicesPool.obtain()),
                (a.length = 0),
                a.push(d),
                a.push(f),
                a.push(p),
                (l = $n.winding(m, g, _, v, b, y)),
                (h = d));
        }
        o.length > 0 && (i.push(o), r.push(a));
        for (let u = 0, c = i.length; u < c; u++) {
            if (((a = r[u]), a.length == 0)) continue;
            let d = a[0],
                f = a[a.length - 1];
            o = i[u];
            let p = o.length - 4,
                m = o[p],
                g = o[p + 1],
                _ = o[p + 2],
                v = o[p + 3],
                b = o[0],
                y = o[1],
                C = o[2],
                w = o[3],
                A = $n.winding(m, g, _, v, b, y);
            for (let E = 0; E < c; E++) {
                if (E == u) continue;
                let S = r[E];
                if (S.length != 3) continue;
                let P = S[0],
                    k = S[1],
                    R = S[2],
                    M = i[E],
                    T = M[M.length - 2],
                    O = M[M.length - 1];
                if (P != d || k != f) continue;
                let L = $n.winding(m, g, _, v, T, O),
                    F = $n.winding(T, O, b, y, C, w);
                L == A &&
                    F == A &&
                    ((M.length = 0),
                    (S.length = 0),
                    o.push(T),
                    o.push(O),
                    a.push(R),
                    (m = _),
                    (g = v),
                    (_ = T),
                    (v = O),
                    (E = 0));
            }
        }
        for (let u = i.length - 1; u >= 0; u--)
            (o = i[u]),
                o.length == 0 &&
                    (i.splice(u, 1),
                    this.polygonPool.free(o),
                    (a = r[u]),
                    r.splice(u, 1),
                    this.polygonIndicesPool.free(a));
        return i;
    }
    static isConcave(e, t, n, i) {
        let r = i[(t + e - 1) % t] << 1,
            a = i[e] << 1,
            o = i[(e + 1) % t] << 1;
        return !this.positiveArea(
            n[r],
            n[r + 1],
            n[a],
            n[a + 1],
            n[o],
            n[o + 1]
        );
    }
    static positiveArea(e, t, n, i, r, a) {
        return e * (a - i) + n * (t - a) + r * (i - t) >= 0;
    }
    static winding(e, t, n, i, r, a) {
        let o = n - e,
            h = i - t;
        return r * h - a * o + o * t - e * h >= 0 ? 1 : -1;
    }
}
class Vu {
    constructor() {
        x(this, "triangulator", new $n());
        x(this, "clippingPolygon", new Array());
        x(this, "clipOutput", new Array());
        x(this, "clippedVertices", new Array());
        x(this, "clippedUVs", new Array());
        x(this, "clippedTriangles", new Array());
        x(this, "scratch", new Array());
        x(this, "clipAttachment", null);
        x(this, "clippingPolygons", null);
    }
    clipStart(e, t) {
        if (this.clipAttachment) return 0;
        this.clipAttachment = t;
        let n = t.worldVerticesLength,
            i = K.setArraySize(this.clippingPolygon, n);
        t.computeWorldVertices(e, 0, n, i, 0, 2);
        let r = this.clippingPolygon;
        Vu.makeClockwise(r);
        let a = (this.clippingPolygons = this.triangulator.decompose(
            r,
            this.triangulator.triangulate(r)
        ));
        for (let o = 0, h = a.length; o < h; o++) {
            let l = a[o];
            Vu.makeClockwise(l), l.push(l[0]), l.push(l[1]);
        }
        return a.length;
    }
    clipEndWithSlot(e) {
        this.clipAttachment &&
            this.clipAttachment.endSlot == e.data &&
            this.clipEnd();
    }
    clipEnd() {
        this.clipAttachment &&
            ((this.clipAttachment = null),
            (this.clippingPolygons = null),
            (this.clippedVertices.length = 0),
            (this.clippedTriangles.length = 0),
            (this.clippingPolygon.length = 0));
    }
    isClipping() {
        return this.clipAttachment != null;
    }
    clipTriangles(e, t, n, i, r, a, o, h) {
        let l, u, c, d, f, p;
        typeof t == "number"
            ? ((l = n), (u = i), (c = r), (d = a), (f = o), (p = h))
            : ((l = t), (u = n), (c = i), (d = r), (f = a), (p = o)),
            c && d && f && typeof p == "boolean"
                ? this.clipTrianglesRender(e, l, u, c, d, f, p)
                : this.clipTrianglesNoRender(e, l, u);
    }
    clipTrianglesNoRender(e, t, n) {
        let i = this.clipOutput,
            r = this.clippedVertices,
            a = this.clippedTriangles,
            o = this.clippingPolygons,
            h = o.length,
            l = 0;
        (r.length = 0), (a.length = 0);
        for (let u = 0; u < n; u += 3) {
            let c = t[u] << 1,
                d = e[c],
                f = e[c + 1];
            c = t[u + 1] << 1;
            let p = e[c],
                m = e[c + 1];
            c = t[u + 2] << 1;
            let g = e[c],
                _ = e[c + 1];
            for (let v = 0; v < h; v++) {
                let b = r.length;
                if (this.clip(d, f, p, m, g, _, o[v], i)) {
                    let y = i.length;
                    if (y == 0) continue;
                    let C = y >> 1,
                        w = this.clipOutput,
                        A = K.setArraySize(r, b + C * 2);
                    for (let S = 0; S < y; S += 2, b += 2) {
                        let P = w[S],
                            k = w[S + 1];
                        (A[b] = P), (A[b + 1] = k);
                    }
                    b = a.length;
                    let E = K.setArraySize(a, b + 3 * (C - 2));
                    C--;
                    for (let S = 1; S < C; S++, b += 3)
                        (E[b] = l), (E[b + 1] = l + S), (E[b + 2] = l + S + 1);
                    l += C + 1;
                } else {
                    let y = K.setArraySize(r, b + 6);
                    (y[b] = d),
                        (y[b + 1] = f),
                        (y[b + 2] = p),
                        (y[b + 3] = m),
                        (y[b + 4] = g),
                        (y[b + 5] = _),
                        (b = a.length);
                    let C = K.setArraySize(a, b + 3);
                    (C[b] = l),
                        (C[b + 1] = l + 1),
                        (C[b + 2] = l + 2),
                        (l += 3);
                    break;
                }
            }
        }
    }
    clipTrianglesRender(e, t, n, i, r, a, o) {
        let h = this.clipOutput,
            l = this.clippedVertices,
            u = this.clippedTriangles,
            c = this.clippingPolygons,
            d = c.length,
            f = o ? 12 : 8,
            p = 0;
        (l.length = 0), (u.length = 0);
        for (let m = 0; m < n; m += 3) {
            let g = t[m] << 1,
                _ = e[g],
                v = e[g + 1],
                b = i[g],
                y = i[g + 1];
            g = t[m + 1] << 1;
            let C = e[g],
                w = e[g + 1],
                A = i[g],
                E = i[g + 1];
            g = t[m + 2] << 1;
            let S = e[g],
                P = e[g + 1],
                k = i[g],
                R = i[g + 1];
            for (let M = 0; M < d; M++) {
                let T = l.length;
                if (this.clip(_, v, C, w, S, P, c[M], h)) {
                    let O = h.length;
                    if (O == 0) continue;
                    let L = w - P,
                        F = S - C,
                        Y = _ - S,
                        V = P - v,
                        W = 1 / (L * Y + F * (v - P)),
                        Z = O >> 1,
                        J = this.clipOutput,
                        G = K.setArraySize(l, T + Z * f);
                    for (let H = 0; H < O; H += 2, T += f) {
                        let pe = J[H],
                            _e = J[H + 1];
                        (G[T] = pe),
                            (G[T + 1] = _e),
                            (G[T + 2] = r.r),
                            (G[T + 3] = r.g),
                            (G[T + 4] = r.b),
                            (G[T + 5] = r.a);
                        let ve = pe - S,
                            re = _e - P,
                            le = (L * ve + F * re) * W,
                            at = (V * ve + Y * re) * W,
                            Ft = 1 - le - at;
                        (G[T + 6] = b * le + A * at + k * Ft),
                            (G[T + 7] = y * le + E * at + R * Ft),
                            o &&
                                ((G[T + 8] = a.r),
                                (G[T + 9] = a.g),
                                (G[T + 10] = a.b),
                                (G[T + 11] = a.a));
                    }
                    T = u.length;
                    let j = K.setArraySize(u, T + 3 * (Z - 2));
                    Z--;
                    for (let H = 1; H < Z; H++, T += 3)
                        (j[T] = p), (j[T + 1] = p + H), (j[T + 2] = p + H + 1);
                    p += Z + 1;
                } else {
                    let O = K.setArraySize(l, T + 3 * f);
                    (O[T] = _),
                        (O[T + 1] = v),
                        (O[T + 2] = r.r),
                        (O[T + 3] = r.g),
                        (O[T + 4] = r.b),
                        (O[T + 5] = r.a),
                        o
                            ? ((O[T + 6] = b),
                              (O[T + 7] = y),
                              (O[T + 8] = a.r),
                              (O[T + 9] = a.g),
                              (O[T + 10] = a.b),
                              (O[T + 11] = a.a),
                              (O[T + 12] = C),
                              (O[T + 13] = w),
                              (O[T + 14] = r.r),
                              (O[T + 15] = r.g),
                              (O[T + 16] = r.b),
                              (O[T + 17] = r.a),
                              (O[T + 18] = A),
                              (O[T + 19] = E),
                              (O[T + 20] = a.r),
                              (O[T + 21] = a.g),
                              (O[T + 22] = a.b),
                              (O[T + 23] = a.a),
                              (O[T + 24] = S),
                              (O[T + 25] = P),
                              (O[T + 26] = r.r),
                              (O[T + 27] = r.g),
                              (O[T + 28] = r.b),
                              (O[T + 29] = r.a),
                              (O[T + 30] = k),
                              (O[T + 31] = R),
                              (O[T + 32] = a.r),
                              (O[T + 33] = a.g),
                              (O[T + 34] = a.b),
                              (O[T + 35] = a.a))
                            : ((O[T + 6] = b),
                              (O[T + 7] = y),
                              (O[T + 8] = C),
                              (O[T + 9] = w),
                              (O[T + 10] = r.r),
                              (O[T + 11] = r.g),
                              (O[T + 12] = r.b),
                              (O[T + 13] = r.a),
                              (O[T + 14] = A),
                              (O[T + 15] = E),
                              (O[T + 16] = S),
                              (O[T + 17] = P),
                              (O[T + 18] = r.r),
                              (O[T + 19] = r.g),
                              (O[T + 20] = r.b),
                              (O[T + 21] = r.a),
                              (O[T + 22] = k),
                              (O[T + 23] = R)),
                        (T = u.length);
                    let L = K.setArraySize(u, T + 3);
                    (L[T] = p),
                        (L[T + 1] = p + 1),
                        (L[T + 2] = p + 2),
                        (p += 3);
                    break;
                }
            }
        }
    }
    clipTrianglesUnpacked(e, t, n, i) {
        let r = this.clipOutput,
            a = this.clippedVertices,
            o = this.clippedUVs,
            h = this.clippedTriangles,
            l = this.clippingPolygons,
            u = l.length,
            c = 0;
        (a.length = 0), (o.length = 0), (h.length = 0);
        for (let d = 0; d < n; d += 3) {
            let f = t[d] << 1,
                p = e[f],
                m = e[f + 1],
                g = i[f],
                _ = i[f + 1];
            f = t[d + 1] << 1;
            let v = e[f],
                b = e[f + 1],
                y = i[f],
                C = i[f + 1];
            f = t[d + 2] << 1;
            let w = e[f],
                A = e[f + 1],
                E = i[f],
                S = i[f + 1];
            for (let P = 0; P < u; P++) {
                let k = a.length;
                if (this.clip(p, m, v, b, w, A, l[P], r)) {
                    let R = r.length;
                    if (R == 0) continue;
                    let M = b - A,
                        T = w - v,
                        O = p - w,
                        L = A - m,
                        F = 1 / (M * O + T * (m - A)),
                        Y = R >> 1,
                        V = this.clipOutput,
                        W = K.setArraySize(a, k + Y * 2),
                        Z = K.setArraySize(o, k + Y * 2);
                    for (let G = 0; G < R; G += 2, k += 2) {
                        let j = V[G],
                            H = V[G + 1];
                        (W[k] = j), (W[k + 1] = H);
                        let pe = j - w,
                            _e = H - A,
                            ve = (M * pe + T * _e) * F,
                            re = (L * pe + O * _e) * F,
                            le = 1 - ve - re;
                        (Z[k] = g * ve + y * re + E * le),
                            (Z[k + 1] = _ * ve + C * re + S * le);
                    }
                    k = h.length;
                    let J = K.setArraySize(h, k + 3 * (Y - 2));
                    Y--;
                    for (let G = 1; G < Y; G++, k += 3)
                        (J[k] = c), (J[k + 1] = c + G), (J[k + 2] = c + G + 1);
                    c += Y + 1;
                } else {
                    let R = K.setArraySize(a, k + 6);
                    (R[k] = p),
                        (R[k + 1] = m),
                        (R[k + 2] = v),
                        (R[k + 3] = b),
                        (R[k + 4] = w),
                        (R[k + 5] = A);
                    let M = K.setArraySize(o, k + 6);
                    (M[k] = g),
                        (M[k + 1] = _),
                        (M[k + 2] = y),
                        (M[k + 3] = C),
                        (M[k + 4] = E),
                        (M[k + 5] = S),
                        (k = h.length);
                    let T = K.setArraySize(h, k + 3);
                    (T[k] = c),
                        (T[k + 1] = c + 1),
                        (T[k + 2] = c + 2),
                        (c += 3);
                    break;
                }
            }
        }
    }
    clip(e, t, n, i, r, a, o, h) {
        let l = h,
            u = !1,
            c;
        o.length % 4 >= 2 ? ((c = h), (h = this.scratch)) : (c = this.scratch),
            (c.length = 0),
            c.push(e),
            c.push(t),
            c.push(n),
            c.push(i),
            c.push(r),
            c.push(a),
            c.push(e),
            c.push(t),
            (h.length = 0);
        let d = o.length - 4,
            f = o;
        for (let p = 0; ; p += 2) {
            let m = f[p],
                g = f[p + 1],
                _ = m - f[p + 2],
                v = g - f[p + 3],
                b = h.length,
                y = c;
            for (let w = 0, A = c.length - 2; w < A; ) {
                let E = y[w],
                    S = y[w + 1];
                w += 2;
                let P = y[w],
                    k = y[w + 1],
                    R = v * (m - P) > _ * (g - k),
                    M = v * (m - E) - _ * (g - S);
                if (M > 0) {
                    if (R) {
                        h.push(P), h.push(k);
                        continue;
                    }
                    let T = P - E,
                        O = k - S,
                        L = M / (T * v - O * _);
                    if (L >= 0 && L <= 1) h.push(E + T * L), h.push(S + O * L);
                    else {
                        h.push(P), h.push(k);
                        continue;
                    }
                } else if (R) {
                    let T = P - E,
                        O = k - S,
                        L = M / (T * v - O * _);
                    if (L >= 0 && L <= 1)
                        h.push(E + T * L),
                            h.push(S + O * L),
                            h.push(P),
                            h.push(k);
                    else {
                        h.push(P), h.push(k);
                        continue;
                    }
                }
                u = !0;
            }
            if (b == h.length) return (l.length = 0), !0;
            if ((h.push(h[0]), h.push(h[1]), p == d)) break;
            let C = h;
            (h = c), (h.length = 0), (c = C);
        }
        if (l != h) {
            l.length = 0;
            for (let p = 0, m = h.length - 2; p < m; p++) l[p] = h[p];
        } else l.length = l.length - 2;
        return u;
    }
    static makeClockwise(e) {
        let t = e,
            n = e.length,
            i = t[n - 2] * t[1] - t[0] * t[n - 1],
            r = 0,
            a = 0,
            o = 0,
            h = 0;
        for (let l = 0, u = n - 3; l < u; l += 2)
            (r = t[l]),
                (a = t[l + 1]),
                (o = t[l + 2]),
                (h = t[l + 3]),
                (i += r * h - o * a);
        if (!(i < 0))
            for (let l = 0, u = n - 2, c = n >> 1; l < c; l += 2) {
                let d = t[l],
                    f = t[l + 1],
                    p = u - l;
                (t[l] = t[p]),
                    (t[l + 1] = t[p + 1]),
                    (t[p] = d),
                    (t[p + 1] = f);
            }
    }
}
class VR {
    constructor(e) {
        x(this, "attachmentLoader");
        x(this, "scale", 1);
        x(this, "linkedMeshes", new Array());
        this.attachmentLoader = e;
    }
    readSkeletonData(e) {
        let t = this.scale,
            n = new Nu(),
            i = typeof e == "string" ? JSON.parse(e) : e,
            r = i.skeleton;
        if (
            (r &&
                ((n.hash = r.hash),
                (n.version = r.spine),
                (n.x = r.x),
                (n.y = r.y),
                (n.width = r.width),
                (n.height = r.height),
                (n.referenceScale = B(r, "referenceScale", 100) * t),
                (n.fps = r.fps),
                (n.imagesPath = r.images ?? null),
                (n.audioPath = r.audio ?? null)),
            i.bones)
        )
            for (let a = 0; a < i.bones.length; a++) {
                let o = i.bones[a],
                    h = null,
                    l = B(o, "parent", null);
                l && (h = n.findBone(l));
                let u = new a2(n.bones.length, o.name, h);
                (u.length = B(o, "length", 0) * t),
                    (u.x = B(o, "x", 0) * t),
                    (u.y = B(o, "y", 0) * t),
                    (u.rotation = B(o, "rotation", 0)),
                    (u.scaleX = B(o, "scaleX", 1)),
                    (u.scaleY = B(o, "scaleY", 1)),
                    (u.shearX = B(o, "shearX", 0)),
                    (u.shearY = B(o, "shearY", 0)),
                    (u.inherit = K.enumValue(bt, B(o, "inherit", "Normal"))),
                    (u.skinRequired = B(o, "skin", !1));
                let c = B(o, "color", null);
                c && u.color.setFromString(c), n.bones.push(u);
            }
        if (i.slots)
            for (let a = 0; a < i.slots.length; a++) {
                let o = i.slots[a],
                    h = o.name,
                    l = n.findBone(o.bone);
                if (!l)
                    throw new Error(
                        `Couldn't find bone ${o.bone} for slot ${h}`
                    );
                let u = new d2(n.slots.length, h, l),
                    c = B(o, "color", null);
                c && u.color.setFromString(c);
                let d = B(o, "dark", null);
                d && (u.darkColor = he.fromString(d)),
                    (u.attachmentName = B(o, "attachment", null)),
                    (u.blendMode = K.enumValue(Lr, B(o, "blend", "normal"))),
                    (u.visible = B(o, "visible", !0)),
                    n.slots.push(u);
            }
        if (i.ik)
            for (let a = 0; a < i.ik.length; a++) {
                let o = i.ik[a],
                    h = new h2(o.name);
                (h.order = B(o, "order", 0)),
                    (h.skinRequired = B(o, "skin", !1));
                for (let u = 0; u < o.bones.length; u++) {
                    let c = n.findBone(o.bones[u]);
                    if (!c)
                        throw new Error(
                            `Couldn't find bone ${o.bones[u]} for IK constraint ${o.name}.`
                        );
                    h.bones.push(c);
                }
                let l = n.findBone(o.target);
                if (!l)
                    throw new Error(
                        `Couldn't find target bone ${o.target} for IK constraint ${o.name}.`
                    );
                (h.target = l),
                    (h.mix = B(o, "mix", 1)),
                    (h.softness = B(o, "softness", 0) * t),
                    (h.bendDirection = B(o, "bendPositive", !0) ? 1 : -1),
                    (h.compress = B(o, "compress", !1)),
                    (h.stretch = B(o, "stretch", !1)),
                    (h.uniform = B(o, "uniform", !1)),
                    n.ikConstraints.push(h);
            }
        if (i.transform)
            for (let a = 0; a < i.transform.length; a++) {
                let o = i.transform[a],
                    h = new f2(o.name);
                (h.order = B(o, "order", 0)),
                    (h.skinRequired = B(o, "skin", !1));
                for (let c = 0; c < o.bones.length; c++) {
                    let d = o.bones[c],
                        f = n.findBone(d);
                    if (!f)
                        throw new Error(
                            `Couldn't find bone ${d} for transform constraint ${o.name}.`
                        );
                    h.bones.push(f);
                }
                let l = o.target,
                    u = n.findBone(l);
                if (!u)
                    throw new Error(
                        `Couldn't find target bone ${l} for transform constraint ${o.name}.`
                    );
                (h.target = u),
                    (h.local = B(o, "local", !1)),
                    (h.relative = B(o, "relative", !1)),
                    (h.offsetRotation = B(o, "rotation", 0)),
                    (h.offsetX = B(o, "x", 0) * t),
                    (h.offsetY = B(o, "y", 0) * t),
                    (h.offsetScaleX = B(o, "scaleX", 0)),
                    (h.offsetScaleY = B(o, "scaleY", 0)),
                    (h.offsetShearY = B(o, "shearY", 0)),
                    (h.mixRotate = B(o, "mixRotate", 1)),
                    (h.mixX = B(o, "mixX", 1)),
                    (h.mixY = B(o, "mixY", h.mixX)),
                    (h.mixScaleX = B(o, "mixScaleX", 1)),
                    (h.mixScaleY = B(o, "mixScaleY", h.mixScaleX)),
                    (h.mixShearY = B(o, "mixShearY", 1)),
                    n.transformConstraints.push(h);
            }
        if (i.path)
            for (let a = 0; a < i.path.length; a++) {
                let o = i.path[a],
                    h = new c2(o.name);
                (h.order = B(o, "order", 0)),
                    (h.skinRequired = B(o, "skin", !1));
                for (let c = 0; c < o.bones.length; c++) {
                    let d = o.bones[c],
                        f = n.findBone(d);
                    if (!f)
                        throw new Error(
                            `Couldn't find bone ${d} for path constraint ${o.name}.`
                        );
                    h.bones.push(f);
                }
                let l = o.target,
                    u = n.findSlot(l);
                if (!u)
                    throw new Error(
                        `Couldn't find target slot ${l} for path constraint ${o.name}.`
                    );
                (h.target = u),
                    (h.positionMode = K.enumValue(
                        Ci,
                        B(o, "positionMode", "Percent")
                    )),
                    (h.spacingMode = K.enumValue(
                        zt,
                        B(o, "spacingMode", "Length")
                    )),
                    (h.rotateMode = K.enumValue(
                        Pa,
                        B(o, "rotateMode", "Tangent")
                    )),
                    (h.offsetRotation = B(o, "rotation", 0)),
                    (h.position = B(o, "position", 0)),
                    h.positionMode == Ci.Fixed && (h.position *= t),
                    (h.spacing = B(o, "spacing", 0)),
                    (h.spacingMode == zt.Length || h.spacingMode == zt.Fixed) &&
                        (h.spacing *= t),
                    (h.mixRotate = B(o, "mixRotate", 1)),
                    (h.mixX = B(o, "mixX", 1)),
                    (h.mixY = B(o, "mixY", h.mixX)),
                    n.pathConstraints.push(h);
            }
        if (i.physics)
            for (let a = 0; a < i.physics.length; a++) {
                const o = i.physics[a],
                    h = new u2(o.name);
                (h.order = B(o, "order", 0)),
                    (h.skinRequired = B(o, "skin", !1));
                const l = o.bone,
                    u = n.findBone(l);
                if (u == null) throw new Error("Physics bone not found: " + l);
                (h.bone = u),
                    (h.x = B(o, "x", 0)),
                    (h.y = B(o, "y", 0)),
                    (h.rotate = B(o, "rotate", 0)),
                    (h.scaleX = B(o, "scaleX", 0)),
                    (h.shearX = B(o, "shearX", 0)),
                    (h.limit = B(o, "limit", 5e3) * t),
                    (h.step = 1 / B(o, "fps", 60)),
                    (h.inertia = B(o, "inertia", 1)),
                    (h.strength = B(o, "strength", 100)),
                    (h.damping = B(o, "damping", 1)),
                    (h.massInverse = 1 / B(o, "mass", 1)),
                    (h.wind = B(o, "wind", 0)),
                    (h.gravity = B(o, "gravity", 0)),
                    (h.mix = B(o, "mix", 1)),
                    (h.inertiaGlobal = B(o, "inertiaGlobal", !1)),
                    (h.strengthGlobal = B(o, "strengthGlobal", !1)),
                    (h.dampingGlobal = B(o, "dampingGlobal", !1)),
                    (h.massGlobal = B(o, "massGlobal", !1)),
                    (h.windGlobal = B(o, "windGlobal", !1)),
                    (h.gravityGlobal = B(o, "gravityGlobal", !1)),
                    (h.mixGlobal = B(o, "mixGlobal", !1)),
                    n.physicsConstraints.push(h);
            }
        if (i.skins)
            for (let a = 0; a < i.skins.length; a++) {
                let o = i.skins[a],
                    h = new Am(o.name);
                if (o.bones)
                    for (let l = 0; l < o.bones.length; l++) {
                        let u = o.bones[l],
                            c = n.findBone(u);
                        if (!c)
                            throw new Error(
                                `Couldn't find bone ${u} for skin ${o.name}.`
                            );
                        h.bones.push(c);
                    }
                if (o.ik)
                    for (let l = 0; l < o.ik.length; l++) {
                        let u = o.ik[l],
                            c = n.findIkConstraint(u);
                        if (!c)
                            throw new Error(
                                `Couldn't find IK constraint ${u} for skin ${o.name}.`
                            );
                        h.constraints.push(c);
                    }
                if (o.transform)
                    for (let l = 0; l < o.transform.length; l++) {
                        let u = o.transform[l],
                            c = n.findTransformConstraint(u);
                        if (!c)
                            throw new Error(
                                `Couldn't find transform constraint ${u} for skin ${o.name}.`
                            );
                        h.constraints.push(c);
                    }
                if (o.path)
                    for (let l = 0; l < o.path.length; l++) {
                        let u = o.path[l],
                            c = n.findPathConstraint(u);
                        if (!c)
                            throw new Error(
                                `Couldn't find path constraint ${u} for skin ${o.name}.`
                            );
                        h.constraints.push(c);
                    }
                if (o.physics)
                    for (let l = 0; l < o.physics.length; l++) {
                        let u = o.physics[l],
                            c = n.findPhysicsConstraint(u);
                        if (!c)
                            throw new Error(
                                `Couldn't find physics constraint ${u} for skin ${o.name}.`
                            );
                        h.constraints.push(c);
                    }
                for (let l in o.attachments) {
                    let u = n.findSlot(l);
                    if (!u)
                        throw new Error(
                            `Couldn't find slot ${l} for skin ${o.name}.`
                        );
                    let c = o.attachments[l];
                    for (let d in c) {
                        let f = this.readAttachment(c[d], h, u.index, d, n);
                        f && h.setAttachment(u.index, d, f);
                    }
                }
                n.skins.push(h), h.name == "default" && (n.defaultSkin = h);
            }
        for (let a = 0, o = this.linkedMeshes.length; a < o; a++) {
            let h = this.linkedMeshes[a],
                l = h.skin ? n.findSkin(h.skin) : n.defaultSkin;
            if (!l) throw new Error(`Skin not found: ${h.skin}`);
            let u = l.getAttachment(h.slotIndex, h.parent);
            if (!u) throw new Error(`Parent mesh not found: ${h.parent}`);
            (h.mesh.timelineAttachment = h.inheritTimeline ? u : h.mesh),
                h.mesh.setParentMesh(u),
                h.mesh.region != null && h.mesh.updateRegion();
        }
        if (((this.linkedMeshes.length = 0), i.events))
            for (let a in i.events) {
                let o = i.events[a],
                    h = new l2(a);
                (h.intValue = B(o, "int", 0)),
                    (h.floatValue = B(o, "float", 0)),
                    (h.stringValue = B(o, "string", "")),
                    (h.audioPath = B(o, "audio", null)),
                    h.audioPath &&
                        ((h.volume = B(o, "volume", 1)),
                        (h.balance = B(o, "balance", 0))),
                    n.events.push(h);
            }
        if (i.animations)
            for (let a in i.animations) {
                let o = i.animations[a];
                this.readAnimation(o, a, n);
            }
        return n;
    }
    readAttachment(e, t, n, i, r) {
        let a = this.scale;
        switch (((i = B(e, "name", i)), B(e, "type", "region"))) {
            case "region": {
                let o = B(e, "path", i),
                    h = this.readSequence(B(e, "sequence", null)),
                    l = this.attachmentLoader.newRegionAttachment(t, i, o, h);
                if (!l) return null;
                (l.path = o),
                    (l.x = B(e, "x", 0) * a),
                    (l.y = B(e, "y", 0) * a),
                    (l.scaleX = B(e, "scaleX", 1)),
                    (l.scaleY = B(e, "scaleY", 1)),
                    (l.rotation = B(e, "rotation", 0)),
                    (l.width = e.width * a),
                    (l.height = e.height * a),
                    (l.sequence = h);
                let u = B(e, "color", null);
                return (
                    u && l.color.setFromString(u),
                    l.region != null && l.updateRegion(),
                    l
                );
            }
            case "boundingbox": {
                let o = this.attachmentLoader.newBoundingBoxAttachment(t, i);
                if (!o) return null;
                this.readVertices(e, o, e.vertexCount << 1);
                let h = B(e, "color", null);
                return h && o.color.setFromString(h), o;
            }
            case "mesh":
            case "linkedmesh": {
                let o = B(e, "path", i),
                    h = this.readSequence(B(e, "sequence", null)),
                    l = this.attachmentLoader.newMeshAttachment(t, i, o, h);
                if (!l) return null;
                l.path = o;
                let u = B(e, "color", null);
                u && l.color.setFromString(u),
                    (l.width = B(e, "width", 0) * a),
                    (l.height = B(e, "height", 0) * a),
                    (l.sequence = h);
                let c = B(e, "parent", null);
                if (c)
                    return (
                        this.linkedMeshes.push(
                            new UR(
                                l,
                                B(e, "skin", null),
                                n,
                                c,
                                B(e, "timelines", !0)
                            )
                        ),
                        l
                    );
                let d = e.uvs;
                return (
                    this.readVertices(e, l, d.length),
                    (l.triangles = e.triangles),
                    (l.regionUVs = d),
                    l.region != null && l.updateRegion(),
                    (l.edges = B(e, "edges", null)),
                    (l.hullLength = B(e, "hull", 0) * 2),
                    l
                );
            }
            case "path": {
                let o = this.attachmentLoader.newPathAttachment(t, i);
                if (!o) return null;
                (o.closed = B(e, "closed", !1)),
                    (o.constantSpeed = B(e, "constantSpeed", !0));
                let h = e.vertexCount;
                this.readVertices(e, o, h << 1);
                let l = K.newArray(h / 3, 0);
                for (let c = 0; c < e.lengths.length; c++)
                    l[c] = e.lengths[c] * a;
                o.lengths = l;
                let u = B(e, "color", null);
                return u && o.color.setFromString(u), o;
            }
            case "point": {
                let o = this.attachmentLoader.newPointAttachment(t, i);
                if (!o) return null;
                (o.x = B(e, "x", 0) * a),
                    (o.y = B(e, "y", 0) * a),
                    (o.rotation = B(e, "rotation", 0));
                let h = B(e, "color", null);
                return h && o.color.setFromString(h), o;
            }
            case "clipping": {
                let o = this.attachmentLoader.newClippingAttachment(t, i);
                if (!o) return null;
                let h = B(e, "end", null);
                h && (o.endSlot = r.findSlot(h));
                let l = e.vertexCount;
                this.readVertices(e, o, l << 1);
                let u = B(e, "color", null);
                return u && o.color.setFromString(u), o;
            }
        }
        return null;
    }
    readSequence(e) {
        if (e == null) return null;
        let t = new Bu(B(e, "count", 0));
        return (
            (t.start = B(e, "start", 1)),
            (t.digits = B(e, "digits", 0)),
            (t.setupIndex = B(e, "setup", 0)),
            t
        );
    }
    readVertices(e, t, n) {
        let i = this.scale;
        t.worldVerticesLength = n;
        let r = e.vertices;
        if (n == r.length) {
            let h = K.toFloatArray(r);
            if (i != 1) for (let l = 0, u = r.length; l < u; l++) h[l] *= i;
            t.vertices = h;
            return;
        }
        let a = new Array(),
            o = new Array();
        for (let h = 0, l = r.length; h < l; ) {
            let u = r[h++];
            o.push(u);
            for (let c = h + u * 4; h < c; h += 4)
                o.push(r[h]),
                    a.push(r[h + 1] * i),
                    a.push(r[h + 2] * i),
                    a.push(r[h + 3]);
        }
        (t.bones = o), (t.vertices = K.toFloatArray(a));
    }
    readAnimation(e, t, n) {
        let i = this.scale,
            r = new Array();
        if (e.slots)
            for (let o in e.slots) {
                let h = e.slots[o],
                    l = n.findSlot(o);
                if (!l) throw new Error("Slot not found: " + o);
                let u = l.index;
                for (let c in h) {
                    let d = h[c];
                    if (!d) continue;
                    let f = d.length;
                    if (c == "attachment") {
                        let p = new xo(f, u);
                        for (let m = 0; m < f; m++) {
                            let g = d[m];
                            p.setFrame(m, B(g, "time", 0), B(g, "name", null));
                        }
                        r.push(p);
                    } else if (c == "rgba") {
                        let p = new UC(f, f << 2, u),
                            m = d[0],
                            g = B(m, "time", 0),
                            _ = he.fromString(m.color);
                        for (let v = 0, b = 0; ; v++) {
                            p.setFrame(v, g, _.r, _.g, _.b, _.a);
                            let y = d[v + 1];
                            if (!y) {
                                p.shrink(b);
                                break;
                            }
                            let C = B(y, "time", 0),
                                w = he.fromString(y.color),
                                A = m.curve;
                            A &&
                                ((b = Ee(A, p, b, v, 0, g, C, _.r, w.r, 1)),
                                (b = Ee(A, p, b, v, 1, g, C, _.g, w.g, 1)),
                                (b = Ee(A, p, b, v, 2, g, C, _.b, w.b, 1)),
                                (b = Ee(A, p, b, v, 3, g, C, _.a, w.a, 1))),
                                (g = C),
                                (_ = w),
                                (m = y);
                        }
                        r.push(p);
                    } else if (c == "rgb") {
                        let p = new zC(f, f * 3, u),
                            m = d[0],
                            g = B(m, "time", 0),
                            _ = he.fromString(m.color);
                        for (let v = 0, b = 0; ; v++) {
                            p.setFrame(v, g, _.r, _.g, _.b);
                            let y = d[v + 1];
                            if (!y) {
                                p.shrink(b);
                                break;
                            }
                            let C = B(y, "time", 0),
                                w = he.fromString(y.color),
                                A = m.curve;
                            A &&
                                ((b = Ee(A, p, b, v, 0, g, C, _.r, w.r, 1)),
                                (b = Ee(A, p, b, v, 1, g, C, _.g, w.g, 1)),
                                (b = Ee(A, p, b, v, 2, g, C, _.b, w.b, 1))),
                                (g = C),
                                (_ = w),
                                (m = y);
                        }
                        r.push(p);
                    } else if (c == "alpha")
                        r.push(Ds(d, new YC(f, f, u), 0, 1));
                    else if (c == "rgba2") {
                        let p = new GC(f, f * 7, u),
                            m = d[0],
                            g = B(m, "time", 0),
                            _ = he.fromString(m.light),
                            v = he.fromString(m.dark);
                        for (let b = 0, y = 0; ; b++) {
                            p.setFrame(b, g, _.r, _.g, _.b, _.a, v.r, v.g, v.b);
                            let C = d[b + 1];
                            if (!C) {
                                p.shrink(y);
                                break;
                            }
                            let w = B(C, "time", 0),
                                A = he.fromString(C.light),
                                E = he.fromString(C.dark),
                                S = m.curve;
                            S &&
                                ((y = Ee(S, p, y, b, 0, g, w, _.r, A.r, 1)),
                                (y = Ee(S, p, y, b, 1, g, w, _.g, A.g, 1)),
                                (y = Ee(S, p, y, b, 2, g, w, _.b, A.b, 1)),
                                (y = Ee(S, p, y, b, 3, g, w, _.a, A.a, 1)),
                                (y = Ee(S, p, y, b, 4, g, w, v.r, E.r, 1)),
                                (y = Ee(S, p, y, b, 5, g, w, v.g, E.g, 1)),
                                (y = Ee(S, p, y, b, 6, g, w, v.b, E.b, 1))),
                                (g = w),
                                (_ = A),
                                (v = E),
                                (m = C);
                        }
                        r.push(p);
                    } else if (c == "rgb2") {
                        let p = new jC(f, f * 6, u),
                            m = d[0],
                            g = B(m, "time", 0),
                            _ = he.fromString(m.light),
                            v = he.fromString(m.dark);
                        for (let b = 0, y = 0; ; b++) {
                            p.setFrame(b, g, _.r, _.g, _.b, v.r, v.g, v.b);
                            let C = d[b + 1];
                            if (!C) {
                                p.shrink(y);
                                break;
                            }
                            let w = B(C, "time", 0),
                                A = he.fromString(C.light),
                                E = he.fromString(C.dark),
                                S = m.curve;
                            S &&
                                ((y = Ee(S, p, y, b, 0, g, w, _.r, A.r, 1)),
                                (y = Ee(S, p, y, b, 1, g, w, _.g, A.g, 1)),
                                (y = Ee(S, p, y, b, 2, g, w, _.b, A.b, 1)),
                                (y = Ee(S, p, y, b, 3, g, w, v.r, E.r, 1)),
                                (y = Ee(S, p, y, b, 4, g, w, v.g, E.g, 1)),
                                (y = Ee(S, p, y, b, 5, g, w, v.b, E.b, 1))),
                                (g = w),
                                (_ = A),
                                (v = E),
                                (m = C);
                        }
                        r.push(p);
                    }
                }
            }
        if (e.bones)
            for (let o in e.bones) {
                let h = e.bones[o],
                    l = n.findBone(o);
                if (!l) throw new Error("Bone not found: " + o);
                let u = l.index;
                for (let c in h) {
                    let d = h[c],
                        f = d.length;
                    if (f != 0) {
                        if (c === "rotate")
                            r.push(Ds(d, new Fu(f, f, u), 0, 1));
                        else if (c === "translate") {
                            let p = new IC(f, f << 1, u);
                            r.push(tp(d, p, "x", "y", 0, i));
                        } else if (c === "translatex") {
                            let p = new RC(f, f, u);
                            r.push(Ds(d, p, 0, i));
                        } else if (c === "translatey") {
                            let p = new LC(f, f, u);
                            r.push(Ds(d, p, 0, i));
                        } else if (c === "scale") {
                            let p = new OC(f, f << 1, u);
                            r.push(tp(d, p, "x", "y", 1, 1));
                        } else if (c === "scalex") {
                            let p = new BC(f, f, u);
                            r.push(Ds(d, p, 1, 1));
                        } else if (c === "scaley") {
                            let p = new FC(f, f, u);
                            r.push(Ds(d, p, 1, 1));
                        } else if (c === "shear") {
                            let p = new $C(f, f << 1, u);
                            r.push(tp(d, p, "x", "y", 0, 1));
                        } else if (c === "shearx") {
                            let p = new DC(f, f, u);
                            r.push(Ds(d, p, 0, 1));
                        } else if (c === "sheary") {
                            let p = new NC(f, f, u);
                            r.push(Ds(d, p, 0, 1));
                        } else if (c === "inherit") {
                            let p = new VC(f, l.index);
                            for (let m = 0; m < d.length; m++) {
                                let g = d[m];
                                p.setFrame(
                                    m,
                                    B(g, "time", 0),
                                    K.enumValue(bt, B(g, "inherit", "Normal"))
                                );
                            }
                            r.push(p);
                        }
                    }
                }
            }
        if (e.ik)
            for (let o in e.ik) {
                let h = e.ik[o],
                    l = h[0];
                if (!l) continue;
                let u = n.findIkConstraint(o);
                if (!u) throw new Error("IK Constraint not found: " + o);
                let c = n.ikConstraints.indexOf(u),
                    d = new XC(h.length, h.length << 1, c),
                    f = B(l, "time", 0),
                    p = B(l, "mix", 1),
                    m = B(l, "softness", 0) * i;
                for (let g = 0, _ = 0; ; g++) {
                    d.setFrame(
                        g,
                        f,
                        p,
                        m,
                        B(l, "bendPositive", !0) ? 1 : -1,
                        B(l, "compress", !1),
                        B(l, "stretch", !1)
                    );
                    let v = h[g + 1];
                    if (!v) {
                        d.shrink(_);
                        break;
                    }
                    let b = B(v, "time", 0),
                        y = B(v, "mix", 1),
                        C = B(v, "softness", 0) * i,
                        w = l.curve;
                    w &&
                        ((_ = Ee(w, d, _, g, 0, f, b, p, y, 1)),
                        (_ = Ee(w, d, _, g, 1, f, b, m, C, i))),
                        (f = b),
                        (p = y),
                        (m = C),
                        (l = v);
                }
                r.push(d);
            }
        if (e.transform)
            for (let o in e.transform) {
                let h = e.transform[o],
                    l = h[0];
                if (!l) continue;
                let u = n.findTransformConstraint(o);
                if (!u) throw new Error("Transform constraint not found: " + o);
                let c = n.transformConstraints.indexOf(u),
                    d = new qC(h.length, h.length * 6, c),
                    f = B(l, "time", 0),
                    p = B(l, "mixRotate", 1),
                    m = B(l, "mixX", 1),
                    g = B(l, "mixY", m),
                    _ = B(l, "mixScaleX", 1),
                    v = B(l, "mixScaleY", _),
                    b = B(l, "mixShearY", 1);
                for (let y = 0, C = 0; ; y++) {
                    d.setFrame(y, f, p, m, g, _, v, b);
                    let w = h[y + 1];
                    if (!w) {
                        d.shrink(C);
                        break;
                    }
                    let A = B(w, "time", 0),
                        E = B(w, "mixRotate", 1),
                        S = B(w, "mixX", 1),
                        P = B(w, "mixY", S),
                        k = B(w, "mixScaleX", 1),
                        R = B(w, "mixScaleY", k),
                        M = B(w, "mixShearY", 1),
                        T = l.curve;
                    T &&
                        ((C = Ee(T, d, C, y, 0, f, A, p, E, 1)),
                        (C = Ee(T, d, C, y, 1, f, A, m, S, 1)),
                        (C = Ee(T, d, C, y, 2, f, A, g, P, 1)),
                        (C = Ee(T, d, C, y, 3, f, A, _, k, 1)),
                        (C = Ee(T, d, C, y, 4, f, A, v, R, 1)),
                        (C = Ee(T, d, C, y, 5, f, A, b, M, 1))),
                        (f = A),
                        (p = E),
                        (m = S),
                        (g = P),
                        (_ = k),
                        (v = R),
                        (_ = k),
                        (l = w);
                }
                r.push(d);
            }
        if (e.path)
            for (let o in e.path) {
                let h = e.path[o],
                    l = n.findPathConstraint(o);
                if (!l) throw new Error("Path constraint not found: " + o);
                let u = n.pathConstraints.indexOf(l);
                for (let c in h) {
                    let d = h[c],
                        f = d[0];
                    if (!f) continue;
                    let p = d.length;
                    if (c === "position") {
                        let m = new HC(p, p, u);
                        r.push(Ds(d, m, 0, l.positionMode == Ci.Fixed ? i : 1));
                    } else if (c === "spacing") {
                        let m = new KC(p, p, u);
                        r.push(
                            Ds(
                                d,
                                m,
                                0,
                                l.spacingMode == zt.Length ||
                                    l.spacingMode == zt.Fixed
                                    ? i
                                    : 1
                            )
                        );
                    } else if (c === "mix") {
                        let m = new ZC(p, p * 3, u),
                            g = B(f, "time", 0),
                            _ = B(f, "mixRotate", 1),
                            v = B(f, "mixX", 1),
                            b = B(f, "mixY", v);
                        for (let y = 0, C = 0; ; y++) {
                            m.setFrame(y, g, _, v, b);
                            let w = d[y + 1];
                            if (!w) {
                                m.shrink(C);
                                break;
                            }
                            let A = B(w, "time", 0),
                                E = B(w, "mixRotate", 1),
                                S = B(w, "mixX", 1),
                                P = B(w, "mixY", S),
                                k = f.curve;
                            k &&
                                ((C = Ee(k, m, C, y, 0, g, A, _, E, 1)),
                                (C = Ee(k, m, C, y, 1, g, A, v, S, 1)),
                                (C = Ee(k, m, C, y, 2, g, A, b, P, 1))),
                                (g = A),
                                (_ = E),
                                (v = S),
                                (b = P),
                                (f = w);
                        }
                        r.push(m);
                    }
                }
            }
        if (e.physics)
            for (let o in e.physics) {
                let h = e.physics[o],
                    l = -1;
                if (o.length > 0) {
                    let u = n.findPhysicsConstraint(o);
                    if (!u)
                        throw new Error("Physics constraint not found: " + o);
                    l = n.physicsConstraints.indexOf(u);
                }
                for (let u in h) {
                    let c = h[u],
                        d = c[0];
                    if (!d) continue;
                    let f = c.length;
                    if (u == "reset") {
                        const m = new $u(f, l);
                        for (let g = 0; d != null; d = c[g + 1], g++)
                            m.setFrame(g, B(d, "time", 0));
                        r.push(m);
                        continue;
                    }
                    let p;
                    if (u == "inertia") p = new QC(f, f, l);
                    else if (u == "strength") p = new JC(f, f, l);
                    else if (u == "damping") p = new e2(f, f, l);
                    else if (u == "mass") p = new t2(f, f, l);
                    else if (u == "wind") p = new n2(f, f, l);
                    else if (u == "gravity") p = new s2(f, f, l);
                    else if (u == "mix") p = new i2(f, f, l);
                    else continue;
                    r.push(Ds(c, p, 0, 1));
                }
            }
        if (e.attachments)
            for (let o in e.attachments) {
                let h = e.attachments[o],
                    l = n.findSkin(o);
                if (!l) throw new Error("Skin not found: " + o);
                for (let u in h) {
                    let c = h[u],
                        d = n.findSlot(u);
                    if (!d) throw new Error("Slot not found: " + u);
                    let f = d.index;
                    for (let p in c) {
                        let m = c[p],
                            g = l.getAttachment(f, p);
                        for (let _ in m) {
                            let v = m[_],
                                b = v[0];
                            if (b) {
                                if (_ == "deform") {
                                    let y = g.bones,
                                        C = g.vertices,
                                        w = y ? (C.length / 3) * 2 : C.length,
                                        A = new WC(v.length, v.length, f, g),
                                        E = B(b, "time", 0);
                                    for (let S = 0, P = 0; ; S++) {
                                        let k,
                                            R = B(b, "vertices", null);
                                        if (!R) k = y ? K.newFloatArray(w) : C;
                                        else {
                                            k = K.newFloatArray(w);
                                            let L = B(b, "offset", 0);
                                            if (
                                                (K.arrayCopy(
                                                    R,
                                                    0,
                                                    k,
                                                    L,
                                                    R.length
                                                ),
                                                i != 1)
                                            )
                                                for (
                                                    let F = L, Y = F + R.length;
                                                    F < Y;
                                                    F++
                                                )
                                                    k[F] *= i;
                                            if (!y)
                                                for (let F = 0; F < w; F++)
                                                    k[F] += C[F];
                                        }
                                        A.setFrame(S, E, k);
                                        let M = v[S + 1];
                                        if (!M) {
                                            A.shrink(P);
                                            break;
                                        }
                                        let T = B(M, "time", 0),
                                            O = b.curve;
                                        O &&
                                            (P = Ee(
                                                O,
                                                A,
                                                P,
                                                S,
                                                0,
                                                E,
                                                T,
                                                0,
                                                1,
                                                1
                                            )),
                                            (E = T),
                                            (b = M);
                                    }
                                    r.push(A);
                                } else if (_ == "sequence") {
                                    let y = new Du(v.length, f, g),
                                        C = 0;
                                    for (let w = 0; w < v.length; w++) {
                                        let A = B(b, "delay", C),
                                            E = B(b, "time", 0),
                                            S = sn[B(b, "mode", "hold")],
                                            P = B(b, "index", 0);
                                        y.setFrame(w, E, S, P, A),
                                            (C = A),
                                            (b = v[w + 1]);
                                    }
                                    r.push(y);
                                }
                            }
                        }
                    }
                }
            }
        if (e.drawOrder) {
            let o = new Sa(e.drawOrder.length),
                h = n.slots.length,
                l = 0;
            for (let u = 0; u < e.drawOrder.length; u++, l++) {
                let c = e.drawOrder[u],
                    d = null,
                    f = B(c, "offsets", null);
                if (f) {
                    d = K.newArray(h, -1);
                    let p = K.newArray(h - f.length, 0),
                        m = 0,
                        g = 0;
                    for (let _ = 0; _ < f.length; _++) {
                        let v = f[_],
                            b = n.findSlot(v.slot);
                        if (!b) throw new Error("Slot not found: " + b);
                        let y = b.index;
                        for (; m != y; ) p[g++] = m++;
                        d[m + v.offset] = m++;
                    }
                    for (; m < h; ) p[g++] = m++;
                    for (let _ = h - 1; _ >= 0; _--)
                        d[_] == -1 && (d[_] = p[--g]);
                }
                o.setFrame(l, B(c, "time", 0), d);
            }
            r.push(o);
        }
        if (e.events) {
            let o = new Yh(e.events.length),
                h = 0;
            for (let l = 0; l < e.events.length; l++, h++) {
                let u = e.events[l],
                    c = n.findEvent(u.name);
                if (!c) throw new Error("Event not found: " + u.name);
                let d = new o2(K.toSinglePrecision(B(u, "time", 0)), c);
                (d.intValue = B(u, "int", c.intValue)),
                    (d.floatValue = B(u, "float", c.floatValue)),
                    (d.stringValue = B(u, "string", c.stringValue)),
                    d.data.audioPath &&
                        ((d.volume = B(u, "volume", 1)),
                        (d.balance = B(u, "balance", 0))),
                    o.setFrame(h, d);
            }
            r.push(o);
        }
        let a = 0;
        for (let o = 0, h = r.length; o < h; o++)
            a = Math.max(a, r[o].getDuration());
        n.animations.push(new zg(t, r, a));
    }
}
class UR {
    constructor(e, t, n, i, r) {
        x(this, "parent");
        x(this, "skin");
        x(this, "slotIndex");
        x(this, "mesh");
        x(this, "inheritTimeline");
        (this.mesh = e),
            (this.skin = t),
            (this.slotIndex = n),
            (this.parent = i),
            (this.inheritTimeline = r);
    }
}
function Ds(s, e, t, n) {
    let i = s[0],
        r = B(i, "time", 0),
        a = B(i, "value", t) * n,
        o = 0;
    for (let h = 0; ; h++) {
        e.setFrame(h, r, a);
        let l = s[h + 1];
        if (!l) return e.shrink(o), e;
        let u = B(l, "time", 0),
            c = B(l, "value", t) * n;
        i.curve && (o = Ee(i.curve, e, o, h, 0, r, u, a, c, n)),
            (r = u),
            (a = c),
            (i = l);
    }
}
function tp(s, e, t, n, i, r) {
    let a = s[0],
        o = B(a, "time", 0),
        h = B(a, t, i) * r,
        l = B(a, n, i) * r,
        u = 0;
    for (let c = 0; ; c++) {
        e.setFrame(c, o, h, l);
        let d = s[c + 1];
        if (!d) return e.shrink(u), e;
        let f = B(d, "time", 0),
            p = B(d, t, i) * r,
            m = B(d, n, i) * r,
            g = a.curve;
        g &&
            ((u = Ee(g, e, u, c, 0, o, f, h, p, r)),
            (u = Ee(g, e, u, c, 1, o, f, l, m, r))),
            (o = f),
            (h = p),
            (l = m),
            (a = d);
    }
}
function Ee(s, e, t, n, i, r, a, o, h, l) {
    if (s == "stepped") return e.setStepped(n), t;
    let u = i << 2,
        c = s[u],
        d = s[u + 1] * l,
        f = s[u + 2],
        p = s[u + 3] * l;
    return e.setBezier(t, n, i, r, o, c, d, f, p, a, h), t + 1;
}
function B(s, e, t) {
    return s[e] !== void 0 ? s[e] : t;
}
typeof Math.fround > "u" &&
    (Math.fround = (function (s) {
        return function (e) {
            return (s[0] = e), s[0];
        };
    })(new Float32Array(1)));
const Vs = class Vs extends HI {
    constructor(t) {
        super(t.resource);
        x(this, "texture");
        this.texture = we.from(t);
    }
    static from(t) {
        return Vs.textureMap.has(t) ? Vs.textureMap.get(t) : new Vs(t);
    }
    setFilters(t, n) {
        const i = this.texture.source.style;
        (i.minFilter = Vs.toPixiTextureFilter(t)),
            (i.magFilter = Vs.toPixiTextureFilter(n)),
            (this.texture.source.autoGenerateMipmaps = Vs.toPixiMipMap(t)),
            this.texture.source.updateMipmaps();
    }
    setWraps(t, n) {
        const i = this.texture.source.style;
        (i.addressModeU = Vs.toPixiTextureWrap(t)),
            (i.addressModeV = Vs.toPixiTextureWrap(n));
    }
    dispose() {
        this.texture.destroy();
    }
    static toPixiMipMap(t) {
        switch (t) {
            case jt.Nearest:
            case jt.Linear:
                return !1;
            case jt.MipMapNearestLinear:
            case jt.MipMapNearestNearest:
            case jt.MipMapLinearLinear:
            case jt.MipMapLinearNearest:
                return !0;
            default:
                throw new Error(`Unknown texture filter: ${String(t)}`);
        }
    }
    static toPixiTextureFilter(t) {
        switch (t) {
            case jt.Nearest:
            case jt.MipMapNearestLinear:
            case jt.MipMapNearestNearest:
                return "nearest";
            case jt.Linear:
            case jt.MipMapLinearLinear:
            case jt.MipMapLinearNearest:
                return "linear";
            default:
                throw new Error(`Unknown texture filter: ${String(t)}`);
        }
    }
    static toPixiTextureWrap(t) {
        switch (t) {
            case Ji.ClampToEdge:
                return "clamp-to-edge";
            case Ji.MirroredRepeat:
                return "mirror-repeat";
            case Ji.Repeat:
                return "repeat";
            default:
                throw new Error(`Unknown texture wrap: ${String(t)}`);
        }
    }
    static toPixiBlending(t) {
        switch (t) {
            case Lr.Normal:
                return "normal";
            case Lr.Additive:
                return "add";
            case Lr.Multiply:
                return "multiply";
            case Lr.Screen:
                return "screen";
            default:
                throw new Error(`Unknown blendMode: ${String(t)}`);
        }
    }
};
x(Vs, "textureMap", new Map());
let Uu = Vs;
const $l = "spineTextureAtlasLoader",
    zR = {
        extension: ee.Asset,
        resolver: {
            test: (s) => Is(s, ".atlas"),
            parse: (s) => {
                var t, n;
                const e = s.split(".");
                return {
                    resolution: parseFloat(
                        ((n =
                            (t = Ha.RETINA_PREFIX) == null
                                ? void 0
                                : t.exec(s)) == null
                            ? void 0
                            : n[1]) ?? "1"
                    ),
                    format: e[e.length - 2],
                    src: s,
                };
            },
        },
        loader: {
            id: $l,
            name: $l,
            extension: { type: ee.LoadParser, priority: Ii.Normal, name: $l },
            test(s) {
                return Is(s, ".atlas");
            },
            async load(s) {
                return await (await rt.get().fetch(s)).text();
            },
            testParse(s, e) {
                const t = Is(e.src, ".atlas"),
                    n = typeof s == "string",
                    i = e.parser === $l || e.loadParser === $l;
                return Promise.resolve((t || i) && n);
            },
            unload(s) {
                s.dispose();
            },
            async parse(s, e, t) {
                const n = e.data || {};
                let i = on.dirname(e.src);
                i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
                const r = new ZI(s);
                if (n.images instanceof cs || typeof n.images == "string") {
                    const o = n.images;
                    (n.images = {}), (n.images[r.pages[0].name] = o);
                }
                const a = [];
                for (const o of r.pages) {
                    const h = o.name,
                        l = n != null && n.images ? n.images[h] : void 0;
                    if (l instanceof cs) o.setTexture(Uu.from(l));
                    else {
                        const u =
                                l ??
                                on.normalize(
                                    [...i.split(on.sep), h].join(on.sep)
                                ),
                            c = {
                                src: Iu(u, e.src),
                                data: {
                                    ...n.imageMetadata,
                                    alphaMode: o.pma
                                        ? "premultiplied-alpha"
                                        : "premultiply-alpha-on-upload",
                                },
                            },
                            d = t.load(c).then((f) => {
                                o.setTexture(Uu.from(f.source));
                            });
                        a.push(d);
                    }
                }
                return await Promise.all(a), r;
            },
        },
    };
Ot.add(zR);
const Dl = "spineSkeletonLoader";
function YR(s) {
    return Object.prototype.hasOwnProperty.call(s, "bones");
}
function GR(s) {
    return s instanceof Uint8Array;
}
const jR = {
    extension: ee.Asset,
    loader: {
        id: Dl,
        name: Dl,
        extension: { type: ee.LoadParser, priority: Ii.Normal, name: Dl },
        test(s) {
            return Is(s, ".skel");
        },
        async load(s) {
            const e = await rt.get().fetch(s);
            return new Uint8Array(await e.arrayBuffer());
        },
        testParse(s, e) {
            const t = Is(e.src, ".json") && YR(s),
                n = Is(e.src, ".skel") && GR(s),
                i = e.parser === Dl || e.loadParser === Dl;
            return Promise.resolve(t || n || i);
        },
    },
};
Ot.add(jR);
const WR = new Float32Array(1),
    XR = new Uint32Array(1);
class qR extends jx {
    constructor() {
        const t = new $a({
                data: WR,
                label: "attribute-batch-buffer",
                usage: qt.VERTEX | qt.COPY_DST,
                shrinkToFit: !1,
            }),
            n = new $a({
                data: XR,
                label: "index-batch-buffer",
                usage: qt.INDEX | qt.COPY_DST,
                shrinkToFit: !1,
            }),
            i = 28;
        super({
            attributes: {
                aPosition: {
                    buffer: t,
                    format: "float32x2",
                    stride: i,
                    offset: 0,
                },
                aUV: { buffer: t, format: "float32x2", stride: i, offset: 8 },
                aColor: {
                    buffer: t,
                    format: "unorm8x4",
                    stride: i,
                    offset: 16,
                },
                aDarkColor: {
                    buffer: t,
                    format: "unorm8x4",
                    stride: i,
                    offset: 20,
                },
                aTextureIdAndRound: {
                    buffer: t,
                    format: "uint16x2",
                    stride: i,
                    offset: 24,
                },
            },
            indexBuffer: n,
        });
    }
}
const HR = {
        name: "color-bit",
        vertex: {
            header: `
            @in aDarkColor: vec4<f32>;
            @out vDarkColor: vec4<f32>;
        `,
            main: `
        vDarkColor = aDarkColor;
        `,
        },
        fragment: {
            header: `
            @in vDarkColor: vec4<f32>;
        `,
            end: `

        let alpha = outColor.a * vColor.a;
        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;

        finalColor = vec4<f32>(rgb, alpha);

        `,
        },
    },
    KR = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aDarkColor;
            out vec4 vDarkColor;
        `,
            main: `
            vDarkColor = aDarkColor;
        `,
        },
        fragment: {
            header: `
            in vec4 vDarkColor;
        `,
            end: `

        finalColor.a = outColor.a * vColor.a;
        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;
        `,
        },
    };
class ZR extends uc {
    constructor(e) {
        const t = Hx({ name: "dark-tint-batch", bits: [Zx, KR, Jx(e), tC] }),
            n = qx({ name: "dark-tint-batch", bits: [Kx, HR, Qx(e), eC] });
        super({
            glProgram: t,
            gpuProgram: n,
            resources: { batchSamplers: nC(e) },
        });
    }
}
let cb = null;
const od = class od extends Yx {
    constructor() {
        super(...arguments);
        x(this, "geometry", new qR());
        x(this, "shader", cb || (cb = new ZR(this.maxTextures)));
        x(this, "name", od.extension.name);
        x(this, "vertexSize", 7);
    }
    packAttributes(t, n, i, r, a) {
        const o = (a << 16) | (t.roundPixels & 65535),
            h = t.transform,
            l = h.a,
            u = h.b,
            c = h.c,
            d = h.d,
            f = h.tx,
            p = h.ty,
            { positions: m, uvs: g } = t,
            _ = t.color,
            v = ((_ >> 24) & 255) / 255,
            b = Vt.shared
                .setValue(t.darkColor)
                .premultiply(v, !0)
                .toPremultiplied(1, !1),
            y = t.attributeOffset,
            C = y + t.attributeSize;
        for (let w = y; w < C; w++) {
            const A = w * 2,
                E = m[A],
                S = m[A + 1];
            (n[r++] = l * E + c * S + f),
                (n[r++] = d * S + u * E + p),
                (n[r++] = g[A]),
                (n[r++] = g[A + 1]),
                (i[r++] = _),
                (i[r++] = b),
                (i[r++] = o);
        }
    }
    packQuadAttributes(t, n, i, r, a) {
        const o = t.texture,
            h = t.transform,
            l = h.a,
            u = h.b,
            c = h.c,
            d = h.d,
            f = h.tx,
            p = h.ty,
            m = t.bounds,
            g = m.maxX,
            _ = m.minX,
            v = m.maxY,
            b = m.minY,
            y = o.uvs,
            C = t.color,
            w = t.darkColor,
            A = (a << 16) | (t.roundPixels & 65535);
        (n[r + 0] = l * _ + c * b + f),
            (n[r + 1] = d * b + u * _ + p),
            (n[r + 2] = y.x0),
            (n[r + 3] = y.y0),
            (i[r + 4] = C),
            (i[r + 5] = w),
            (i[r + 6] = A),
            (n[r + 7] = l * g + c * b + f),
            (n[r + 8] = d * b + u * g + p),
            (n[r + 9] = y.x1),
            (n[r + 10] = y.y1),
            (i[r + 11] = C),
            (i[r + 12] = w),
            (i[r + 13] = A),
            (n[r + 14] = l * g + c * v + f),
            (n[r + 15] = d * v + u * g + p),
            (n[r + 16] = y.x2),
            (n[r + 17] = y.y2),
            (i[r + 18] = C),
            (i[r + 19] = w),
            (i[r + 20] = A),
            (n[r + 21] = l * _ + c * v + f),
            (n[r + 22] = d * v + u * _ + p),
            (n[r + 23] = y.x3),
            (n[r + 24] = y.y3),
            (i[r + 25] = C),
            (i[r + 26] = w),
            (i[r + 27] = A);
    }
};
x(od, "extension", { type: [ee.Batcher], name: "darkTint" });
let Sm = od;
Ot.add(Sm);
class QR {
    constructor() {
        x(this, "indexOffset", 0);
        x(this, "attributeOffset", 0);
        x(this, "indexSize");
        x(this, "attributeSize");
        x(this, "batcherName", "darkTint");
        x(this, "topology", "triangle-list");
        x(this, "packAsQuad", !1);
        x(this, "renderable");
        x(this, "positions");
        x(this, "indices");
        x(this, "uvs");
        x(this, "roundPixels");
        x(this, "data");
        x(this, "blendMode");
        x(this, "darkTint");
        x(this, "texture");
        x(this, "transform");
        x(this, "_textureId");
        x(this, "_attributeStart");
        x(this, "_indexStart");
        x(this, "_batcher");
        x(this, "_batch");
    }
    get color() {
        const e = this.data.color,
            t = this.renderable.groupColor,
            n = this.renderable.groupAlpha;
        let i;
        const r = e.a * n * 255;
        if (t !== 16777215) {
            const a = (t >> 16) & 255,
                o = (t >> 8) & 255,
                h = t & 255,
                l = e.r * h,
                u = e.g * o,
                c = e.b * a;
            i = (r << 24) | (c << 16) | (u << 8) | l;
        } else
            i =
                (r << 24) |
                ((e.b * 255) << 16) |
                ((e.g * 255) << 8) |
                (e.r * 255);
        return i;
    }
    get darkColor() {
        const e = this.data.darkColor;
        return ((e.b * 255) << 16) | ((e.g * 255) << 8) | (e.r * 255);
    }
    get groupTransform() {
        return this.renderable.groupTransform;
    }
    setData(e, t, n, i) {
        if (
            ((this.renderable = e),
            (this.transform = e.groupTransform),
            (this.data = t),
            t.clipped)
        ) {
            const r = t.clippedData;
            (this.indexSize = r.indicesCount),
                (this.attributeSize = r.vertexCount),
                (this.positions = r.vertices),
                (this.indices = r.indices),
                (this.uvs = r.uvs);
        } else
            (this.indexSize = t.indices.length),
                (this.attributeSize = t.vertices.length / 2),
                (this.positions = t.vertices),
                (this.indices = t.indices),
                (this.uvs = t.uvs);
        (this.texture = t.texture),
            (this.roundPixels = i),
            (this.blendMode = n),
            (this.batcherName = t.darkTint ? "darkTint" : "default");
    }
}
const JR = { 0: "normal", 1: "add", 2: "multiply", 3: "screen" };
class p2 {
    constructor(e) {
        x(this, "renderer");
        x(this, "gpuSpineData", {});
        x(this, "_destroyRenderableBound", this.destroyRenderable.bind(this));
        this.renderer = e;
    }
    validateRenderable(e) {
        if ((e._validateAndTransformAttachments(), e.spineAttachmentsDirty))
            return !0;
        if (e.spineTexturesDirty) {
            const t = e.skeleton.drawOrder,
                n = this.gpuSpineData[e.uid];
            for (let i = 0, r = t.length; i < r; i++) {
                const a = t[i],
                    o = a.getAttachment();
                if (o instanceof Gs || o instanceof Xs) {
                    const h = e._getCachedData(a, o),
                        l = n.slotBatches[h.id],
                        u = h.texture;
                    if (
                        u !== l.texture &&
                        !l._batcher.checkAndUpdateTexture(l, u)
                    )
                        return !0;
                }
            }
        }
        return !1;
    }
    addRenderable(e, t) {
        var o, h;
        const n = this._getSpineData(e),
            i = this.renderer.renderPipes.batch,
            r = e.skeleton.drawOrder,
            a = this.renderer._roundPixels | e._roundPixels;
        e._validateAndTransformAttachments(),
            (e.spineAttachmentsDirty = !1),
            (e.spineTexturesDirty = !1);
        for (let l = 0, u = r.length; l < u; l++) {
            const c = r[l],
                d = c.getAttachment(),
                f = JR[c.data.blendMode];
            if (d instanceof Gs || d instanceof Xs) {
                const m = e._getCachedData(c, d),
                    g = (o = n.slotBatches)[(h = m.id)] || (o[h] = new QR());
                g.setData(e, m, f, a), m.skipRender || i.addToBatch(g, t);
            }
            const p = e._slotsObject[c.data.name];
            if (p) {
                const m = p.container;
                (m.includeInBuild = !0),
                    zI(m, t, this.renderer),
                    (m.includeInBuild = !1);
            }
        }
    }
    updateRenderable(e) {
        var i;
        const t = this.gpuSpineData[e.uid];
        e._validateAndTransformAttachments(),
            (e.spineAttachmentsDirty = !1),
            (e.spineTexturesDirty = !1);
        const n = e.skeleton.drawOrder;
        for (let r = 0, a = n.length; r < a; r++) {
            const o = n[r],
                h = o.getAttachment();
            if (
                (h instanceof Gs || h instanceof Xs) &&
                !e._getCachedData(o, h).skipRender
            ) {
                const u = t.slotBatches[e._getCachedData(o, h).id];
                (i = u._batcher) == null || i.updateElement(u);
            }
        }
    }
    destroyRenderable(e) {
        (this.gpuSpineData[e.uid] = null),
            e.off("destroyed", this._destroyRenderableBound);
    }
    destroy() {
        (this.gpuSpineData = null), (this.renderer = null);
    }
    _getSpineData(e) {
        return this.gpuSpineData[e.uid] || this._initMeshData(e);
    }
    _initMeshData(e) {
        return (
            (this.gpuSpineData[e.uid] = { slotBatches: {} }),
            e.on("destroyed", this._destroyRenderableBound),
            this.gpuSpineData[e.uid]
        );
    }
}
x(p2, "extension", {
    type: [ee.WebGLPipes, ee.WebGPUPipes, ee.CanvasPipes],
    name: "spine",
});
Ot.add(p2);
const Yc = new Ou();
Gh.yDown = !0;
const oo = new Vu(),
    ub = new zh(() => new rl());
class jr extends Cd {
    constructor(t) {
        t instanceof Nu && (t = { skeletonData: t });
        super({});
        x(this, "batched", !0);
        x(this, "buildId", 0);
        x(this, "renderPipeId", "spine");
        x(this, "_didSpineUpdate", !1);
        x(this, "beforeUpdateWorldTransforms", () => {});
        x(this, "afterUpdateWorldTransforms", () => {});
        x(this, "skeleton");
        x(this, "state");
        x(this, "skeletonBounds");
        x(this, "darkTint", !1);
        x(this, "_debug");
        x(this, "_slotsObject", Object.create(null));
        x(this, "clippingSlotToPixiMasks", Object.create(null));
        x(this, "spineAttachmentsDirty", !0);
        x(this, "spineTexturesDirty", !0);
        x(this, "_lastAttachments", []);
        x(this, "_stateChanged", !0);
        x(this, "attachmentCacheData", []);
        x(this, "_autoUpdate", !1);
        x(this, "_boundsProvider");
        x(this, "hasNeverUpdated", !0);
        x(this, "currentClippingSlot");
        this.allowChildren = !0;
        const n = t instanceof Nu ? t : t.skeletonData;
        (this.skeleton = new Gh(n)),
            (this.state = new xm(new qI(n))),
            (this.autoUpdate = (t == null ? void 0 : t.autoUpdate) ?? !0),
            (this.darkTint =
                (t == null ? void 0 : t.darkTint) === void 0
                    ? this.skeleton.slots.some((r) => !!r.data.darkColor)
                    : t == null
                    ? void 0
                    : t.darkTint);
        const i = this.skeleton.slots;
        for (let r = 0; r < i.length; r++)
            this.attachmentCacheData[r] = Object.create(null);
        this._boundsProvider = t.boundsProvider;
    }
    getSlotFromRef(t) {
        let n;
        if (
            (typeof t == "number"
                ? (n = this.skeleton.slots[t])
                : typeof t == "string"
                ? (n = this.skeleton.findSlot(t))
                : (n = t),
            !n)
        )
            throw new Error(
                `No slot found with the given slot reference: ${t}`
            );
        return n;
    }
    get debug() {
        return this._debug;
    }
    set debug(t) {
        this._debug && this._debug.unregisterSpine(this),
            t && t.registerSpine(this),
            (this._debug = t);
    }
    get autoUpdate() {
        return this._autoUpdate;
    }
    set autoUpdate(t) {
        t && !this._autoUpdate
            ? Ir.shared.add(this.internalUpdate, this)
            : !t &&
              this._autoUpdate &&
              Ir.shared.remove(this.internalUpdate, this),
            (this._autoUpdate = t);
    }
    get boundsProvider() {
        return this._boundsProvider;
    }
    set boundsProvider(t) {
        (this._boundsProvider = t),
            t && (this._boundsDirty = !1),
            this.updateBounds();
    }
    update(t) {
        this.internalUpdate(0, t);
    }
    internalUpdate(t, n) {
        this._updateAndApplyState(n ?? Ir.shared.deltaMS / 1e3);
    }
    get bounds() {
        return this._boundsDirty && this.updateBounds(), this._bounds;
    }
    setBonePosition(t, n) {
        const i = t;
        if ((typeof t == "string" && (t = this.skeleton.findBone(t)), !t))
            throw Error(`Cant set bone position, bone ${String(i)} not found`);
        if ((Yc.set(n.x, n.y), t.parent)) {
            const r = t.parent.worldToLocal(Yc);
            (t.x = r.x), (t.y = -r.y);
        } else (t.x = Yc.x), (t.y = Yc.y);
    }
    getBonePosition(t, n) {
        const i = t;
        return (
            typeof t == "string" && (t = this.skeleton.findBone(t)),
            t
                ? (n || (n = { x: 0, y: 0 }),
                  (n.x = t.worldX),
                  (n.y = t.worldY),
                  n)
                : (console.error(
                      `Cant set bone position! Bone ${String(i)} not found`
                  ),
                  n)
        );
    }
    _updateAndApplyState(t) {
        (this.hasNeverUpdated = !1),
            this.state.update(t),
            this.skeleton.update(t);
        const { skeleton: n } = this;
        this.state.apply(n),
            this.beforeUpdateWorldTransforms(this),
            n.updateWorldTransform(xr.update),
            this.afterUpdateWorldTransforms(this),
            this.updateSlotObjects(),
            (this._stateChanged = !0),
            this.onViewUpdate();
    }
    _validateAndTransformAttachments() {
        this._stateChanged &&
            ((this._stateChanged = !1),
            this.validateAttachments(),
            this.transformAttachments());
    }
    validateAttachments() {
        const t = this.skeleton.drawOrder,
            n = this._lastAttachments;
        let i = 0,
            r = !1;
        for (let a = 0; a < t.length; a++) {
            const h = t[a].getAttachment();
            h && (h !== n[i] && ((r = !0), (n[i] = h)), i++);
        }
        i !== n.length && ((r = !0), (n.length = i)),
            this.spineAttachmentsDirty || (this.spineAttachmentsDirty = r);
    }
    updateAndSetPixiMask(t, n) {
        var o, h;
        const i = t.attachment;
        if (i && i instanceof Ea) {
            const l =
                (o = this.clippingSlotToPixiMasks)[(h = t.data.name)] ||
                (o[h] = { slot: t, vertices: new Array() });
            (l.maskComputed = !1), (this.currentClippingSlot = l);
            return;
        }
        let r = this.currentClippingSlot,
            a = this._slotsObject[t.data.name];
        if (r && a) {
            let l = r.mask;
            if (
                (l || ((l = ub.obtain()), (r.mask = l), this.addChild(l)),
                !r.maskComputed)
            ) {
                let u = r.slot,
                    c = u.attachment;
                r.maskComputed = !0;
                const d = c.worldVerticesLength,
                    f = r.vertices;
                c.computeWorldVertices(u, 0, d, f, 0, 2),
                    l
                        .clear()
                        .poly(f)
                        .stroke({ width: 0 })
                        .fill({ alpha: 0.25 });
            }
            a.container.mask = l;
        } else a != null && a.container.mask && (a.container.mask = null);
        if (
            (r &&
                r.slot.attachment.endSlot == t.data &&
                (this.currentClippingSlot = void 0),
            n)
        ) {
            for (const l in this.clippingSlotToPixiMasks) {
                const u = this.clippingSlotToPixiMasks[l];
                (!(u.slot.attachment instanceof Ea) || !u.maskComputed) &&
                    u.mask &&
                    (this.removeChild(u.mask),
                    ub.free(u.mask),
                    (u.mask = void 0));
            }
            this.currentClippingSlot = void 0;
        }
    }
    transformAttachments() {
        var n;
        const t = this.skeleton.drawOrder;
        for (let i = 0; i < t.length; i++) {
            const r = t[i];
            this.updateAndSetPixiMask(r, i === t.length - 1);
            const a = r.getAttachment();
            if (a) {
                if (a instanceof Xs || a instanceof Gs) {
                    const o = this._getCachedData(r, a);
                    a instanceof Gs
                        ? a.computeWorldVertices(r, o.vertices, 0, 2)
                        : a.computeWorldVertices(
                              r,
                              0,
                              a.worldVerticesLength,
                              o.vertices,
                              0,
                              2
                          ),
                        o.uvs.length < a.uvs.length &&
                            (o.uvs = new Float32Array(a.uvs.length)),
                        mm(a.uvs.buffer, o.uvs.buffer);
                    const l = r.bone.skeleton.color,
                        u = r.color,
                        c = a.color;
                    o.color.set(
                        l.r * u.r * c.r,
                        l.g * u.g * c.g,
                        l.b * u.b * c.b,
                        l.a * u.a * c.a
                    ),
                        r.darkColor && o.darkColor.setFromColor(r.darkColor),
                        (o.skipRender = o.clipped = !1);
                    const d =
                        ((n = a.region) == null ? void 0 : n.texture.texture) ||
                        we.EMPTY;
                    o.texture !== d &&
                        ((o.texture = d), (this.spineTexturesDirty = !0)),
                        oo.isClipping() && this.updateClippingData(o);
                } else if (a instanceof Ea) {
                    oo.clipStart(r, a);
                    continue;
                }
            }
            oo.clipEndWithSlot(r);
        }
        oo.clipEnd();
    }
    updateClippingData(t) {
        (t.clipped = !0),
            oo.clipTrianglesUnpacked(
                t.vertices,
                t.indices,
                t.indices.length,
                t.uvs
            );
        const { clippedVertices: n, clippedUVs: i, clippedTriangles: r } = oo,
            a = n.length / 2,
            o = r.length;
        t.clippedData ||
            ((t.clippedData = {
                vertices: new Float32Array(a * 2),
                uvs: new Float32Array(a * 2),
                vertexCount: a,
                indices: new Uint16Array(o),
                indicesCount: o,
            }),
            (this.spineAttachmentsDirty = !0));
        const h = t.clippedData,
            l = h.vertexCount !== a || o !== h.indicesCount;
        (t.skipRender = a === 0),
            l &&
                ((this.spineAttachmentsDirty = !0),
                h.vertexCount < a &&
                    ((h.vertices = new Float32Array(a * 2)),
                    (h.uvs = new Float32Array(a * 2))),
                h.indices.length < o && (h.indices = new Uint16Array(o)));
        const { vertices: u, uvs: c, indices: d } = h;
        for (let f = 0; f < a; f++)
            (u[f * 2] = n[f * 2]),
                (u[f * 2 + 1] = n[f * 2 + 1]),
                (c[f * 2] = i[f * 2]),
                (c[f * 2 + 1] = i[f * 2 + 1]);
        h.vertexCount = a;
        for (let f = 0; f < o; f++)
            d[f] !== r[f] && ((this.spineAttachmentsDirty = !0), (d[f] = r[f]));
        h.indicesCount = o;
    }
    updateSlotObjects() {
        for (const t in this._slotsObject) {
            const n = this._slotsObject[t];
            n && this.updateSlotObject(n);
        }
    }
    updateSlotObject(t) {
        const { slot: n, container: i } = t,
            r = t.followAttachmentTimeline ? !!n.attachment : !0;
        if (
            ((i.visible = this.skeleton.drawOrder.includes(n) && r), i.visible)
        ) {
            let a = n.bone;
            i.position.set(a.worldX, a.worldY),
                (i.angle = a.getWorldRotationX());
            let o = 1,
                h = 1;
            for (; a; ) (o *= a.scaleX), (h *= a.scaleY), (a = a.parent);
            o < 0 && (i.angle -= 180),
                i.scale.set(
                    n.bone.getWorldScaleX() * Math.sign(o),
                    n.bone.getWorldScaleY() * Math.sign(h)
                ),
                (i.alpha = this.skeleton.color.a * n.color.a);
        }
    }
    _getCachedData(t, n) {
        return (
            this.attachmentCacheData[t.data.index][n.name] ||
            this.initCachedData(t, n)
        );
    }
    initCachedData(t, n) {
        var r, a;
        let i;
        return (
            n instanceof Gs
                ? ((i = new Float32Array(8)),
                  (this.attachmentCacheData[t.data.index][n.name] = {
                      id: `${t.data.index}-${n.name}`,
                      vertices: i,
                      clipped: !1,
                      indices: [0, 1, 2, 0, 2, 3],
                      uvs: new Float32Array(n.uvs.length),
                      color: new he(1, 1, 1, 1),
                      darkColor: new he(0, 0, 0, 0),
                      darkTint: this.darkTint,
                      skipRender: !1,
                      texture:
                          (r = n.region) == null ? void 0 : r.texture.texture,
                  }))
                : ((i = new Float32Array(n.worldVerticesLength)),
                  (this.attachmentCacheData[t.data.index][n.name] = {
                      id: `${t.data.index}-${n.name}`,
                      vertices: i,
                      clipped: !1,
                      indices: n.triangles,
                      uvs: new Float32Array(n.uvs.length),
                      color: new he(1, 1, 1, 1),
                      darkColor: new he(0, 0, 0, 0),
                      darkTint: this.darkTint,
                      skipRender: !1,
                      texture:
                          (a = n.region) == null ? void 0 : a.texture.texture,
                  })),
            this.attachmentCacheData[t.data.index][n.name]
        );
    }
    onViewUpdate() {
        var n;
        if (
            (this._didViewChangeTick++,
            this._boundsProvider || (this._boundsDirty = !0),
            this.didViewUpdate)
        )
            return;
        this.didViewUpdate = !0;
        const t = this.renderGroup || this.parentRenderGroup;
        t && t.onChildViewUpdate(this),
            (n = this.debug) == null || n.renderDebug(this);
    }
    addSlotObject(t, n, i) {
        var a;
        t = this.getSlotFromRef(t);
        for (const o in this._slotsObject)
            ((a = this._slotsObject[o]) == null ? void 0 : a.container) === n &&
                this.removeSlotObject(this._slotsObject[o].slot);
        this.removeSlotObject(t), (n.includeInBuild = !1), this.addChild(n);
        const r = {
            container: n,
            slot: t,
            followAttachmentTimeline:
                (i == null ? void 0 : i.followAttachmentTimeline) || !1,
        };
        (this._slotsObject[t.data.name] = r), this.updateSlotObject(r);
    }
    removeSlotObject(t) {
        var i, r;
        let n;
        if (t instanceof hn) {
            for (const a in this._slotsObject)
                if (
                    ((i = this._slotsObject[a]) == null
                        ? void 0
                        : i.container) === t
                ) {
                    (this._slotsObject[a] = null), (n = t);
                    break;
                }
        } else {
            const a = this.getSlotFromRef(t);
            (n =
                (r = this._slotsObject[a.data.name]) == null
                    ? void 0
                    : r.container),
                (this._slotsObject[a.data.name] = null);
        }
        n && (this.removeChild(n), (n.includeInBuild = !0));
    }
    removeSlotObjects() {
        Object.entries(this._slotsObject).forEach(([t, n]) => {
            n && n.container.removeFromParent(), delete this._slotsObject[t];
        });
    }
    getSlotObject(t) {
        var n;
        return (
            (t = this.getSlotFromRef(t)),
            (n = this._slotsObject[t.data.name]) == null ? void 0 : n.container
        );
    }
    updateBounds() {
        (this._boundsDirty = !1),
            this.skeletonBounds || (this.skeletonBounds = new NR());
        const t = this.skeletonBounds;
        if ((t.update(this.skeleton, !0), this._boundsProvider)) {
            const n = this._boundsProvider.calculateBounds(this),
                i = this._bounds;
            i.clear(),
                (i.x = n.x),
                (i.y = n.y),
                (i.width = n.width),
                (i.height = n.height);
        } else if (t.minX === 1 / 0) {
            this.hasNeverUpdated &&
                (this._updateAndApplyState(0), (this._boundsDirty = !1)),
                this._validateAndTransformAttachments();
            const n = this.skeleton.drawOrder,
                i = this._bounds;
            i.clear();
            for (let r = 0; r < n.length; r++) {
                const a = n[r],
                    o = a.getAttachment();
                if (o && (o instanceof Gs || o instanceof Xs)) {
                    const h = this._getCachedData(a, o);
                    i.addVertexData(h.vertices, 0, h.vertices.length);
                }
            }
        } else
            (this._bounds.minX = t.minX),
                (this._bounds.minY = t.minY),
                (this._bounds.maxX = t.maxX),
                (this._bounds.maxY = t.maxY);
    }
    addBounds(t) {
        t.addBounds(this.bounds);
    }
    destroy(t = !1) {
        super.destroy(t),
            Ir.shared.remove(this.internalUpdate, this),
            this.state.clearListeners(),
            (this.debug = void 0),
            (this.skeleton = null),
            (this.state = null),
            (this._slotsObject = null),
            (this._lastAttachments.length = 0),
            (this.attachmentCacheData = null);
    }
    skeletonToPixiWorldCoordinates(t) {
        this.worldTransform.apply(t, t);
    }
    pixiWorldCoordinatesToSkeleton(t) {
        this.worldTransform.applyInverse(t, t);
    }
    pixiWorldCoordinatesToBone(t, n) {
        this.pixiWorldCoordinatesToSkeleton(t),
            n.parent ? n.parent.worldToLocal(t) : n.worldToLocal(t);
    }
    static from({
        skeleton: t,
        atlas: n,
        scale: i = 1,
        darkTint: r,
        autoUpdate: a = !0,
        boundsProvider: o,
    }) {
        const h = `${t}-${n}-${i}`;
        if (et.has(h))
            return new jr({
                skeletonData: et.get(h),
                darkTint: r,
                autoUpdate: a,
                boundsProvider: o,
            });
        const l = Xi.get(t),
            u = Xi.get(n),
            c = new eR(u),
            d = l instanceof Uint8Array ? new rR(c) : new VR(c);
        d.scale = i;
        const f = d.readSkeletonData(l);
        return (
            et.set(h, f),
            new jr({
                skeletonData: f,
                darkTint: r,
                autoUpdate: a,
                boundsProvider: o,
            })
        );
    }
}
var m2 = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,
    g2 = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}`,
    eL = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uBackground;

void main(void){
    vec4 front = texture(uTexture, vTextureCoord);
    vec4 back = texture(uBackground, vTextureCoord);

    if (front.a == 0.0) {
        discard;
    }

    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);

    finalColor = vec4(color, 1.0);
}`,
    tL = `@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var uBackground: texture_2d<f32>;

@fragment
fn mainFragment(
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);
    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);

    if (front.a == 0.0) {
        discard;
    }

    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);

    return vec4<f32>(color, 1.0);
}`,
    nL = Object.defineProperty,
    sL = (s, e, t) =>
        e in s
            ? nL(s, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: t,
              })
            : (s[e] = t),
    iL = (s, e, t) => (sL(s, e + "", t), t);
class rL extends AC {
    constructor(e) {
        super(e),
            iL(this, "_blendPass"),
            (this.blendRequired = !0),
            (this.padding = 0),
            (this._blendPass = new Sd({
                gpuProgram: Hr.from({
                    vertex: { source: g2, entryPoint: "mainVertex" },
                    fragment: { source: tL, entryPoint: "mainFragment" },
                }),
                glProgram: vl.from({
                    vertex: m2,
                    fragment: eL,
                    name: "drop-shadow-filter",
                }),
                resources: { uBackground: we.EMPTY },
            }));
    }
    apply(e, t, n, i) {
        const r = e._activeFilterData.backTexture,
            a = Gr.getSameSizeTexture(t);
        super.apply(e, r, a, !0),
            (this._blendPass.resources.uBackground = a.source),
            this._blendPass.apply(e, t, n, i),
            Gr.returnTexture(a);
    }
    updatePadding() {
        this.padding = 0;
    }
}
var aL = `precision highp float;
in vec2 vTextureCoord;
out vec4 finalColor;

uniform sampler2D uTexture;
uniform vec2 uVelocity;
uniform int uKernelSize;
uniform float uOffset;

uniform vec4 uInputSize;

const int MAX_KERNEL_SIZE = 2048;

// Notice:
// the perfect way:
//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);
// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.
// So use uKernelSize directly.

void main(void)
{
    vec4 color = texture(uTexture, vTextureCoord);

    if (uKernelSize == 0)
    {
        finalColor = color;
        return;
    }

    vec2 velocity = uVelocity / uInputSize.xy;
    float offset = -uOffset / length(uVelocity) - 0.5;
    int k = uKernelSize - 1;

    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {
        if (i == k) {
            break;
        }
        vec2 bias = velocity * (float(i) / float(k) + offset);
        color += texture(uTexture, vTextureCoord + bias);
    }
    finalColor = color / float(uKernelSize);
}
`,
    oL = `struct MotionBlurUniforms {
  uVelocity: vec2<f32>,
  uKernelSize: i32,
  uOffset: f32,
};

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;

@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler: sampler;
@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  @location(0) uv : vec2<f32>
) -> @location(0) vec4<f32> {
  let uVelocity = motionBlurUniforms.uVelocity;
  let uKernelSize = motionBlurUniforms.uKernelSize;
  let uOffset = motionBlurUniforms.uOffset;

  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;
  let offset: f32 = -uOffset / length(uVelocity) - 0.5;
  let k: i32 = min(uKernelSize - 1, MAX_KERNEL_SIZE - 1);

  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);

  for(var i: i32 = 0; i < k; i += 1) {
    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);
    color += textureSample(uTexture, uSampler, uv + bias);
  }

  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);
}

const MAX_KERNEL_SIZE: i32 = 2048;`,
    lL = Object.defineProperty,
    hL = (s, e, t) =>
        e in s
            ? lL(s, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: t,
              })
            : (s[e] = t),
    Em = (s, e, t) => (hL(s, typeof e != "symbol" ? e + "" : e, t), t);
const _2 = class v2 extends Sd {
    constructor(...e) {
        let t = e[0] ?? {};
        if (Array.isArray(t) || ("x" in t && "y" in t) || t instanceof Wt) {
            ae(
                "6.0.0",
                "MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }"
            );
            const r = "x" in t ? t.x : t[0],
                a = "y" in t ? t.y : t[1];
            (t = { velocity: { x: r, y: a } }),
                e[1] !== void 0 && (t.kernelSize = e[1]),
                e[2] !== void 0 && (t.offset = e[2]);
        }
        t = { ...v2.DEFAULT_OPTIONS, ...t };
        const n = Hr.from({
                vertex: { source: g2, entryPoint: "mainVertex" },
                fragment: { source: oL, entryPoint: "mainFragment" },
            }),
            i = vl.from({
                vertex: m2,
                fragment: aL,
                name: "motion-blur-filter",
            });
        super({
            gpuProgram: n,
            glProgram: i,
            resources: {
                motionBlurUniforms: {
                    uVelocity: { value: t.velocity, type: "vec2<f32>" },
                    uKernelSize: {
                        value: Math.trunc(t.kernelSize ?? 5),
                        type: "i32",
                    },
                    uOffset: { value: t.offset, type: "f32" },
                },
            },
        }),
            Em(this, "uniforms"),
            Em(this, "_kernelSize"),
            (this.uniforms = this.resources.motionBlurUniforms.uniforms),
            Object.assign(this, t);
    }
    get velocity() {
        return this.uniforms.uVelocity;
    }
    set velocity(e) {
        Array.isArray(e) && (e = { x: e[0], y: e[1] }),
            (this.uniforms.uVelocity = e),
            this._updateDirty();
    }
    get velocityX() {
        return this.velocity.x;
    }
    set velocityX(e) {
        (this.velocity.x = e), this._updateDirty();
    }
    get velocityY() {
        return this.velocity.y;
    }
    set velocityY(e) {
        (this.velocity.y = e), this._updateDirty();
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(e) {
        (this._kernelSize = e), this._updateDirty();
    }
    get offset() {
        return this.uniforms.uOffset;
    }
    set offset(e) {
        this.uniforms.uOffset = e;
    }
    _updateDirty() {
        (this.padding =
            (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >>
                0) +
            1),
            (this.uniforms.uKernelSize =
                this.velocityX !== 0 || this.velocityY !== 0
                    ? this._kernelSize
                    : 0);
    }
};
Em(_2, "DEFAULT_OPTIONS", {
    velocity: { x: 0, y: 0 },
    kernelSize: 5,
    offset: 0,
});
let cL = _2;
class uL {
    constructor() {
        x(this, "container");
        x(this, "anticipationContainer", new hn());
        x(this, "backgroundSpine");
        x(this, "screensSpine");
        x(this, "blurFilter");
        x(this, "backDropBlurRectangle");
        x(this, "continueSprite");
        x(this, "payoutText");
        x(this, "currentPayout", 0);
        x(this, "displayPayout", 0);
        (this.container = new hn()),
            (this.backgroundSpine = jr.from({
                skeleton: "backgroundData",
                atlas: "masterAtlas",
            })),
            (this.backgroundSpine.label = "background"),
            this.container.addChild(this.backgroundSpine),
            this.backgroundSpine.state.setAnimation(0, "idle", !0),
            this.backgroundSpine.state.setAnimation(1, "ghosts", !0),
            this.anticipationContainer.addChild(this.container),
            (this.screensSpine = jr.from({
                skeleton: "screensData",
                atlas: "masterAtlas",
            })),
            (this.screensSpine.scale = 0.87),
            this.container.addChild(this.screensSpine),
            jg.attach(this.screensSpine),
            (this.continueSprite = sl.from("continue")),
            (this.continueSprite.anchor = 0.5),
            (this.continueSprite.zIndex = 1),
            (this.continueSprite.alpha = 0),
            go(this.continueSprite),
            (this.payoutText = new SC({
                text: "",
                style: { fontFamily: "md_white_wide", fontSize: 50 },
            })),
            (this.payoutText.anchor.x = 0.5),
            (this.payoutText.anchor.y = 0.5),
            kh(() => {
                var e;
                return Fw(
                    (e = this.backgroundSpine) == null ? void 0 : e.label,
                    "slot_win",
                    this.payoutText
                );
            }, 40),
            (this.blurFilter = new rL({ strength: 4 })),
            (this.backDropBlurRectangle = new rl()
                .rect(-2800, -2300, 6e3, 6e3)
                .fill({ color: rP, alpha: 0.75 })),
            (this.backDropBlurRectangle.filters = [this.blurFilter]),
            this.screensSpine.addSlotObject("fade", this.backDropBlurRectangle),
            (this.backgroundSpine.afterUpdateWorldTransforms = () => {
                this.backgroundSpine._slotsObject &&
                    Object.entries(this.backgroundSpine._slotsObject).forEach(
                        ([e, t]) => {
                            t != null &&
                                t.container &&
                                t != null &&
                                t.slot &&
                                (t.container.alpha = t.slot.attachment
                                    ? t.slot.color.a
                                    : 0);
                        }
                    );
            });
    }
    async playBonusEnter(e) {
        De.next({ type: "bonusIntro", scenario: "fromBase" }),
            this.screensSpine.state.setAnimation(0, "bonus_intro"),
            (this.screensSpine.interactive = !0),
            (this.screensSpine.cursor = "pointer"),
            this.playContinue(),
            await new Promise((n) => {
                C0(async () => {
                    Je.killTweensOf(this.continueSprite),
                        Je.to(this.continueSprite, {
                            alpha: 0,
                            duration: 0.25,
                        }),
                        De.next({ type: "bonusOutro", scenario: "toBonus" }),
                        this.screensSpine.state.setAnimation(0, "bonus_outro"),
                        this.screensSpine.state.addEmptyAnimation(0),
                        (this.screensSpine.interactive = !1),
                        n();
                }, 999999999);
            });
    }
    async playBonusExit(e) {
        De.next({ type: "bonusIntro", scenario: "fromBonus" }),
            (this.backgroundSpine.interactive = !0),
            (this.backgroundSpine.cursor = "pointer"),
            this.playContinue(),
            await new Promise((n) => {
                C0(async () => {
                    Je.killTweensOf(this.continueSprite),
                        Je.to(this.continueSprite, {
                            alpha: 0,
                            duration: 0.25,
                        }),
                        De.next({ type: "bonusOutro", scenario: "toBase" }),
                        (this.backgroundSpine.interactive = !1),
                        await Le(500),
                        n();
                }, 999999999);
            });
    }
    playShake() {}
    updatePayoutText(e) {
        const t = Q(Ra) * e;
        this.displayPayout,
            (this.currentPayout = t),
            this.currentPayout === 0
                ? (this.payoutText.text = "")
                : Je.to(this, {
                      displayPayout: t,
                      duration: 0.5,
                      ease: "power2.out",
                      onUpdate: () => {
                          this.payoutText.text = this.displayPayout.toFixed(2);
                      },
                  });
    }
    resetPayoutText() {
        (this.currentPayout = 0),
            (this.displayPayout = 0),
            Je.to(this.payoutText, {
                alpha: 0,
                duration: 0.3,
                ease: "power2.out",
                onComplete: () => {
                    (this.payoutText.text = ""), (this.payoutText.alpha = 1);
                },
            });
    }
    playFinal() {
        (this.anticipationContainer.x = Q(Ye).width / 2),
            (this.anticipationContainer.y = Q(Ye).height / 2),
            (this.anticipationContainer.pivot.x = Q(Ye).width / 2),
            (this.anticipationContainer.pivot.y = Q(Ye).height / 2),
            Je.to(this.anticipationContainer, {
                y: Q(Ye).height / 2 - 200,
                duration: 0.5,
                ease: "power2.out",
            }),
            Je.to(this.anticipationContainer.scale, {
                x: 1.6,
                y: 1.6,
                duration: 0.5,
                ease: "power2.out",
            });
    }
    playFinalBack() {
        this.anticipationContainer.scale.x !== 1 &&
            (Je.to(this.anticipationContainer, {
                y: Q(Ye).height / 2,
                duration: 0.5,
                ease: "power2.out",
            }),
            Je.to(this.anticipationContainer.scale, {
                x: 1,
                y: 1,
                duration: 0.5,
                ease: "power2.out",
            }));
    }
    playContinue() {
        (this.continueSprite.y = Q(Ye).height + 100),
            (this.continueSprite.alpha = 0),
            Je.to(this.continueSprite, {
                y: Q(Ye).height * 0.96,
                alpha: 1,
                duration: 0.9,
                delay: 0.5,
            });
    }
    resize() {
        (this.continueSprite.x = Q(Ye).width / 2),
            (this.continueSprite.y = Q(Ye).height * 0.96),
            (this.continueSprite.scale = Math.min(
                Math.max(1, Q(Ye).width / 800),
                Q(Ye).height / 1e3
            )),
            lP(
                this.container,
                0,
                Q(Ye).height >= 300 && Q(Ye).width <= 400
                    ? -26
                    : Q(Ye).height <= 1e3
                    ? -10
                    : 0
            ),
            S0({
                container: this.container,
                maxDimensions: { width: 500, height: 840 },
                originalDimensions: {
                    width: 500,
                    height:
                        Q(Ye).width <= 400
                            ? 1720
                            : Q(Ye).height <= 1e3
                            ? 1680
                            : 1200,
                },
            }),
            S0({
                container: this.screensSpine,
                maxDimensions: { width: 500, height: 500 },
                originalDimensions: {
                    width: 500,
                    height: Q(Ye).height <= 400 ? 100 : 500,
                },
            });
    }
}
let dL = class b2 {
    constructor(e, t, n = 0) {
        x(this, "container");
        x(this, "subContainer", new hn());
        x(this, "spine");
        x(this, "state", "static");
        x(this, "symbolInfo");
        x(this, "reelIndex");
        x(this, "rowIndex");
        x(this, "index");
        x(this, "singleReelMode", !1);
        x(this, "bufferSymbol", null);
        x(this, "currentDurability", 0);
        x(this, "maxDurability", 0);
        (this.container = new hn()),
            (this.reelIndex = e),
            (this.rowIndex = t),
            (this.index = e * Mr.y + t),
            (this.spine = jr.from({
                skeleton: "symbolsData",
                atlas: "masterAtlas",
            })),
            (this.spine.label = `tile_${e}_${t}:${n}`),
            (this.container.y = t * ut),
            (this.container.x = e * ut),
            (this.container.label = `tile_${e}_${t}_container`),
            (this.symbolInfo = zk[e][t]),
            this.setSymbol(this.symbolInfo),
            (this.spine.scale = uh),
            (this.spine.zIndex = 1),
            (this.spine.y = 0),
            (this.subContainer.y = 0),
            this.subContainer.addChild(this.spine),
            this.container.addChild(this.subContainer);
    }
    setAnimation(e = "static") {
        var n, i;
        if (
            !((n = this.spine) != null && n.state) ||
            !((i = this.symbolInfo) != null && i.symbol)
        )
            return;
        const t = Uk[this.symbolInfo.symbol][e];
        return this.spine.state.setAnimation(0, t);
    }
    setSymbol(e, t = "static") {
        Je.killTweensOf(this.spine),
            Je.killTweensOf(this.container),
            (this.state = t),
            (this.symbolInfo = e),
            (this.maxDurability = Gk[e.symbol] || 0),
            (this.currentDurability = this.maxDurability),
            (this.container.x = this.reelIndex * ut),
            (this.container.y = this.rowIndex * ut),
            (this.container.rotation = 0),
            (this.container.scaleX = 1),
            (this.container.scaleY = 1),
            (this.spine.scale.x = uh),
            (this.spine.scale.y = uh),
            this.setAnimation(this.state),
            this.updateDurabilityAnimation(),
            this.spine.state.setEmptyAnimation(2);
    }
    setStatic() {
        (this.state = "static"), this.setAnimation(this.state);
    }
    singleReelPrespin() {
        if (
            ((this.state = "spin"),
            Je.killTweensOf(this.subContainer),
            !this.singleReelMode)
        ) {
            (this.singleReelMode = !0),
                this.bufferSymbol &&
                    (this.subContainer.removeChild(this.bufferSymbol.container),
                    this.bufferSymbol.destroy(),
                    (this.bufferSymbol = null)),
                (this.subContainer.y = 0),
                (this.spine.y = 0);
            const t = new rl();
            t.rect(-ut / 2, -ut / 2 + 5, ut, ut - 15),
                t.fill(16777215),
                (t.alpha = 0),
                (this.container.mask = t),
                this.container.addChild(t),
                (this.bufferSymbol = new b2(
                    this.reelIndex,
                    this.rowIndex,
                    Date.now()
                )),
                this.bufferSymbol.setSymbol(q0()),
                this.subContainer.addChild(this.bufferSymbol.container),
                (this.spine.y = 0),
                (this.bufferSymbol.spine.y = -ut),
                (this.subContainer.y = 0),
                new cL({ velocity: { y: 50, x: 0 }, kernelSize: 21 });
        }
        Je.to(this.subContainer, {
            y: `+=${ut}`,
            duration: 0.12,
            ease: "none",
            onComplete: () => {
                requestAnimationFrame(() => {
                    !this.bufferSymbol ||
                        !this.singleReelMode ||
                        (this.setSymbol(this.bufferSymbol.symbolInfo),
                        (this.subContainer.y = 0),
                        (this.spine.y = 0),
                        this.bufferSymbol.setSymbol(q0()),
                        (this.bufferSymbol.spine.y = -ut),
                        this.singleReelMode && this.singleReelPrespin());
                });
            },
        });
    }
    async singleReelReveal(e) {
        if (
            (await this.stopSingleReelSpin(),
            this.bufferSymbol &&
                (this.subContainer.removeChild(this.bufferSymbol.container),
                this.bufferSymbol.destroy(),
                (this.bufferSymbol = null)),
            this.container.mask)
        ) {
            const i = this.container.mask;
            this.container.removeChild(i),
                (this.container.mask = null),
                i.destroy();
        }
        (this.subContainer.filters = []),
            this.setSymbol(e, "land"),
            (this.spine.y = 0);
        const t = 15,
            n = 0.2;
        await Je.to(this.subContainer, {
            y: t,
            duration: n * 0.6,
            ease: "power2.out",
        }),
            De.next({
                type: "symbolLand",
                symbol: this.symbolInfo,
                reel: this.reelIndex,
            }),
            await Je.to(this.subContainer, {
                y: 0,
                duration: n * 0.4,
                ease: "back.out(1.2)",
            });
    }
    async stopSingleReelSpin() {
        (this.singleReelMode = !1), Je.killTweensOf(this.subContainer);
        const e = this.subContainer.y,
            t = ut;
        if (e !== t) {
            if (e < t) {
                const i = 0.12 * ((t - e) / ut);
                await Je.to(this.subContainer, {
                    y: t,
                    duration: i,
                    ease: "none",
                });
            } else
                e > t &&
                    (await Je.to(this.subContainer, {
                        y: t,
                        duration: 0.06,
                        ease: "power2.out",
                    }));
            (this.subContainer.y = 0), (this.spine.y = 0);
        }
    }
    animateWin() {
        this.tintWhite(), (this.state = "win"), this.setAnimation(this.state);
    }
    async upgrade() {
        ["3", "4", "5"].includes(this.symbolInfo.symbol) &&
            (this.setAnimation("upgrade"),
            await Le(800),
            this.setSymbol({ symbol: "2" }));
    }
    tintDark() {
        this.spine.tint = Dk;
    }
    tintWhite() {
        this.spine.tint = iP;
    }
    updateDurabilityAnimation() {
        ["2", "3", "4", "5"].includes(this.symbolInfo.symbol) &&
        this.currentDurability > 0 &&
        this.maxDurability > 0
            ? this.spine.state.setAnimation(1, `dur_${this.currentDurability}`)
            : this.spine.state.setEmptyAnimation(1);
    }
    hitBlock() {
        return this.currentDurability > 0
            ? (this.currentDurability--,
              this.updateDurabilityAnimation(),
              this.currentDurability === 0 &&
                  this.spine.state.setAnimation(2, "pickaxe_break"),
              this.currentDurability === 0)
            : !1;
    }
    isDead() {
        return this.currentDurability <= 0 && this.maxDurability > 0;
    }
    destroy() {
        this.spine && this.spine.state && this.spine.destroy(),
            this.container && this.container.destroy({ children: !0 }),
            (this.spine = null),
            (this.container = null);
    }
};
class fL {
    constructor(e, t) {
        x(this, "container");
        x(this, "spine");
        x(this, "block", "d");
        x(this, "blockName", "dirt");
        x(this, "reelIndex");
        x(this, "rowIndex");
        x(this, "index");
        x(this, "currentDurability", 0);
        x(this, "maxDurability", 0);
        x(this, "payoutTextContainer", new hn());
        x(this, "payoutText");
        (this.container = new hn()),
            (this.reelIndex = e),
            (this.rowIndex = t),
            (this.index = e * It.y + t),
            (this.spine = jr.from({
                skeleton: "blockData",
                atlas: "masterAtlas",
            })),
            (this.spine.label = `tile_${e}_${t}`),
            (this.container.y = t * ut + 374),
            (this.container.x = e * ut),
            (this.container.label = `tile_${e}_${t}_container`),
            (this.payoutText = new SC({
                text: "",
                style: { fontFamily: "md_white_wide", fontSize: 50 },
            })),
            (this.payoutText.anchor.x = 0.5),
            (this.payoutText.anchor.y = 0.5),
            this.payoutTextContainer.addChild(this.payoutText),
            kh(() => {
                var n;
                return Fw(
                    (n = this.spine) == null ? void 0 : n.label,
                    "slot_num",
                    this.payoutTextContainer
                );
            }, 40),
            this.setBlock(Yk[this.index]),
            (this.spine.zIndex = 1),
            this.container.addChild(this.spine),
            (this.spine.afterUpdateWorldTransforms = () => {
                this.spine._slotsObject &&
                    Object.entries(this.spine._slotsObject).forEach(
                        ([n, i]) => {
                            i != null &&
                                i.container &&
                                i != null &&
                                i.slot &&
                                (i.container.alpha = i.slot.attachment
                                    ? i.slot.color.a
                                    : 0);
                        }
                    );
            });
    }
    setBlock(e) {
        (this.block = e),
            (this.blockName = Hk(e)),
            (this.maxDurability = jk[e] || 1),
            (this.currentDurability = this.maxDurability);
        const t =
            this.blockName === "dirt" && this.rowIndex === 0
                ? "block_grass"
                : `block_${this.blockName}`;
        this.spine.state.setAnimation(0, t),
            this.spine.state.setAnimation(1, "block_reveal"),
            this.spine.state.setEmptyAnimation(2),
            (this.payoutText.text = "");
    }
    hitBlock() {
        if (this.currentDurability > 0) {
            this.currentDurability--;
            let e;
            return (
                this.currentDurability === 0
                    ? ((e = "block_break_final"),
                      De.next({ type: "blockBreak", block: this.blockName }),
                      this.showPayoutText())
                    : (De.next({ type: "pickHit" }),
                      (e = `block_break_${this.getBreakAnimationNumber()}`)),
                this.spine.state.setAnimation(2, e),
                this.currentDurability === 0
            );
        }
        return !1;
    }
    getBreakAnimationNumber() {
        const e = this.maxDurability - this.currentDurability;
        switch (this.blockName) {
            case "dirt":
                return 1;
            case "stone":
                return 6;
            case "ruby":
                return Math.min(6, 3 + e);
            case "gold":
                return Math.min(6, 2 + e);
            case "diamond":
                return Math.min(6, 1 + e);
            case "obsidian":
                return Math.min(6, e);
            default:
                return Math.min(6, e);
        }
    }
    hitBlockInstant() {
        if (this.currentDurability > 0) {
            this.currentDurability--;
            let e;
            return (
                this.currentDurability === 0
                    ? ((e = "block_break_final"), this.showPayoutText())
                    : (e = `block_break_${this.getBreakAnimationNumber()}`),
                this.spine.state.setAnimation(2, e),
                this.currentDurability === 0
            );
        }
        return !1;
    }
    showPayoutText() {
        const e = Wk[this.block] || 0,
            t = Q(Ra) * e;
        ka.attach(this.payoutText),
            t > 0
                ? ((this.payoutText.text = `${t.toFixed(2)}`),
                  De.next({ type: "blockBreak", amount: t }))
                : (this.payoutText.text = "");
    }
    isBroken() {
        return this.currentDurability <= 0;
    }
    destroy() {
        this.spine && this.spine.state && this.spine.destroy(),
            this.container && this.container.destroy({ children: !0 }),
            (this.spine = null),
            (this.container = null);
    }
}
class pL {
    constructor(e) {
        x(this, "container");
        x(this, "spine");
        x(this, "reelIndex");
        (this.container = new hn()),
            (this.reelIndex = e),
            (this.spine = jr.from({
                skeleton: "blockData",
                atlas: "masterAtlas",
            })),
            (this.container.y = 6 * ut + 415),
            (this.container.x = e * ut),
            (this.spine.zIndex = 1),
            this.container.addChild(this.spine),
            this.spine.state.setAnimation(0, "block_chest");
    }
}
class mL {
    constructor() {
        x(this, "container");
        x(this, "symbols", []);
        x(this, "blocks", []);
        x(this, "chests", []);
        this.container = new hn();
        for (let t = 0; t < Mr.x; t++)
            for (let n = 0; n < Mr.y; n++) {
                const i = new dL(t, n);
                this.symbols.push(i), this.container.addChild(i.container);
            }
        const e = [];
        for (let t = 0; t < It.x; t++)
            for (let n = It.y - 1; n >= 0; n--)
                e.push({ reelIndex: t, rowIndex: n });
        A0(
            e,
            ({ reelIndex: t, rowIndex: n }) => {
                const i = new fL(t, n);
                this.blocks.push(i), this.container.addChild(i.container);
            },
            8
        );
        for (let t = 0; t < Mr.x; t++) {
            const n = new pL(t);
            this.chests.push(n),
                this.container.addChild(n.container),
                _h.attach(n.container);
        }
        (this.container.pivot.x = j0.x), (this.container.pivot.y = j0.y);
    }
    tintDarkAllSymbols() {
        this.symbols.forEach((e) => e.tintDark());
    }
    tintWhiteAllSymbols() {
        this.symbols.forEach((e) => e.tintWhite());
    }
    setAllSymbolsStatic() {
        this.symbols.forEach((e) => e.setStatic());
    }
    async animateBonusSymbols(e) {
        De.next({ type: "symbolWin", symbol: tl }),
            this.tintDarkAllSymbols(),
            e.forEach((t) => {
                this.symbolAt(t).animateWin();
            }),
            await Le(500),
            this.tintWhiteAllSymbols();
    }
    symbolAt(e) {
        return this.symbols[e.reel * Mr.y + e.row];
    }
    inverseBlockAt(e, t) {
        const n = e * It.y + (It.y - 1 - t);
        return this.blocks[n];
    }
    blockAt(e, t) {
        const n = e * It.y + t;
        return this.blocks[n];
    }
    async setBlocks(e) {
        const n = e
            .split("")
            .slice(0, this.blocks.length)
            .map((i, r) => ({ block: i, logicalIndex: r }));
        await A0(
            n,
            ({ block: i, logicalIndex: r }) => {
                const a = Math.floor(r / It.y),
                    o = r % It.y,
                    h = a * It.y + (It.y - 1 - o);
                h < this.blocks.length && this.blocks[h].setBlock(i);
            },
            ye.skip || Te.turbo ? 0 : 15
        ),
            (Te.turbo || ye.skip) && (await Le(100));
    }
    resetAllSymbolPositions() {
        this.symbols.forEach((e) => {
            (e.container.x = e.reelIndex * ut),
                (e.container.y = e.rowIndex * ut),
                (e.container.rotation = 0),
                (e.container.scaleX = 1),
                (e.container.scaleY = 1),
                (e.spine.scale.x = uh),
                (e.spine.scale.y = uh);
        });
    }
    async prespinReels() {
        this.resetAllSymbolPositions();
        for (let e = 0; e < this.symbols.length; e++)
            this.symbols[e].singleReelPrespin(),
                !Te.turbo && !ye.skip && (await Le(20));
    }
    async revealReels(e, t) {
        let n = qk(e, 3);
        const i = t > 0;
        for (let r = 0; r < this.symbols.length; r++) {
            const a = this.symbols[r];
            if (
                (a.singleReelReveal(e[a.reelIndex][a.rowIndex]),
                !Te.turbo && !ye.skip)
            ) {
                const o = i && a.reelIndex >= t,
                    h = i && a.index >= n;
                o && !h
                    ? (this.tintDarkAllSymbols(),
                      Xk(e, tl.symbol).forEach((u) => {
                          this.symbolAt(u).tintWhite();
                      }),
                      await Le(W0.anticipationDuration * 1e3))
                    : await Le(W0.reelRevealOffsetDuration * 1e3);
            }
        }
    }
    async enhanceSymbols(e, t) {
        await Le(100),
            this.tintDarkAllSymbols(),
            e.forEach((n) => {
                this.symbolAt(n).tintWhite();
            }),
            t.forEach((n) => {
                this.symbolAt(n).tintWhite();
            });
        for (const n of e) this.symbolAt(n).animateWin();
        await Le(200), De.next({ type: "symbolWin", symbol: N1 });
        for (const n of t) this.symbolAt(n).upgrade();
        await Le(500), this.tintWhiteAllSymbols();
    }
    async animateMining(e) {
        const t = {};
        for (const i of e)
            for (const r of i.pickaxes) {
                const a = { ...r, reelIndex: i.reel };
                t[i.reel] || (t[i.reel] = []), t[i.reel].push(a);
            }
        const n = [];
        for (const i in t) {
            const a = t[i].filter((h) => {
                const l = this.symbolAt({ reel: h.reelIndex, row: h.row });
                return (
                    ["2", "3", "4", "5"].includes(l.symbolInfo.symbol) &&
                    !l.isDead() &&
                    l.symbolInfo.symbol === h.symbol
                );
            });
            a.sort((h, l) => {
                const u = this.symbolAt({ reel: h.reelIndex, row: h.row }),
                    c = this.symbolAt({ reel: l.reelIndex, row: l.row });
                return u.currentDurability - c.currentDurability;
            });
            const o = this.animateReelMining(a);
            n.push(o), ye.skip || (await Le(Te.turbo ? 20 : 100));
        }
        await Promise.race([
            Promise.all(n),
            new Promise((i) => setTimeout(() => i, 1e4)),
        ]);
    }
    async animateReelMining(e) {
        for (const t of e) {
            const n = this.symbolAt({ reel: t.reelIndex, row: t.row });
            if (!(n.isDead() || n.symbolInfo.symbol !== t.symbol)) {
                if (this.isReelCompletelyBroken(t.reelIndex)) {
                    for (; !n.isDead(); ) n.hitBlock();
                    continue;
                }
                await this.animatePickaxeHit(n, t.breakBlock);
            }
        }
    }
    async animatePickaxeHit(e, t) {
        if (e.isDead()) return;
        ka.attach(e.container), e.reelIndex;
        const n = Math.floor(t / It.y),
            i = t % It.y,
            r = [];
        for (let o = 0; o <= i; o++) {
            const h = this.inverseBlockAt(n, o);
            h.isBroken() || r.push({ reelIndex: n, rowIndex: o, block: h });
        }
        if (ye.skip) {
            this.instantCompleteMining(e, r);
            return;
        }
        let a = 0;
        for (let o = 0; o < r.length; o++) {
            const { block: h } = r[o];
            if (e.isDead()) break;
            if (ye.skip) {
                this.instantCompleteMining(e, r.slice(o));
                return;
            }
            const l = h.container.x,
                u = h.container.y - 60;
            let c = !1;
            const d = o === r.length - 1;
            for (; !c && !e.isDead(); ) {
                if (ye.skip) {
                    this.instantCompleteMining(e, r.slice(o));
                    return;
                }
                if (
                    ((a += Math.PI),
                    await Je.to(e.container, {
                        x: l,
                        y: u,
                        rotation: a,
                        duration: ye.skip || Te.turbo ? 0.1 : 0.3,
                        ease: "power2.in",
                    }),
                    (c = h.hitBlock()),
                    d && c && !e.isDead())
                ) {
                    for (; !e.isDead(); ) e.hitBlock();
                    break;
                }
                if (e.hitBlock()) break;
                const p = 250;
                (a += Math.PI),
                    await Je.to(e.container, {
                        y: u - p,
                        rotation: a,
                        duration: ye.skip || Te.turbo ? 0.07 : 0.2,
                        ease: "power2.out",
                    });
            }
            if (e.isDead()) break;
        }
        if (!e.isDead()) {
            a += Math.PI;
            const o = ye.skip || Te.turbo ? 0.1 : 0.5,
                h = e.reelIndex * ut,
                l = e.rowIndex * ut;
            await Promise.all([
                new Promise((u) => {
                    Je.to(e.container, {
                        x: h,
                        y: l,
                        duration: o,
                        ease: "power2.out",
                        onComplete: u,
                    });
                }),
                new Promise((u) => {
                    Je.to(e.container, {
                        rotation: a,
                        duration: o,
                        ease: "power2.out",
                        onComplete: u,
                    });
                }),
            ]);
        }
    }
    instantCompleteMining(e, t) {
        for (let n = 0; n < t.length; n++) {
            const { block: i } = t[n];
            if (e.isDead()) break;
            const r = n === t.length - 1;
            let a = !1;
            for (; !a && !e.isDead(); ) {
                if (((a = i.hitBlockInstant()), r && a && !e.isDead())) {
                    for (; !e.isDead(); ) e.hitBlock();
                    break;
                }
                if (e.hitBlock()) break;
            }
        }
        e.isDead() ||
            ((e.container.x = e.reelIndex * ut),
            (e.container.y = e.rowIndex * ut),
            (e.container.rotation = 0));
    }
    async animateTnt(e) {
        await Le(Te.turbo || ye.skip ? 50 : 200);
        const t = [...e].sort((n, i) =>
            n.reel !== i.reel ? n.reel - i.reel : n.row - i.row
        );
        for (let n = 0; n < t.length; n++) {
            const i = t[n];
            n > 0 && !ye.skip && (await Le(200)),
                await this.animateSingleTnt(i);
        }
    }
    async animateSingleTnt(e) {
        const t = this.symbolAt({ reel: e.reel, row: e.row });
        ka.attach(t.container);
        const n = Math.floor(e.blockIndex / It.y);
        let i = It.y - 1;
        for (let c = 0; c < It.y; c++)
            if (!this.inverseBlockAt(n, c).isBroken()) {
                i = c;
                break;
            }
        const r = this.inverseBlockAt(n, i),
            a = r.container.x,
            o = r.container.y - 90;
        if (ye.skip) {
            this.instantCompleteTnt(t, e, a, o, r);
            return;
        }
        let h = !1;
        const l = () => {
                h || (this.instantCompleteTnt(t, e, a, o, r), (h = !0));
            },
            u = new Promise(async (c) => {
                try {
                    if (ye.skip) {
                        l(), c();
                        return;
                    }
                    if (
                        (await Je.to(t.container, {
                            x: a,
                            y: o,
                            duration: Te.turbo ? 0.26 : 0.8,
                            ease: "bounce.out",
                        }),
                        ye.skip)
                    ) {
                        l(), c();
                        return;
                    }
                    if (
                        (t.setAnimation("win"),
                        kh(
                            () =>
                                De.next({
                                    type: "symbolWin",
                                    symbol: t.symbolInfo,
                                }),
                            Te.turbo ? 950 : 1150
                        ),
                        await Le(1150),
                        ye.skip)
                    ) {
                        l(), c();
                        return;
                    }
                    this.applyTntDamage(
                        e.blockIndex,
                        r.rowIndex,
                        e.brokenBlocks
                    ),
                        await Le(300),
                        (h = !0),
                        c();
                } catch {
                    (h = !0), c();
                }
            });
        try {
            await u;
        } finally {
            kh(() => {
                (t.container.x = t.reelIndex * ut),
                    (t.container.y = t.rowIndex * ut),
                    (t.container.rotation = 0);
            }, 500);
        }
    }
    instantCompleteTnt(e, t, n, i, r) {
        Je.killTweensOf(e.container), (e.container.x = n), (e.container.y = i);
        const a = e.setAnimation("win");
        a && (a.trackTime = a.animation.duration * 0.8),
            this.applyTntDamage(t.blockIndex, r.rowIndex, t.brokenBlocks);
    }
    applyTntDamage(e, t, n) {
        const i = Math.floor(e / It.y),
            r = [
                { reel: i - 1, row: t - 2 },
                { reel: i, row: t - 2 },
                { reel: i + 1, row: t - 2 },
                { reel: i - 1, row: t - 1 },
                { reel: i, row: t - 1 },
                { reel: i + 1, row: t - 1 },
                { reel: i - 1, row: t },
                { reel: i, row: t },
                { reel: i + 1, row: t },
            ];
        for (const a of r)
            if (a.reel >= 0 && a.reel < It.x && a.row >= 0 && a.row < It.y) {
                const o = this.inverseBlockAt(a.reel, a.row);
                a.reel * It.y + a.row,
                    o.isBroken() ||
                        (ye.skip
                            ? (o.hitBlockInstant(),
                              o.isBroken() || o.hitBlockInstant())
                            : (o.hitBlock(), o.isBroken() || o.hitBlock()));
            }
    }
    isReelCompletelyBroken(e) {
        for (let t = 0; t < It.y; t++)
            if (!this.inverseBlockAt(e, t).isBroken()) return !1;
        return !0;
    }
    getOpenedChestReels() {
        const e = [];
        for (let t = 0; t < It.x; t++)
            this.isReelCompletelyBroken(t) && e.push(t);
        return e;
    }
    async animateChestReward(e, t) {
        if (e < 0 || e >= this.chests.length) return;
        const n = this.chests[e];
        n.spine.state.setAnimation(0, "chest_open"),
            n.spine.state.setAnimation(1, `chest_${t}`),
            De.next({ type: "chestOpen", multiplier: t }),
            _h.attach(n.container),
            await Le(ye.skip || Te.turbo ? 500 : 2e3);
    }
    async handleFinalWin(e) {
        const t = this.getOpenedChestReels(),
            { multipliers: n } = e,
            i = n.slice(0, t.length);
        for (const [r, a] of Object.entries(t)) {
            const o = i[Number(r)];
            this.animateChestReward(a, o), await Le(900);
        }
        await Le(200);
        for (const r of t) {
            const a = this.chests[r];
            a.spine.state.setAnimation(0, `chest_mult_move_${a.reelIndex}`);
        }
        De.next({ type: "multMove" }),
            await Le(550),
            Kn.updatePayoutText(e.finalWin),
            De.next({ type: "multCombine" });
        for (const r of t) {
            const a = this.chests[r];
            _h.detach(a.container);
        }
        await Le(200);
    }
    resetChests() {
        for (const e of this.chests)
            e.spine.state.setAnimation(0, "block_chest"),
                e.spine.state.setEmptyAnimation(1);
    }
}
let ka, _h, jg, y2, Kn, dn;
function gL() {
    (ka = new zc()),
        (_h = new zc()),
        (jg = new zc()),
        (y2 = new zc()),
        (Kn = new uL()),
        (dn = new mL());
}
function _L(s, e) {
    Ne(e, !0);
    const t = () => U(Ye, "$windowSizes", n),
        [n, i] = tt();
    Fs(() => {
        gL(),
            go(Kn.anticipationContainer),
            Kn.container.addChild(dn.container),
            go(ka),
            go(_h),
            go(jg),
            go(y2),
            De.register({
                skip: () => {
                    ye.skip = !0;
                },
                skipInvoked: () => {},
                betStart: () => {
                    (ye.skip = !1),
                        Kn.resetPayoutText(),
                        dn.resetChests(),
                        dn.prespinReels();
                },
                resumeBetStart: () => {},
                reveal: async (r) => {
                    ka.detachAll(), Kn.resetPayoutText(), dn.resetChests();
                    const a = X0(r.board);
                    await dn.prespinReels(),
                        await Promise.all([
                            dn.setBlocks(r.blocks),
                            dn.revealReels(a, r.anticipation),
                        ]),
                        dn.tintWhiteAllSymbols(),
                        await Le(Te.turbo || ye.skip ? 10 : 35),
                        (ye.skip = !1);
                },
                bonusReveal: async (r) => {
                    await Le(Te.turbo || ye.skip ? 300 : 600),
                        lg.set(r.freeSpinsRemaining),
                        ka.detachAll();
                    const a = X0(r.board);
                    await dn.prespinReels(),
                        await dn.revealReels(a, r.anticipation),
                        await Le(180),
                        (ye.skip = !1);
                },
                enhance: async (r) => {
                    let a = lf(r.enhancePositions);
                    const o = lf(r.tierUpgrades);
                    (a = a.filter((h) => o.some((l) => l.reel === h.reel))),
                        !(a.length === 0 && o.length === 0) &&
                            (await dn.enhanceSymbols(a, o), await Le(400));
                },
                mine: async (r) => {
                    (ye.skip = !1),
                        await Le(Te.turbo || ye.skip ? 30 : 100),
                        await dn.animateMining(r.pickaxePhase),
                        await dn.animateTnt(r.tntPhase);
                },
                bonusEnter: async (r) => {
                    await dn.animateBonusSymbols(lf(r.positions)),
                        (ye.skip = !1),
                        Wi.set(!0),
                        await Kn.playBonusEnter(r.freeSpinCount),
                        Wi.set(!1),
                        Ys.set("bonus"),
                        (ye.skip = !1),
                        await Le(400);
                },
                bonusExit: async (r) => {
                    (ye.skip = !1),
                        await Kn.playBonusExit(r.totalWin),
                        Kn.playFinalBack(),
                        Wi.set(!1),
                        Ys.set("base"),
                        (ye.skip = !1),
                        De.next({ type: "realFinalWin", finalWin: r.totalWin });
                },
                symbolLand: ({ symbol: r }) => {
                    r.symbol === tl.symbol && Kn.playShake();
                },
                totalWin: ({ totalWin: r }) => {
                    Kn.updatePayoutText(r);
                },
                finalWin: async ({
                    finalWin: r,
                    baseWinAmount: a,
                    multipliers: o,
                }) => {
                    Q(Ys) === "bonus"
                        ? Wi.set(!0)
                        : De.next({ type: "realFinalWin", finalWin: r }),
                        a !== r &&
                            Q(Ys) === "bonus" &&
                            (await Le(250),
                            Kn.playFinal(),
                            await dn.handleFinalWin({
                                finalWin: r,
                                baseWinAmount: a,
                                multipliers: o,
                            }));
                },
            });
    }),
        _n(() => {
            t(), Kn.resize();
        }),
        Ve(),
        i();
}
const vL = (s) => s;
function Wg(s) {
    const e = s - 1;
    return e * e * e + 1;
}
function db(s) {
    const e = typeof s == "string" && s.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
    return e ? [parseFloat(e[1]), e[2] || "px"] : [s, "px"];
}
function Wr(s, { delay: e = 0, duration: t = 400, easing: n = vL } = {}) {
    const i = +getComputedStyle(s).opacity;
    return {
        delay: e,
        duration: t,
        easing: n,
        css: (r) => `opacity: ${r * i}`,
    };
}
function Id(
    s,
    {
        delay: e = 0,
        duration: t = 400,
        easing: n = Wg,
        x: i = 0,
        y: r = 0,
        opacity: a = 0,
    } = {}
) {
    const o = getComputedStyle(s),
        h = +o.opacity,
        l = o.transform === "none" ? "" : o.transform,
        u = h * (1 - a),
        [c, d] = db(i),
        [f, p] = db(r);
    return {
        delay: e,
        duration: t,
        easing: n,
        css: (m, g) => `
			transform: ${l} translate(${(1 - m) * c}${d}, ${(1 - m) * f}${p});
			opacity: ${h - u * g}`,
    };
}
function bL(
    s,
    { delay: e = 0, duration: t = 400, easing: n = Wg, axis: i = "y" } = {}
) {
    const r = getComputedStyle(s),
        a = +r.opacity,
        o = i === "y" ? "height" : "width",
        h = parseFloat(r[o]),
        l = i === "y" ? ["top", "bottom"] : ["left", "right"],
        u = l.map((_) => `${_[0].toUpperCase()}${_.slice(1)}`),
        c = parseFloat(r[`padding${u[0]}`]),
        d = parseFloat(r[`padding${u[1]}`]),
        f = parseFloat(r[`margin${u[0]}`]),
        p = parseFloat(r[`margin${u[1]}`]),
        m = parseFloat(r[`border${u[0]}Width`]),
        g = parseFloat(r[`border${u[1]}Width`]);
    return {
        delay: e,
        duration: t,
        easing: n,
        css: (_) =>
            `overflow: hidden;opacity: ${Math.min(_ * 20, 1) * a};${o}: ${
                _ * h
            }px;padding-${l[0]}: ${_ * c}px;padding-${l[1]}: ${
                _ * d
            }px;margin-${l[0]}: ${_ * f}px;margin-${l[1]}: ${_ * p}px;border-${
                l[0]
            }-width: ${_ * m}px;border-${l[1]}-width: ${_ * g}px;min-${o}: 0`,
    };
}
function yL(
    s,
    {
        delay: e = 0,
        duration: t = 400,
        easing: n = Wg,
        start: i = 0,
        opacity: r = 0,
    } = {}
) {
    const a = getComputedStyle(s),
        o = +a.opacity,
        h = a.transform === "none" ? "" : a.transform,
        l = 1 - i,
        u = o * (1 - r);
    return {
        delay: e,
        duration: t,
        easing: n,
        css: (c, d) => `
			transform: ${h} scale(${1 - l * d});
			opacity: ${o - u * d}
		`,
    };
}
var wL = X(
        '<div class="continue svelte-1f5lgaa"><img class="cont-img svelte-1f5lgaa" src="./assets/continue.webp"/></div>'
    ),
    xL = X(
        '<div class="background svelte-1f5lgaa"></div> <div class="loader svelte-1f5lgaa"><img class="name svelte-1f5lgaa" src="./assets/paperclip_name_s.png"/> <img class="game-title svelte-1f5lgaa" src="./assets/md_loader.webp"/> <div class="progress-bar svelte-1f5lgaa"><div class="loader-bar svelte-1f5lgaa"></div> <img class="icon svelte-1f5lgaa" src="./assets/paperclip_icon_inv_s.png"/></div></div> <!>',
        1
    );
function CL(s, e) {
    Ne(e, !0);
    const t = () => U(gl, "$loaded", r),
        n = () => U(Ye, "$windowSizes", r),
        i = () => U(vd, "$progressValue", r),
        [r, a] = tt(),
        o = nP(" "),
        h = async () => {
            t() && (_l.set(!0), o.unsubscribe());
        };
    _n(() => {
        Qe.replay && t() && h();
    }),
        Fs(async () => {
            o.press = h;
        });
    const l = Me(() =>
        Math.min(
            n().height < 900 ? n().height / 900 : 1,
            n().width < 600 ? n().width / 600 : 1
        )
    );
    var u = xL();
    Ip("click", wh, h);
    var c = N(me(u), 2),
        d = N(I(c), 4),
        f = I(d),
        p = N(c, 2);
    {
        var m = (g) => {
            var _ = wL();
            Vn(3, _, () => Id), D(g, _);
        };
        ne(p, (g) => {
            t() && g(m);
        });
    }
    ie(() => {
        an(
            c,
            `transform: scale(${$(l) ?? ""}); cursor: ${
                t() ? "pointer" : "default"
            }
	`
        ),
            an(f, `height: ${i() * 132}px;`);
    }),
        D(s, u),
        Ve(),
        a();
}
const AL = [
        { alias: "backgroundData", src: "./assets/md_background.skel" },
        { alias: "masterAtlas", src: "./assets/md_master.atlas" },
        { alias: "symbolsData", src: "./assets/md_symbols.skel" },
        { alias: "screensData", src: "./assets/md_screens.skel" },
        { alias: "blockData", src: "./assets/md_block.skel" },
        { alias: "mdWhite", src: "./assets/md_white.xml" },
        { alias: "mdWhiteWide", src: "./assets/md_white_wide.xml" },
        { alias: "continue", src: "./assets/continue.webp" },
        { alias: "audio", src: "./assets/md_sounds.json" },
    ],
    SL = [
        "./assets/md_ante.webp",
        "./assets/md_bonus.webp",
        "./assets/md_loader.webp",
        "./assets/md_loader_bg.jpg",
        "./assets/paperclip_icon_inv_s.png",
        "./assets/paperclip_name_s.png",
    ],
    EL = (s) => {
        for (const e of s) {
            const t = new Image();
            t.src = e;
        }
    };
function PL() {
    EL(SL);
}
const fb = async (s) => {
    s.forEach((t) => {
        Xi.add({ alias: t.alias, src: t.src });
    });
    const e = await Xi.load(
        s.map((t) => t.alias),
        (t) => {
            vd.set(t);
        }
    );
    for (const t of s)
        t.scaleMode &&
            e[t.alias].pageTextures.forEach(
                (n) => (n.texture.source.scaleMode = t.scaleMode)
            );
};
var kL = X(
    '<div class="canvas-wrap svelte-7jn005"><canvas class="canvas svelte-7jn005"></canvas></div>'
);
function TL(s, e) {
    Ne(e, !0);
    var t =
        (this && this.__awaiter) ||
        function (c, d, f, p) {
            function m(g) {
                return g instanceof f
                    ? g
                    : new f(function (_) {
                          _(g);
                      });
            }
            return new (f || (f = Promise))(function (g, _) {
                function v(C) {
                    try {
                        y(p.next(C));
                    } catch (w) {
                        _(w);
                    }
                }
                function b(C) {
                    try {
                        y(p.throw(C));
                    } catch (w) {
                        _(w);
                    }
                }
                function y(C) {
                    C.done ? g(C.value) : m(C.value).then(v, b);
                }
                y((p = p.apply(c, d || [])).next());
            });
        };
    let n = y0(e, "antialias", 3, !1),
        i = y0(e, "background", 3, "#000000"),
        r = gt(void 0),
        a = gt(void 0),
        o,
        h = null;
    Fs(() =>
        t(void 0, void 0, void 0, function* () {
            (o = new $x()),
                yield o.init({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    resolution: Math.min(2, window.devicePixelRatio),
                    antialias: n(),
                    autoDensity: !0,
                    view: $(r),
                    background: i(),
                    resizeTo: window,
                    useBackBuffer: !0,
                }),
                (window.__PIXI_DEVTOOLS__ = { pixiApp: o }),
                (globalThis.__PIXI_APP__ = o),
                ug.set(o),
                (o.ticker.maxFPS = 60),
                (o.ticker.minFPS = 30),
                e.preloadAssets && (yield fb(e.preloadAssets)),
                hg.set(!0),
                e.assets && (yield fb(e.assets));
            const c = () => {
                if (!o) return;
                const d = document.hidden;
                (o.ticker.autoStart = !d),
                    d ? o.ticker.stop() : o.ticker.start();
            };
            document.addEventListener("visibilitychange", c),
                window.addEventListener("blur", c),
                window.addEventListener("focus", c),
                (h = () => {
                    document.removeEventListener("visibilitychange", c),
                        window.removeEventListener("blur", c),
                        window.removeEventListener("focus", c);
                }),
                c();
        })
    ),
        gd(() => {
            h == null || h(), (h = null);
        });
    var l = kL(),
        u = I(l);
    b0(
        u,
        (c) => Re(r, c),
        () => $(r)
    ),
        b0(
            l,
            (c) => Re(a, c),
            () => $(a)
        ),
        D(s, l),
        Ve();
}
var np = new WeakMap(),
    Gc;
function sp(s, e) {
    return (
        (Gc =
            Gc ||
            new ResizeObserver((t) => {
                for (let n of t) {
                    let i = np.get(n.target);
                    i && i(n);
                }
            })),
        np.set(s, e),
        Gc.observe(s),
        {
            destroy() {
                Gc.unobserve(s), np.delete(s);
            },
        }
    );
}
var ML = bn(
    '<svg width="43" height="43" viewBox="0 0 43 43" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.27699 0H38.603C40.9651 0 42.88 1.91488 42.88 4.27699C42.88 6.63911 40.9651 8.55399 38.603 8.55399H4.27699C1.91487 8.55399 0 6.63911 0 4.27699C0 1.91488 1.91488 0 4.27699 0ZM38.603 17.108H4.27699C1.91488 17.108 0 19.0229 0 21.385C0 23.7471 1.91487 25.662 4.27699 25.662H38.603C40.9651 25.662 42.88 23.7471 42.88 21.385C42.88 19.0229 40.9651 17.108 38.603 17.108ZM38.603 34.216H4.27699C1.91488 34.216 0 36.1309 0 38.493C0 40.8551 1.91487 42.77 4.27699 42.77H38.603C40.9651 42.77 42.88 40.8551 42.88 38.493C42.88 36.1309 40.9651 34.216 38.603 34.216Z" fill="currentColor"></path></svg>'
);
function IL(s) {
    var e = ML();
    D(s, e);
}
var RL = bn(
    '<svg width="43" height="43" viewBox="0 0 43 43" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28.5352 21.3838L41.4822 34.3309C43.424 36.2726 43.424 39.4209 41.4822 41.3626C39.5404 43.3044 36.3922 43.3044 34.4504 41.3626L21.5034 28.4156L8.54668 41.3723C6.60491 43.3141 3.45668 43.3141 1.51491 41.3723C-0.426861 39.4305 -0.426861 36.2823 1.51491 34.3405L14.4716 21.3838L1.63548 8.54768C-0.306292 6.60592 -0.306289 3.45769 1.63548 1.51592C3.57725 -0.425853 6.72548 -0.425853 8.66725 1.51592L21.5034 14.3521L34.3299 1.52559C36.2716 -0.416184 39.4198 -0.416181 41.3616 1.52559C43.3034 3.46736 43.3034 6.61559 41.3616 8.55736L28.5352 21.3838Z" fill="currentColor"></path></svg>'
);
function zu(s) {
    var e = RL();
    D(s, e);
}
var LL = bn(
    '<svg width="12" height="40" viewBox="0 0 5 15" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.10092 2.05046C4.10092 3.17982 3.18783 4.10092 2.05046 4.10092C0.921105 4.10092 0 3.17982 0 2.05046C0 0.921106 0.921105 0 2.05046 0C3.17982 0 4.10092 0.921106 4.10092 2.05046ZM1.28906 5.43945H2.80528C3.35757 5.43945 3.80528 5.88717 3.80528 6.43945V13.4182C3.80528 13.9705 3.35757 14.4182 2.80528 14.4182H1.28906C0.736778 14.4182 0.289062 13.9705 0.289062 13.4182V6.43945C0.289062 5.88717 0.736778 5.43945 1.28906 5.43945Z" fill="currentColor"></path></svg>'
);
function pb(s) {
    var e = LL();
    D(s, e);
}
var OL = bn(
    '<svg width="48" height="39" viewBox="-1 -2 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.77344 0.922992C8.77344 0.560258 9.06872 0.261741 9.42847 0.308137C10.2259 0.410981 10.9665 0.698963 11.6056 1.12739C12.973 2.04404 13.8756 3.60362 13.8756 5.36833C13.8756 7.17808 12.9263 8.77209 11.5 9.67819C10.8855 10.0686 10.1824 10.3313 9.42845 10.4285C9.0687 10.4749 8.77344 10.1764 8.77344 9.81366C8.77344 9.45093 9.06967 9.16285 9.42702 9.10057C9.94072 9.01103 10.4191 8.81783 10.8397 8.54336C11.8762 7.86693 12.562 6.69689 12.562 5.36833C12.562 4.03976 11.8762 2.86972 10.8397 2.19329C10.4191 1.91882 9.94072 1.72562 9.42702 1.63609C9.06967 1.5738 8.77344 1.28573 8.77344 0.922992ZM3.40698 1.99137C3.26305 2.06738 3.10275 2.10711 2.93999 2.10711H0.999999C0.447714 2.10711 0 2.55482 0 3.10711V7.61892C0 8.1712 0.447715 8.61892 1 8.61892H2.93999C3.10275 8.61892 3.26305 8.65865 3.40698 8.73466L5.70962 9.95071C6.37559 10.3024 7.17661 9.81958 7.17661 9.06645V1.65957C7.17661 0.906447 6.37559 0.423611 5.70962 0.775314L3.40698 1.99137ZM11.5768 5.3684C11.5768 4.04658 10.6574 2.93559 9.42444 2.64132C9.07162 2.55711 8.77344 2.85909 8.77344 3.22182C8.77344 3.58455 9.08139 3.86577 9.40915 4.02117C9.91468 4.26087 10.2632 4.77684 10.2632 5.3684C10.2632 5.95875 9.91191 6.47383 9.40874 6.71416C9.08143 6.87049 8.77344 7.15224 8.77344 7.51497C8.77344 7.87771 9.07162 8.17968 9.42444 8.09547C10.6574 7.8012 11.5768 6.69021 11.5768 5.3684Z" fill="currentColor"></path></svg>'
);
function BL(s) {
    var e = OL();
    D(s, e);
}
var FL = bn(
    '<svg width="48" height="39" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.6576 7.44524C14.6576 7.44745 14.6558 7.44927 14.6536 7.44927C14.6514 7.44927 14.6496 7.45108 14.6496 7.45329C14.6486 8.71053 14.1823 9.85915 13.4204 10.7464C13.0228 11.2093 12.9623 11.9214 13.3938 12.3529L13.8887 12.8477C14.1762 13.1353 14.1762 13.6015 13.8887 13.889C13.6011 14.1765 13.135 14.1765 12.8474 13.889L0.520903 1.56248C0.233216 1.2748 0.233216 0.808366 0.520903 0.520679C0.808372 0.23321 1.27438 0.232962 1.56215 0.520124L4.27674 3.22892C4.58664 3.53816 5.06165 3.60987 5.44902 3.40589L6.49562 2.85476C7.16154 2.5041 7.96155 2.98698 7.96155 3.73959V6.49841C7.96155 6.76363 8.06691 7.01798 8.25445 7.20552L9.52607 8.47714C9.77741 8.72848 10.1605 8.84762 10.4467 8.63678C10.8134 8.36658 11.0533 7.93591 11.0533 7.44927C11.0533 6.84997 10.6982 6.33098 10.1877 6.09187C9.86123 5.93896 9.55547 5.65921 9.55547 5.29869C9.55547 4.93817 9.85179 4.63808 10.2026 4.72127C11.4375 5.01413 12.3588 6.12607 12.3588 7.44927C12.3588 8.26896 12.0014 9.00924 11.4352 9.52161C11.2038 9.73093 11.1513 10.1024 11.3719 10.323C11.5312 10.4823 11.783 10.5091 11.9568 10.3657C12.7995 9.67064 13.344 8.62402 13.344 7.44927C13.344 5.58169 11.9888 4.02733 10.2093 3.71707C9.85192 3.65477 9.55547 3.36667 9.55547 3.00394C9.55547 2.6412 9.85106 2.3427 10.2108 2.38912C12.713 2.71198 14.6556 4.85765 14.6576 7.44524ZM1.78516 10.7006C1.23287 10.7006 0.785156 10.2529 0.785156 9.70061V6.64306C0.785156 5.75216 1.8623 5.30599 2.49226 5.93596L7.76375 11.2074C7.89054 11.3342 7.96177 11.5062 7.96177 11.6855C7.96177 12.1947 7.4202 12.5211 6.96995 12.2833L4.19213 10.8164C4.04821 10.7403 3.88791 10.7006 3.72514 10.7006H1.78516Z" fill="currentColor"></path></svg>'
);
function $L(s) {
    var e = FL();
    D(s, e);
}
var DL = bn(
    '<svg width="86" height="95" viewBox="0 0 86 95" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M77.5293 0.158936C81.8878 -0.777668 85.9998 2.54463 86 7.00269V63.8298C86 64.0211 85.9877 64.2096 85.9668 64.3953C85.9873 64.7073 86 65.0219 86 65.3386C85.9999 73.8989 78.3888 80.8386 69 80.8386C59.6112 80.8386 52.0001 73.8989 52 65.3386C52 56.7782 59.6112 49.8386 69 49.8386C71.4954 49.8386 73.8653 50.3282 76 51.2087V19.1189C76 14.6176 71.8128 11.286 67.4268 12.2976L39.4268 18.7585C36.2506 19.4914 34.0001 22.3193 34 25.5789V77.3386C34 77.5922 33.9798 77.8413 33.9434 78.0847C33.9797 78.4983 34 78.9165 34 79.3386C33.9999 87.8989 26.3888 94.8386 17 94.8386C7.61124 94.8386 0.000137936 87.8989 0 79.3386C0 70.7782 7.61116 63.8386 17 63.8386C19.4954 63.8386 21.8653 64.3282 24 65.2087V17.321C24 14.022 26.3039 11.1706 29.5293 10.4773L77.5293 0.158936Z" fill="currentColor"></path></svg>'
);
function NL(s) {
    var e = DL();
    D(s, e);
}
var VL = bn(
    '<svg width="98" height="95" viewBox="0 0 98 95" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M34 42.5642V77.3386C34 77.5922 33.9798 77.8413 33.9434 78.0847C33.9797 78.4983 34 78.9165 34 79.3386C33.9998 87.8989 26.3887 94.8386 17 94.8386C7.61126 94.8386 0.000166481 87.8989 0 79.3386C0 70.7782 7.61116 63.8386 17 63.8386C19.4954 63.8386 21.8653 64.3282 24 65.2087V33.8542L34 42.5642ZM77.5293 0.158936C81.8878 -0.777668 85.9998 2.54463 86 7.00269V63.8298C86 64.021 85.9877 64.2096 85.9668 64.3953C85.9873 64.7073 86 65.0219 86 65.3386C86 66.8563 85.7594 68.3226 85.3135 69.7087L95.5176 78.5964C97.3914 80.2287 97.588 83.071 95.9561 84.9451C94.9352 86.1171 93.4407 86.6323 92.0059 86.4548L2.00098 8.06323C1.62876 6.66697 1.93473 5.11677 2.95508 3.94507C4.58736 2.07096 7.43058 1.87528 9.30469 3.50757L24.0654 16.364C24.4612 13.4828 26.6204 11.1026 29.5293 10.4773L77.5293 0.158936ZM76.2471 79.3601C74.0487 80.307 71.5927 80.8386 69 80.8386C59.6113 80.8386 52.0002 73.8989 52 65.3386C52 63.2264 52.4655 61.2137 53.3047 59.3787L76.2471 79.3601ZM76 19.1189C76 14.6176 71.8128 11.286 67.4268 12.2976L39.4268 18.7585C36.4284 19.4504 34.2554 22.0093 34.0215 25.0359L63.4648 50.6794C65.2 50.1349 67.062 49.8386 69 49.8386C71.4954 49.8386 73.8653 50.3282 76 51.2087V19.1189Z" fill="currentColor"></path></svg>'
);
function UL(s) {
    var e = VL();
    D(s, e);
}
const ce = (s) => typeof s == "string",
    Nl = () => {
        let s, e;
        const t = new Promise((n, i) => {
            (s = n), (e = i);
        });
        return (t.resolve = s), (t.reject = e), t;
    },
    mb = (s) => (s == null ? "" : "" + s),
    zL = (s, e, t) => {
        s.forEach((n) => {
            e[n] && (t[n] = e[n]);
        });
    },
    YL = /###/g,
    gb = (s) => (s && s.indexOf("###") > -1 ? s.replace(YL, ".") : s),
    _b = (s) => !s || ce(s),
    vh = (s, e, t) => {
        const n = ce(e) ? e.split(".") : e;
        let i = 0;
        for (; i < n.length - 1; ) {
            if (_b(s)) return {};
            const r = gb(n[i]);
            !s[r] && t && (s[r] = new t()),
                Object.prototype.hasOwnProperty.call(s, r)
                    ? (s = s[r])
                    : (s = {}),
                ++i;
        }
        return _b(s) ? {} : { obj: s, k: gb(n[i]) };
    },
    vb = (s, e, t) => {
        const { obj: n, k: i } = vh(s, e, Object);
        if (n !== void 0 || e.length === 1) {
            n[i] = t;
            return;
        }
        let r = e[e.length - 1],
            a = e.slice(0, e.length - 1),
            o = vh(s, a, Object);
        for (; o.obj === void 0 && a.length; )
            (r = `${a[a.length - 1]}.${r}`),
                (a = a.slice(0, a.length - 1)),
                (o = vh(s, a, Object)),
                o &&
                    o.obj &&
                    typeof o.obj[`${o.k}.${r}`] < "u" &&
                    (o.obj = void 0);
        o.obj[`${o.k}.${r}`] = t;
    },
    GL = (s, e, t, n) => {
        const { obj: i, k: r } = vh(s, e, Object);
        (i[r] = i[r] || []), i[r].push(t);
    },
    Yu = (s, e) => {
        const { obj: t, k: n } = vh(s, e);
        if (t) return t[n];
    },
    jL = (s, e, t) => {
        const n = Yu(s, t);
        return n !== void 0 ? n : Yu(e, t);
    },
    w2 = (s, e, t) => {
        for (const n in e)
            n !== "__proto__" &&
                n !== "constructor" &&
                (n in s
                    ? ce(s[n]) ||
                      s[n] instanceof String ||
                      ce(e[n]) ||
                      e[n] instanceof String
                        ? t && (s[n] = e[n])
                        : w2(s[n], e[n], t)
                    : (s[n] = e[n]));
        return s;
    },
    lo = (s) => s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var WL = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
};
const XL = (s) => (ce(s) ? s.replace(/[&<>"'\/]/g, (e) => WL[e]) : s);
class qL {
    constructor(e) {
        (this.capacity = e),
            (this.regExpMap = new Map()),
            (this.regExpQueue = []);
    }
    getRegExp(e) {
        const t = this.regExpMap.get(e);
        if (t !== void 0) return t;
        const n = new RegExp(e);
        return (
            this.regExpQueue.length === this.capacity &&
                this.regExpMap.delete(this.regExpQueue.shift()),
            this.regExpMap.set(e, n),
            this.regExpQueue.push(e),
            n
        );
    }
}
const HL = [" ", ",", "?", "!", ";"],
    KL = new qL(20),
    ZL = (s, e, t) => {
        (e = e || ""), (t = t || "");
        const n = HL.filter((a) => e.indexOf(a) < 0 && t.indexOf(a) < 0);
        if (n.length === 0) return !0;
        const i = KL.getRegExp(
            `(${n.map((a) => (a === "?" ? "\\?" : a)).join("|")})`
        );
        let r = !i.test(s);
        if (!r) {
            const a = s.indexOf(t);
            a > 0 && !i.test(s.substring(0, a)) && (r = !0);
        }
        return r;
    },
    Pm = function (s, e) {
        let t =
            arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : ".";
        if (!s) return;
        if (s[e]) return s[e];
        const n = e.split(t);
        let i = s;
        for (let r = 0; r < n.length; ) {
            if (!i || typeof i != "object") return;
            let a,
                o = "";
            for (let h = r; h < n.length; ++h)
                if (
                    (h !== r && (o += t), (o += n[h]), (a = i[o]), a !== void 0)
                ) {
                    if (
                        ["string", "number", "boolean"].indexOf(typeof a) >
                            -1 &&
                        h < n.length - 1
                    )
                        continue;
                    r += h - r + 1;
                    break;
                }
            i = a;
        }
        return i;
    },
    Gu = (s) => s && s.replace("_", "-"),
    QL = {
        type: "logger",
        log(s) {
            this.output("log", s);
        },
        warn(s) {
            this.output("warn", s);
        },
        error(s) {
            this.output("error", s);
        },
        output(s, e) {
            console && console[s] && console[s].apply(console, e);
        },
    };
class ju {
    constructor(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(e, t);
    }
    init(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (this.prefix = t.prefix || "i18next:"),
            (this.logger = e || QL),
            (this.options = t),
            (this.debug = t.debug);
    }
    log() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return this.forward(t, "log", "", !0);
    }
    warn() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return this.forward(t, "warn", "", !0);
    }
    error() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return this.forward(t, "error", "");
    }
    deprecate() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
    }
    forward(e, t, n, i) {
        return i && !this.debug
            ? null
            : (ce(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`),
              this.logger[t](e));
    }
    create(e) {
        return new ju(this.logger, {
            prefix: `${this.prefix}:${e}:`,
            ...this.options,
        });
    }
    clone(e) {
        return (
            (e = e || this.options),
            (e.prefix = e.prefix || this.prefix),
            new ju(this.logger, e)
        );
    }
}
var bi = new ju();
class Rd {
    constructor() {
        this.observers = {};
    }
    on(e, t) {
        return (
            e.split(" ").forEach((n) => {
                this.observers[n] || (this.observers[n] = new Map());
                const i = this.observers[n].get(t) || 0;
                this.observers[n].set(t, i + 1);
            }),
            this
        );
    }
    off(e, t) {
        if (this.observers[e]) {
            if (!t) {
                delete this.observers[e];
                return;
            }
            this.observers[e].delete(t);
        }
    }
    emit(e) {
        for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1;
            i < t;
            i++
        )
            n[i - 1] = arguments[i];
        this.observers[e] &&
            Array.from(this.observers[e].entries()).forEach((a) => {
                let [o, h] = a;
                for (let l = 0; l < h; l++) o(...n);
            }),
            this.observers["*"] &&
                Array.from(this.observers["*"].entries()).forEach((a) => {
                    let [o, h] = a;
                    for (let l = 0; l < h; l++) o.apply(o, [e, ...n]);
                });
    }
}
class bb extends Rd {
    constructor(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : { ns: ["translation"], defaultNS: "translation" };
        super(),
            (this.data = e || {}),
            (this.options = t),
            this.options.keySeparator === void 0 &&
                (this.options.keySeparator = "."),
            this.options.ignoreJSONStructure === void 0 &&
                (this.options.ignoreJSONStructure = !0);
    }
    addNamespaces(e) {
        this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
    }
    removeNamespaces(e) {
        const t = this.options.ns.indexOf(e);
        t > -1 && this.options.ns.splice(t, 1);
    }
    getResource(e, t, n) {
        let i =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const r =
                i.keySeparator !== void 0
                    ? i.keySeparator
                    : this.options.keySeparator,
            a =
                i.ignoreJSONStructure !== void 0
                    ? i.ignoreJSONStructure
                    : this.options.ignoreJSONStructure;
        let o;
        e.indexOf(".") > -1
            ? (o = e.split("."))
            : ((o = [e, t]),
              n &&
                  (Array.isArray(n)
                      ? o.push(...n)
                      : ce(n) && r
                      ? o.push(...n.split(r))
                      : o.push(n)));
        const h = Yu(this.data, o);
        return (
            !h &&
                !t &&
                !n &&
                e.indexOf(".") > -1 &&
                ((e = o[0]), (t = o[1]), (n = o.slice(2).join("."))),
            h || !a || !ce(n)
                ? h
                : Pm(this.data && this.data[e] && this.data[e][t], n, r)
        );
    }
    addResource(e, t, n, i) {
        let r =
            arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : { silent: !1 };
        const a =
            r.keySeparator !== void 0
                ? r.keySeparator
                : this.options.keySeparator;
        let o = [e, t];
        n && (o = o.concat(a ? n.split(a) : n)),
            e.indexOf(".") > -1 && ((o = e.split(".")), (i = t), (t = o[1])),
            this.addNamespaces(t),
            vb(this.data, o, i),
            r.silent || this.emit("added", e, t, n, i);
    }
    addResources(e, t, n) {
        let i =
            arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : { silent: !1 };
        for (const r in n)
            (ce(n[r]) || Array.isArray(n[r])) &&
                this.addResource(e, t, r, n[r], { silent: !0 });
        i.silent || this.emit("added", e, t, n);
    }
    addResourceBundle(e, t, n, i, r) {
        let a =
                arguments.length > 5 && arguments[5] !== void 0
                    ? arguments[5]
                    : { silent: !1, skipCopy: !1 },
            o = [e, t];
        e.indexOf(".") > -1 &&
            ((o = e.split(".")), (i = n), (n = t), (t = o[1])),
            this.addNamespaces(t);
        let h = Yu(this.data, o) || {};
        a.skipCopy || (n = JSON.parse(JSON.stringify(n))),
            i ? w2(h, n, r) : (h = { ...h, ...n }),
            vb(this.data, o, h),
            a.silent || this.emit("added", e, t, n);
    }
    removeResourceBundle(e, t) {
        this.hasResourceBundle(e, t) && delete this.data[e][t],
            this.removeNamespaces(t),
            this.emit("removed", e, t);
    }
    hasResourceBundle(e, t) {
        return this.getResource(e, t) !== void 0;
    }
    getResourceBundle(e, t) {
        return (
            t || (t = this.options.defaultNS),
            this.options.compatibilityAPI === "v1"
                ? { ...this.getResource(e, t) }
                : this.getResource(e, t)
        );
    }
    getDataByLanguage(e) {
        return this.data[e];
    }
    hasLanguageSomeTranslations(e) {
        const t = this.getDataByLanguage(e);
        return !!((t && Object.keys(t)) || []).find(
            (i) => t[i] && Object.keys(t[i]).length > 0
        );
    }
    toJSON() {
        return this.data;
    }
}
var x2 = {
    processors: {},
    addPostProcessor(s) {
        this.processors[s.name] = s;
    },
    handle(s, e, t, n, i) {
        return (
            s.forEach((r) => {
                this.processors[r] &&
                    (e = this.processors[r].process(e, t, n, i));
            }),
            e
        );
    },
};
const yb = {};
class Wu extends Rd {
    constructor(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(),
            zL(
                [
                    "resourceStore",
                    "languageUtils",
                    "pluralResolver",
                    "interpolator",
                    "backendConnector",
                    "i18nFormat",
                    "utils",
                ],
                e,
                this
            ),
            (this.options = t),
            this.options.keySeparator === void 0 &&
                (this.options.keySeparator = "."),
            (this.logger = bi.create("translator"));
    }
    changeLanguage(e) {
        e && (this.language = e);
    }
    exists(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : { interpolation: {} };
        if (e == null) return !1;
        const n = this.resolve(e, t);
        return n && n.res !== void 0;
    }
    extractFromKey(e, t) {
        let n =
            t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
        n === void 0 && (n = ":");
        const i =
            t.keySeparator !== void 0
                ? t.keySeparator
                : this.options.keySeparator;
        let r = t.ns || this.options.defaultNS || [];
        const a = n && e.indexOf(n) > -1,
            o =
                !this.options.userDefinedKeySeparator &&
                !t.keySeparator &&
                !this.options.userDefinedNsSeparator &&
                !t.nsSeparator &&
                !ZL(e, n, i);
        if (a && !o) {
            const h = e.match(this.interpolator.nestingRegexp);
            if (h && h.length > 0)
                return { key: e, namespaces: ce(r) ? [r] : r };
            const l = e.split(n);
            (n !== i || (n === i && this.options.ns.indexOf(l[0]) > -1)) &&
                (r = l.shift()),
                (e = l.join(i));
        }
        return { key: e, namespaces: ce(r) ? [r] : r };
    }
    translate(e, t, n) {
        if (
            (typeof t != "object" &&
                this.options.overloadTranslationOptionHandler &&
                (t = this.options.overloadTranslationOptionHandler(arguments)),
            typeof t == "object" && (t = { ...t }),
            t || (t = {}),
            e == null)
        )
            return "";
        Array.isArray(e) || (e = [String(e)]);
        const i =
                t.returnDetails !== void 0
                    ? t.returnDetails
                    : this.options.returnDetails,
            r =
                t.keySeparator !== void 0
                    ? t.keySeparator
                    : this.options.keySeparator,
            { key: a, namespaces: o } = this.extractFromKey(e[e.length - 1], t),
            h = o[o.length - 1],
            l = t.lng || this.language,
            u =
                t.appendNamespaceToCIMode ||
                this.options.appendNamespaceToCIMode;
        if (l && l.toLowerCase() === "cimode") {
            if (u) {
                const y = t.nsSeparator || this.options.nsSeparator;
                return i
                    ? {
                          res: `${h}${y}${a}`,
                          usedKey: a,
                          exactUsedKey: a,
                          usedLng: l,
                          usedNS: h,
                          usedParams: this.getUsedParamsDetails(t),
                      }
                    : `${h}${y}${a}`;
            }
            return i
                ? {
                      res: a,
                      usedKey: a,
                      exactUsedKey: a,
                      usedLng: l,
                      usedNS: h,
                      usedParams: this.getUsedParamsDetails(t),
                  }
                : a;
        }
        const c = this.resolve(e, t);
        let d = c && c.res;
        const f = (c && c.usedKey) || a,
            p = (c && c.exactUsedKey) || a,
            m = Object.prototype.toString.apply(d),
            g = ["[object Number]", "[object Function]", "[object RegExp]"],
            _ =
                t.joinArrays !== void 0
                    ? t.joinArrays
                    : this.options.joinArrays,
            v = !this.i18nFormat || this.i18nFormat.handleAsObject,
            b = !ce(d) && typeof d != "boolean" && typeof d != "number";
        if (v && d && b && g.indexOf(m) < 0 && !(ce(_) && Array.isArray(d))) {
            if (!t.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler ||
                    this.logger.warn(
                        "accessing an object - but returnObjects options is not enabled!"
                    );
                const y = this.options.returnedObjectHandler
                    ? this.options.returnedObjectHandler(f, d, { ...t, ns: o })
                    : `key '${a} (${this.language})' returned an object instead of string.`;
                return i
                    ? ((c.res = y),
                      (c.usedParams = this.getUsedParamsDetails(t)),
                      c)
                    : y;
            }
            if (r) {
                const y = Array.isArray(d),
                    C = y ? [] : {},
                    w = y ? p : f;
                for (const A in d)
                    if (Object.prototype.hasOwnProperty.call(d, A)) {
                        const E = `${w}${r}${A}`;
                        (C[A] = this.translate(E, {
                            ...t,
                            joinArrays: !1,
                            ns: o,
                        })),
                            C[A] === E && (C[A] = d[A]);
                    }
                d = C;
            }
        } else if (v && ce(_) && Array.isArray(d))
            (d = d.join(_)), d && (d = this.extendTranslation(d, e, t, n));
        else {
            let y = !1,
                C = !1;
            const w = t.count !== void 0 && !ce(t.count),
                A = Wu.hasDefaultValue(t),
                E = w ? this.pluralResolver.getSuffix(l, t.count, t) : "",
                S =
                    t.ordinal && w
                        ? this.pluralResolver.getSuffix(l, t.count, {
                              ordinal: !1,
                          })
                        : "",
                P =
                    w &&
                    !t.ordinal &&
                    t.count === 0 &&
                    this.pluralResolver.shouldUseIntlApi(),
                k =
                    (P &&
                        t[`defaultValue${this.options.pluralSeparator}zero`]) ||
                    t[`defaultValue${E}`] ||
                    t[`defaultValue${S}`] ||
                    t.defaultValue;
            !this.isValidLookup(d) && A && ((y = !0), (d = k)),
                this.isValidLookup(d) || ((C = !0), (d = a));
            const M =
                    (t.missingKeyNoValueFallbackToKey ||
                        this.options.missingKeyNoValueFallbackToKey) &&
                    C
                        ? void 0
                        : d,
                T = A && k !== d && this.options.updateMissing;
            if (C || y || T) {
                if (
                    (this.logger.log(
                        T ? "updateKey" : "missingKey",
                        l,
                        h,
                        a,
                        T ? k : d
                    ),
                    r)
                ) {
                    const Y = this.resolve(a, { ...t, keySeparator: !1 });
                    Y &&
                        Y.res &&
                        this.logger.warn(
                            "Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format."
                        );
                }
                let O = [];
                const L = this.languageUtils.getFallbackCodes(
                    this.options.fallbackLng,
                    t.lng || this.language
                );
                if (this.options.saveMissingTo === "fallback" && L && L[0])
                    for (let Y = 0; Y < L.length; Y++) O.push(L[Y]);
                else
                    this.options.saveMissingTo === "all"
                        ? (O = this.languageUtils.toResolveHierarchy(
                              t.lng || this.language
                          ))
                        : O.push(t.lng || this.language);
                const F = (Y, V, W) => {
                    const Z = A && W !== d ? W : M;
                    this.options.missingKeyHandler
                        ? this.options.missingKeyHandler(Y, h, V, Z, T, t)
                        : this.backendConnector &&
                          this.backendConnector.saveMissing &&
                          this.backendConnector.saveMissing(Y, h, V, Z, T, t),
                        this.emit("missingKey", Y, h, V, d);
                };
                this.options.saveMissing &&
                    (this.options.saveMissingPlurals && w
                        ? O.forEach((Y) => {
                              const V = this.pluralResolver.getSuffixes(Y, t);
                              P &&
                                  t[
                                      `defaultValue${this.options.pluralSeparator}zero`
                                  ] &&
                                  V.indexOf(
                                      `${this.options.pluralSeparator}zero`
                                  ) < 0 &&
                                  V.push(`${this.options.pluralSeparator}zero`),
                                  V.forEach((W) => {
                                      F([Y], a + W, t[`defaultValue${W}`] || k);
                                  });
                          })
                        : F(O, a, k));
            }
            (d = this.extendTranslation(d, e, t, c, n)),
                C &&
                    d === a &&
                    this.options.appendNamespaceToMissingKey &&
                    (d = `${h}:${a}`),
                (C || y) &&
                    this.options.parseMissingKeyHandler &&
                    (this.options.compatibilityAPI !== "v1"
                        ? (d = this.options.parseMissingKeyHandler(
                              this.options.appendNamespaceToMissingKey
                                  ? `${h}:${a}`
                                  : a,
                              y ? d : void 0
                          ))
                        : (d = this.options.parseMissingKeyHandler(d)));
        }
        return i
            ? ((c.res = d), (c.usedParams = this.getUsedParamsDetails(t)), c)
            : d;
    }
    extendTranslation(e, t, n, i, r) {
        var a = this;
        if (this.i18nFormat && this.i18nFormat.parse)
            e = this.i18nFormat.parse(
                e,
                { ...this.options.interpolation.defaultVariables, ...n },
                n.lng || this.language || i.usedLng,
                i.usedNS,
                i.usedKey,
                { resolved: i }
            );
        else if (!n.skipInterpolation) {
            n.interpolation &&
                this.interpolator.init({
                    ...n,
                    interpolation: {
                        ...this.options.interpolation,
                        ...n.interpolation,
                    },
                });
            const l =
                ce(e) &&
                (n &&
                n.interpolation &&
                n.interpolation.skipOnVariables !== void 0
                    ? n.interpolation.skipOnVariables
                    : this.options.interpolation.skipOnVariables);
            let u;
            if (l) {
                const d = e.match(this.interpolator.nestingRegexp);
                u = d && d.length;
            }
            let c = n.replace && !ce(n.replace) ? n.replace : n;
            if (
                (this.options.interpolation.defaultVariables &&
                    (c = {
                        ...this.options.interpolation.defaultVariables,
                        ...c,
                    }),
                (e = this.interpolator.interpolate(
                    e,
                    c,
                    n.lng || this.language || i.usedLng,
                    n
                )),
                l)
            ) {
                const d = e.match(this.interpolator.nestingRegexp),
                    f = d && d.length;
                u < f && (n.nest = !1);
            }
            !n.lng &&
                this.options.compatibilityAPI !== "v1" &&
                i &&
                i.res &&
                (n.lng = this.language || i.usedLng),
                n.nest !== !1 &&
                    (e = this.interpolator.nest(
                        e,
                        function () {
                            for (
                                var d = arguments.length,
                                    f = new Array(d),
                                    p = 0;
                                p < d;
                                p++
                            )
                                f[p] = arguments[p];
                            return r && r[0] === f[0] && !n.context
                                ? (a.logger.warn(
                                      `It seems you are nesting recursively key: ${f[0]} in key: ${t[0]}`
                                  ),
                                  null)
                                : a.translate(...f, t);
                        },
                        n
                    )),
                n.interpolation && this.interpolator.reset();
        }
        const o = n.postProcess || this.options.postProcess,
            h = ce(o) ? [o] : o;
        return (
            e != null &&
                h &&
                h.length &&
                n.applyPostProcessor !== !1 &&
                (e = x2.handle(
                    h,
                    e,
                    t,
                    this.options && this.options.postProcessPassResolved
                        ? {
                              i18nResolved: {
                                  ...i,
                                  usedParams: this.getUsedParamsDetails(n),
                              },
                              ...n,
                          }
                        : n,
                    this
                )),
            e
        );
    }
    resolve(e) {
        let t =
                arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
            n,
            i,
            r,
            a,
            o;
        return (
            ce(e) && (e = [e]),
            e.forEach((h) => {
                if (this.isValidLookup(n)) return;
                const l = this.extractFromKey(h, t),
                    u = l.key;
                i = u;
                let c = l.namespaces;
                this.options.fallbackNS &&
                    (c = c.concat(this.options.fallbackNS));
                const d = t.count !== void 0 && !ce(t.count),
                    f =
                        d &&
                        !t.ordinal &&
                        t.count === 0 &&
                        this.pluralResolver.shouldUseIntlApi(),
                    p =
                        t.context !== void 0 &&
                        (ce(t.context) || typeof t.context == "number") &&
                        t.context !== "",
                    m = t.lngs
                        ? t.lngs
                        : this.languageUtils.toResolveHierarchy(
                              t.lng || this.language,
                              t.fallbackLng
                          );
                c.forEach((g) => {
                    this.isValidLookup(n) ||
                        ((o = g),
                        !yb[`${m[0]}-${g}`] &&
                            this.utils &&
                            this.utils.hasLoadedNamespace &&
                            !this.utils.hasLoadedNamespace(o) &&
                            ((yb[`${m[0]}-${g}`] = !0),
                            this.logger.warn(
                                `key "${i}" for languages "${m.join(
                                    ", "
                                )}" won't get resolved as namespace "${o}" was not yet loaded`,
                                "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
                            )),
                        m.forEach((_) => {
                            if (this.isValidLookup(n)) return;
                            a = _;
                            const v = [u];
                            if (
                                this.i18nFormat &&
                                this.i18nFormat.addLookupKeys
                            )
                                this.i18nFormat.addLookupKeys(v, u, _, g, t);
                            else {
                                let y;
                                d &&
                                    (y = this.pluralResolver.getSuffix(
                                        _,
                                        t.count,
                                        t
                                    ));
                                const C = `${this.options.pluralSeparator}zero`,
                                    w = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                                if (
                                    (d &&
                                        (v.push(u + y),
                                        t.ordinal &&
                                            y.indexOf(w) === 0 &&
                                            v.push(
                                                u +
                                                    y.replace(
                                                        w,
                                                        this.options
                                                            .pluralSeparator
                                                    )
                                            ),
                                        f && v.push(u + C)),
                                    p)
                                ) {
                                    const A = `${u}${this.options.contextSeparator}${t.context}`;
                                    v.push(A),
                                        d &&
                                            (v.push(A + y),
                                            t.ordinal &&
                                                y.indexOf(w) === 0 &&
                                                v.push(
                                                    A +
                                                        y.replace(
                                                            w,
                                                            this.options
                                                                .pluralSeparator
                                                        )
                                                ),
                                            f && v.push(A + C));
                                }
                            }
                            let b;
                            for (; (b = v.pop()); )
                                this.isValidLookup(n) ||
                                    ((r = b),
                                    (n = this.getResource(_, g, b, t)));
                        }));
                });
            }),
            { res: n, usedKey: i, exactUsedKey: r, usedLng: a, usedNS: o }
        );
    }
    isValidLookup(e) {
        return (
            e !== void 0 &&
            !(!this.options.returnNull && e === null) &&
            !(!this.options.returnEmptyString && e === "")
        );
    }
    getResource(e, t, n) {
        let i =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource
            ? this.i18nFormat.getResource(e, t, n, i)
            : this.resourceStore.getResource(e, t, n, i);
    }
    getUsedParamsDetails() {
        let e =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const t = [
                "defaultValue",
                "ordinal",
                "context",
                "replace",
                "lng",
                "lngs",
                "fallbackLng",
                "ns",
                "keySeparator",
                "nsSeparator",
                "returnObjects",
                "returnDetails",
                "joinArrays",
                "postProcess",
                "interpolation",
            ],
            n = e.replace && !ce(e.replace);
        let i = n ? e.replace : e;
        if (
            (n && typeof e.count < "u" && (i.count = e.count),
            this.options.interpolation.defaultVariables &&
                (i = { ...this.options.interpolation.defaultVariables, ...i }),
            !n)
        ) {
            i = { ...i };
            for (const r of t) delete i[r];
        }
        return i;
    }
    static hasDefaultValue(e) {
        const t = "defaultValue";
        for (const n in e)
            if (
                Object.prototype.hasOwnProperty.call(e, n) &&
                t === n.substring(0, t.length) &&
                e[n] !== void 0
            )
                return !0;
        return !1;
    }
}
const ip = (s) => s.charAt(0).toUpperCase() + s.slice(1);
class wb {
    constructor(e) {
        (this.options = e),
            (this.supportedLngs = this.options.supportedLngs || !1),
            (this.logger = bi.create("languageUtils"));
    }
    getScriptPartFromCode(e) {
        if (((e = Gu(e)), !e || e.indexOf("-") < 0)) return null;
        const t = e.split("-");
        return t.length === 2 ||
            (t.pop(), t[t.length - 1].toLowerCase() === "x")
            ? null
            : this.formatLanguageCode(t.join("-"));
    }
    getLanguagePartFromCode(e) {
        if (((e = Gu(e)), !e || e.indexOf("-") < 0)) return e;
        const t = e.split("-");
        return this.formatLanguageCode(t[0]);
    }
    formatLanguageCode(e) {
        if (ce(e) && e.indexOf("-") > -1) {
            if (typeof Intl < "u" && typeof Intl.getCanonicalLocales < "u")
                try {
                    let i = Intl.getCanonicalLocales(e)[0];
                    if (
                        (i &&
                            this.options.lowerCaseLng &&
                            (i = i.toLowerCase()),
                        i)
                    )
                        return i;
                } catch {}
            const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            let n = e.split("-");
            return (
                this.options.lowerCaseLng
                    ? (n = n.map((i) => i.toLowerCase()))
                    : n.length === 2
                    ? ((n[0] = n[0].toLowerCase()),
                      (n[1] = n[1].toUpperCase()),
                      t.indexOf(n[1].toLowerCase()) > -1 &&
                          (n[1] = ip(n[1].toLowerCase())))
                    : n.length === 3 &&
                      ((n[0] = n[0].toLowerCase()),
                      n[1].length === 2 && (n[1] = n[1].toUpperCase()),
                      n[0] !== "sgn" &&
                          n[2].length === 2 &&
                          (n[2] = n[2].toUpperCase()),
                      t.indexOf(n[1].toLowerCase()) > -1 &&
                          (n[1] = ip(n[1].toLowerCase())),
                      t.indexOf(n[2].toLowerCase()) > -1 &&
                          (n[2] = ip(n[2].toLowerCase()))),
                n.join("-")
            );
        }
        return this.options.cleanCode || this.options.lowerCaseLng
            ? e.toLowerCase()
            : e;
    }
    isSupportedCode(e) {
        return (
            (this.options.load === "languageOnly" ||
                this.options.nonExplicitSupportedLngs) &&
                (e = this.getLanguagePartFromCode(e)),
            !this.supportedLngs ||
                !this.supportedLngs.length ||
                this.supportedLngs.indexOf(e) > -1
        );
    }
    getBestMatchFromCodes(e) {
        if (!e) return null;
        let t;
        return (
            e.forEach((n) => {
                if (t) return;
                const i = this.formatLanguageCode(n);
                (!this.options.supportedLngs || this.isSupportedCode(i)) &&
                    (t = i);
            }),
            !t &&
                this.options.supportedLngs &&
                e.forEach((n) => {
                    if (t) return;
                    const i = this.getLanguagePartFromCode(n);
                    if (this.isSupportedCode(i)) return (t = i);
                    t = this.options.supportedLngs.find((r) => {
                        if (r === i) return r;
                        if (
                            !(r.indexOf("-") < 0 && i.indexOf("-") < 0) &&
                            ((r.indexOf("-") > 0 &&
                                i.indexOf("-") < 0 &&
                                r.substring(0, r.indexOf("-")) === i) ||
                                (r.indexOf(i) === 0 && i.length > 1))
                        )
                            return r;
                    });
                }),
            t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
            t
        );
    }
    getFallbackCodes(e, t) {
        if (!e) return [];
        if (
            (typeof e == "function" && (e = e(t)),
            ce(e) && (e = [e]),
            Array.isArray(e))
        )
            return e;
        if (!t) return e.default || [];
        let n = e[t];
        return (
            n || (n = e[this.getScriptPartFromCode(t)]),
            n || (n = e[this.formatLanguageCode(t)]),
            n || (n = e[this.getLanguagePartFromCode(t)]),
            n || (n = e.default),
            n || []
        );
    }
    toResolveHierarchy(e, t) {
        const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e),
            i = [],
            r = (a) => {
                a &&
                    (this.isSupportedCode(a)
                        ? i.push(a)
                        : this.logger.warn(
                              `rejecting language code not found in supportedLngs: ${a}`
                          ));
            };
        return (
            ce(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1)
                ? (this.options.load !== "languageOnly" &&
                      r(this.formatLanguageCode(e)),
                  this.options.load !== "languageOnly" &&
                      this.options.load !== "currentOnly" &&
                      r(this.getScriptPartFromCode(e)),
                  this.options.load !== "currentOnly" &&
                      r(this.getLanguagePartFromCode(e)))
                : ce(e) && r(this.formatLanguageCode(e)),
            n.forEach((a) => {
                i.indexOf(a) < 0 && r(this.formatLanguageCode(a));
            }),
            i
        );
    }
}
let JL = [
        {
            lngs: [
                "ach",
                "ak",
                "am",
                "arn",
                "br",
                "fil",
                "gun",
                "ln",
                "mfe",
                "mg",
                "mi",
                "oc",
                "pt",
                "pt-BR",
                "tg",
                "tl",
                "ti",
                "tr",
                "uz",
                "wa",
            ],
            nr: [1, 2],
            fc: 1,
        },
        {
            lngs: [
                "af",
                "an",
                "ast",
                "az",
                "bg",
                "bn",
                "ca",
                "da",
                "de",
                "dev",
                "el",
                "en",
                "eo",
                "es",
                "et",
                "eu",
                "fi",
                "fo",
                "fur",
                "fy",
                "gl",
                "gu",
                "ha",
                "hi",
                "hu",
                "hy",
                "ia",
                "it",
                "kk",
                "kn",
                "ku",
                "lb",
                "mai",
                "ml",
                "mn",
                "mr",
                "nah",
                "nap",
                "nb",
                "ne",
                "nl",
                "nn",
                "no",
                "nso",
                "pa",
                "pap",
                "pms",
                "ps",
                "pt-PT",
                "rm",
                "sco",
                "se",
                "si",
                "so",
                "son",
                "sq",
                "sv",
                "sw",
                "ta",
                "te",
                "tk",
                "ur",
                "yo",
            ],
            nr: [1, 2],
            fc: 2,
        },
        {
            lngs: [
                "ay",
                "bo",
                "cgg",
                "fa",
                "ht",
                "id",
                "ja",
                "jbo",
                "ka",
                "km",
                "ko",
                "ky",
                "lo",
                "ms",
                "sah",
                "su",
                "th",
                "tt",
                "ug",
                "vi",
                "wo",
                "zh",
            ],
            nr: [1],
            fc: 3,
        },
        {
            lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
            nr: [1, 2, 5],
            fc: 4,
        },
        { lngs: ["ar"], nr: [0, 1, 2, 3, 11, 100], fc: 5 },
        { lngs: ["cs", "sk"], nr: [1, 2, 5], fc: 6 },
        { lngs: ["csb", "pl"], nr: [1, 2, 5], fc: 7 },
        { lngs: ["cy"], nr: [1, 2, 3, 8], fc: 8 },
        { lngs: ["fr"], nr: [1, 2], fc: 9 },
        { lngs: ["ga"], nr: [1, 2, 3, 7, 11], fc: 10 },
        { lngs: ["gd"], nr: [1, 2, 3, 20], fc: 11 },
        { lngs: ["is"], nr: [1, 2], fc: 12 },
        { lngs: ["jv"], nr: [0, 1], fc: 13 },
        { lngs: ["kw"], nr: [1, 2, 3, 4], fc: 14 },
        { lngs: ["lt"], nr: [1, 2, 10], fc: 15 },
        { lngs: ["lv"], nr: [1, 2, 0], fc: 16 },
        { lngs: ["mk"], nr: [1, 2], fc: 17 },
        { lngs: ["mnk"], nr: [0, 1, 2], fc: 18 },
        { lngs: ["mt"], nr: [1, 2, 11, 20], fc: 19 },
        { lngs: ["or"], nr: [2, 1], fc: 2 },
        { lngs: ["ro"], nr: [1, 2, 20], fc: 20 },
        { lngs: ["sl"], nr: [5, 1, 2, 3], fc: 21 },
        { lngs: ["he", "iw"], nr: [1, 2, 20, 21], fc: 22 },
    ],
    eO = {
        1: (s) => +(s > 1),
        2: (s) => +(s != 1),
        3: (s) => 0,
        4: (s) =>
            s % 10 == 1 && s % 100 != 11
                ? 0
                : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20)
                ? 1
                : 2,
        5: (s) =>
            s == 0
                ? 0
                : s == 1
                ? 1
                : s == 2
                ? 2
                : s % 100 >= 3 && s % 100 <= 10
                ? 3
                : s % 100 >= 11
                ? 4
                : 5,
        6: (s) => (s == 1 ? 0 : s >= 2 && s <= 4 ? 1 : 2),
        7: (s) =>
            s == 1
                ? 0
                : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20)
                ? 1
                : 2,
        8: (s) => (s == 1 ? 0 : s == 2 ? 1 : s != 8 && s != 11 ? 2 : 3),
        9: (s) => +(s >= 2),
        10: (s) => (s == 1 ? 0 : s == 2 ? 1 : s < 7 ? 2 : s < 11 ? 3 : 4),
        11: (s) =>
            s == 1 || s == 11
                ? 0
                : s == 2 || s == 12
                ? 1
                : s > 2 && s < 20
                ? 2
                : 3,
        12: (s) => +(s % 10 != 1 || s % 100 == 11),
        13: (s) => +(s !== 0),
        14: (s) => (s == 1 ? 0 : s == 2 ? 1 : s == 3 ? 2 : 3),
        15: (s) =>
            s % 10 == 1 && s % 100 != 11
                ? 0
                : s % 10 >= 2 && (s % 100 < 10 || s % 100 >= 20)
                ? 1
                : 2,
        16: (s) => (s % 10 == 1 && s % 100 != 11 ? 0 : s !== 0 ? 1 : 2),
        17: (s) => (s == 1 || (s % 10 == 1 && s % 100 != 11) ? 0 : 1),
        18: (s) => (s == 0 ? 0 : s == 1 ? 1 : 2),
        19: (s) =>
            s == 1
                ? 0
                : s == 0 || (s % 100 > 1 && s % 100 < 11)
                ? 1
                : s % 100 > 10 && s % 100 < 20
                ? 2
                : 3,
        20: (s) =>
            s == 1 ? 0 : s == 0 || (s % 100 > 0 && s % 100 < 20) ? 1 : 2,
        21: (s) =>
            s % 100 == 1
                ? 1
                : s % 100 == 2
                ? 2
                : s % 100 == 3 || s % 100 == 4
                ? 3
                : 0,
        22: (s) =>
            s == 1 ? 0 : s == 2 ? 1 : (s < 0 || s > 10) && s % 10 == 0 ? 2 : 3,
    };
const tO = ["v1", "v2", "v3"],
    nO = ["v4"],
    xb = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 },
    sO = () => {
        const s = {};
        return (
            JL.forEach((e) => {
                e.lngs.forEach((t) => {
                    s[t] = { numbers: e.nr, plurals: eO[e.fc] };
                });
            }),
            s
        );
    };
class iO {
    constructor(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (this.languageUtils = e),
            (this.options = t),
            (this.logger = bi.create("pluralResolver")),
            (!this.options.compatibilityJSON ||
                nO.includes(this.options.compatibilityJSON)) &&
                (typeof Intl > "u" || !Intl.PluralRules) &&
                ((this.options.compatibilityJSON = "v3"),
                this.logger.error(
                    "Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling."
                )),
            (this.rules = sO()),
            (this.pluralRulesCache = {});
    }
    addRule(e, t) {
        this.rules[e] = t;
    }
    clearCache() {
        this.pluralRulesCache = {};
    }
    getRule(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi()) {
            const n = Gu(e === "dev" ? "en" : e),
                i = t.ordinal ? "ordinal" : "cardinal",
                r = JSON.stringify({ cleanedCode: n, type: i });
            if (r in this.pluralRulesCache) return this.pluralRulesCache[r];
            let a;
            try {
                a = new Intl.PluralRules(n, { type: i });
            } catch {
                if (!e.match(/-|_/)) return;
                const h = this.languageUtils.getLanguagePartFromCode(e);
                a = this.getRule(h, t);
            }
            return (this.pluralRulesCache[r] = a), a;
        }
        return (
            this.rules[e] ||
            this.rules[this.languageUtils.getLanguagePartFromCode(e)]
        );
    }
    needsPlural(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const n = this.getRule(e, t);
        return this.shouldUseIntlApi()
            ? n && n.resolvedOptions().pluralCategories.length > 1
            : n && n.numbers.length > 1;
    }
    getPluralFormsOfKey(e, t) {
        let n =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(e, n).map((i) => `${t}${i}`);
    }
    getSuffixes(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const n = this.getRule(e, t);
        return n
            ? this.shouldUseIntlApi()
                ? n
                      .resolvedOptions()
                      .pluralCategories.sort((i, r) => xb[i] - xb[r])
                      .map(
                          (i) =>
                              `${this.options.prepend}${
                                  t.ordinal
                                      ? `ordinal${this.options.prepend}`
                                      : ""
                              }${i}`
                      )
                : n.numbers.map((i) => this.getSuffix(e, i, t))
            : [];
    }
    getSuffix(e, t) {
        let n =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const i = this.getRule(e, n);
        return i
            ? this.shouldUseIntlApi()
                ? `${this.options.prepend}${
                      n.ordinal ? `ordinal${this.options.prepend}` : ""
                  }${i.select(t)}`
                : this.getSuffixRetroCompatible(i, t)
            : (this.logger.warn(`no plural rule found for: ${e}`), "");
    }
    getSuffixRetroCompatible(e, t) {
        const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
        let i = e.numbers[n];
        this.options.simplifyPluralSuffix &&
            e.numbers.length === 2 &&
            e.numbers[0] === 1 &&
            (i === 2 ? (i = "plural") : i === 1 && (i = ""));
        const r = () =>
            this.options.prepend && i.toString()
                ? this.options.prepend + i.toString()
                : i.toString();
        return this.options.compatibilityJSON === "v1"
            ? i === 1
                ? ""
                : typeof i == "number"
                ? `_plural_${i.toString()}`
                : r()
            : this.options.compatibilityJSON === "v2" ||
              (this.options.simplifyPluralSuffix &&
                  e.numbers.length === 2 &&
                  e.numbers[0] === 1)
            ? r()
            : this.options.prepend && n.toString()
            ? this.options.prepend + n.toString()
            : n.toString();
    }
    shouldUseIntlApi() {
        return !tO.includes(this.options.compatibilityJSON);
    }
}
const Cb = function (s, e, t) {
        let n =
                arguments.length > 3 && arguments[3] !== void 0
                    ? arguments[3]
                    : ".",
            i =
                arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : !0,
            r = jL(s, e, t);
        return (
            !r &&
                i &&
                ce(t) &&
                ((r = Pm(s, t, n)), r === void 0 && (r = Pm(e, t, n))),
            r
        );
    },
    rp = (s) => s.replace(/\$/g, "$$$$");
class rO {
    constructor() {
        let e =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        (this.logger = bi.create("interpolator")),
            (this.options = e),
            (this.format =
                (e.interpolation && e.interpolation.format) || ((t) => t)),
            this.init(e);
    }
    init() {
        let e =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        e.interpolation || (e.interpolation = { escapeValue: !0 });
        const {
            escape: t,
            escapeValue: n,
            useRawValueToEscape: i,
            prefix: r,
            prefixEscaped: a,
            suffix: o,
            suffixEscaped: h,
            formatSeparator: l,
            unescapeSuffix: u,
            unescapePrefix: c,
            nestingPrefix: d,
            nestingPrefixEscaped: f,
            nestingSuffix: p,
            nestingSuffixEscaped: m,
            nestingOptionsSeparator: g,
            maxReplaces: _,
            alwaysFormat: v,
        } = e.interpolation;
        (this.escape = t !== void 0 ? t : XL),
            (this.escapeValue = n !== void 0 ? n : !0),
            (this.useRawValueToEscape = i !== void 0 ? i : !1),
            (this.prefix = r ? lo(r) : a || "{{"),
            (this.suffix = o ? lo(o) : h || "}}"),
            (this.formatSeparator = l || ","),
            (this.unescapePrefix = u ? "" : c || "-"),
            (this.unescapeSuffix = this.unescapePrefix ? "" : u || ""),
            (this.nestingPrefix = d ? lo(d) : f || lo("$t(")),
            (this.nestingSuffix = p ? lo(p) : m || lo(")")),
            (this.nestingOptionsSeparator = g || ","),
            (this.maxReplaces = _ || 1e3),
            (this.alwaysFormat = v !== void 0 ? v : !1),
            this.resetRegExp();
    }
    reset() {
        this.options && this.init(this.options);
    }
    resetRegExp() {
        const e = (t, n) =>
            t && t.source === n ? ((t.lastIndex = 0), t) : new RegExp(n, "g");
        (this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`)),
            (this.regexpUnescape = e(
                this.regexpUnescape,
                `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`
            )),
            (this.nestingRegexp = e(
                this.nestingRegexp,
                `${this.nestingPrefix}(.+?)${this.nestingSuffix}`
            ));
    }
    interpolate(e, t, n, i) {
        let r, a, o;
        const h =
                (this.options &&
                    this.options.interpolation &&
                    this.options.interpolation.defaultVariables) ||
                {},
            l = (f) => {
                if (f.indexOf(this.formatSeparator) < 0) {
                    const _ = Cb(
                        t,
                        h,
                        f,
                        this.options.keySeparator,
                        this.options.ignoreJSONStructure
                    );
                    return this.alwaysFormat
                        ? this.format(_, void 0, n, {
                              ...i,
                              ...t,
                              interpolationkey: f,
                          })
                        : _;
                }
                const p = f.split(this.formatSeparator),
                    m = p.shift().trim(),
                    g = p.join(this.formatSeparator).trim();
                return this.format(
                    Cb(
                        t,
                        h,
                        m,
                        this.options.keySeparator,
                        this.options.ignoreJSONStructure
                    ),
                    g,
                    n,
                    { ...i, ...t, interpolationkey: m }
                );
            };
        this.resetRegExp();
        const u =
                (i && i.missingInterpolationHandler) ||
                this.options.missingInterpolationHandler,
            c =
                i &&
                i.interpolation &&
                i.interpolation.skipOnVariables !== void 0
                    ? i.interpolation.skipOnVariables
                    : this.options.interpolation.skipOnVariables;
        return (
            [
                { regex: this.regexpUnescape, safeValue: (f) => rp(f) },
                {
                    regex: this.regexp,
                    safeValue: (f) =>
                        this.escapeValue ? rp(this.escape(f)) : rp(f),
                },
            ].forEach((f) => {
                for (o = 0; (r = f.regex.exec(e)); ) {
                    const p = r[1].trim();
                    if (((a = l(p)), a === void 0))
                        if (typeof u == "function") {
                            const g = u(e, r, i);
                            a = ce(g) ? g : "";
                        } else if (
                            i &&
                            Object.prototype.hasOwnProperty.call(i, p)
                        )
                            a = "";
                        else if (c) {
                            a = r[0];
                            continue;
                        } else
                            this.logger.warn(
                                `missed to pass in variable ${p} for interpolating ${e}`
                            ),
                                (a = "");
                    else !ce(a) && !this.useRawValueToEscape && (a = mb(a));
                    const m = f.safeValue(a);
                    if (
                        ((e = e.replace(r[0], m)),
                        c
                            ? ((f.regex.lastIndex += a.length),
                              (f.regex.lastIndex -= r[0].length))
                            : (f.regex.lastIndex = 0),
                        o++,
                        o >= this.maxReplaces)
                    )
                        break;
                }
            }),
            e
        );
    }
    nest(e, t) {
        let n =
                arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : {},
            i,
            r,
            a;
        const o = (h, l) => {
            const u = this.nestingOptionsSeparator;
            if (h.indexOf(u) < 0) return h;
            const c = h.split(new RegExp(`${u}[ ]*{`));
            let d = `{${c[1]}`;
            (h = c[0]), (d = this.interpolate(d, a));
            const f = d.match(/'/g),
                p = d.match(/"/g);
            ((f && f.length % 2 === 0 && !p) || p.length % 2 !== 0) &&
                (d = d.replace(/'/g, '"'));
            try {
                (a = JSON.parse(d)), l && (a = { ...l, ...a });
            } catch (m) {
                return (
                    this.logger.warn(
                        `failed parsing options string in nesting for key ${h}`,
                        m
                    ),
                    `${h}${u}${d}`
                );
            }
            return (
                a.defaultValue &&
                    a.defaultValue.indexOf(this.prefix) > -1 &&
                    delete a.defaultValue,
                h
            );
        };
        for (; (i = this.nestingRegexp.exec(e)); ) {
            let h = [];
            (a = { ...n }),
                (a = a.replace && !ce(a.replace) ? a.replace : a),
                (a.applyPostProcessor = !1),
                delete a.defaultValue;
            let l = !1;
            if (
                i[0].indexOf(this.formatSeparator) !== -1 &&
                !/{.*}/.test(i[1])
            ) {
                const u = i[1].split(this.formatSeparator).map((c) => c.trim());
                (i[1] = u.shift()), (h = u), (l = !0);
            }
            if (
                ((r = t(o.call(this, i[1].trim(), a), a)),
                r && i[0] === e && !ce(r))
            )
                return r;
            ce(r) || (r = mb(r)),
                r ||
                    (this.logger.warn(
                        `missed to resolve ${i[1]} for nesting ${e}`
                    ),
                    (r = "")),
                l &&
                    (r = h.reduce(
                        (u, c) =>
                            this.format(u, c, n.lng, {
                                ...n,
                                interpolationkey: i[1].trim(),
                            }),
                        r.trim()
                    )),
                (e = e.replace(i[0], r)),
                (this.regexp.lastIndex = 0);
        }
        return e;
    }
}
const aO = (s) => {
        let e = s.toLowerCase().trim();
        const t = {};
        if (s.indexOf("(") > -1) {
            const n = s.split("(");
            e = n[0].toLowerCase().trim();
            const i = n[1].substring(0, n[1].length - 1);
            e === "currency" && i.indexOf(":") < 0
                ? t.currency || (t.currency = i.trim())
                : e === "relativetime" && i.indexOf(":") < 0
                ? t.range || (t.range = i.trim())
                : i.split(";").forEach((a) => {
                      if (a) {
                          const [o, ...h] = a.split(":"),
                              l = h
                                  .join(":")
                                  .trim()
                                  .replace(/^'+|'+$/g, ""),
                              u = o.trim();
                          t[u] || (t[u] = l),
                              l === "false" && (t[u] = !1),
                              l === "true" && (t[u] = !0),
                              isNaN(l) || (t[u] = parseInt(l, 10));
                      }
                  });
        }
        return { formatName: e, formatOptions: t };
    },
    ho = (s) => {
        const e = {};
        return (t, n, i) => {
            let r = i;
            i &&
                i.interpolationkey &&
                i.formatParams &&
                i.formatParams[i.interpolationkey] &&
                i[i.interpolationkey] &&
                (r = { ...r, [i.interpolationkey]: void 0 });
            const a = n + JSON.stringify(r);
            let o = e[a];
            return o || ((o = s(Gu(n), i)), (e[a] = o)), o(t);
        };
    };
class oO {
    constructor() {
        let e =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        (this.logger = bi.create("formatter")),
            (this.options = e),
            (this.formats = {
                number: ho((t, n) => {
                    const i = new Intl.NumberFormat(t, { ...n });
                    return (r) => i.format(r);
                }),
                currency: ho((t, n) => {
                    const i = new Intl.NumberFormat(t, {
                        ...n,
                        style: "currency",
                    });
                    return (r) => i.format(r);
                }),
                datetime: ho((t, n) => {
                    const i = new Intl.DateTimeFormat(t, { ...n });
                    return (r) => i.format(r);
                }),
                relativetime: ho((t, n) => {
                    const i = new Intl.RelativeTimeFormat(t, { ...n });
                    return (r) => i.format(r, n.range || "day");
                }),
                list: ho((t, n) => {
                    const i = new Intl.ListFormat(t, { ...n });
                    return (r) => i.format(r);
                }),
            }),
            this.init(e);
    }
    init(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : { interpolation: {} };
        this.formatSeparator = t.interpolation.formatSeparator || ",";
    }
    add(e, t) {
        this.formats[e.toLowerCase().trim()] = t;
    }
    addCached(e, t) {
        this.formats[e.toLowerCase().trim()] = ho(t);
    }
    format(e, t, n) {
        let i =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const r = t.split(this.formatSeparator);
        if (
            r.length > 1 &&
            r[0].indexOf("(") > 1 &&
            r[0].indexOf(")") < 0 &&
            r.find((o) => o.indexOf(")") > -1)
        ) {
            const o = r.findIndex((h) => h.indexOf(")") > -1);
            r[0] = [r[0], ...r.splice(1, o)].join(this.formatSeparator);
        }
        return r.reduce((o, h) => {
            const { formatName: l, formatOptions: u } = aO(h);
            if (this.formats[l]) {
                let c = o;
                try {
                    const d =
                            (i &&
                                i.formatParams &&
                                i.formatParams[i.interpolationkey]) ||
                            {},
                        f = d.locale || d.lng || i.locale || i.lng || n;
                    c = this.formats[l](o, f, { ...u, ...i, ...d });
                } catch (d) {
                    this.logger.warn(d);
                }
                return c;
            } else this.logger.warn(`there was no format function for ${l}`);
            return o;
        }, e);
    }
}
const lO = (s, e) => {
    s.pending[e] !== void 0 && (delete s.pending[e], s.pendingCount--);
};
class hO extends Rd {
    constructor(e, t, n) {
        let i =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super(),
            (this.backend = e),
            (this.store = t),
            (this.services = n),
            (this.languageUtils = n.languageUtils),
            (this.options = i),
            (this.logger = bi.create("backendConnector")),
            (this.waitingReads = []),
            (this.maxParallelReads = i.maxParallelReads || 10),
            (this.readingCalls = 0),
            (this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5),
            (this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350),
            (this.state = {}),
            (this.queue = []),
            this.backend &&
                this.backend.init &&
                this.backend.init(n, i.backend, i);
    }
    queueLoad(e, t, n, i) {
        const r = {},
            a = {},
            o = {},
            h = {};
        return (
            e.forEach((l) => {
                let u = !0;
                t.forEach((c) => {
                    const d = `${l}|${c}`;
                    !n.reload && this.store.hasResourceBundle(l, c)
                        ? (this.state[d] = 2)
                        : this.state[d] < 0 ||
                          (this.state[d] === 1
                              ? a[d] === void 0 && (a[d] = !0)
                              : ((this.state[d] = 1),
                                (u = !1),
                                a[d] === void 0 && (a[d] = !0),
                                r[d] === void 0 && (r[d] = !0),
                                h[c] === void 0 && (h[c] = !0)));
                }),
                    u || (o[l] = !0);
            }),
            (Object.keys(r).length || Object.keys(a).length) &&
                this.queue.push({
                    pending: a,
                    pendingCount: Object.keys(a).length,
                    loaded: {},
                    errors: [],
                    callback: i,
                }),
            {
                toLoad: Object.keys(r),
                pending: Object.keys(a),
                toLoadLanguages: Object.keys(o),
                toLoadNamespaces: Object.keys(h),
            }
        );
    }
    loaded(e, t, n) {
        const i = e.split("|"),
            r = i[0],
            a = i[1];
        t && this.emit("failedLoading", r, a, t),
            !t &&
                n &&
                this.store.addResourceBundle(r, a, n, void 0, void 0, {
                    skipCopy: !0,
                }),
            (this.state[e] = t ? -1 : 2),
            t && n && (this.state[e] = 0);
        const o = {};
        this.queue.forEach((h) => {
            GL(h.loaded, [r], a),
                lO(h, e),
                t && h.errors.push(t),
                h.pendingCount === 0 &&
                    !h.done &&
                    (Object.keys(h.loaded).forEach((l) => {
                        o[l] || (o[l] = {});
                        const u = h.loaded[l];
                        u.length &&
                            u.forEach((c) => {
                                o[l][c] === void 0 && (o[l][c] = !0);
                            });
                    }),
                    (h.done = !0),
                    h.errors.length ? h.callback(h.errors) : h.callback());
        }),
            this.emit("loaded", o),
            (this.queue = this.queue.filter((h) => !h.done));
    }
    read(e, t, n) {
        let i =
                arguments.length > 3 && arguments[3] !== void 0
                    ? arguments[3]
                    : 0,
            r =
                arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : this.retryTimeout,
            a = arguments.length > 5 ? arguments[5] : void 0;
        if (!e.length) return a(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: e,
                ns: t,
                fcName: n,
                tried: i,
                wait: r,
                callback: a,
            });
            return;
        }
        this.readingCalls++;
        const o = (l, u) => {
                if ((this.readingCalls--, this.waitingReads.length > 0)) {
                    const c = this.waitingReads.shift();
                    this.read(
                        c.lng,
                        c.ns,
                        c.fcName,
                        c.tried,
                        c.wait,
                        c.callback
                    );
                }
                if (l && u && i < this.maxRetries) {
                    setTimeout(() => {
                        this.read.call(this, e, t, n, i + 1, r * 2, a);
                    }, r);
                    return;
                }
                a(l, u);
            },
            h = this.backend[n].bind(this.backend);
        if (h.length === 2) {
            try {
                const l = h(e, t);
                l && typeof l.then == "function"
                    ? l.then((u) => o(null, u)).catch(o)
                    : o(null, l);
            } catch (l) {
                o(l);
            }
            return;
        }
        return h(e, t, o);
    }
    prepareLoading(e, t) {
        let n =
                arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : {},
            i = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend)
            return (
                this.logger.warn(
                    "No backend was added via i18next.use. Will not load resources."
                ),
                i && i()
            );
        ce(e) && (e = this.languageUtils.toResolveHierarchy(e)),
            ce(t) && (t = [t]);
        const r = this.queueLoad(e, t, n, i);
        if (!r.toLoad.length) return r.pending.length || i(), null;
        r.toLoad.forEach((a) => {
            this.loadOne(a);
        });
    }
    load(e, t, n) {
        this.prepareLoading(e, t, {}, n);
    }
    reload(e, t, n) {
        this.prepareLoading(e, t, { reload: !0 }, n);
    }
    loadOne(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const n = e.split("|"),
            i = n[0],
            r = n[1];
        this.read(i, r, "read", void 0, void 0, (a, o) => {
            a &&
                this.logger.warn(
                    `${t}loading namespace ${r} for language ${i} failed`,
                    a
                ),
                !a &&
                    o &&
                    this.logger.log(
                        `${t}loaded namespace ${r} for language ${i}`,
                        o
                    ),
                this.loaded(e, a, o);
        });
    }
    saveMissing(e, t, n, i, r) {
        let a =
                arguments.length > 5 && arguments[5] !== void 0
                    ? arguments[5]
                    : {},
            o =
                arguments.length > 6 && arguments[6] !== void 0
                    ? arguments[6]
                    : () => {};
        if (
            this.services.utils &&
            this.services.utils.hasLoadedNamespace &&
            !this.services.utils.hasLoadedNamespace(t)
        ) {
            this.logger.warn(
                `did not save key "${n}" as the namespace "${t}" was not yet loaded`,
                "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
            );
            return;
        }
        if (!(n == null || n === "")) {
            if (this.backend && this.backend.create) {
                const h = { ...a, isUpdate: r },
                    l = this.backend.create.bind(this.backend);
                if (l.length < 6)
                    try {
                        let u;
                        l.length === 5
                            ? (u = l(e, t, n, i, h))
                            : (u = l(e, t, n, i)),
                            u && typeof u.then == "function"
                                ? u.then((c) => o(null, c)).catch(o)
                                : o(null, u);
                    } catch (u) {
                        o(u);
                    }
                else l(e, t, n, i, o, h);
            }
            !e || !e[0] || this.store.addResource(e[0], t, n, i);
        }
    }
}
const Ab = () => ({
        debug: !1,
        initImmediate: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !1,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: (s) => {
            let e = {};
            if (
                (typeof s[1] == "object" && (e = s[1]),
                ce(s[1]) && (e.defaultValue = s[1]),
                ce(s[2]) && (e.tDescription = s[2]),
                typeof s[2] == "object" || typeof s[3] == "object")
            ) {
                const t = s[3] || s[2];
                Object.keys(t).forEach((n) => {
                    e[n] = t[n];
                });
            }
            return e;
        },
        interpolation: {
            escapeValue: !0,
            format: (s) => s,
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0,
        },
    }),
    Sb = (s) => (
        ce(s.ns) && (s.ns = [s.ns]),
        ce(s.fallbackLng) && (s.fallbackLng = [s.fallbackLng]),
        ce(s.fallbackNS) && (s.fallbackNS = [s.fallbackNS]),
        s.supportedLngs &&
            s.supportedLngs.indexOf("cimode") < 0 &&
            (s.supportedLngs = s.supportedLngs.concat(["cimode"])),
        s
    ),
    jc = () => {},
    cO = (s) => {
        Object.getOwnPropertyNames(Object.getPrototypeOf(s)).forEach((t) => {
            typeof s[t] == "function" && (s[t] = s[t].bind(s));
        });
    };
class jh extends Rd {
    constructor() {
        let e =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
        if (
            (super(),
            (this.options = Sb(e)),
            (this.services = {}),
            (this.logger = bi),
            (this.modules = { external: [] }),
            cO(this),
            t && !this.isInitialized && !e.isClone)
        ) {
            if (!this.options.initImmediate) return this.init(e, t), this;
            setTimeout(() => {
                this.init(e, t);
            }, 0);
        }
    }
    init() {
        var e = this;
        let t =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {},
            n = arguments.length > 1 ? arguments[1] : void 0;
        (this.isInitializing = !0),
            typeof t == "function" && ((n = t), (t = {})),
            !t.defaultNS &&
                t.defaultNS !== !1 &&
                t.ns &&
                (ce(t.ns)
                    ? (t.defaultNS = t.ns)
                    : t.ns.indexOf("translation") < 0 &&
                      (t.defaultNS = t.ns[0]));
        const i = Ab();
        (this.options = { ...i, ...this.options, ...Sb(t) }),
            this.options.compatibilityAPI !== "v1" &&
                (this.options.interpolation = {
                    ...i.interpolation,
                    ...this.options.interpolation,
                }),
            t.keySeparator !== void 0 &&
                (this.options.userDefinedKeySeparator = t.keySeparator),
            t.nsSeparator !== void 0 &&
                (this.options.userDefinedNsSeparator = t.nsSeparator);
        const r = (u) => (u ? (typeof u == "function" ? new u() : u) : null);
        if (!this.options.isClone) {
            this.modules.logger
                ? bi.init(r(this.modules.logger), this.options)
                : bi.init(null, this.options);
            let u;
            this.modules.formatter
                ? (u = this.modules.formatter)
                : typeof Intl < "u" && (u = oO);
            const c = new wb(this.options);
            this.store = new bb(this.options.resources, this.options);
            const d = this.services;
            (d.logger = bi),
                (d.resourceStore = this.store),
                (d.languageUtils = c),
                (d.pluralResolver = new iO(c, {
                    prepend: this.options.pluralSeparator,
                    compatibilityJSON: this.options.compatibilityJSON,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix,
                })),
                u &&
                    (!this.options.interpolation.format ||
                        this.options.interpolation.format ===
                            i.interpolation.format) &&
                    ((d.formatter = r(u)),
                    d.formatter.init(d, this.options),
                    (this.options.interpolation.format =
                        d.formatter.format.bind(d.formatter))),
                (d.interpolator = new rO(this.options)),
                (d.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
                }),
                (d.backendConnector = new hO(
                    r(this.modules.backend),
                    d.resourceStore,
                    d,
                    this.options
                )),
                d.backendConnector.on("*", function (f) {
                    for (
                        var p = arguments.length,
                            m = new Array(p > 1 ? p - 1 : 0),
                            g = 1;
                        g < p;
                        g++
                    )
                        m[g - 1] = arguments[g];
                    e.emit(f, ...m);
                }),
                this.modules.languageDetector &&
                    ((d.languageDetector = r(this.modules.languageDetector)),
                    d.languageDetector.init &&
                        d.languageDetector.init(
                            d,
                            this.options.detection,
                            this.options
                        )),
                this.modules.i18nFormat &&
                    ((d.i18nFormat = r(this.modules.i18nFormat)),
                    d.i18nFormat.init && d.i18nFormat.init(this)),
                (this.translator = new Wu(this.services, this.options)),
                this.translator.on("*", function (f) {
                    for (
                        var p = arguments.length,
                            m = new Array(p > 1 ? p - 1 : 0),
                            g = 1;
                        g < p;
                        g++
                    )
                        m[g - 1] = arguments[g];
                    e.emit(f, ...m);
                }),
                this.modules.external.forEach((f) => {
                    f.init && f.init(this);
                });
        }
        if (
            ((this.format = this.options.interpolation.format),
            n || (n = jc),
            this.options.fallbackLng &&
                !this.services.languageDetector &&
                !this.options.lng)
        ) {
            const u = this.services.languageUtils.getFallbackCodes(
                this.options.fallbackLng
            );
            u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
        }
        !this.services.languageDetector &&
            !this.options.lng &&
            this.logger.warn(
                "init: no languageDetector is used and no lng is defined"
            ),
            [
                "getResource",
                "hasResourceBundle",
                "getResourceBundle",
                "getDataByLanguage",
            ].forEach((u) => {
                this[u] = function () {
                    return e.store[u](...arguments);
                };
            }),
            [
                "addResource",
                "addResources",
                "addResourceBundle",
                "removeResourceBundle",
            ].forEach((u) => {
                this[u] = function () {
                    return e.store[u](...arguments), e;
                };
            });
        const h = Nl(),
            l = () => {
                const u = (c, d) => {
                    (this.isInitializing = !1),
                        this.isInitialized &&
                            !this.initializedStoreOnce &&
                            this.logger.warn(
                                "init: i18next is already initialized. You should call init just once!"
                            ),
                        (this.isInitialized = !0),
                        this.options.isClone ||
                            this.logger.log("initialized", this.options),
                        this.emit("initialized", this.options),
                        h.resolve(d),
                        n(c, d);
                };
                if (
                    this.languages &&
                    this.options.compatibilityAPI !== "v1" &&
                    !this.isInitialized
                )
                    return u(null, this.t.bind(this));
                this.changeLanguage(this.options.lng, u);
            };
        return (
            this.options.resources || !this.options.initImmediate
                ? l()
                : setTimeout(l, 0),
            h
        );
    }
    loadResources(e) {
        let n =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : jc;
        const i = ce(e) ? e : this.language;
        if (
            (typeof e == "function" && (n = e),
            !this.options.resources || this.options.partialBundledLanguages)
        ) {
            if (
                i &&
                i.toLowerCase() === "cimode" &&
                (!this.options.preload || this.options.preload.length === 0)
            )
                return n();
            const r = [],
                a = (o) => {
                    if (!o || o === "cimode") return;
                    this.services.languageUtils
                        .toResolveHierarchy(o)
                        .forEach((l) => {
                            l !== "cimode" && r.indexOf(l) < 0 && r.push(l);
                        });
                };
            i
                ? a(i)
                : this.services.languageUtils
                      .getFallbackCodes(this.options.fallbackLng)
                      .forEach((h) => a(h)),
                this.options.preload &&
                    this.options.preload.forEach((o) => a(o)),
                this.services.backendConnector.load(r, this.options.ns, (o) => {
                    !o &&
                        !this.resolvedLanguage &&
                        this.language &&
                        this.setResolvedLanguage(this.language),
                        n(o);
                });
        } else n(null);
    }
    reloadResources(e, t, n) {
        const i = Nl();
        return (
            typeof e == "function" && ((n = e), (e = void 0)),
            typeof t == "function" && ((n = t), (t = void 0)),
            e || (e = this.languages),
            t || (t = this.options.ns),
            n || (n = jc),
            this.services.backendConnector.reload(e, t, (r) => {
                i.resolve(), n(r);
            }),
            i
        );
    }
    use(e) {
        if (!e)
            throw new Error(
                "You are passing an undefined module! Please check the object you are passing to i18next.use()"
            );
        if (!e.type)
            throw new Error(
                "You are passing a wrong module! Please check the object you are passing to i18next.use()"
            );
        return (
            e.type === "backend" && (this.modules.backend = e),
            (e.type === "logger" || (e.log && e.warn && e.error)) &&
                (this.modules.logger = e),
            e.type === "languageDetector" &&
                (this.modules.languageDetector = e),
            e.type === "i18nFormat" && (this.modules.i18nFormat = e),
            e.type === "postProcessor" && x2.addPostProcessor(e),
            e.type === "formatter" && (this.modules.formatter = e),
            e.type === "3rdParty" && this.modules.external.push(e),
            this
        );
    }
    setResolvedLanguage(e) {
        if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
            for (let t = 0; t < this.languages.length; t++) {
                const n = this.languages[t];
                if (
                    !(["cimode", "dev"].indexOf(n) > -1) &&
                    this.store.hasLanguageSomeTranslations(n)
                ) {
                    this.resolvedLanguage = n;
                    break;
                }
            }
    }
    changeLanguage(e, t) {
        var n = this;
        this.isLanguageChangingTo = e;
        const i = Nl();
        this.emit("languageChanging", e);
        const r = (h) => {
                (this.language = h),
                    (this.languages =
                        this.services.languageUtils.toResolveHierarchy(h)),
                    (this.resolvedLanguage = void 0),
                    this.setResolvedLanguage(h);
            },
            a = (h, l) => {
                l
                    ? (r(l),
                      this.translator.changeLanguage(l),
                      (this.isLanguageChangingTo = void 0),
                      this.emit("languageChanged", l),
                      this.logger.log("languageChanged", l))
                    : (this.isLanguageChangingTo = void 0),
                    i.resolve(function () {
                        return n.t(...arguments);
                    }),
                    t &&
                        t(h, function () {
                            return n.t(...arguments);
                        });
            },
            o = (h) => {
                !e && !h && this.services.languageDetector && (h = []);
                const l = ce(h)
                    ? h
                    : this.services.languageUtils.getBestMatchFromCodes(h);
                l &&
                    (this.language || r(l),
                    this.translator.language ||
                        this.translator.changeLanguage(l),
                    this.services.languageDetector &&
                        this.services.languageDetector.cacheUserLanguage &&
                        this.services.languageDetector.cacheUserLanguage(l)),
                    this.loadResources(l, (u) => {
                        a(u, l);
                    });
            };
        return (
            !e &&
            this.services.languageDetector &&
            !this.services.languageDetector.async
                ? o(this.services.languageDetector.detect())
                : !e &&
                  this.services.languageDetector &&
                  this.services.languageDetector.async
                ? this.services.languageDetector.detect.length === 0
                    ? this.services.languageDetector.detect().then(o)
                    : this.services.languageDetector.detect(o)
                : o(e),
            i
        );
    }
    getFixedT(e, t, n) {
        var i = this;
        const r = function (a, o) {
            let h;
            if (typeof o != "object") {
                for (
                    var l = arguments.length,
                        u = new Array(l > 2 ? l - 2 : 0),
                        c = 2;
                    c < l;
                    c++
                )
                    u[c - 2] = arguments[c];
                h = i.options.overloadTranslationOptionHandler(
                    [a, o].concat(u)
                );
            } else h = { ...o };
            (h.lng = h.lng || r.lng),
                (h.lngs = h.lngs || r.lngs),
                (h.ns = h.ns || r.ns),
                h.keyPrefix !== "" &&
                    (h.keyPrefix = h.keyPrefix || n || r.keyPrefix);
            const d = i.options.keySeparator || ".";
            let f;
            return (
                h.keyPrefix && Array.isArray(a)
                    ? (f = a.map((p) => `${h.keyPrefix}${d}${p}`))
                    : (f = h.keyPrefix ? `${h.keyPrefix}${d}${a}` : a),
                i.t(f, h)
            );
        };
        return (
            ce(e) ? (r.lng = e) : (r.lngs = e), (r.ns = t), (r.keyPrefix = n), r
        );
    }
    t() {
        return this.translator && this.translator.translate(...arguments);
    }
    exists() {
        return this.translator && this.translator.exists(...arguments);
    }
    setDefaultNamespace(e) {
        this.options.defaultNS = e;
    }
    hasLoadedNamespace(e) {
        let t =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized)
            return (
                this.logger.warn(
                    "hasLoadedNamespace: i18next was not initialized",
                    this.languages
                ),
                !1
            );
        if (!this.languages || !this.languages.length)
            return (
                this.logger.warn(
                    "hasLoadedNamespace: i18n.languages were undefined or empty",
                    this.languages
                ),
                !1
            );
        const n = t.lng || this.resolvedLanguage || this.languages[0],
            i = this.options ? this.options.fallbackLng : !1,
            r = this.languages[this.languages.length - 1];
        if (n.toLowerCase() === "cimode") return !0;
        const a = (o, h) => {
            const l = this.services.backendConnector.state[`${o}|${h}`];
            return l === -1 || l === 0 || l === 2;
        };
        if (t.precheck) {
            const o = t.precheck(this, a);
            if (o !== void 0) return o;
        }
        return !!(
            this.hasResourceBundle(n, e) ||
            !this.services.backendConnector.backend ||
            (this.options.resources && !this.options.partialBundledLanguages) ||
            (a(n, e) && (!i || a(r, e)))
        );
    }
    loadNamespaces(e, t) {
        const n = Nl();
        return this.options.ns
            ? (ce(e) && (e = [e]),
              e.forEach((i) => {
                  this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
              }),
              this.loadResources((i) => {
                  n.resolve(), t && t(i);
              }),
              n)
            : (t && t(), Promise.resolve());
    }
    loadLanguages(e, t) {
        const n = Nl();
        ce(e) && (e = [e]);
        const i = this.options.preload || [],
            r = e.filter(
                (a) =>
                    i.indexOf(a) < 0 &&
                    this.services.languageUtils.isSupportedCode(a)
            );
        return r.length
            ? ((this.options.preload = i.concat(r)),
              this.loadResources((a) => {
                  n.resolve(), t && t(a);
              }),
              n)
            : (t && t(), Promise.resolve());
    }
    dir(e) {
        if (
            (e ||
                (e =
                    this.resolvedLanguage ||
                    (this.languages && this.languages.length > 0
                        ? this.languages[0]
                        : this.language)),
            !e)
        )
            return "rtl";
        const t = [
                "ar",
                "shu",
                "sqr",
                "ssh",
                "xaa",
                "yhd",
                "yud",
                "aao",
                "abh",
                "abv",
                "acm",
                "acq",
                "acw",
                "acx",
                "acy",
                "adf",
                "ads",
                "aeb",
                "aec",
                "afb",
                "ajp",
                "apc",
                "apd",
                "arb",
                "arq",
                "ars",
                "ary",
                "arz",
                "auz",
                "avl",
                "ayh",
                "ayl",
                "ayn",
                "ayp",
                "bbz",
                "pga",
                "he",
                "iw",
                "ps",
                "pbt",
                "pbu",
                "pst",
                "prp",
                "prd",
                "ug",
                "ur",
                "ydd",
                "yds",
                "yih",
                "ji",
                "yi",
                "hbo",
                "men",
                "xmn",
                "fa",
                "jpr",
                "peo",
                "pes",
                "prs",
                "dv",
                "sam",
                "ckb",
            ],
            n = (this.services && this.services.languageUtils) || new wb(Ab());
        return t.indexOf(n.getLanguagePartFromCode(e)) > -1 ||
            e.toLowerCase().indexOf("-arab") > 1
            ? "rtl"
            : "ltr";
    }
    static createInstance() {
        let e =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
        return new jh(e, t);
    }
    cloneInstance() {
        let e =
                arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {},
            t =
                arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : jc;
        const n = e.forkResourceStore;
        n && delete e.forkResourceStore;
        const i = { ...this.options, ...e, isClone: !0 },
            r = new jh(i);
        return (
            (e.debug !== void 0 || e.prefix !== void 0) &&
                (r.logger = r.logger.clone(e)),
            ["store", "services", "language"].forEach((o) => {
                r[o] = this[o];
            }),
            (r.services = { ...this.services }),
            (r.services.utils = {
                hasLoadedNamespace: r.hasLoadedNamespace.bind(r),
            }),
            n &&
                ((r.store = new bb(this.store.data, i)),
                (r.services.resourceStore = r.store)),
            (r.translator = new Wu(r.services, i)),
            r.translator.on("*", function (o) {
                for (
                    var h = arguments.length,
                        l = new Array(h > 1 ? h - 1 : 0),
                        u = 1;
                    u < h;
                    u++
                )
                    l[u - 1] = arguments[u];
                r.emit(o, ...l);
            }),
            r.init(i, t),
            (r.translator.options = i),
            (r.translator.backendConnector.services.utils = {
                hasLoadedNamespace: r.hasLoadedNamespace.bind(r),
            }),
            r
        );
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage,
        };
    }
}
const oe = jh.createInstance();
oe.createInstance = jh.createInstance;
oe.createInstance;
oe.dir;
oe.init;
oe.loadResources;
oe.reloadResources;
oe.use;
oe.changeLanguage;
oe.getFixedT;
oe.t;
oe.exists;
oe.setDefaultNamespace;
oe.hasLoadedNamespace;
oe.loadNamespaces;
oe.loadLanguages;
const uO = (s, e, t) => {
        Re(e, t() === 0 ? $(e) : t(), !0), Ia(Eh, t() === 0 ? $(e) : 0);
    },
    dO = (s, e, t) => {
        Re(e, t() === 0 ? $(e) : t(), !0), Ia(Ph, t() === 0 ? $(e) : 0);
    };
var fO = () => ah.set(!0),
    pO = X(
        '<div class="portrait-info-wrap svelte-1kxcfjy"><div class="icon-wrap svelte-1kxcfjy"><!></div></div>'
    ),
    mO = (s, e) => Ia(qo, !e()),
    gO = () => ah.set(!0),
    _O = (s) => s.stopPropagation(),
    vO = (s) => s.stopPropagation(),
    bO = X(
        '<div class="menu-popup svelte-1kxcfjy"><div class="menu-option svelte-1kxcfjy"><div class="icon-wrap svelte-1kxcfjy"><!></div> <span class="text svelte-1kxcfjy"> </span></div> <div class="menu-option svelte-1kxcfjy"><div class="icon-wrap svelte-1kxcfjy"><!></div> <input class="volume-slider svelte-1kxcfjy" type="range" min="0" max="1" step="0.01"/></div> <div class="menu-option svelte-1kxcfjy"><div class="icon-wrap svelte-1kxcfjy"><!></div> <input class="volume-slider svelte-1kxcfjy" type="range" min="0" max="1" step="0.01"/></div></div>'
    ),
    yO = X(
        '<div class="menu-button-wrap svelte-1kxcfjy"><div class="menu-button svelte-1kxcfjy"><!></div> <!></div>'
    );
function Fo(s, e) {
    Ne(e, !0);
    const t = () => U(Eh, "$soundVolume", u),
        n = () => U(Ph, "$musicVolume", u),
        i = () => U(xi, "$showAutoSpinMenu", u),
        r = () => U(wi, "$showBetAmountMenu", u),
        a = () => U(us, "$layoutType", u),
        o = () => U(qo, "$showMenu", u),
        h = () => U(qE, "$soundOn", u),
        l = () => U(HE, "$musicOn", u),
        [u, c] = tt();
    let d = gt(rn(t())),
        f = gt(rn(n()));
    _n(() => {
        (i() || r()) && qo.set(!1);
    });
    var p = Oe(),
        m = me(p);
    {
        var g = (v) => {
                var b = pO();
                b.__click = [fO];
                var y = I(b),
                    C = I(y);
                pb(C), D(v, b);
            },
            _ = (v) => {
                var b = yO(),
                    y = I(b);
                y.__click = [mO, o];
                var C = I(y);
                {
                    var w = (P) => {
                            zu(P);
                        },
                        A = (P) => {
                            IL(P);
                        };
                    ne(C, (P) => {
                        o() ? P(w) : P(A, !1);
                    });
                }
                var E = N(y, 2);
                {
                    var S = (P) => {
                        var k = bO(),
                            R = I(k);
                        R.__click = [gO];
                        var M = I(R),
                            T = I(M);
                        pb(T);
                        var O = N(M, 2),
                            L = I(O),
                            F = N(R, 2);
                        F.__click = [uO, d, t];
                        var Y = I(F),
                            V = I(Y);
                        {
                            var W = (re) => {
                                    BL(re);
                                },
                                Z = (re) => {
                                    $L(re);
                                };
                            ne(V, (re) => {
                                h() ? re(W) : re(Z, !1);
                            });
                        }
                        var J = N(Y, 2);
                        J.__click = [_O];
                        var G = N(F, 2);
                        G.__click = [dO, f, n];
                        var j = I(G),
                            H = I(j);
                        {
                            var pe = (re) => {
                                    NL(re);
                                },
                                _e = (re) => {
                                    UL(re);
                                };
                            ne(H, (re) => {
                                l() ? re(pe) : re(_e, !1);
                            });
                        }
                        var ve = N(j, 2);
                        (ve.__click = [vO]),
                            ie((re) => se(L, re), [() => oe.t("INFO")]),
                            _0(J, t, (re) => Ia(Eh, re)),
                            _0(ve, n, (re) => Ia(Ph, re)),
                            Vn(
                                3,
                                k,
                                () => Id,
                                () => ({ y: 10, duration: 120 })
                            ),
                            D(P, k);
                    };
                    ne(E, (P) => {
                        o() && P(S);
                    });
                }
                D(v, b);
            };
        ne(m, (v) => {
            a() === "portrait" ? v(g) : v(_, !1);
        });
    }
    D(s, p), Ve(), c();
}
Jt(["click"]);
var wO = X("<div><span> </span> <span> </span></div>");
function Wh(s, e) {
    Ne(e, !0);
    const t = () => U(l, "$displayBalance", a),
        n = () => U(Js, "$currency", a),
        i = () => U(us, "$layoutType", a),
        r = () => U(Ki, "$showBuyScreen", a),
        [a, o] = tt();
    let h = oe.t("BALANCE");
    const { displayBalance: l } = Ke;
    let u = Me(() => nr(t() ?? 0, n()));
    var c = wO(),
        d = I(c),
        f = I(d),
        p = N(d, 2),
        m = I(p);
    ie(() => {
        qe(
            c,
            1,
            `wrap ${i() ?? ""} ${(r() && "buy-screen") ?? ""}`,
            "svelte-1tfpb4o"
        ),
            qe(d, 1, `text ${i() ?? ""}`, "svelte-1tfpb4o"),
            se(f, h),
            qe(
                p,
                1,
                `value ${i() ?? ""} ${(r() && "buy-screen") ?? ""}`,
                "svelte-1tfpb4o"
            ),
            se(m, $(u));
    }),
        D(s, c),
        Ve(),
        o();
}
var xO = bn(
    '<svg width="61" height="79" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 61 86" fill="currentColor"><path d="M33.23,85.78c-2.41,0-4.75-.5-6.93-1.51-5.06-2.33-9.12-7.31-11.73-14.4-4.05-10.99-4.54-12.33-5.06-13.76-.59-1.6-1.21-3.33-6.96-18.92C-.71,28.36-.84,20.64,2.15,14.25c2.74-5.85,7.9-10.16,15.31-12.79,10.73-3.81,25.91-1.08,33.37,19.15,4.52,12.26,7.03,19.09,8.42,22.86l1.34,3.66c.05.14.1.28.14.41.02.05.04.09.05.14l.07.18h-.02c1.14,4.11-1.67,5.52-2.6,5.86-1.69.63-4.66.38-5.88-2.9-.03-.08-.06-.16-.08-.24-.48-1.33-2.45-6.68-9.88-26.86-4.4-11.94-12.59-17.08-21.91-13.78-5.06,1.8-8.49,4.53-10.17,8.13-1.94,4.13-1.7,9.51.69,16,5.75,15.61,6.38,17.34,6.97,18.94.52,1.43,1.01,2.77,5.05,13.74,1.77,4.8,4.21,8.03,7.05,9.34,1.99.92,4.29.91,6.82-.02,6.88-2.55,8.8-8.11,5.71-16.53-5.1-13.89-6.21-16.89-7.54-20.48-.76-2.05-1.59-4.29-3.27-8.86-1.4-3.79-4.05-4.34-6.08-3.6-1.97.73-3.77,2.92-2.37,6.71,4.49,12.19,9.65,25.08,9.71,25.21.92,2.31-.2,4.93-2.5,5.85-2.31.92-4.93-.2-5.85-2.5-.05-.13-5.26-13.13-9.8-25.44-3.25-8.82,1.54-16,7.71-18.27,6.28-2.31,14.35.01,17.63,8.93,1.68,4.56,2.51,6.8,3.27,8.84,1.33,3.59,2.44,6.59,7.55,20.5,4.79,13.03.56,23.79-11.03,28.08-2.29.85-4.56,1.27-6.77,1.27Z" fill="currentColor"></path></svg>'
);
function C2(s) {
    var e = xO();
    D(s, e);
}
const CO = (s, e) => {
    e().next({ type: "playButtonClick", isSpecial: !0 }), Ki.set(!0);
};
var AO = X('<div><div class="icon svelte-1nke5ai"><!></div></div>'),
    SO = X(
        '<div><span class="buy-button-text svelte-1nke5ai">DISABLE</span></div>'
    );
function A2(s, e) {
    Ne(e, !0);
    const t = () => U(Ws, "$gameState", a),
        n = () => U(og, "$isAutoSpin", a),
        i = () => U(Os, "$betMode", a),
        r = () => U(ei, "$eventEmitter", a),
        [a, o] = tt();
    let h = Me(() => t() === "activeBet" || n()),
        l = Me(() => i() !== "BASE");
    const u = () => {
        $(h) || (r().next({ type: "playButtonClick" }), Os.set("BASE"));
    };
    var c = Oe(),
        d = me(c);
    {
        var f = (m) => {
                var g = AO();
                let _;
                g.__click = [CO, r];
                var v = I(g),
                    b = I(v);
                C2(b),
                    ie(
                        (y) =>
                            (_ = qe(
                                g,
                                1,
                                "buy-button svelte-1nke5ai",
                                null,
                                _,
                                y
                            )),
                        [() => ({ disabled: $(h) })]
                    ),
                    D(m, g);
            },
            p = (m) => {
                var g = SO();
                let _;
                (g.__click = u),
                    ie(
                        (v) =>
                            (_ = qe(
                                g,
                                1,
                                "buy-button svelte-1nke5ai",
                                null,
                                _,
                                v
                            )),
                        [() => ({ disabled: $(h) })]
                    ),
                    D(m, g);
            };
        ne(d, (m) => {
            $(l) ? m(p, !1) : m(f);
        });
    }
    D(s, c), Ve(), o();
}
Jt(["click"]);
var EO = X(
    '<div class="wrap svelte-yfe2tu"><div class="wrap svelte-yfe2tu"><div><span> </span> <span> </span></div></div></div>'
);
function $o(s, e) {
    Ne(e, !0);
    const t = () => U(Sh, "$winAmount", r),
        n = () => U(Js, "$currency", r),
        i = () => U(us, "$layoutType", r),
        [r, a] = tt();
    let o = oe.t("WIN"),
        h = Me(() => nr(t() ?? 0, n()));
    var l = Oe(),
        u = me(l);
    {
        var c = (d) => {
            var f = EO(),
                p = I(f),
                m = I(p),
                g = I(m),
                _ = I(g),
                v = N(g, 2),
                b = I(v);
            ie(() => {
                qe(m, 1, `wrap ${i() ?? ""}`, "svelte-yfe2tu"),
                    qe(g, 1, `text ${i() ?? ""}`, "svelte-yfe2tu"),
                    se(_, o),
                    qe(v, 1, `value ${i() ?? ""}`, "svelte-yfe2tu"),
                    se(b, $(h));
            }),
                Vn(
                    1,
                    p,
                    () => Wr,
                    () => ({ delay: Q(aa) ? 0 : 50, duration: Q(aa) ? 0 : 300 })
                ),
                Vn(
                    1,
                    f,
                    () => bL,
                    () => ({ delay: Q(aa) ? 0 : 50, duration: Q(aa) ? 0 : 300 })
                ),
                Vn(
                    2,
                    f,
                    () => Wr,
                    () => ({ delay: Q(aa) ? 0 : 50, duration: Q(aa) ? 0 : 100 })
                ),
                D(d, f);
        };
        ne(u, (d) => {
            t() && d(c);
        });
    }
    D(s, l), Ve(), a();
}
var PO = (s, e) => Ia(wi, !e()),
    kO = X(
        '<div class="indicator-backer svelte-1qql217"><div class="indicator svelte-1qql217"></div></div>'
    ),
    TO = X(
        '<div class="bet-indicator-wrap svelte-1qql217"><div><span> </span> <span> </span></div> <!></div>'
    );
function Xg(s, e) {
    Ne(e, !0);
    const t = () => U(Ws, "$gameState", f),
        n = () => U(xi, "$showAutoSpinMenu", f),
        i = () => U(Os, "$betMode", f),
        r = () => U(lc, "$betModesMeta", f),
        a = () => U(vu, "$adjustedBetAmount", f),
        o = () => U(Js, "$currency", f),
        h = () => U(ml, "$betAmountOptions", f),
        l = () => U(Nt, "$betAmount", f),
        u = () => U(us, "$layoutType", f),
        c = () => U(Ki, "$showBuyScreen", f),
        d = () => U(wi, "$showBetAmountMenu", f),
        [f, p] = tt();
    let m = Me(() => t() === "activeBet");
    _u(() => {
        $(m) && wi.set(!1);
    }),
        _u(() => {
            n() && wi.set(!1);
        });
    let g = Me(() => (i() !== "BASE" ? r()[i()].title : oe.t("BET"))),
        _ = Me(() => nr(a(), o())),
        v = Me(
            () =>
                `${(h().findIndex((k) => k === l()) / (h().length - 1)) * 100}%`
        );
    var b = TO(),
        y = I(b);
    y.__click = [PO, d];
    var C = I(y),
        w = I(C),
        A = N(C, 2),
        E = I(A),
        S = N(y, 2);
    {
        var P = (k) => {
            var R = kO(),
                M = I(R);
            ie(() =>
                an(
                    M,
                    `width: ${$(
                        v
                    )}; transition: ease-out; transition-duration: 0.3s;`
                )
            ),
                D(k, R);
        };
        ne(S, (k) => {
            (u() === "desktop" || u() === "landscape") && k(P);
        });
    }
    ie(() => {
        qe(
            y,
            1,
            `bet-indicator-button ${u() ?? ""} ${(c() && "buy-screen") ?? ""} ${
                ($(m) && "disabled") ?? ""
            }`,
            "svelte-1qql217"
        ),
            qe(C, 1, `text ${u() ?? ""}`, "svelte-1qql217"),
            se(w, $(g)),
            qe(A, 1, `value ${u() ?? ""}`, "svelte-1qql217"),
            se(E, $(_));
    }),
        D(s, b),
        Ve(),
        p();
}
Jt(["click"]);
var MO = X(
        '<div class="wrap svelte-1oy98w7"><span class="text svelte-1oy98w7"> </span> <span class="value svelte-1oy98w7"> </span></div>'
    ),
    IO = X(
        '<div class="mobile-wrap svelte-1oy98w7"><span class="mobile-text svelte-1oy98w7"> </span> <span class="mobile-value svelte-1oy98w7"> </span></div>'
    );
function Xu(s, e) {
    Ne(e, !0);
    const t = () => U(Nt, "$betAmount", r),
        n = () => U(Js, "$currency", r),
        i = () => U(us, "$layoutType", r),
        [r, a] = tt();
    let o = oe.t("BET"),
        h = Me(() => nr(t(), n()));
    var l = Oe(),
        u = me(l);
    {
        var c = (f) => {
                var p = MO(),
                    m = I(p),
                    g = I(m),
                    _ = N(m, 2),
                    v = I(_);
                ie(() => {
                    se(g, o), se(v, $(h));
                }),
                    D(f, p);
            },
            d = (f) => {
                var p = IO(),
                    m = I(p),
                    g = I(m),
                    _ = N(m, 2),
                    v = I(_);
                ie(() => {
                    se(g, o), se(v, $(h));
                }),
                    D(f, p);
            };
        ne(u, (f) => {
            i() === "desktop" || i() === "landscape" ? f(c) : f(d, !1);
        });
    }
    D(s, l), Ve(), a();
}
var RO = bn(
    '<svg width="101" height="101" viewBox="0 0 65 66" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_273_146)"><path d="M62.1995 35.85C62.0795 35.03 61.2795 34.57 60.5095 34.87C55.0495 36.99 48.2795 40.27 41.0395 43.85C40.4095 44.16 40.3595 45.04 40.9695 45.4C40.9695 45.4 42.4595 46.56 45.1795 48.36C40.0195 52.76 32.4095 54.22 25.6895 53.81C16.5195 53.09 8.66947 46.67 4.85947 38.02C4.40947 36.96 2.75947 37.32 2.78947 38.48C2.89947 43.94 5.16947 49.45 8.82947 53.92C21.0095 69.11 44.0295 69.09 57.5795 55.56C60.6795 57.16 63.0795 58.3 63.0795 58.3C63.6895 58.65 64.4295 58.17 64.3795 57.47C63.6295 46.87 63.0595 41.73 62.1895 35.85H62.1995Z" fill="currentColor"></path><path d="M19.2297 22.68C19.7497 22.42 19.7897 21.7 19.2897 21.41C19.2897 21.41 18.0197 20.43 15.7297 18.91C20.4397 12.75 27.7397 8.74005 35.6397 8.27005C45.8197 8.09005 56.5097 12.6 61.1897 22.27C61.3997 22.71 61.8997 22.96 62.3997 22.84C62.9697 22.7 63.3297 22.13 63.1897 21.56C62.5097 18.68 61.2397 15.88 59.4897 13.39C57.7497 10.89 55.5697 8.70005 53.1497 6.79005C45.6697 0.730048 35.6397 -0.949952 26.2297 0.480048C18.0697 1.76005 10.5097 6.41005 5.47968 12.98C2.98968 11.7 1.07968 10.79 1.07968 10.79C0.579681 10.5 -0.0303186 10.9 0.00968141 11.48C0.629681 20.21 1.09968 24.43 1.81968 29.27C1.91968 29.94 2.57968 30.32 3.20968 30.07C7.69968 28.32 13.2697 25.62 19.2297 22.67V22.68Z" fill="currentColor"></path></g><defs><clipPath id="clip0_273_146"><rect width="64.39" height="65.52" fill="white"></rect></clipPath></defs></svg>'
);
function Eb(s) {
    var e = RO();
    D(s, e);
}
var LO = bn(
    '<svg viewBox="0 0 30 30" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 4C0 1.79086 1.79086 0 4 0H26C28.2091 0 30 1.79086 30 4V26C30 28.2091 28.2091 30 26 30H4C1.79086 30 0 28.2091 0 26V4Z" fill="currentColor"></path></svg>'
);
function OO(s) {
    var e = LO();
    D(s, e);
}
var BO = bn(
    '<svg width="101" height="101" viewBox="0 0 65 66" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_273_146)"><path d="M62.1995 35.85C62.0795 35.03 61.2795 34.57 60.5095 34.87C55.0495 36.99 48.2795 40.27 41.0395 43.85C40.4095 44.16 40.3595 45.04 40.9695 45.4C40.9695 45.4 42.4595 46.56 45.1795 48.36C40.0195 52.76 32.4095 54.22 25.6895 53.81C16.5195 53.09 8.66947 46.67 4.85947 38.02C4.40947 36.96 2.75947 37.32 2.78947 38.48C2.89947 43.94 5.16947 49.45 8.82947 53.92C21.0095 69.11 44.0295 69.09 57.5795 55.56C60.6795 57.16 63.0795 58.3 63.0795 58.3C63.6895 58.65 64.4295 58.17 64.3795 57.47C63.6295 46.87 63.0595 41.73 62.1895 35.85H62.1995Z" fill="currentColor"></path><path d="M19.2297 22.68C19.7497 22.42 19.7897 21.7 19.2897 21.41C19.2897 21.41 18.0197 20.43 15.7297 18.91C20.4397 12.75 27.7397 8.74005 35.6397 8.27005C45.8197 8.09005 56.5097 12.6 61.1897 22.27C61.3997 22.71 61.8997 22.96 62.3997 22.84C62.9697 22.7 63.3297 22.13 63.1897 21.56C62.5097 18.68 61.2397 15.88 59.4897 13.39C57.7497 10.89 55.5697 8.70005 53.1497 6.79005C45.6697 0.730048 35.6397 -0.949952 26.2297 0.480048C18.0697 1.76005 10.5097 6.41005 5.47968 12.98C2.98968 11.7 1.07968 10.79 1.07968 10.79C0.579681 10.5 -0.0303186 10.9 0.00968141 11.48C0.629681 20.21 1.09968 24.43 1.81968 29.27C1.91968 29.94 2.57968 30.32 3.20968 30.07C7.69968 28.32 13.2697 25.62 19.2297 22.67V22.68Z" fill="currentColor"></path><path d="M27.5792 20.65C27.5792 20.65 27.0392 24.78 27.0892 31.31C27.1292 36.65 27.6692 42.71 27.6692 42.71C27.6692 43.32 28.3592 43.66 28.8592 43.31C36.3992 38.12 39.9692 35.45 43.9492 32.24C44.4992 31.79 44.4992 31 43.9392 30.56C39.9792 27.44 34.5892 23.84 28.7692 20.03C28.2592 19.7 27.5892 20.04 27.5892 20.65H27.5792Z" fill="currentColor"></path></g><defs><clipPath id="clip0_273_146"><rect width="64.39" height="65.52" fill="white"></rect></clipPath></defs></svg>'
);
function FO(s) {
    var e = BO();
    D(s, e);
}
var $O = bn(
    '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="32" height="32" viewBox="0 0 24 24"><path d="M20.288 9.463a4.856 4.856 0 0 0-4.336-2.3 4.586 4.586 0 0 0-3.343 1.767c.071.116.148.226.212.347l.879 1.652.134-.254a2.71 2.71 0 0 1 2.206-1.519 2.845 2.845 0 1 1 0 5.686 2.708 2.708 0 0 1-2.205-1.518L13.131 12l-1.193-2.26a4.709 4.709 0 0 0-3.89-2.581 4.845 4.845 0 1 0 0 9.682 4.586 4.586 0 0 0 3.343-1.767c-.071-.116-.148-.226-.212-.347l-.879-1.656-.134.254a2.71 2.71 0 0 1-2.206 1.519 2.855 2.855 0 0 1-2.559-1.369 2.825 2.825 0 0 1 0-2.946 2.862 2.862 0 0 1 2.442-1.374h.121a2.708 2.708 0 0 1 2.205 1.518l.7 1.327 1.193 2.26a4.709 4.709 0 0 0 3.89 2.581h.209a4.846 4.846 0 0 0 4.127-7.378z"></path></svg>'
);
function DO(s) {
    var e = $O();
    D(s, e);
}
var NO = (s, e) => Re(e, !0),
    VO = (s, e) => Re(e, !1),
    UO = X(
        '<div class="autospins-text svelte-191q57s"><!></div> <div class="stop-icon-wrap svelte-191q57s"><!></div>',
        1
    ),
    zO = X(
        '<div class="bet-button svelte-191q57s"><div class="bet-button-svg-wrap svelte-191q57s"><!></div></div>'
    );
function S2(s, e) {
    Ne(e, !0);
    const t = () => U(Wi, "$hideUI", f),
        n = () => U(gl, "$loaded", f),
        i = () => U(_l, "$startGame", f),
        r = () => U(og, "$isAutoSpin", f),
        a = () => U(Ws, "$gameState", f),
        o = () => U(xi, "$showAutoSpinMenu", f),
        h = () => U(Fp, "$selectedAutoSpinsRounds", f),
        l = () => U(ei, "$eventEmitter", f),
        u = () => U(vu, "$adjustedBetAmount", f),
        c = () => U(da, "$autoSpinsCounter", f),
        d = () => U(Us, "$betButtonState", f),
        [f, p] = tt();
    let m = gt(!1),
        g = gt(!1),
        _ = null;
    const v = 400;
    let b = 0;
    _n(() => {
        t() === !1 && (b = Date.now());
    });
    const y = () => {
        if (!(!n() || t() || !i()) && !(Date.now() - b < 500)) {
            if (r()) {
                br.set(!0);
                return;
            }
            a() === "idle" && !$(A)
                ? o() && h()
                    ? (da.set(h()), l().asyncNext({ type: "startAutobet" }))
                    : (l().next({ type: "betButtonClick" }), Re(m, !1))
                : l().next({ type: "skip" });
        }
    };
    function C(M) {
        M.code === "Space" &&
            !M.repeat &&
            (y(),
            (_ = setTimeout(() => {
                Re(g, !0),
                    bu.disabled || ((Te.baseTurbo = !0), (Te.turbo = !0));
            }, v)));
    }
    function w(M) {
        M.code === "Space" &&
            ($(g) && (Re(g, !1), (Te.baseTurbo = !1), (Te.turbo = !1)),
            _ && (clearTimeout(_), (_ = null)));
    }
    Fs(() => {
        window.addEventListener("keydown", C),
            window.addEventListener("keyup", w);
    }),
        gd(() => {
            window.removeEventListener("keydown", C),
                window.removeEventListener("keyup", w),
                _ && clearTimeout(_);
        });
    let A = gt(!1);
    _n(() => {
        Re(
            A,
            (a() === "activeBet" && !r()) || u() > Ke.instantBalance || t(),
            !0
        ),
            $(A)
                ? Us.set("disabled")
                : o()
                ? Us.set("preAutoSpin")
                : c()
                ? Us.set("autoSpinActive")
                : a() !== "activeBet" && Us.set("default");
    }),
        _n(() => {
            $(g) && !$(A) && y();
        });
    var E = zO();
    (E.__mouseover = [NO, m]), (E.__mouseout = [VO, m]), (E.__click = y);
    var S = I(E),
        P = I(S);
    {
        var k = (M) => {
                Eb(M);
            },
            R = (M) => {
                var T = Oe(),
                    O = me(T);
                {
                    var L = (Y) => {
                            Eb(Y);
                        },
                        F = (Y) => {
                            var V = Oe(),
                                W = me(V);
                            {
                                var Z = (G) => {
                                        var j = UO(),
                                            H = me(j),
                                            pe = I(H);
                                        {
                                            var _e = (at) => {
                                                    DO(at);
                                                },
                                                ve = (at) => {
                                                    var Ft = kE();
                                                    ie(() => se(Ft, c())),
                                                        D(at, Ft);
                                                };
                                            ne(pe, (at) => {
                                                c() === 1 / 0
                                                    ? at(_e)
                                                    : at(ve, !1);
                                            });
                                        }
                                        var re = N(H, 2),
                                            le = I(re);
                                        OO(le), D(G, j);
                                    },
                                    J = (G) => {
                                        var j = Oe(),
                                            H = me(j);
                                        {
                                            var pe = (_e) => {
                                                FO(_e);
                                            };
                                            ne(
                                                H,
                                                (_e) => {
                                                    d() === "preAutoSpin" &&
                                                        _e(pe);
                                                },
                                                !0
                                            );
                                        }
                                        D(G, j);
                                    };
                                ne(
                                    W,
                                    (G) => {
                                        r() ? G(Z) : G(J, !1);
                                    },
                                    !0
                                );
                            }
                            D(Y, V);
                        };
                    ne(
                        O,
                        (Y) => {
                            d() === "disabled" && !r() ? Y(L) : Y(F, !1);
                        },
                        !0
                    );
                }
                D(M, T);
            };
        ne(P, (M) => {
            d() === "default" ? M(k) : M(R, !1);
        });
    }
    ie(() =>
        an(
            S,
            d() === "disabled"
                ? "pointer-events: none; color: dimgrey;}"
                : `cursor: pointer; color: ${
                      $(m) ? "var(--game-theme-color)" : "black"
                  };`
        )
    ),
        D(s, E),
        Ve(),
        p();
}
Jt(["mouseover", "mouseout", "click"]);
var YO = bn(
    '<svg width="31" height="30" viewBox="0 0 65 66" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_273_146)"><path d="M62.1995 35.85C62.0795 35.03 61.2795 34.57 60.5095 34.87C55.0495 36.99 48.2795 40.27 41.0395 43.85C40.4095 44.16 40.3595 45.04 40.9695 45.4C40.9695 45.4 42.4595 46.56 45.1795 48.36C40.0195 52.76 32.4095 54.22 25.6895 53.81C16.5195 53.09 8.66947 46.67 4.85947 38.02C4.40947 36.96 2.75947 37.32 2.78947 38.48C2.89947 43.94 5.16947 49.45 8.82947 53.92C21.0095 69.11 44.0295 69.09 57.5795 55.56C60.6795 57.16 63.0795 58.3 63.0795 58.3C63.6895 58.65 64.4295 58.17 64.3795 57.47C63.6295 46.87 63.0595 41.73 62.1895 35.85H62.1995Z" fill="currentColor"></path><path d="M19.2297 22.68C19.7497 22.42 19.7897 21.7 19.2897 21.41C19.2897 21.41 18.0197 20.43 15.7297 18.91C20.4397 12.75 27.7397 8.74005 35.6397 8.27005C45.8197 8.09005 56.5097 12.6 61.1897 22.27C61.3997 22.71 61.8997 22.96 62.3997 22.84C62.9697 22.7 63.3297 22.13 63.1897 21.56C62.5097 18.68 61.2397 15.88 59.4897 13.39C57.7497 10.89 55.5697 8.70005 53.1497 6.79005C45.6697 0.730048 35.6397 -0.949952 26.2297 0.480048C18.0697 1.76005 10.5097 6.41005 5.47968 12.98C2.98968 11.7 1.07968 10.79 1.07968 10.79C0.579681 10.5 -0.0303186 10.9 0.00968141 11.48C0.629681 20.21 1.09968 24.43 1.81968 29.27C1.91968 29.94 2.57968 30.32 3.20968 30.07C7.69968 28.32 13.2697 25.62 19.2297 22.67V22.68Z" fill="currentColor"></path><path d="M27.5792 20.65C27.5792 20.65 27.0392 24.78 27.0892 31.31C27.1292 36.65 27.6692 42.71 27.6692 42.71C27.6692 43.32 28.3592 43.66 28.8592 43.31C36.3992 38.12 39.9692 35.45 43.9492 32.24C44.4992 31.79 44.4992 31 43.9392 30.56C39.9792 27.44 34.5892 23.84 28.7692 20.03C28.2592 19.7 27.5892 20.04 27.5892 20.65H27.5792Z" fill="currentColor"></path></g><defs><clipPath id="clip0_273_146"><rect width="64.39" height="65.52" fill="white"></rect></clipPath></defs></svg>'
);
function Pb(s) {
    var e = YO();
    D(s, e);
}
const GO = (s, e, t) => {
    e().next({ type: "playButtonClick" }), Ia(xi, !t());
};
var jO = X(
        '<div class="wrap svelte-7uhvbe"><div class="disabled-button-container svelte-7uhvbe"></div> <div class="button-svg-wrap disabled svelte-7uhvbe"><!></div></div>'
    ),
    WO = X(
        '<div class="wrap svelte-7uhvbe"><div class="button-container svelte-7uhvbe"></div> <div class="button-svg-wrap svelte-7uhvbe"><!></div></div>'
    );
function E2(s, e) {
    Ne(e, !0);
    const t = () => U(Ws, "$gameState", o),
        n = () => U(og, "$isAutoSpin", o),
        i = () => U(wi, "$showBetAmountMenu", o),
        r = () => U(ei, "$eventEmitter", o),
        a = () => U(xi, "$showAutoSpinMenu", o),
        [o, h] = tt();
    let l = Me(() => t() === "activeBet" || n());
    _u(() => {
        $(l) && xi.set(!1);
    }),
        _u(() => {
            i() && xi.set(!1);
        });
    var u = Oe(),
        c = me(u);
    {
        var d = (p) => {
                var m = jO(),
                    g = N(I(m), 2),
                    _ = I(g);
                Pb(_), D(p, m);
            },
            f = (p) => {
                var m = WO(),
                    g = I(m);
                g.__click = [GO, r, a];
                var _ = N(g, 2),
                    v = I(_);
                Pb(v), D(p, m);
            };
        ne(c, (p) => {
            $(l) ? p(d) : p(f, !1);
        });
    }
    D(s, u), Ve(), h();
}
Jt(["click"]);
var XO = bn(
    '<svg width="20" height="30" viewBox="0 0 8 12" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.82055 0.757516C2.97241 0.377857 3.34012 0.128906 3.74903 0.128906H6.4764C6.70822 0.128906 6.85245 0.380625 6.73521 0.580618L4.70235 4.04859C4.58511 4.24858 4.72934 4.5003 4.96116 4.5003H6.43435C6.91516 4.5003 7.20066 5.03754 6.93163 5.43603L2.72291 11.6698C2.60793 11.8401 2.36549 11.8618 2.22218 11.7145V11.7145C2.14188 11.632 2.11141 11.513 2.14215 11.4021L3.39471 6.88039C3.44765 6.68927 3.30391 6.5003 3.1056 6.5003H1.40966C0.985179 6.5003 0.694924 6.07158 0.852571 5.67746L2.82055 0.757516Z" fill="currentColor"></path></svg>'
);
function sh(s) {
    var e = XO();
    D(s, e);
}
const qO = (s, e, t) => {
    bu.disabled ||
        (e().next({ type: "playButtonClick" }),
        t() === "base" ? Te.toggleBaseTurbo() : Te.toggleBonusTurbo());
};
var HO = X('<div class="wrap svelte-hnw2x7"><div></div> <div><!></div></div>');
function Do(s, e) {
    Ne(e, !0);
    const t = () => U(ei, "$eventEmitter", i),
        n = () => U(Ys, "$gameMode", i),
        [i, r] = tt();
    var a = HO(),
        o = I(a);
    o.__click = [qO, t, n];
    var h = N(o, 2),
        l = I(h);
    sh(l),
        ie(() => {
            qe(
                o,
                1,
                `button-container ${bu.disabled ? "disabled" : ""} ${
                    Te.turbo ? "active" : ""
                }`,
                "svelte-hnw2x7"
            ),
                qe(
                    h,
                    1,
                    `button-svg-wrap ${bu.disabled ? "disabled" : ""} ${
                        Te.turbo ? "active" : ""
                    }`,
                    "svelte-hnw2x7"
                );
        }),
        D(s, a),
        Ve(),
        r();
}
Jt(["click"]);
var KO = bn(
    '<svg width="44" height="26" viewBox="0 0 44 26" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M18.0018 1.37523C19.0758 0.395938 20.4449 -0.0557467 21.7905 0.00547807C23.164 -0.0568981 24.5603 0.415151 25.6406 1.43189L41.9236 16.7571C44.0423 18.7512 44.1433 22.0852 42.1493 24.2038C40.1552 26.3225 36.8212 26.4235 34.7026 24.4295L21.7376 12.2271L8.81745 24.0072C6.66748 25.9675 3.33549 25.8137 1.37523 23.6638C-0.585033 21.5138 -0.431249 18.1818 1.71871 16.2215L18.0018 1.37523Z" fill="currentColor"></path></svg>'
);
function kb(s) {
    var e = KO();
    D(s, e);
}
var ZO = X('<div><div class="button-svg-wrap svelte-q72fdw"><!></div></div>'),
    QO = X('<div><div class="button-svg-wrap svelte-q72fdw"><!></div></div>');
function qg(s, e) {
    Ne(e, !0);
    const t = () => U(ml, "$betAmountOptions", h),
        n = () => U(Nt, "$betAmount", h),
        i = () => U(Ws, "$gameState", h),
        r = () => U(ei, "$eventEmitter", h),
        a = () => U(Ki, "$showBuyScreen", h),
        o = () => U(us, "$layoutType", h),
        [h, l] = tt();
    let u = Me(() => t().findIndex((_) => _ === n())),
        c = Me(() => i() === "activeBet" || $(u) === t().length - 1);
    const d = () => {
        $(u) !== t().length - 1 && Nt.set(t()[$(u) + 1]),
            r().next({ type: "increaseBet" });
    };
    var f = Oe(),
        p = me(f);
    {
        var m = (_) => {
                var v = ZO(),
                    b = I(v),
                    y = I(b);
                kb(y),
                    ie(() => {
                        an(v, a() ? "border-bottom-right-radius: 1em;" : ""),
                            qe(
                                v,
                                1,
                                `disabled-bet-amount-button ${o() ?? ""}`,
                                "svelte-q72fdw"
                            );
                    }),
                    D(_, v);
            },
            g = (_) => {
                var v = QO();
                v.__click = d;
                var b = I(v),
                    y = I(b);
                kb(y),
                    ie(() => {
                        qe(
                            v,
                            1,
                            `bet-amount-button ${o() ?? ""}`,
                            "svelte-q72fdw"
                        ),
                            an(
                                v,
                                a() ? "border-bottom-right-radius: 1em;" : ""
                            );
                    }),
                    D(_, v);
            };
        ne(p, (_) => {
            $(c) ? _(m) : _(g, !1);
        });
    }
    D(s, f), Ve(), l();
}
Jt(["click"]);
var JO = bn(
    '<svg width="44" height="26" viewBox="0 0 44 26" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M1.43187 1.65753C3.42591 -0.461142 6.75992 -0.562172 8.87859 1.43187L21.8436 13.6342L34.7637 1.85411C36.9137 -0.106144 40.2457 0.047637 42.2059 2.1976C44.1662 4.34757 44.0124 7.67956 41.8624 9.63982L25.5794 24.4861C24.5053 25.4654 23.1363 25.9171 21.7906 25.8559C20.4171 25.9183 19.0209 25.4462 17.9406 24.4295L1.65753 9.10425C-0.461141 7.11021 -0.562172 3.7762 1.43187 1.65753Z" fill="currentColor"></path></svg>'
);
function Tb(s) {
    var e = JO();
    D(s, e);
}
var eB = X('<div><div class="button-svg-wrap svelte-1e9h9vo"><!></div></div>'),
    tB = X('<div><div class="button-svg-wrap svelte-1e9h9vo"><!></div></div>');
function Hg(s, e) {
    Ne(e, !0);
    const t = () => U(ml, "$betAmountOptions", h),
        n = () => U(Nt, "$betAmount", h),
        i = () => U(Ws, "$gameState", h),
        r = () => U(ei, "$eventEmitter", h),
        a = () => U(us, "$layoutType", h),
        o = () => U(Ki, "$showBuyScreen", h),
        [h, l] = tt();
    let u = Me(() => t().findIndex((_) => _ === n())),
        c = Me(() => i() === "activeBet" || $(u) === 0);
    const d = () => {
        $(u) !== 0 && Nt.set(t()[$(u) - 1]), r().next({ type: "decreaseBet" });
    };
    var f = Oe(),
        p = me(f);
    {
        var m = (_) => {
                var v = eB(),
                    b = I(v),
                    y = I(b);
                Tb(y),
                    ie(() => {
                        qe(
                            v,
                            1,
                            `disabled-bet-amount-button ${a() ?? ""}`,
                            "svelte-1e9h9vo"
                        ),
                            an(v, o() ? "border-bottom-left-radius: 1em;" : "");
                    }),
                    D(_, v);
            },
            g = (_) => {
                var v = tB();
                v.__click = d;
                var b = I(v),
                    y = I(b);
                Tb(y),
                    ie(() => {
                        qe(
                            v,
                            1,
                            `bet-amount-button ${a() ?? ""}`,
                            "svelte-1e9h9vo"
                        ),
                            an(v, o() ? "border-bottom-left-radius: 1em;" : "");
                    }),
                    D(_, v);
            };
        ne(p, (_) => {
            $(c) ? _(m) : _(g, !1);
        });
    }
    D(s, f), Ve(), l();
}
Jt(["click"]);
var nB = X(
        '<div class="free-wrap svelte-1yhn98i"><span class="free-text svelte-1yhn98i"> </span> <span class="divider svelte-1yhn98i"></span> <span class="value svelte-1yhn98i"> </span></div>'
    ),
    sB = X(
        '<div class="desktop-wrap svelte-1yhn98i"><div class="wrap svelte-1yhn98i"><span class="text svelte-1yhn98i"> </span> <span class="value svelte-1yhn98i"> </span></div> <!></div>'
    ),
    iB = X(
        '<div class="wrap svelte-1yhn98i"><span class="free-text svelte-1yhn98i"> </span> <span class="value svelte-1yhn98i"> </span></div>'
    ),
    rB = X(
        '<div class="mobile-wrap svelte-1yhn98i"><div class="wrap svelte-1yhn98i"><span class="text svelte-1yhn98i"> </span> <span class="value svelte-1yhn98i"> </span></div> <!></div>'
    );
function qu(s, e) {
    Ne(e, !0);
    const t = () => U(Zc, "$totalWin", o),
        n = () => U(Js, "$currency", o),
        i = () => U(us, "$layoutType", o),
        r = () => U(Ys, "$gameMode", o),
        a = () => U(lg, "$freeSpinsRemaining", o),
        [o, h] = tt();
    let l = oe.t("TOTAL_WIN"),
        u = oe.t("FREE_SPINS"),
        c = Me(() => nr(t() ?? 0, n()));
    var d = Oe(),
        f = me(d);
    {
        var p = (g) => {
                var _ = sB(),
                    v = I(_),
                    b = I(v),
                    y = I(b),
                    C = N(b, 2),
                    w = I(C),
                    A = N(v, 2);
                {
                    var E = (S) => {
                        var P = nB(),
                            k = I(P),
                            R = I(k),
                            M = N(k, 4),
                            T = I(M);
                        ie(() => {
                            se(R, u), se(T, a());
                        }),
                            D(S, P);
                    };
                    ne(A, (S) => {
                        r() === "bonus" && S(E);
                    });
                }
                ie(() => {
                    an(
                        _,
                        `transform: scale(${i() === "landscape" ? "0.8" : "1"})`
                    ),
                        se(y, l),
                        se(w, $(c));
                }),
                    D(g, _);
            },
            m = (g) => {
                var _ = rB(),
                    v = I(_),
                    b = I(v),
                    y = I(b),
                    C = N(b, 2),
                    w = I(C),
                    A = N(v, 2);
                {
                    var E = (S) => {
                        var P = iB(),
                            k = I(P),
                            R = I(k),
                            M = N(k, 2),
                            T = I(M);
                        ie(() => {
                            se(R, u), se(T, a());
                        }),
                            D(S, P);
                    };
                    ne(A, (S) => {
                        r() === "bonus" && S(E);
                    });
                }
                ie(() => {
                    se(y, l), se(w, $(c));
                }),
                    D(g, _);
            };
        ne(f, (g) => {
            i() !== "portrait" ? g(p) : g(m, !1);
        });
    }
    D(s, d), Ve(), h();
}
var aB = X(
        '<div class="desktop-panel-wrap svelte-19w4kju"><div class="main-panel-desktop-wrap svelte-19w4kju"><div class="main-panel-container svelte-19w4kju"><div class="texts-wrap svelte-19w4kju"><!> <!> <!></div> <div class="info-panel-wrap svelte-19w4kju"><!> <!></div></div></div></div>'
    ),
    oB = X(
        '<div class="desktop-panel-wrap svelte-19w4kju"><!> <div class="main-panel-desktop-wrap svelte-19w4kju"><div class="main-panel-container svelte-19w4kju"><div class="texts-wrap svelte-19w4kju"><!> <!> <!></div> <div class="bet-controls-wrap svelte-19w4kju"><div class="bet-indicator-wrap svelte-19w4kju"><!> <div class="bet-buttons-controls-wrap svelte-19w4kju"><!> <!></div></div> <div class="bet-button-wrap svelte-19w4kju"><!> <div class="control-buttons-wrap svelte-19w4kju"><!> <!></div></div></div></div></div></div>'
    ),
    lB = X(
        '<div class="desktop-panel-wrap svelte-19w4kju"><div class="main-panel-desktop-wrap svelte-19w4kju"><div class="main-panel-container svelte-19w4kju"><div class="texts-wrap svelte-19w4kju"><!> <!> <!> <!></div> <div class="info-panel-wrap svelte-19w4kju"><!> <!></div></div></div></div>'
    );
function hB(s, e) {
    Ne(e, !0);
    const t = () => U(Ys, "$gameMode", i),
        n = () => U(Iw, "$showBuyButton", i),
        [i, r] = tt();
    var a = Oe(),
        o = me(a);
    {
        var h = (u) => {
                var c = aB(),
                    d = I(c),
                    f = I(d),
                    p = I(f),
                    m = I(p);
                Fo(m, {});
                var g = N(m, 2);
                Xu(g, {});
                var _ = N(g, 2);
                $o(_, {});
                var v = N(p, 2),
                    b = I(v);
                qu(b, {});
                var y = N(b, 2);
                Do(y, {}), D(u, c);
            },
            l = (u) => {
                var c = Oe(),
                    d = me(c);
                {
                    var f = (m) => {
                            var g = oB(),
                                _ = I(g);
                            {
                                var v = (W) => {
                                    A2(W, {});
                                };
                                ne(_, (W) => {
                                    n() && W(v);
                                });
                            }
                            var b = N(_, 2),
                                y = I(b),
                                C = I(y),
                                w = I(C);
                            Fo(w, {});
                            var A = N(w, 2);
                            Wh(A, {});
                            var E = N(A, 2);
                            $o(E, {});
                            var S = N(C, 2),
                                P = I(S),
                                k = I(P);
                            Xg(k, {});
                            var R = N(k, 2),
                                M = I(R);
                            qg(M, {});
                            var T = N(M, 2);
                            Hg(T, {});
                            var O = N(P, 2),
                                L = I(O);
                            S2(L, {});
                            var F = N(L, 2),
                                Y = I(F);
                            E2(Y, {});
                            var V = N(Y, 2);
                            Do(V, {}), D(m, g);
                        },
                        p = (m) => {
                            var g = lB(),
                                _ = I(g),
                                v = I(_),
                                b = I(v),
                                y = I(b);
                            Fo(y, {});
                            var C = N(y, 2);
                            Wh(C, {});
                            var w = N(C, 2);
                            Xu(w, {});
                            var A = N(w, 2);
                            $o(A, {});
                            var E = N(b, 2),
                                S = I(E);
                            qu(S, {});
                            var P = N(S, 2);
                            Do(P, {}), D(m, g);
                        };
                    ne(
                        d,
                        (m) => {
                            t() === "base" ? m(f) : m(p, !1);
                        },
                        !0
                    );
                }
                D(u, c);
            };
        ne(o, (u) => {
            Qe.replay ? u(h) : u(l, !1);
        });
    }
    D(s, a), Ve(), r();
}
var cB = X(
        '<div class="main-panel-wrap-portrait svelte-15xhv4t"><div class="bonus-panel-container-portrait svelte-15xhv4t"><div class="bonus-menu-button svelte-15xhv4t"><!></div> <div class="bonus-info-panel svelte-15xhv4t"><!></div> <div class="bonus-menu-button svelte-15xhv4t"><!></div></div> <div class="info-bar-container svelte-15xhv4t"><div class="text-container svelte-15xhv4t"><!></div> <div class="text-container svelte-15xhv4t"><!></div></div></div>'
    ),
    uB = X(
        '<div class="main-panel-wrap-portrait svelte-15xhv4t"><div class="panel-container-portrait svelte-15xhv4t"><div class="menu-button svelte-15xhv4t"><!></div> <div class="bet-buttons svelte-15xhv4t"><!> <!> <!></div> <!></div> <div class="info-bar-container svelte-15xhv4t"><div class="text-container svelte-15xhv4t"><!></div> <div class="bet-amount-container svelte-15xhv4t"><!> <!> <!></div> <div class="text-container svelte-15xhv4t"><!></div></div></div>'
    ),
    dB = X(
        '<div class="main-panel-wrap-portrait svelte-15xhv4t"><div class="bonus-panel-container-portrait svelte-15xhv4t"><div class="bonus-menu-button svelte-15xhv4t"><!></div> <div class="bonus-info-panel svelte-15xhv4t"><!></div> <div class="bonus-menu-button svelte-15xhv4t"><!></div></div> <div class="info-bar-container bonus svelte-15xhv4t"><div class="text-container svelte-15xhv4t"><!></div> <div class="text-container svelte-15xhv4t"><!></div> <div class="text-container svelte-15xhv4t"><!></div></div></div>'
    );
function fB(s, e) {
    Ne(e, !0);
    const t = () => U(Ys, "$gameMode", i),
        n = () => U(Iw, "$showBuyButton", i),
        [i, r] = tt();
    var a = Oe(),
        o = me(a);
    {
        var h = (u) => {
                var c = cB(),
                    d = I(c),
                    f = I(d),
                    p = I(f);
                Fo(p, {});
                var m = N(f, 2),
                    g = I(m);
                qu(g, {});
                var _ = N(m, 2),
                    v = I(_);
                Do(v, {});
                var b = N(d, 2),
                    y = I(b),
                    C = I(y);
                Xu(C, {});
                var w = N(y, 2),
                    A = I(w);
                $o(A, {}), D(u, c);
            },
            l = (u) => {
                var c = Oe(),
                    d = me(c);
                {
                    var f = (m) => {
                            var g = uB(),
                                _ = I(g),
                                v = I(_),
                                b = I(v);
                            Fo(b, {});
                            var y = N(v, 2),
                                C = I(y);
                            E2(C, {});
                            var w = N(C, 2);
                            S2(w, {});
                            var A = N(w, 2);
                            Do(A, {});
                            var E = N(y, 2);
                            {
                                var S = (V) => {
                                    A2(V, {});
                                };
                                ne(E, (V) => {
                                    n() && V(S);
                                });
                            }
                            var P = N(_, 2),
                                k = I(P),
                                R = I(k);
                            Wh(R, {});
                            var M = N(k, 2),
                                T = I(M);
                            Hg(T, {});
                            var O = N(T, 2);
                            Xg(O, {});
                            var L = N(O, 2);
                            qg(L, {});
                            var F = N(M, 2),
                                Y = I(F);
                            $o(Y, {}), D(m, g);
                        },
                        p = (m) => {
                            var g = dB(),
                                _ = I(g),
                                v = I(_),
                                b = I(v);
                            Fo(b, {});
                            var y = N(v, 2),
                                C = I(y);
                            qu(C, {});
                            var w = N(y, 2),
                                A = I(w);
                            Do(A, {});
                            var E = N(_, 2),
                                S = I(E),
                                P = I(S);
                            Wh(P, {});
                            var k = N(S, 2),
                                R = I(k);
                            Xu(R, {});
                            var M = N(k, 2),
                                T = I(M);
                            $o(T, {}), D(m, g);
                        };
                    ne(
                        d,
                        (m) => {
                            t() === "base" ? m(f) : m(p, !1);
                        },
                        !0
                    );
                }
                D(u, c);
            };
        ne(o, (u) => {
            Qe.replay ? u(h) : u(l, !1);
        });
    }
    D(s, a), Ve(), r();
}
var pB = X("<span> </span>"),
    mB = X(
        '<div class="paytable-column-container svelte-117qztj"><img class="paytable-image svelte-117qztj"/> <div class="paytable-column svelte-117qztj"></div></div>'
    ),
    gB = X('<div class="paysection svelte-117qztj"></div>'),
    _B = X("<span> </span>"),
    vB = X(
        '<div class="paytable-column-container svelte-117qztj"><img class="paytable-image svelte-117qztj"/> <div class="paytable-column svelte-117qztj"></div></div>'
    ),
    bB = X('<div class="paysection svelte-117qztj"></div>'),
    yB = X("<span> </span>"),
    wB = X(
        '<div class="paytable-column-container svelte-117qztj"><img class="paytable-image svelte-117qztj"/> <div class="paytable-column svelte-117qztj"></div></div>'
    ),
    xB = X('<div class="paysection svelte-117qztj"></div>'),
    CB = X("<span> </span>"),
    AB = X(
        '<div class="paytable-column-container svelte-117qztj"><img class="paytable-image svelte-117qztj"/> <div class="paytable-column svelte-117qztj"></div></div>'
    ),
    SB = X('<div class="paysection svelte-117qztj"></div>'),
    EB = X(
        '<div class="paytable-column-container svelte-117qztj"><img class="paytable-image svelte-117qztj"/> <div class="paytable-column svelte-117qztj"><span> </span></div></div>'
    ),
    PB = X('<div class="paysection svelte-117qztj"></div>'),
    kB = X(
        '<div class="section svelte-117qztj"><h1 class="svelte-117qztj"> </h1> <!> <!> <!> <!> <!></div>'
    ),
    TB = X("<span></span>"),
    MB = X('<div class="payline svelte-117qztj"></div>'),
    IB = X('<div class="payline-wrap svelte-117qztj"></div>'),
    RB = X("<span></span>"),
    LB = X(
        '<div class="scatter-wrap svelte-117qztj"><div class="payline svelte-117qztj"></div></div>'
    ),
    OB = X("<span></span>"),
    BB = X(
        '<div class="cluster-wrap"><div class="payline svelte-117qztj"></div></div>'
    ),
    FB = X("<span></span>"),
    $B = X(
        '<div class="ways-wrap svelte-117qztj"><div class="payline svelte-117qztj"></div></div>'
    ),
    DB = X(
        '<div aria-hidden="true" class="info-screen-wrap svelte-117qztj"><div class="close-button svelte-117qztj"><!></div> <div class="info-wrap svelte-117qztj"><div class="section svelte-117qztj"><h1 class="svelte-117qztj"> </h1> <p class="svelte-117qztj"> </p></div> <!> <div class="section svelte-117qztj"><h1 class="svelte-117qztj"> </h1> <p class="svelte-117qztj"> </p> <!> <!> <!> <!></div> <div class="section svelte-117qztj"><h1 class="svelte-117qztj"> </h1> <p class="svelte-117qztj"> </p></div> <div class="section svelte-117qztj"><h1 class="svelte-117qztj"> </h1> <p class="svelte-117qztj"> </p></div> <p class="svelte-117qztj"> </p></div></div>'
    );
function P2(s, e) {
    Ne(e, !0);
    const t = () => U(ah, "$showInfoScreen", i),
        n = () => U(Lw, "$gameRuleMeta", i),
        [i, r] = tt(),
        a = () => {
            ah.set(!1);
        };
    _n(() => {
        Wi.set(t());
    });
    function o(d) {
        d.code === "Escape" && !d.repeat && ah.set(!1);
    }
    function h(d, f, p) {
        return p.some((m) => m.reel === d && m.row === f);
    }
    Fs(() => {
        window.addEventListener("keydown", o);
    }),
        gd(() => {
            window.removeEventListener("keydown", o);
        });
    var l = Oe(),
        u = me(l);
    {
        var c = (d) => {
            var f = DB();
            f.__click = a;
            var p = I(f);
            p.__click = a;
            var m = I(p);
            zu(m);
            var g = N(p, 2),
                _ = I(g),
                v = I(_),
                b = I(v),
                y = N(v, 2),
                C = I(y),
                w = N(_, 2);
            {
                var A = (Ae) => {
                    var Fe = kB(),
                        $e = I(Fe),
                        Gt = I($e),
                        ct = N($e, 2);
                    {
                        var Xe = (Mt) => {
                            var In = Oe(),
                                Fi = me(In);
                            lt(
                                Fi,
                                1,
                                () => n().paytable,
                                ot,
                                ($i, Rn) => {
                                    var Ln = gB();
                                    lt(
                                        Ln,
                                        21,
                                        () => $(Rn).symbols,
                                        ot,
                                        (Di, en) => {
                                            var Xn = mB(),
                                                On = I(Xn),
                                                ps = N(On, 2);
                                            lt(
                                                ps,
                                                21,
                                                () =>
                                                    Array.from(
                                                        {
                                                            length:
                                                                $(Rn).max -
                                                                $(Rn).min +
                                                                1,
                                                        },
                                                        (ai, mt) =>
                                                            $(Rn).min + mt
                                                    ),
                                                ot,
                                                (ai, mt) => {
                                                    var tn = pB(),
                                                        oi = I(tn);
                                                    ie(() =>
                                                        se(
                                                            oi,
                                                            `${$(mt) ?? ""} | ${
                                                                $(en)[$(mt)] ??
                                                                ""
                                                            }x`
                                                        )
                                                    ),
                                                        D(ai, tn);
                                                }
                                            ),
                                                ie(() =>
                                                    wr(On, "src", $(en).image)
                                                ),
                                                D(Di, Xn);
                                        }
                                    ),
                                        D($i, Ln);
                                }
                            ),
                                D(Mt, In);
                        };
                        ne(ct, (Mt) => {
                            n().payType === "payline" && Mt(Xe);
                        });
                    }
                    var ft = N(ct, 2);
                    {
                        var pt = (Mt) => {
                            var In = Oe(),
                                Fi = me(In);
                            lt(
                                Fi,
                                1,
                                () => n().paytable,
                                ot,
                                ($i, Rn) => {
                                    var Ln = bB();
                                    lt(
                                        Ln,
                                        21,
                                        () => $(Rn).symbols,
                                        ot,
                                        (Di, en) => {
                                            const Xn = Me(() =>
                                                Object.keys($(en))
                                                    .filter(
                                                        (mt) =>
                                                            !isNaN(Number(mt))
                                                    )
                                                    .map(Number)
                                                    .sort((mt, tn) => mt - tn)
                                            );
                                            var On = vB(),
                                                ps = I(On),
                                                ai = N(ps, 2);
                                            lt(
                                                ai,
                                                21,
                                                () => $(Xn),
                                                ot,
                                                (mt, tn, oi) => {
                                                    const El = Me(() =>
                                                            oi === 0
                                                                ? $(Rn).min
                                                                : $(Xn)[
                                                                      oi - 1
                                                                  ] + 1
                                                        ),
                                                        Kd = Me(() => $(tn));
                                                    var Pl = _B(),
                                                        Zd = I(Pl);
                                                    ie(() =>
                                                        se(
                                                            Zd,
                                                            `${$(El) ?? ""} - ${
                                                                $(Kd) ?? ""
                                                            } | ${
                                                                $(en)[$(tn)] ??
                                                                ""
                                                            }x`
                                                        )
                                                    ),
                                                        D(mt, Pl);
                                                }
                                            ),
                                                ie(() =>
                                                    wr(ps, "src", $(en).image)
                                                ),
                                                D(Di, On);
                                        }
                                    ),
                                        D($i, Ln);
                                }
                            ),
                                D(Mt, In);
                        };
                        ne(ft, (Mt) => {
                            n().payType === "scatter" && Mt(pt);
                        });
                    }
                    var fs = N(ft, 2);
                    {
                        var Bi = (Mt) => {
                            var In = Oe(),
                                Fi = me(In);
                            lt(
                                Fi,
                                1,
                                () => n().paytable,
                                ot,
                                ($i, Rn) => {
                                    var Ln = xB();
                                    lt(
                                        Ln,
                                        21,
                                        () => $(Rn).symbols,
                                        ot,
                                        (Di, en) => {
                                            const Xn = Me(() =>
                                                Object.keys($(en))
                                                    .filter(
                                                        (mt) =>
                                                            !isNaN(Number(mt))
                                                    )
                                                    .map(Number)
                                                    .sort((mt, tn) => mt - tn)
                                            );
                                            var On = wB(),
                                                ps = I(On),
                                                ai = N(ps, 2);
                                            lt(
                                                ai,
                                                21,
                                                () => $(Xn),
                                                ot,
                                                (mt, tn, oi) => {
                                                    const El = Me(() =>
                                                            oi === 0
                                                                ? $(Rn).min
                                                                : $(Xn)[
                                                                      oi - 1
                                                                  ] + 1
                                                        ),
                                                        Kd = Me(() => $(tn));
                                                    var Pl = yB(),
                                                        Zd = I(Pl);
                                                    ie(() =>
                                                        se(
                                                            Zd,
                                                            `${$(El) ?? ""} - ${
                                                                $(Kd) ?? ""
                                                            } | ${
                                                                $(en)[$(tn)] ??
                                                                ""
                                                            }x`
                                                        )
                                                    ),
                                                        D(mt, Pl);
                                                }
                                            ),
                                                ie(() =>
                                                    wr(ps, "src", $(en).image)
                                                ),
                                                D(Di, On);
                                        }
                                    ),
                                        D($i, Ln);
                                }
                            ),
                                D(Mt, In);
                        };
                        ne(fs, (Mt) => {
                            n().payType === "cluster" && Mt(Bi);
                        });
                    }
                    var Sl = N(fs, 2);
                    {
                        var to = (Mt) => {
                            var In = Oe(),
                                Fi = me(In);
                            lt(
                                Fi,
                                1,
                                () => n().paytable,
                                ot,
                                ($i, Rn) => {
                                    var Ln = SB();
                                    lt(
                                        Ln,
                                        21,
                                        () => $(Rn).symbols,
                                        ot,
                                        (Di, en) => {
                                            const Xn = Me(() =>
                                                Object.keys($(en))
                                                    .filter(
                                                        (mt) =>
                                                            !isNaN(Number(mt))
                                                    )
                                                    .map(Number)
                                                    .sort((mt, tn) => mt - tn)
                                            );
                                            var On = AB(),
                                                ps = I(On),
                                                ai = N(ps, 2);
                                            lt(
                                                ai,
                                                21,
                                                () => $(Xn),
                                                ot,
                                                (mt, tn) => {
                                                    var oi = CB(),
                                                        El = I(oi);
                                                    ie(() =>
                                                        se(
                                                            El,
                                                            `${$(tn) ?? ""} | ${
                                                                $(en)[$(tn)] ??
                                                                ""
                                                            }x`
                                                        )
                                                    ),
                                                        D(mt, oi);
                                                }
                                            ),
                                                ie(() =>
                                                    wr(ps, "src", $(en).image)
                                                ),
                                                D(Di, On);
                                        }
                                    ),
                                        D($i, Ln);
                                }
                            ),
                                D(Mt, In);
                        };
                        ne(Sl, (Mt) => {
                            n().payType === "ways" && Mt(to);
                        });
                    }
                    var yS = N(Sl, 2);
                    {
                        var wS = (Mt) => {
                            var In = Oe(),
                                Fi = me(In);
                            lt(
                                Fi,
                                1,
                                () => n().paytable,
                                ot,
                                ($i, Rn) => {
                                    var Ln = PB();
                                    lt(
                                        Ln,
                                        21,
                                        () => $(Rn).symbols,
                                        ot,
                                        (Di, en) => {
                                            var Xn = EB(),
                                                On = I(Xn),
                                                ps = N(On, 2),
                                                ai = I(ps),
                                                mt = I(ai);
                                            ie(() => {
                                                wr(On, "src", $(en).image),
                                                    se(mt, $(en).customText);
                                            }),
                                                D(Di, Xn);
                                        }
                                    ),
                                        D($i, Ln);
                                }
                            ),
                                D(Mt, In);
                        };
                        ne(yS, (Mt) => {
                            n().payType === "custom" && Mt(wS);
                        });
                    }
                    ie((Mt) => se(Gt, Mt), [() => oe.t("PAYTABLE")]), D(Ae, Fe);
                };
                ne(w, (Ae) => {
                    n().payType !== "none" && Ae(A);
                });
            }
            var E = N(w, 2),
                S = I(E),
                P = I(S),
                k = N(S, 2),
                R = I(k),
                M = N(k, 2);
            {
                var T = (Ae) => {
                    var Fe = IB();
                    lt(
                        Fe,
                        5,
                        () => Object.values(n().paylines),
                        ot,
                        ($e, Gt) => {
                            var ct = MB();
                            lt(
                                ct,
                                5,
                                () => Array(n().reels * n().rows),
                                ot,
                                (Xe, ft, pt) => {
                                    var fs = TB();
                                    ie(
                                        (Bi) =>
                                            qe(
                                                fs,
                                                1,
                                                `payline-index ${Bi ?? ""}`,
                                                "svelte-117qztj"
                                            ),
                                        [
                                            () =>
                                                h(
                                                    pt % n().reels,
                                                    Math.floor(pt / n().reels),
                                                    $(Gt)
                                                )
                                                    ? "is-active"
                                                    : "",
                                        ]
                                    ),
                                        D(Xe, fs);
                                }
                            ),
                                ie(() =>
                                    an(
                                        ct,
                                        `grid-template-columns: repeat(${
                                            n().reels ?? ""
                                        }, 1fr); grid-template-rows: repeat(${
                                            n().rows ?? ""
                                        }, 1fr);`
                                    )
                                ),
                                D($e, ct);
                        }
                    ),
                        D(Ae, Fe);
                };
                ne(M, (Ae) => {
                    n().payType === "payline" && Ae(T);
                });
            }
            var O = N(M, 2);
            {
                var L = (Ae) => {
                    var Fe = LB(),
                        $e = I(Fe);
                    lt(
                        $e,
                        5,
                        () => Array(n().reels * n().rows),
                        ot,
                        (Gt, ct, Xe) => {
                            const ft = Me(() =>
                                [0, 4, 9, 10, 18, 19, 27, 28].includes(Xe)
                            );
                            var pt = RB();
                            ie(() =>
                                qe(
                                    pt,
                                    1,
                                    `payline-index ${$(ft) ? "is-active" : ""}`,
                                    "svelte-117qztj"
                                )
                            ),
                                D(Gt, pt);
                        }
                    ),
                        ie(() =>
                            an(
                                $e,
                                `grid-template-columns: repeat(${
                                    n().reels ?? ""
                                }, 1fr); grid-template-rows: repeat(${
                                    n().rows ?? ""
                                }, 1fr);`
                            )
                        ),
                        D(Ae, Fe);
                };
                ne(O, (Ae) => {
                    n().payType === "scatter" && Ae(L);
                });
            }
            var F = N(O, 2);
            {
                var Y = (Ae) => {
                    var Fe = BB(),
                        $e = I(Fe);
                    lt(
                        $e,
                        5,
                        () => Array(n().reels * n().rows),
                        ot,
                        (Gt, ct, Xe) => {
                            const ft = Me(() =>
                                [10, 11, 16, 17, 18]
                                    .slice(0, n().paytable[0].min)
                                    .includes(Xe)
                            );
                            var pt = OB();
                            ie(() =>
                                qe(
                                    pt,
                                    1,
                                    `payline-index ${$(ft) ? "is-active" : ""}`,
                                    "svelte-117qztj"
                                )
                            ),
                                D(Gt, pt);
                        }
                    ),
                        ie(() =>
                            an(
                                $e,
                                `grid-template-columns: repeat(${
                                    n().reels ?? ""
                                }, 1fr); grid-template-rows: repeat(${
                                    n().rows ?? ""
                                }, 1fr);`
                            )
                        ),
                        D(Ae, Fe);
                };
                ne(F, (Ae) => {
                    n().payType === "cluster" && Ae(Y);
                });
            }
            var V = N(F, 2);
            {
                var W = (Ae) => {
                    var Fe = $B(),
                        $e = I(Fe);
                    lt(
                        $e,
                        5,
                        () => Array(n().reels * n().rows),
                        ot,
                        (Gt, ct, Xe) => {
                            const ft = Me(
                                () =>
                                    (Xe % n().reels === 0 ||
                                        Xe % n().reels === 1 ||
                                        Xe % n().reels === 2) &&
                                    Math.floor(Xe / n().reels) === 2
                            );
                            var pt = FB();
                            ie(() =>
                                qe(
                                    pt,
                                    1,
                                    `payline-index ${$(ft) ? "is-active" : ""}`,
                                    "svelte-117qztj"
                                )
                            ),
                                D(Gt, pt);
                        }
                    ),
                        ie(() =>
                            an(
                                $e,
                                `grid-template-columns: repeat(${
                                    n().reels ?? ""
                                }, 1fr); grid-template-rows: repeat(${
                                    n().rows ?? ""
                                }, 1fr);`
                            )
                        ),
                        D(Ae, Fe);
                };
                ne(V, (Ae) => {
                    n().payType === "ways" && Ae(W);
                });
            }
            var Z = N(E, 2),
                J = I(Z),
                G = I(J),
                j = N(J, 2),
                H = I(j),
                pe = N(Z, 2),
                _e = I(pe),
                ve = I(_e),
                re = N(_e, 2),
                le = I(re),
                at = N(pe, 2),
                Ft = I(at);
            ie(
                (Ae, Fe, $e, Gt, ct, Xe, ft, pt) => {
                    se(b, Ae),
                        se(C, Fe),
                        se(P, $e),
                        se(R, Gt),
                        se(G, ct),
                        se(H, Xe),
                        se(ve, ft),
                        se(le, pt),
                        se(Ft, n().version);
                },
                [
                    () => oe.t("GAMERULES"),
                    () => oe.t("GAME_RULES.RULES"),
                    () => oe.t("WAYS_TO_WIN"),
                    () => oe.t("GAME_RULES.WAYS_TO_WIN"),
                    () => oe.t("FEATURES"),
                    () => oe.t("GAME_RULES.FEATURES"),
                    () => oe.t("GENERAL_TERMS"),
                    () => oe.t("GAME_RULES.GENERAL"),
                ]
            ),
                Vn(
                    3,
                    f,
                    () => Wr,
                    () => ({ delay: 0, duration: 60 })
                ),
                D(d, f);
        };
        ne(u, (d) => {
            t() && d(c);
        });
    }
    D(s, l), Ve(), r();
}
Jt(["click"]);
const NB = [1 / 0, 10, 25, 50, 100, 250, 500, 1e3];
var VB = (s, e, t) => e($(t)),
    UB = X("<button> </button>"),
    zB = X(
        '<div><div class="autospin-menu-header svelte-xxc9db"><span class="autospin-menu-title svelte-xxc9db"> </span> <span class="autospin-menu-subtitle svelte-xxc9db"> </span></div> <div class="autospin-options-grid svelte-xxc9db"></div></div>'
    );
function YB(s, e) {
    Ne(e, !0);
    const t = () => U(wi, "$showBetAmountMenu", o),
        n = () => U(qo, "$showMenu", o),
        i = () => U(xi, "$showAutoSpinMenu", o),
        r = () => U(us, "$layoutType", o),
        a = () => U(Fp, "$selectedAutoSpinsRounds", o),
        [o, h] = tt();
    _n(() => {
        (t() || n()) && xi.set(!1);
    });
    function l(p) {
        Fp.set(p);
    }
    function u(p) {
        return p === 1 / 0 ? "" : p.toString();
    }
    var c = Oe(),
        d = me(c);
    {
        var f = (p) => {
            var m = zB(),
                g = I(m),
                _ = I(g),
                v = I(_),
                b = N(_, 2),
                y = I(b),
                C = N(g, 2);
            lt(
                C,
                21,
                () => NB,
                ot,
                (w, A) => {
                    var E = UB();
                    let S;
                    E.__click = [VB, l, A];
                    var P = I(E);
                    ie(
                        (k, R) => {
                            (S = qe(
                                E,
                                1,
                                "autospin-option svelte-xxc9db",
                                null,
                                S,
                                k
                            )),
                                se(P, R);
                        },
                        [() => ({ active: a() === $(A) }), () => u($(A))]
                    ),
                        D(w, E);
                }
            ),
                ie(
                    (w, A) => {
                        qe(m, 1, `autospin-menu ${r() ?? ""}`, "svelte-xxc9db"),
                            se(v, w),
                            se(y, A);
                    },
                    [() => oe.t("AUTOPLAY"), () => oe.t("NUMBER_OF_ROUNDS")]
                ),
                Vn(
                    3,
                    m,
                    () => Id,
                    () => ({ y: 10, duration: 120 })
                ),
                D(p, m);
        };
        ne(d, (p) => {
            i() && p(f);
        });
    }
    D(s, c), Ve(), h();
}
Jt(["click"]);
var GB = (s, e, t) => e($(t)),
    jB = X("<button> </button>"),
    WB = X(
        '<div><div class="bet-menu-header svelte-1v3c2o7"><span class="bet-menu-title svelte-1v3c2o7"> </span></div> <div class="bet-options-grid svelte-1v3c2o7"></div></div>'
    );
function XB(s, e) {
    Ne(e, !0);
    const t = () => U(xi, "$showAutoSpinMenu", d),
        n = () => U(qo, "$showMenu", d),
        i = () => U(wi, "$showBetAmountMenu", d),
        r = () => U(Ki, "$showBuyScreen", d),
        a = () => U(us, "$layoutType", d),
        o = () => U(ml, "$betAmountOptions", d),
        h = () => U(Nt, "$betAmount", d),
        l = () => U(lc, "$betModesMeta", d),
        u = () => U(Os, "$betMode", d),
        c = () => U(Js, "$currency", d),
        [d, f] = tt();
    _n(() => {
        (t() || n()) && wi.set(!1);
    });
    function p(v) {
        Nt.set(v), wi.set(!1);
    }
    var m = Oe(),
        g = me(m);
    {
        var _ = (v) => {
            var b = WB(),
                y = I(b),
                C = I(y),
                w = I(C),
                A = N(y, 2);
            lt(A, 5, o, ot, (E, S) => {
                var P = jB();
                let k;
                P.__click = [GB, p, S];
                var R = I(P);
                ie(
                    (M, T) => {
                        (k = qe(P, 1, "bet-option svelte-1v3c2o7", null, k, M)),
                            se(R, T);
                    },
                    [
                        () => ({ active: h() === $(S) }),
                        () => nr($(S) * l()[u()].costMultiplier, c()),
                    ]
                ),
                    D(E, P);
            }),
                ie(
                    (E) => {
                        qe(b, 1, `bet-menu ${a() ?? ""}`, "svelte-1v3c2o7"),
                            se(w, E);
                    },
                    [() => oe.t("BET_MENU")]
                ),
                Vn(
                    3,
                    b,
                    () => Id,
                    () => ({ y: 10, duration: 120 })
                ),
                D(v, b);
        };
        ne(g, (v) => {
            i() && !r() && v(_);
        });
    }
    D(s, m), Ve(), f();
}
Jt(["click"]);
var qB = X('<div class="game-wrap svelte-7214jv"><!> <!> <!> <!></div>');
function HB(s, e) {
    Ne(e, !0);
    const t = () => U(us, "$layoutType", i),
        n = () => U(Ye, "$windowSizes", i),
        [i, r] = tt();
    let a = Me(() =>
        t() === "portrait"
            ? Math.min(n().width <= 400 ? (n().width * 10) / 400 : 10)
            : Math.min(
                  n().height <= 500 ? (n().height * 12) / 500 : 12,
                  n().width <= 1040 ? (n().width * 12) / 1040 : 12
              )
    );
    var o = qB(),
        h = I(o);
    P2(h, {});
    var l = N(h, 2);
    XB(l, {});
    var u = N(l, 2);
    YB(u, {});
    var c = N(u, 2);
    {
        var d = (p) => {
                hB(p, {});
            },
            f = (p) => {
                var m = Oe(),
                    g = me(m);
                {
                    var _ = (v) => {
                        fB(v, {});
                    };
                    ne(
                        g,
                        (v) => {
                            t() === "portrait" && v(_);
                        },
                        !0
                    );
                }
                D(p, m);
            };
        ne(c, (p) => {
            t() === "desktop" || t() === "landscape" ? p(d) : p(f, !1);
        });
    }
    ie(() => an(o, `font-size: ${$(a) ?? ""}px;`)), D(s, o), Ve(), r();
}
const Mb = async ({ loadEvent: s, method: e, endpoint: t, variables: n }) =>
    ((s == null ? void 0 : s.fetch) || fetch)(t, {
        method: e,
        headers: { "Content-Type": "application/json" },
        ...(e === "GET" ? {} : { body: JSON.stringify(n) }),
    });
class KB extends Error {
    constructor(e, t) {
        super(t), (this.status = e);
    }
}
const Ib = async (s) => {
        if (!s.ok) throw new KB(s.status, await s.text());
        return s.json();
    },
    dc = {
        post: async function (e) {
            const t = await Mb({
                method: "POST",
                variables: e.variables,
                loadEvent: e.loadEvent,
                endpoint: new URL(e.url, `http://${e.rgsUrl}`).toString(),
            });
            return Ib(t);
        },
        get: async function (e) {
            const t = await Mb({
                method: "GET",
                loadEvent: e.loadEvent,
                endpoint: new URL(e.url, `https://${e.rgsUrl}`).toString(),
            });
            return Ib(t);
        },
    },
    ZB = (s) =>
        dc.post({
            rgsUrl: s.rgsUrl,
            loadEvent: s.loadEvent,
            url: "/wallet/authenticate",
            variables: { sessionID: s.sessionID, language: s.language },
        }),
    QB = (s) =>
        dc.post({
            rgsUrl: s.rgsUrl,
            loadEvent: s.loadEvent,
            url: "/wallet/end-round",
            variables: { sessionID: s.sessionID },
        }),
    JB = (s) =>
        dc.post({
            rgsUrl: s.rgsUrl,
            loadEvent: s.loadEvent,
            url: "/wallet/play",
            variables: {
                mode: s.mode,
                currency: s.currency,
                sessionID: s.sessionID,
                amount: s.amount,
            },
        }),
    e4 = (s) =>
        dc.post({
            rgsUrl: s.rgsUrl,
            loadEvent: s.loadEvent,
            url: "/wallet/balance",
            variables: { sessionID: s.sessionID },
        }),
    t4 = (s) =>
        dc.get({
            rgsUrl: s.rgsUrl,
            loadEvent: s.loadEvent,
            url: `/bet/replay/${s.game}/${s.version}/${s.mode}/${s.event}`,
        });
function n4(s, e, t = {}) {
    const i = {
        ...{
            autoUpdateBalanceOnStartRound: !0,
            autoUpdateBalanceOnEndRound: !0,
            autobetTimeoutDuration: 150,
            resumePlayDisabled: !1,
            isAsyncGame: !1,
        },
        ...t,
    };
    let r = Date.now();
    const a = () => {
            s.asyncNext({ type: "betStart" }),
                Sh.set(0, { duration: 0 }),
                qo.set(!1),
                Us.set("disabled"),
                Ws.set("activeBet");
        },
        o = () => {
            Ke.update({
                duration: isNaN(Number(i.customBalanceUpdateDuration))
                    ? 500
                    : i.customBalanceUpdateDuration,
            }),
                Us.set("default"),
                Ws.set("idle");
        },
        h = async () => {
            var v, b, y, C;
            try {
                a();
                const w = Q(Nt),
                    A = await JB({
                        sessionID: Q(Mo),
                        rgsUrl: Q(ba),
                        currency: Q(Js),
                        amount: w * es,
                        mode: Q(Os),
                    });
                i.autoUpdateBalanceOnStartRound &&
                !Ke.forceUpdateBalanceFromServer
                    ? ((Ke.instantBalance =
                          (A == null ? void 0 : A.balance.amount) / es),
                      Ke.update({
                          duration: isNaN(Number(i.customBalanceUpdateDuration))
                              ? 50
                              : i.customBalanceUpdateDuration,
                      }))
                    : Ke.forceUpdateBalanceFromServer &&
                      ((Ke.instantBalance =
                          (A == null ? void 0 : A.balance.amount) / es),
                      Ke.update({
                          duration: isNaN(Number(i.customBalanceUpdateDuration))
                              ? 20
                              : i.customBalanceUpdateDuration,
                      })),
                    Ra.set(w);
                const E =
                    (b =
                        (v = A == null ? void 0 : A.round) == null
                            ? void 0
                            : v.state) == null
                        ? void 0
                        : b.some((S) => S.type === "bonusEnter");
                A != null && A.round.active && !E
                    ? await Promise.all([
                          s.asyncNext({ type: "endRound" }),
                          c(
                              (y = A == null ? void 0 : A.round) == null
                                  ? void 0
                                  : y.state
                          ),
                      ])
                    : await c(
                          (C = A == null ? void 0 : A.round) == null
                              ? void 0
                              : C.state
                      ),
                    (r = Date.now()),
                    o();
            } catch (w) {
                i.autoUpdateBalanceOnStartRound ||
                    ((Ke.instantBalance = Ke.instantBalance + Q(Nt)),
                    Ke.update({ duration: 0 })),
                    da.set(0),
                    br.set(!0),
                    console.error(w),
                    ya.set(JSON.parse(w.message.toString()));
            }
        },
        l = async () => {
            a();
            const v = Q(Nt);
            Ra.set(v);
            const b = Q(ZE);
            await c(b), o();
        },
        u = async () => {
            var A, E;
            i.isAsyncGame || a();
            const v = (A = Q(To)) == null ? void 0 : A.event,
                b = (E = Q(To)) == null ? void 0 : E.state,
                C = [
                    ...b.slice(0, v).filter((S) => Q(Ow).includes(S.type)),
                    ...b.slice(v),
                ];
            To.set(null),
                Os.set("BASE"),
                (b == null ? void 0 : b.some((S) => S.type === "bonusEnter")) ||
                    s.asyncNext({ type: "endRound" }),
                await c(C),
                o();
        },
        c = async (v) => {
            for (const b of v) {
                const y = e == null ? void 0 : e[b.type];
                y &&
                    (b.type === "bonusExit"
                        ? await Promise.all([
                              s.asyncNext({ type: "endRound" }),
                              y(b),
                          ])
                        : await y(b));
            }
        },
        d = async (v = !1, b = !1) => {
            if (!Qe.replay)
                try {
                    const y = await QB({ sessionID: Q(Mo), rgsUrl: Q(ba) });
                    (i.autoUpdateBalanceOnEndRound || v) &&
                        (Ke.instantBalance =
                            (y == null ? void 0 : y.balance.amount) / es),
                        b &&
                            ((Ke.instantBalance =
                                (y == null ? void 0 : y.balance.amount) / es),
                            Ke.update()),
                        (r = Date.now());
                } catch (y) {
                    console.error(y), ya.set(JSON.parse(y.message.toString()));
                }
        },
        f = async () => {
            Us.set("autoSpinActive");
            let v = null;
            i.isAsyncGame &&
                (v = setInterval(() => {
                    const b = Q(Ke.displayBalance),
                        y = Q(vu);
                    Number(b) < y && !Q(br) && br.set(!0);
                }, 100));
            for (let b = Q(da); b > 0; b--) {
                if (i.isAsyncGame) {
                    const y = Q(Ke.displayBalance),
                        C = Q(vu);
                    if (Number(y) < C) {
                        br.set(!0);
                        break;
                    }
                    if (!(await p())) break;
                }
                if (Q(br)) break;
                await s.asyncNext({ type: "betButtonClick" }),
                    await Le(i.autobetTimeoutDuration),
                    da.set(b - 1);
            }
            v && clearInterval(v), Us.set("default"), da.set(0), br.set(!1);
        },
        p = async () =>
            new Promise((v) => {
                let b = !1;
                const y = Q(Ke.displayBalance),
                    C = Q(Nt);
                if (Number(y) < C) {
                    v(!1);
                    return;
                }
                const w = setTimeout(() => {
                        !b && Ke.instantBalance < Q(Nt) && ((b = !0), v(!1));
                    }, 1e3),
                    A = () => {
                        if (b) return;
                        const E = Q(Ke.displayBalance),
                            S = Q(Nt);
                        if (Q(br)) {
                            (b = !0), clearTimeout(w), v(!1);
                            return;
                        }
                        if (Number(E) < S) {
                            (b = !0), clearTimeout(w), v(!1);
                            return;
                        }
                        Number(E) >= S
                            ? ((b = !0), clearTimeout(w), v(!0))
                            : setTimeout(A, 50);
                    };
                A();
            }),
        m = async () => {
            var v;
            try {
                if ((a(), !gi.data))
                    throw new Error("Replay data not available");
                await c((v = gi.data) == null ? void 0 : v.state),
                    Sh.set(0, { duration: 0 });
            } catch (b) {
                console.error(b), ya.set(JSON.parse(b.message.toString()));
            }
        },
        g = async () => {
            if (
                !(
                    Q(Ys) !== "base" ||
                    i.isAsyncGame ||
                    Q(Ws) === "activeBet" ||
                    Date.now() - r < 5e3
                )
            )
                try {
                    const b = await e4({ sessionID: Q(Mo), rgsUrl: Q(ba) });
                    (Ke.instantBalance =
                        (b == null ? void 0 : b.balance.amount) / es),
                        Ke.update();
                } catch {}
        };
    return {
        createBetService: () => {
            s.register({
                betButtonClick: async () => await h(),
                forceBetStart: async () => await l(),
                resumeBetStart: async () => await u(),
                endRound: async ({ forceUpdateBalance: v, fromResume: b }) =>
                    await d(v, b),
                startAutobet: async () => await f(),
                startReplay: async () => await m(),
                pollBalance: async () => await g(),
            });
        },
    };
}
const s4 = {
        en: {
            translation: {
                BALANCE: "BALANCE",
                WIN: "WIN",
                BUY: "BUY",
                BET: "BET",
                BET_MENU: "BET MENU",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "NUMBER OF ROUNDS",
                INFO: "INFO",
                SOUND: "SOUND",
                TOTAL_WIN: "TOTAL WIN",
                FREE_SPINS: "FREE SPINS",
                GAMERULES: "Game Rules",
                PAYTABLE: "Paytable",
                WAYS_TO_WIN: "Ways to Win",
                FEATURES: "Features",
                GENERAL_TERMS: "General Terms",
                GAME_REPLAY: "Game Replay",
                COST_MULTIPLIER: "Cost Multiplier",
                BASE_BET: "Base Bet",
                MODE: "Mode",
                START: "Start",
                LOADING: "Loading...",
                LOADING_REPLAY_DATA: "Loading replay data...",
                FAILED_TO_LOAD_REPLAY_DATA: "Failed to load replay data",
                ERROR: "Error",
            },
        },
        social: {
            translation: {
                BALANCE: "BALANCE",
                WIN: "WIN",
                BUY: "PLAY",
                BET: "SPIN",
                BET_MENU: "PLAY MENU",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "NUMBER OF ROUNDS",
                INFO: "INFO",
                SOUND: "SOUND",
                TOTAL_WIN: "TOTAL WIN",
                FREE_SPINS: "FREE SPINS",
                GAMERULES: "Game Rules",
                PAYTABLE: "Award table",
                WAYS_TO_WIN: "Ways to Win",
                FEATURES: "Features",
                GENERAL_TERMS: "General Terms",
                GAME_REPLAY: "Game Replay",
                COST_MULTIPLIER: "Play Multiplier",
                BASE_BET: "Base Play",
                MODE: "Mode",
                START: "Start",
                LOADING: "Loading...",
                LOADING_REPLAY_DATA: "Loading replay data...",
                FAILED_TO_LOAD_REPLAY_DATA: "Failed to load replay data",
                ERROR: "Error",
            },
        },
        ar: {
            translation: {
                BALANCE: "",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: " ",
                AUTOPLAY: " ",
                NUMBER_OF_ROUNDS: " ",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: " ",
                FREE_SPINS: " ",
                GAMERULES: " ",
                PAYTABLE: " ",
                WAYS_TO_WIN: " ",
                FEATURES: "",
                GENERAL_TERMS: " ",
                GAME_REPLAY: " ",
                COST_MULTIPLIER: " ",
                BASE_BET: " ",
                MODE: "",
                START: "",
                LOADING: " ...",
                LOADING_REPLAY_DATA: "   ...",
                FAILED_TO_LOAD_REPLAY_DATA: "   ",
                ERROR: "",
            },
        },
        de: {
            translation: {
                BALANCE: "GUTHABEN",
                WIN: "GEWINN",
                BUY: "BUY",
                BET: "EINSATZ",
                BET_MENU: "EINSATZMEN",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "ANZAHL DER RUNDEN",
                INFO: "INFO",
                SOUND: "SOUND",
                TOTAL_WIN: "GESAMTGEWINN",
                FREE_SPINS: "FREISPIELE",
                GAMERULES: "Spielregeln",
                PAYTABLE: "Gewinntabelle",
                WAYS_TO_WIN: "Gewinnwege",
                FEATURES: "Features",
                GENERAL_TERMS: "Allgemeine Geschftsbedingungen",
                GAME_REPLAY: "Spiel-Wiederholung",
                COST_MULTIPLIER: "Kosten-Multiplikator",
                BASE_BET: "Basiseinsatz",
                MODE: "Modus",
                START: "Start",
                LOADING: "Laden...",
                LOADING_REPLAY_DATA: "Wiederholungsdaten werden geladen...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "Laden der Wiederholungsdaten fehlgeschlagen",
                ERROR: "Fehler",
            },
        },
        es: {
            translation: {
                BALANCE: "SALDO",
                WIN: "GANANCIA",
                BUY: "BUY",
                BET: "APUESTA",
                BET_MENU: "MEN DE APUESTAS",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "NMERO DE RONDAS",
                INFO: "INFO",
                SOUND: "SONIDO",
                TOTAL_WIN: "GANANCIA TOTAL",
                FREE_SPINS: "GIROS GRATIS",
                GAMERULES: "Reglas del Juego",
                PAYTABLE: "Tabla de Pagos",
                WAYS_TO_WIN: "Formas de Ganar",
                FEATURES: "Caractersticas",
                GENERAL_TERMS: "Trminos Generales",
                GAME_REPLAY: "Repeticin del Juego",
                COST_MULTIPLIER: "Multiplicador de Costo",
                BASE_BET: "Apuesta Base",
                MODE: "Modo",
                START: "Iniciar",
                LOADING: "Cargando...",
                LOADING_REPLAY_DATA: "Cargando datos de repeticin...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "Error al cargar datos de repeticin",
                ERROR: "Error",
            },
        },
        fi: {
            translation: {
                BALANCE: "SALDO",
                WIN: "VOITTO",
                BUY: "BUY",
                BET: "PANOS",
                BET_MENU: "PANOSVALIKKO",
                AUTOPLAY: "AUTOMAATTIPELI",
                NUMBER_OF_ROUNDS: "KIERROSTEN MR",
                INFO: "INFO",
                SOUND: "NI",
                TOTAL_WIN: "KOKONAISVOITTO",
                FREE_SPINS: "ILMAISKIERROKSET",
                GAMERULES: "Peliohjeet",
                PAYTABLE: "Voitonmaksutaulukko",
                WAYS_TO_WIN: "Voittotavat",
                FEATURES: "Ominaisuudet",
                GENERAL_TERMS: "Yleiset Ehdot",
                GAME_REPLAY: "Pelin Toisto",
                COST_MULTIPLIER: "Kustannuskerroin",
                BASE_BET: "Peruspanos",
                MODE: "Tila",
                START: "Aloita",
                LOADING: "Ladataan...",
                LOADING_REPLAY_DATA: "Ladataan toiston tietoja...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "Toiston tietojen lataaminen eponnistui",
                ERROR: "Virhe",
            },
        },
        fr: {
            translation: {
                BALANCE: "SOLDE",
                WIN: "GAIN",
                BUY: "BUY",
                BET: "MISE",
                BET_MENU: "MENU DES MISES",
                AUTOPLAY: "JEU AUTOMATIQUE",
                NUMBER_OF_ROUNDS: "NOMBRE DE TOURS",
                INFO: "INFO",
                SOUND: "SON",
                TOTAL_WIN: "GAIN TOTAL",
                FREE_SPINS: "TOURS GRATUITS",
                GAMERULES: "Rgles du Jeu",
                PAYTABLE: "Tableau des Gains",
                WAYS_TO_WIN: "Faons de Gagner",
                FEATURES: "Fonctionnalits",
                GENERAL_TERMS: "Conditions Gnrales",
                GAME_REPLAY: "Replay du Jeu",
                COST_MULTIPLIER: "Multiplicateur de Cot",
                BASE_BET: "Mise de Base",
                MODE: "Mode",
                START: "Dmarrer",
                LOADING: "Chargement...",
                LOADING_REPLAY_DATA: "Chargement des donnes de replay...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "chec du chargement des donnes de replay",
                ERROR: "Erreur",
            },
        },
        hi: {
            translation: {
                BALANCE: " ",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: " ",
                AUTOPLAY: "",
                NUMBER_OF_ROUNDS: "  ",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: " ",
                FREE_SPINS: " ",
                GAMERULES: " ",
                PAYTABLE: " ",
                WAYS_TO_WIN: "  ",
                FEATURES: "",
                GENERAL_TERMS: " ",
                GAME_REPLAY: " ",
                COST_MULTIPLIER: " ",
                BASE_BET: " ",
                MODE: "",
                START: " ",
                LOADING: "   ...",
                LOADING_REPLAY_DATA: "     ...",
                FAILED_TO_LOAD_REPLAY_DATA: "     ",
                ERROR: "",
            },
        },
        id: {
            translation: {
                BALANCE: "SALDO",
                WIN: "MENANG",
                BUY: "BUY",
                BET: "TARUHAN",
                BET_MENU: "MENU TARUHAN",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "JUMLAH PUTARAN",
                INFO: "INFO",
                SOUND: "SUARA",
                TOTAL_WIN: "TOTAL MENANG",
                FREE_SPINS: "PUTARAN GRATIS",
                GAMERULES: "Aturan Permainan",
                PAYTABLE: "Tabel Pembayaran",
                WAYS_TO_WIN: "Cara Menang",
                FEATURES: "Fitur",
                GENERAL_TERMS: "Syarat Umum",
                GAME_REPLAY: "Ulang Permainan",
                COST_MULTIPLIER: "Pengganda Biaya",
                BASE_BET: "Taruhan Dasar",
                MODE: "Mode",
                START: "Mulai",
                LOADING: "Memuat...",
                LOADING_REPLAY_DATA: "Memuat data ulang...",
                FAILED_TO_LOAD_REPLAY_DATA: "Gagal memuat data ulang",
                ERROR: "Kesalahan",
            },
        },
        ja: {
            translation: {
                BALANCE: "",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: "",
                AUTOPLAY: "",
                NUMBER_OF_ROUNDS: "",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: "",
                FREE_SPINS: "",
                GAMERULES: "",
                PAYTABLE: "",
                WAYS_TO_WIN: "",
                FEATURES: "",
                GENERAL_TERMS: "",
                GAME_REPLAY: "",
                COST_MULTIPLIER: "",
                BASE_BET: "",
                MODE: "",
                START: "",
                LOADING: "...",
                LOADING_REPLAY_DATA: "...",
                FAILED_TO_LOAD_REPLAY_DATA: "",
                ERROR: "",
            },
        },
        ko: {
            translation: {
                BALANCE: "",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: " ",
                AUTOPLAY: " ",
                NUMBER_OF_ROUNDS: " ",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: " ",
                FREE_SPINS: " ",
                GAMERULES: " ",
                PAYTABLE: " ",
                WAYS_TO_WIN: " ",
                FEATURES: "",
                GENERAL_TERMS: " ",
                GAME_REPLAY: " ",
                COST_MULTIPLIER: " ",
                BASE_BET: " ",
                MODE: "",
                START: "",
                LOADING: " ...",
                LOADING_REPLAY_DATA: "   ...",
                FAILED_TO_LOAD_REPLAY_DATA: "   ",
                ERROR: "",
            },
        },
        pl: {
            translation: {
                BALANCE: "SALDO",
                WIN: "WYGRANA",
                BUY: "BUY",
                BET: "ZAKAD",
                BET_MENU: "MENU ZAKADW",
                AUTOPLAY: "AUTOGRA",
                NUMBER_OF_ROUNDS: "LICZBA RUND",
                INFO: "INFO",
                SOUND: "DWIK",
                TOTAL_WIN: "CAKOWITA WYGRANA",
                FREE_SPINS: "DARMOWE SPYNY",
                GAMERULES: "Zasady Gry",
                PAYTABLE: "Tabela Wypat",
                WAYS_TO_WIN: "Sposoby na Wygran",
                FEATURES: "Funkcje",
                GENERAL_TERMS: "Oglne Warunki",
                GAME_REPLAY: "Powtrka Gry",
                COST_MULTIPLIER: "Mnonik Kosztu",
                BASE_BET: "Podstawowy Zakad",
                MODE: "Tryb",
                START: "Start",
                LOADING: "adowanie...",
                LOADING_REPLAY_DATA: "adowanie danych powtrki...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "Nie udao si zaadowa danych powtrki",
                ERROR: "Bd",
            },
        },
        pt: {
            translation: {
                BALANCE: "SALDO",
                WIN: "GANHO",
                BUY: "BUY",
                BET: "APOSTA",
                BET_MENU: "MENU DE APOSTAS",
                AUTOPLAY: "AUTOPLAY",
                NUMBER_OF_ROUNDS: "NMERO DE RODADAS",
                INFO: "INFO",
                SOUND: "SOM",
                TOTAL_WIN: "GANHO TOTAL",
                FREE_SPINS: "RODADAS GRTIS",
                GAMERULES: "Regras do Jogo",
                PAYTABLE: "Tabela de Pagamentos",
                WAYS_TO_WIN: "Formas de Ganhar",
                FEATURES: "Recursos",
                GENERAL_TERMS: "Termos Gerais",
                GAME_REPLAY: "Repetio do Jogo",
                COST_MULTIPLIER: "Multiplicador de Custo",
                BASE_BET: "Aposta Base",
                MODE: "Modo",
                START: "Iniciar",
                LOADING: "Carregando...",
                LOADING_REPLAY_DATA: "Carregando dados de repetio...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "Falha ao carregar dados de repetio",
                ERROR: "Erro",
            },
        },
        ru: {
            translation: {
                BALANCE: "",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: " ",
                AUTOPLAY: "",
                NUMBER_OF_ROUNDS: " ",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: " ",
                FREE_SPINS: " ",
                GAMERULES: " ",
                PAYTABLE: " ",
                WAYS_TO_WIN: " ",
                FEATURES: "",
                GENERAL_TERMS: " ",
                GAME_REPLAY: " ",
                COST_MULTIPLIER: " ",
                BASE_BET: " ",
                MODE: "",
                START: "",
                LOADING: "...",
                LOADING_REPLAY_DATA: "  ...",
                FAILED_TO_LOAD_REPLAY_DATA:
                    "    ",
                ERROR: "",
            },
        },
        tr: {
            translation: {
                BALANCE: "BAKYE",
                WIN: "KAZAN",
                BUY: "BUY",
                BET: "BAHS",
                BET_MENU: "BAHS MENS",
                AUTOPLAY: "OTOMATK OYNATMA",
                NUMBER_OF_ROUNDS: "TUR SAYISI",
                INFO: "BLG",
                SOUND: "SES",
                TOTAL_WIN: "TOPLAM KAZAN",
                FREE_SPINS: "CRETSZ DNLER",
                GAMERULES: "Oyun Kurallar",
                PAYTABLE: "deme Tablosu",
                WAYS_TO_WIN: "Kazanma Yollar",
                FEATURES: "zellikler",
                GENERAL_TERMS: "Genel artlar",
                GAME_REPLAY: "Oyun Tekrar",
                COST_MULTIPLIER: "Maliyet arpan",
                BASE_BET: "Temel Bahis",
                MODE: "Mod",
                START: "Balat",
                LOADING: "Ykleniyor...",
                LOADING_REPLAY_DATA: "Tekrar verileri ykleniyor...",
                FAILED_TO_LOAD_REPLAY_DATA: "Tekrar verileri yklenemedi",
                ERROR: "Hata",
            },
        },
        vi: {
            translation: {
                BALANCE: "S D",
                WIN: "THNG",
                BUY: "BUY",
                BET: "CC",
                BET_MENU: "MENU CC",
                AUTOPLAY: "T NG CHI",
                NUMBER_OF_ROUNDS: "S LT",
                INFO: "THNG TIN",
                SOUND: "M THANH",
                TOTAL_WIN: "TNG THNG",
                FREE_SPINS: "VNG QUAY MIN PH",
                GAMERULES: "Lut Chi",
                PAYTABLE: "Bng Thanh Ton",
                WAYS_TO_WIN: "Cch Thng",
                FEATURES: "Tnh Nng",
                GENERAL_TERMS: "iu Khon Chung",
                GAME_REPLAY: "Pht Li Tr Chi",
                COST_MULTIPLIER: "H S Chi Ph",
                BASE_BET: "Cc C Bn",
                MODE: "Ch ",
                START: "Bt u",
                LOADING: "ang ti...",
                LOADING_REPLAY_DATA: "ang ti d liu pht li...",
                FAILED_TO_LOAD_REPLAY_DATA: "Khng ti c d liu pht li",
                ERROR: "Li",
            },
        },
        zh: {
            translation: {
                BALANCE: "",
                WIN: "",
                BUY: "BUY",
                BET: "",
                BET_MENU: "",
                AUTOPLAY: "",
                NUMBER_OF_ROUNDS: "",
                INFO: "",
                SOUND: "",
                TOTAL_WIN: "",
                FREE_SPINS: "",
                GAMERULES: "",
                PAYTABLE: "",
                WAYS_TO_WIN: "",
                FEATURES: "",
                GENERAL_TERMS: "",
                GAME_REPLAY: "",
                COST_MULTIPLIER: "",
                BASE_BET: "",
                MODE: "",
                START: "",
                LOADING: "...",
                LOADING_REPLAY_DATA: "...",
                FAILED_TO_LOAD_REPLAY_DATA: "",
                ERROR: "",
            },
        },
    },
    i4 = (s) => {
        Ye.set({ width: s.contentRect.width, height: s.contentRect.height });
    };
function Ns(s) {
    return new URL(window.location.href).searchParams.get(s);
}
const r4 = () => {
        const s = Ns("lang"),
            e = Ns("sessionID"),
            t = Ns("rgs_url"),
            n = Ns("social"),
            i = Ns("replay"),
            r = Ns("game"),
            a = Ns("currency"),
            o = Ns("mode"),
            h = Ns("version"),
            l = Ns("event"),
            u = Ns("amount");
        Qc.set(s || Q(Qc)),
            Mo.set(e || Q(Mo)),
            ba.set(t || Q(ba)),
            x0.set(n === "true" || !1),
            (Qe.replay = i === "true" || !1),
            (Qe.game = r || ""),
            (Qe.currency = a || "USD"),
            (Qe.mode = o || ""),
            (Qe.version = Number(h)),
            (Qe.event = Number(l)),
            (Qe.amount = Number(u) || 1e6),
            Qe.replay &&
                (Ra.set(Qe.amount / es),
                Nt.set(Qe.amount / es),
                Js.set(Qe.currency),
                Qc.set(Qe.lang),
                Os.set(Qe.mode));
        const c = Q(x0) ? "social" : s || "en";
        oe.init({ lng: c, resources: $p(s4, Q(Rw)) }),
            document.addEventListener("contextmenu", (d) => d.preventDefault());
    },
    k2 = async () => {
        var s;
        try {
            const e = await ZB({
                rgsUrl: Q(ba),
                sessionID: Q(Mo),
                language: Q(Qc),
            });
            if (
                (e != null &&
                    e.balance &&
                    ((Mw.authenticated = !0),
                    Js.set(e.balance.currency),
                    (Ke.instantBalance = e.balance.amount / es),
                    Ke.update()),
                e != null &&
                    e.config &&
                    (KE.set(
                        (s = e == null ? void 0 : e.config) == null
                            ? void 0
                            : s.jurisdiction
                    ),
                    ml.set(e.config.betLevels.map((t) => t / es)),
                    (e != null && e.round) ||
                        Nt.set(e.config.defaultBetLevel / es)),
                e != null && e.round)
            ) {
                To.set(e.round), Os.set(e.round.mode);
                const t = e.round.amount > 0 ? e.round.amount / es : 0;
                Nt.set(t), Ra.set(t);
            }
        } catch (e) {
            try {
                ya.set(JSON.parse(e.message));
            } catch {
                ya.set({ message: e.message });
            }
            console.error(e);
        }
    };
let Wc = null;
function Rb() {
    "wakeLock" in navigator &&
        ((Wc && !Wc.released) ||
            navigator.wakeLock
                .request("screen")
                .then((s) => {
                    (Wc = s), Wc.addEventListener("release", () => {});
                })
                .catch((s) => {}));
}
const a4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-300-COlrd1hX.woff2",
            import.meta.url
        ).href,
    o4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-regular-BDXaL9-u.woff2",
            import.meta.url
        ).href,
    l4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-500-CMfhJlfe.woff2",
            import.meta.url
        ).href,
    h4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-600-DuSOvJ_5.woff2",
            import.meta.url
        ).href,
    c4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-700-D9T176aR.woff2",
            import.meta.url
        ).href,
    u4 =
        "" +
        new URL(
            "outfit-v11-latin_latin-ext-800-ySok2YOt.woff2",
            import.meta.url
        ).href,
    d4 = [
        { url: a4, weight: "300" },
        { url: o4, weight: "400" },
        { url: l4, weight: "500" },
        { url: h4, weight: "600" },
        { url: c4, weight: "700" },
        { url: u4, weight: "800" },
    ],
    f4 = async () => {
        for (const s of d4) {
            const e = new FontFace("Outfit", `url(${s.url})`, {
                style: "normal",
                weight: s.weight,
            });
            await e.load(), document.fonts.add(e);
        }
    };
var p4 = X('<div class="underlay svelte-qfki8h"></div>');
function m4(s, e) {
    var t = p4();
    (t.__click = function (...n) {
        var i;
        (i = e.onclick) == null || i.apply(this, n);
    }),
        D(s, t);
}
Jt(["click"]);
var g4 = (s, e, t, n) => {
        e().next({ type: "playButtonClick" }), Re(t, $(n), !0);
    },
    _4 = X('<div class="volatility-on svelte-1opqva"><!></div>'),
    v4 = X('<div class="volatility-off svelte-1opqva"><!></div>'),
    b4 = (s, e, t, n, i, r) => {
        e().next({ type: "playButtonClick" }),
            $(t) === $(n) && i(r()[$(n)].type.toUpperCase() === "BUY");
    },
    y4 = X(
        '<div aria-hidden="true"><div class="buy-card-top-back svelte-1opqva"><img class="header-image svelte-1opqva"/></div> <div class="buy-card-wrap svelte-1opqva"><div class="volatility-wrap svelte-1opqva"><!> <!></div> <span class="title svelte-1opqva"> </span> <span class="amount svelte-1opqva"> </span> <div aria-hidden="true"> </div></div></div>'
    ),
    w4 = X(
        '<div class="buy-screen-wrap svelte-1opqva"><div class="close-button svelte-1opqva"><!></div> <div></div> <div><!> <div class="bet-wrap svelte-1opqva"><!> <!> <!></div></div></div>'
    ),
    x4 = (s, e) => Re(e, ""),
    C4 = X('<div class="volatility-on svelte-1opqva"><!></div>'),
    A4 = X('<div class="volatility-off svelte-1opqva"><!></div>'),
    S4 = (s, e, t, n) => {
        e(t()[$(n)].type.toUpperCase() === "BUY");
    },
    E4 = X(
        '<div class="confirm-popup-wrap svelte-1opqva"><!> <div class="close-button svelte-1opqva"><!></div> <div class="confirm-wrap-outer svelte-1opqva"><div class="confirm-card-top-back svelte-1opqva"><img class="header-image svelte-1opqva"/></div> <div class="confirm-card-wrap svelte-1opqva"><div class="volatility-wrap svelte-1opqva"><!> <!></div> <span class="title svelte-1opqva"> </span> <span class="dialog-text svelte-1opqva"> </span> <span class="amount svelte-1opqva"> </span> <div class="select-button confirm svelte-1opqva">CONFIRM</div></div></div></div>'
    ),
    P4 = X("<!> <!>", 1);
function k4(s, e) {
    Ne(e, !0);
    const t = () => U(ei, "$eventEmitter", l),
        n = () => U(Ki, "$showBuyScreen", l),
        i = () => U(lc, "$betModesMeta", l),
        r = () => U(Nt, "$betAmount", l),
        a = () => U(Ye, "$windowSizes", l),
        o = () => U(us, "$layoutType", l),
        h = () => U(Js, "$currency", l),
        [l, u] = tt();
    let c = gt("");
    const d = () => {
            Ki.set(!1), Re(c, "");
        },
        f = (C) => {
            t().next({ type: "playButtonClick" }),
                Os.set($(c)),
                C && (t().next({ type: "betButtonClick" }), Os.set("BASE")),
                d();
        };
    _n(() => {
        n(), Re(c, ""), XE(n());
    }),
        _n(() => {
            var C;
            i() &&
                ((C = i()[$(c)]) == null ? void 0 : C.costMultiplier) * r() >
                    Ke.instantBalance &&
                Re(c, "");
        }),
        _n(() => {
            Wi.set(n());
        });
    function p(C) {
        C.code === "Escape" &&
            !C.repeat &&
            ($(c) ? Re(c, "") : n() && Ki.set(!1));
    }
    const m = Me(() =>
        a().width < 768 && a().height > a().width
            ? 16
            : Math.min(
                  a().width < 1200 ? (a().width * 16) / 1200 : 16,
                  a().height < 460 ? (a().height * 16) / 460 : 16
              )
    );
    Fs(() => {
        window.addEventListener("keydown", p);
    }),
        gd(() => {
            window.removeEventListener("keydown", p);
        });
    var g = P4(),
        _ = me(g);
    {
        var v = (C) => {
            var w = w4(),
                A = I(w);
            A.__click = d;
            var E = I(A);
            zu(E);
            var S = N(A, 2);
            lt(
                S,
                5,
                () => Object.keys(i()),
                ot,
                (L, F, Y, V) => {
                    var W = Oe(),
                        Z = me(W);
                    {
                        var J = (G) => {
                            var j = y4();
                            j.__click = [g4, t, c, F];
                            var H = I(j),
                                pe = I(H),
                                _e = N(H, 2),
                                ve = I(_e),
                                re = I(ve);
                            lt(
                                re,
                                1,
                                () =>
                                    Array.from(
                                        { length: i()[$(F)].volatility },
                                        (ct, Xe) => Xe
                                    ),
                                ot,
                                (ct, Xe) => {
                                    var ft = _4(),
                                        pt = I(ft);
                                    sh(pt), D(ct, ft);
                                }
                            );
                            var le = N(re, 2);
                            lt(
                                le,
                                1,
                                () =>
                                    Array.from(
                                        { length: 5 - i()[$(F)].volatility },
                                        (ct, Xe) => Xe
                                    ),
                                ot,
                                (ct, Xe) => {
                                    var ft = v4(),
                                        pt = I(ft);
                                    sh(pt), D(ct, ft);
                                }
                            );
                            var at = N(ve, 2),
                                Ft = I(at),
                                Ae = N(at, 2),
                                Fe = I(Ae),
                                $e = N(Ae, 2);
                            $e.__click = [b4, t, c, F, f, i];
                            var Gt = I($e);
                            ie(
                                (ct, Xe, ft, pt) => {
                                    qe(
                                        j,
                                        1,
                                        `buy-card ${ct ?? ""}`,
                                        "svelte-1opqva"
                                    ),
                                        wr(pe, "src", i()[$(F)].image),
                                        se(Ft, i()[$(F)].title),
                                        se(Fe, Xe),
                                        qe(
                                            $e,
                                            1,
                                            `select-button ${ft ?? ""}`,
                                            "svelte-1opqva"
                                        ),
                                        se(Gt, pt);
                                },
                                [
                                    () =>
                                        Ke.instantBalance <
                                            r() *
                                                Number(
                                                    i()[$(F)].costMultiplier
                                                ) && "disabled",
                                    () =>
                                        nr(
                                            r() *
                                                Number(
                                                    i()[$(F)].costMultiplier
                                                ),
                                            h()
                                        ),
                                    () =>
                                        i()[$(F)].type.toUpperCase() ===
                                            "BUY" && "buy",
                                    () =>
                                        $(c) === $(F)
                                            ? "CONFIRM"
                                            : oe.t(
                                                  i()[$(F)].type.toUpperCase()
                                              ),
                                ]
                            ),
                                D(G, j);
                        };
                        ne(Z, (G) => {
                            i()[$(F)].type !== "default" && G(J);
                        });
                    }
                    D(L, W);
                }
            );
            var P = N(S, 2),
                k = I(P);
            Wh(k, {});
            var R = N(k, 2),
                M = I(R);
            Hg(M, {});
            var T = N(M, 2);
            Xg(T, {});
            var O = N(T, 2);
            qg(O, {}),
                ie(() => {
                    an(w, `font-size: ${$(m) ?? ""}px`),
                        qe(
                            S,
                            1,
                            `buy-cards-wrap ${o() ?? ""}`,
                            "svelte-1opqva"
                        ),
                        qe(P, 1, `bottom-panel ${o() ?? ""}`, "svelte-1opqva");
                }),
                Vn(
                    3,
                    w,
                    () => Wr,
                    () => ({ delay: 0, duration: 20 })
                ),
                D(C, w);
        };
        ne(_, (C) => {
            n() && C(v);
        });
    }
    var b = N(_, 2);
    {
        var y = (C) => {
            var w = E4(),
                A = I(w);
            m4(A, { onclick: () => Re(c, "") });
            var E = N(A, 2);
            E.__click = [x4, c];
            var S = I(E);
            zu(S);
            var P = N(E, 2),
                k = I(P),
                R = I(k),
                M = N(k, 2),
                T = I(M),
                O = I(T);
            lt(
                O,
                1,
                () => Array.from({ length: i()[$(c)].volatility }, (j, H) => H),
                ot,
                (j, H) => {
                    var pe = C4(),
                        _e = I(pe);
                    sh(_e), D(j, pe);
                }
            );
            var L = N(O, 2);
            lt(
                L,
                1,
                () =>
                    Array.from(
                        { length: 5 - i()[$(c)].volatility },
                        (j, H) => H
                    ),
                ot,
                (j, H) => {
                    var pe = A4(),
                        _e = I(pe);
                    sh(_e), D(j, pe);
                }
            );
            var F = N(T, 2),
                Y = I(F),
                V = N(F, 2),
                W = I(V),
                Z = N(V, 2),
                J = I(Z),
                G = N(Z, 2);
            (G.__click = [S4, f, i, c]),
                ie(
                    (j, H) => {
                        an(w, `font-size: ${$(m) ?? ""}px`),
                            wr(R, "src", i()[$(c)].image),
                            se(Y, i()[$(c)].title),
                            se(W, j),
                            se(J, H);
                    },
                    [
                        () => oe.t(`BET_MODE_META.${$(c)}.DIALOG`),
                        () => nr(r() * Number(i()[$(c)].costMultiplier), h()),
                    ]
                ),
                Vn(
                    3,
                    P,
                    () => yL,
                    () => ({ easing: ag, delay: 0, duration: 150 })
                ),
                D(C, w);
        };
        ne(b, (C) => {
            $(c) && C(y);
        });
    }
    D(s, g), Ve(), u();
}
Jt(["click"]);
function T4(s, e) {
    Ne(e, !0),
        Fs(async () => {
            await k2();
        }),
        Ve();
}
var M4 = X(
    '<div class="underlay svelte-1az9jq"><div class="error-wrapper svelte-1az9jq"><span class="error svelte-1az9jq">ERROR</span> <br/> <span> </span></div></div>'
);
function I4(s, e) {
    Ne(e, !0);
    const t = () => U(ya, "$errorResponse", n),
        [n, i] = tt(),
        r = () => {
            switch (t().error) {
                case "ERR_IPB":
                    Us.set("default"), Ws.set("idle");
                    break;
                case "ERR_GEN":
                    Us.set("default"), Ws.set("idle");
                case "ERR_VAL":
                    k2();
            }
            ya.set(null);
        };
    var a = Oe(),
        o = me(a);
    {
        var h = (l) => {
            var u = M4();
            u.__click = r;
            var c = I(u),
                d = N(I(c), 4),
                f = I(d);
            ie(() => se(f, t().message)), D(l, u);
        };
        ne(o, (l) => {
            t() && l(h);
        });
    }
    D(s, a), Ve(), i();
}
Jt(["click"]);
const R4 = (s, e) => {
    e().next({ type: "resumeBetStart" });
};
var L4 = X(
    '<div class="underlay svelte-15ugo6m"><div class="resume-wrapper svelte-15ugo6m"><div class="modal-content svelte-15ugo6m"><h3 class="resume-title svelte-15ugo6m">Resume Active Game?</h3> <p class="resume-subtitle svelte-15ugo6m">You have an active round in progress</p> <div class="button-container svelte-15ugo6m"><button class="cancel-button svelte-15ugo6m">Cancel</button> <button class="resume-button svelte-15ugo6m">Resume</button></div></div></div></div>'
);
function O4(s, e) {
    Ne(e, !0);
    const t = () => U(ei, "$eventEmitter", h),
        n = () => U(gl, "$loaded", h),
        i = () => U(_l, "$startGame", h),
        r = () => U(To, "$lastBet", h),
        a = () => U(Wi, "$hideUI", h),
        o = () => U(cg, "$paperclipLoaderFinished", h),
        [h, l] = tt(),
        u = async () => {
            To.set(null),
                Os.set("BASE"),
                await t().next({ type: "endRound", fromResume: !0 });
        };
    var c = Oe(),
        d = me(c);
    {
        var f = (p) => {
            var m = L4(),
                g = I(m),
                _ = I(g),
                v = N(I(_), 4),
                b = I(v);
            b.__click = u;
            var y = N(b, 2);
            (y.__click = [R4, t]), D(p, m);
        };
        ne(d, (p) => {
            var m;
            n() && i() && (m = r()) != null && m.active && !a() && o() && p(f);
        });
    }
    D(s, c), Ve(), l();
}
Jt(["click"]);
const B4 = (s, e, t) => {
    e().next({ type: "startReplay" }), Re(t, !1);
};
var F4 = X(
        '<p class="resume-subtitle svelte-r5pcli"><span> </span></p> <div class="button-container svelte-r5pcli"><button class="resume-button loading svelte-r5pcli" disabled> </button></div>',
        1
    ),
    $4 = X(
        '<p class="resume-subtitle error svelte-r5pcli"><span> </span></p> <div class="button-container svelte-r5pcli"><button class="resume-button error svelte-r5pcli" disabled> </button></div>',
        1
    ),
    D4 = X(
        '<p class="resume-subtitle svelte-r5pcli"><span> </span> <span> </span> <span> </span></p> <div class="button-container svelte-r5pcli"><button class="resume-button svelte-r5pcli"> </button></div>',
        1
    ),
    N4 = X(
        '<div class="underlay svelte-r5pcli"><div class="resume-wrapper svelte-r5pcli"><div class="modal-content svelte-r5pcli"><h3 class="resume-title svelte-r5pcli"> </h3> <!></div></div></div>'
    );
function V4(s, e) {
    Ne(e, !0);
    const t = () => U(ei, "$eventEmitter", a),
        n = () => U(Js, "$currency", a),
        i = () => U(gl, "$loaded", a),
        r = () => U(_l, "$startGame", a),
        [a, o] = tt();
    let h = gt(!0);
    const l = Me(() => {
            var m;
            return ((m = gi.data) == null ? void 0 : m.costMultiplier) ?? 1;
        }),
        u = Me(() => Qe.amount / es),
        c = Me(() => nr($(u), n()));
    var d = Oe(),
        f = me(d);
    {
        var p = (m) => {
            var g = N4(),
                _ = I(g),
                v = I(_),
                b = I(v),
                y = I(b),
                C = N(b, 2);
            {
                var w = (E) => {
                        var S = F4(),
                            P = me(S),
                            k = I(P),
                            R = I(k),
                            M = N(P, 2),
                            T = I(M),
                            O = I(T);
                        ie(
                            (L, F) => {
                                se(R, L), se(O, F);
                            },
                            [
                                () => oe.t("LOADING_REPLAY_DATA"),
                                () => oe.t("LOADING"),
                            ]
                        ),
                            D(E, S);
                    },
                    A = (E) => {
                        var S = Oe(),
                            P = me(S);
                        {
                            var k = (M) => {
                                    var T = $4(),
                                        O = me(T),
                                        L = I(O),
                                        F = I(L),
                                        Y = N(O, 2),
                                        V = I(Y),
                                        W = I(V);
                                    ie(
                                        (Z, J) => {
                                            se(F, Z), se(W, J);
                                        },
                                        [
                                            () =>
                                                oe.t(
                                                    "FAILED_TO_LOAD_REPLAY_DATA"
                                                ),
                                            () => oe.t("ERROR"),
                                        ]
                                    ),
                                        D(M, T);
                                },
                                R = (M) => {
                                    var T = D4(),
                                        O = me(T),
                                        L = I(O),
                                        F = I(L),
                                        Y = N(L, 2),
                                        V = I(Y),
                                        W = N(Y, 2),
                                        Z = I(W),
                                        J = N(O, 2),
                                        G = I(J);
                                    G.__click = [B4, t, h];
                                    var j = I(G);
                                    ie(
                                        (H, pe, _e, ve) => {
                                            se(F, `${H ?? ""}: ${$(c) ?? ""}`),
                                                se(
                                                    V,
                                                    `${pe ?? ""}: ${
                                                        $(l) ?? ""
                                                    }x`
                                                ),
                                                se(
                                                    Z,
                                                    `${_e ?? ""}: ${
                                                        Qe.mode ?? ""
                                                    }`
                                                ),
                                                se(j, ve);
                                        },
                                        [
                                            () => oe.t("BASE_BET"),
                                            () => oe.t("COST_MULTIPLIER"),
                                            () => oe.t("MODE"),
                                            () => oe.t("START"),
                                        ]
                                    ),
                                        D(M, T);
                                };
                            ne(
                                P,
                                (M) => {
                                    gi.error ? M(k) : M(R, !1);
                                },
                                !0
                            );
                        }
                        D(E, S);
                    };
                ne(C, (E) => {
                    gi.loading ? E(w) : E(A, !1);
                });
            }
            ie((E) => se(y, E), [() => oe.t("GAME_REPLAY")]), D(m, g);
        };
        ne(f, (m) => {
            i() && r() && Qe.replay && $(h) && m(p);
        });
    }
    D(s, d), Ve(), o();
}
Jt(["click"]);
const Lb = "" + new URL("paperclip-rMFDawAD.gif", import.meta.url).href;
var U4 = X(
    '<div class="loader svelte-13m1mdy"><img class="svelte-13m1mdy"/></div>'
);
function z4(s, e) {
    Ne(e, !0);
    const t = () => U(hg, "$preloaded", n),
        [n, i] = tt();
    let r = gt(!0);
    function a(u) {
        return new Promise((c, d) => {
            const f = new Image();
            (f.onload = () => c(f)), (f.onerror = d), (f.src = u);
        });
    }
    Fs(async () => {
        await a(Lb), await Le(2700), Re(r, !1), cg.set(!0);
    });
    var o = Oe(),
        h = me(o);
    {
        var l = (u) => {
            var c = U4(),
                d = I(c);
            ie(() => wr(d, "src", Lb)), Vn(2, c, () => Wr), D(u, c);
        };
        ne(h, (u) => {
            ($(r) || !t()) && u(l);
        });
    }
    D(s, o), Ve(), i();
}
/*! Tweakpane 4.0.5 (c) 2016 cocopon, licensed under the MIT license. */ function Ct(
    s
) {
    return s == null;
}
function Kg(s) {
    return s !== null && typeof s == "object";
}
function km(s) {
    return s !== null && typeof s == "object";
}
function Y4(s, e) {
    if (s.length !== e.length) return !1;
    for (let t = 0; t < s.length; t++) if (s[t] !== e[t]) return !1;
    return !0;
}
function Da(s, e) {
    return Array.from(new Set([...Object.keys(s), ...Object.keys(e)])).reduce(
        (n, i) => {
            const r = s[i],
                a = e[i];
            return km(r) && km(a)
                ? Object.assign(Object.assign({}, n), { [i]: Da(r, a) })
                : Object.assign(Object.assign({}, n), { [i]: i in e ? a : r });
        },
        {}
    );
}
function G4(s) {
    return Kg(s) ? "target" in s : !1;
}
const j4 = {
    alreadydisposed: () => "View has been already disposed",
    invalidparams: (s) => `Invalid parameters for '${s.name}'`,
    nomatchingcontroller: (s) => `No matching controller for '${s.key}'`,
    nomatchingview: (s) => `No matching view for '${JSON.stringify(s.params)}'`,
    notbindable: () => "Value is not bindable",
    notcompatible: (s) => `Not compatible with  plugin '${s.id}'`,
    propertynotfound: (s) => `Property '${s.name}' not found`,
    shouldneverhappen: () => "This error should never happen",
};
let Na = class vo {
        static alreadyDisposed() {
            return new vo({ type: "alreadydisposed" });
        }
        static notBindable() {
            return new vo({ type: "notbindable" });
        }
        static notCompatible(e, t) {
            return new vo({
                type: "notcompatible",
                context: { id: `${e}.${t}` },
            });
        }
        static propertyNotFound(e) {
            return new vo({ type: "propertynotfound", context: { name: e } });
        }
        static shouldNeverHappen() {
            return new vo({ type: "shouldneverhappen" });
        }
        constructor(e) {
            var t;
            (this.message =
                (t = j4[e.type](e.context)) !== null && t !== void 0
                    ? t
                    : "Unexpected error"),
                (this.name = this.constructor.name),
                (this.stack = new Error(this.message).stack),
                (this.type = e.type);
        }
        toString() {
            return this.message;
        }
    },
    Ob = class T2 {
        constructor(e, t) {
            (this.obj_ = e), (this.key = t);
        }
        static isBindable(e) {
            return !(
                e === null ||
                (typeof e != "object" && typeof e != "function")
            );
        }
        read() {
            return this.obj_[this.key];
        }
        write(e) {
            this.obj_[this.key] = e;
        }
        writeProperty(e, t) {
            const n = this.read();
            if (!T2.isBindable(n)) throw Na.notBindable();
            if (!(e in n)) throw Na.propertyNotFound(e);
            n[e] = t;
        }
    },
    ds = class {
        constructor() {
            this.observers_ = {};
        }
        on(e, t, n) {
            var i;
            let r = this.observers_[e];
            return (
                r || (r = this.observers_[e] = []),
                r.push({
                    handler: t,
                    key:
                        (i = n == null ? void 0 : n.key) !== null &&
                        i !== void 0
                            ? i
                            : t,
                }),
                this
            );
        }
        off(e, t) {
            const n = this.observers_[e];
            return (
                n && (this.observers_[e] = n.filter((i) => i.key !== t)), this
            );
        }
        emit(e, t) {
            const n = this.observers_[e];
            n &&
                n.forEach((i) => {
                    i.handler(t);
                });
        }
    },
    W4 = class {
        constructor(e, t) {
            var n;
            (this.constraint_ = t == null ? void 0 : t.constraint),
                (this.equals_ =
                    (n = t == null ? void 0 : t.equals) !== null && n !== void 0
                        ? n
                        : (i, r) => i === r),
                (this.emitter = new ds()),
                (this.rawValue_ = e);
        }
        get constraint() {
            return this.constraint_;
        }
        get rawValue() {
            return this.rawValue_;
        }
        set rawValue(e) {
            this.setRawValue(e, { forceEmit: !1, last: !0 });
        }
        setRawValue(e, t) {
            const n = t ?? { forceEmit: !1, last: !0 },
                i = this.constraint_ ? this.constraint_.constrain(e) : e,
                r = this.rawValue_;
            (this.equals_(r, i) && !n.forceEmit) ||
                (this.emitter.emit("beforechange", { sender: this }),
                (this.rawValue_ = i),
                this.emitter.emit("change", {
                    options: n,
                    previousRawValue: r,
                    rawValue: i,
                    sender: this,
                }));
        }
    },
    X4 = class {
        constructor(e) {
            (this.emitter = new ds()), (this.value_ = e);
        }
        get rawValue() {
            return this.value_;
        }
        set rawValue(e) {
            this.setRawValue(e, { forceEmit: !1, last: !0 });
        }
        setRawValue(e, t) {
            const n = t ?? { forceEmit: !1, last: !0 },
                i = this.value_;
            (i === e && !n.forceEmit) ||
                (this.emitter.emit("beforechange", { sender: this }),
                (this.value_ = e),
                this.emitter.emit("change", {
                    options: n,
                    previousRawValue: i,
                    rawValue: this.value_,
                    sender: this,
                }));
        }
    },
    q4 = class {
        constructor(e) {
            (this.emitter = new ds()),
                (this.onValueBeforeChange_ =
                    this.onValueBeforeChange_.bind(this)),
                (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.value_ = e),
                this.value_.emitter.on(
                    "beforechange",
                    this.onValueBeforeChange_
                ),
                this.value_.emitter.on("change", this.onValueChange_);
        }
        get rawValue() {
            return this.value_.rawValue;
        }
        onValueBeforeChange_(e) {
            this.emitter.emit(
                "beforechange",
                Object.assign(Object.assign({}, e), { sender: this })
            );
        }
        onValueChange_(e) {
            this.emitter.emit(
                "change",
                Object.assign(Object.assign({}, e), { sender: this })
            );
        }
    };
function Qt(s, e) {
    const t = e == null ? void 0 : e.constraint,
        n = e == null ? void 0 : e.equals;
    return !t && !n ? new X4(s) : new W4(s, e);
}
function H4(s) {
    return [
        new q4(s),
        (e, t) => {
            s.setRawValue(e, t);
        },
    ];
}
let He = class M2 {
        constructor(e) {
            (this.emitter = new ds()), (this.valMap_ = e);
            for (const t in this.valMap_)
                this.valMap_[t].emitter.on("change", () => {
                    this.emitter.emit("change", { key: t, sender: this });
                });
        }
        static createCore(e) {
            return Object.keys(e).reduce(
                (n, i) => Object.assign(n, { [i]: Qt(e[i]) }),
                {}
            );
        }
        static fromObject(e) {
            const t = this.createCore(e);
            return new M2(t);
        }
        get(e) {
            return this.valMap_[e].rawValue;
        }
        set(e, t) {
            this.valMap_[e].rawValue = t;
        }
        value(e) {
            return this.valMap_[e];
        }
    },
    Ld = class {
        constructor(e) {
            this.values = He.fromObject({ max: e.max, min: e.min });
        }
        constrain(e) {
            const t = this.values.get("max"),
                n = this.values.get("min");
            return Math.min(Math.max(e, n), t);
        }
    },
    K4 = class {
        constructor(e) {
            this.values = He.fromObject({ max: e.max, min: e.min });
        }
        constrain(e) {
            const t = this.values.get("max"),
                n = this.values.get("min");
            let i = e;
            return (
                Ct(n) || (i = Math.max(i, n)), Ct(t) || (i = Math.min(i, t)), i
            );
        }
    },
    Z4 = class {
        constructor(e, t = 0) {
            (this.step = e), (this.origin = t);
        }
        constrain(e) {
            const t = this.origin % this.step,
                n = Math.round((e - t) / this.step);
            return t + n * this.step;
        }
    },
    Q4 = class {
        constructor(e) {
            this.text = e;
        }
        evaluate() {
            return Number(this.text);
        }
        toString() {
            return this.text;
        }
    };
const J4 = {
    "**": (s, e) => Math.pow(s, e),
    "*": (s, e) => s * e,
    "/": (s, e) => s / e,
    "%": (s, e) => s % e,
    "+": (s, e) => s + e,
    "-": (s, e) => s - e,
    "<<": (s, e) => s << e,
    ">>": (s, e) => s >> e,
    ">>>": (s, e) => s >>> e,
    "&": (s, e) => s & e,
    "^": (s, e) => s ^ e,
    "|": (s, e) => s | e,
};
let e6 = class {
    constructor(e, t, n) {
        (this.left = t), (this.operator = e), (this.right = n);
    }
    evaluate() {
        const e = J4[this.operator];
        if (!e)
            throw new Error(`unexpected binary operator: '${this.operator}`);
        return e(this.left.evaluate(), this.right.evaluate());
    }
    toString() {
        return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")",
        ].join(" ");
    }
};
const t6 = { "+": (s) => s, "-": (s) => -s, "~": (s) => ~s };
let n6 = class {
    constructor(e, t) {
        (this.operator = e), (this.expression = t);
    }
    evaluate() {
        const e = t6[this.operator];
        if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
        return e(this.expression.evaluate());
    }
    toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
    }
};
function Zg(s) {
    return (e, t) => {
        for (let n = 0; n < s.length; n++) {
            const i = s[n](e, t);
            if (i !== "") return i;
        }
        return "";
    };
}
function Xh(s, e) {
    var t;
    const n = s.substr(e).match(/^\s+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function s6(s, e) {
    const t = s.substr(e, 1);
    return t.match(/^[1-9]$/) ? t : "";
}
function qh(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-9]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function i6(s, e) {
    const t = qh(s, e);
    if (t !== "") return t;
    const n = s.substr(e, 1);
    if (((e += 1), n !== "-" && n !== "+")) return "";
    const i = qh(s, e);
    return i === "" ? "" : n + i;
}
function Qg(s, e) {
    const t = s.substr(e, 1);
    if (((e += 1), t.toLowerCase() !== "e")) return "";
    const n = i6(s, e);
    return n === "" ? "" : t + n;
}
function I2(s, e) {
    const t = s.substr(e, 1);
    if (t === "0") return t;
    const n = s6(s, e);
    return (e += n.length), n === "" ? "" : n + qh(s, e);
}
function r6(s, e) {
    const t = I2(s, e);
    if (((e += t.length), t === "")) return "";
    const n = s.substr(e, 1);
    if (((e += n.length), n !== ".")) return "";
    const i = qh(s, e);
    return (e += i.length), t + n + i + Qg(s, e);
}
function a6(s, e) {
    const t = s.substr(e, 1);
    if (((e += t.length), t !== ".")) return "";
    const n = qh(s, e);
    return (e += n.length), n === "" ? "" : t + n + Qg(s, e);
}
function o6(s, e) {
    const t = I2(s, e);
    return (e += t.length), t === "" ? "" : t + Qg(s, e);
}
const l6 = Zg([r6, a6, o6]);
function h6(s, e) {
    var t;
    const n = s.substr(e).match(/^[01]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function c6(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0b")) return "";
    const n = h6(s, e);
    return n === "" ? "" : t + n;
}
function u6(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-7]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function d6(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0o")) return "";
    const n = u6(s, e);
    return n === "" ? "" : t + n;
}
function f6(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-9a-f]+/i);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function p6(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0x")) return "";
    const n = f6(s, e);
    return n === "" ? "" : t + n;
}
const m6 = Zg([c6, d6, p6]),
    g6 = Zg([m6, l6]);
function _6(s, e) {
    const t = g6(s, e);
    return (
        (e += t.length), t === "" ? null : { evaluable: new Q4(t), cursor: e }
    );
}
function v6(s, e) {
    const t = s.substr(e, 1);
    if (((e += t.length), t !== "(")) return null;
    const n = L2(s, e);
    if (!n) return null;
    (e = n.cursor), (e += Xh(s, e).length);
    const i = s.substr(e, 1);
    return (
        (e += i.length),
        i !== ")" ? null : { evaluable: n.evaluable, cursor: e }
    );
}
function b6(s, e) {
    var t;
    return (t = _6(s, e)) !== null && t !== void 0 ? t : v6(s, e);
}
function R2(s, e) {
    const t = b6(s, e);
    if (t) return t;
    const n = s.substr(e, 1);
    if (((e += n.length), n !== "+" && n !== "-" && n !== "~")) return null;
    const i = R2(s, e);
    return i
        ? ((e = i.cursor), { cursor: e, evaluable: new n6(n, i.evaluable) })
        : null;
}
function y6(s, e, t) {
    t += Xh(e, t).length;
    const n = s.filter((i) => e.startsWith(i, t))[0];
    return n
        ? ((t += n.length), (t += Xh(e, t).length), { cursor: t, operator: n })
        : null;
}
function w6(s, e) {
    return (t, n) => {
        const i = s(t, n);
        if (!i) return null;
        n = i.cursor;
        let r = i.evaluable;
        for (;;) {
            const a = y6(e, t, n);
            if (!a) break;
            n = a.cursor;
            const o = s(t, n);
            if (!o) return null;
            (n = o.cursor), (r = new e6(a.operator, r, o.evaluable));
        }
        return r ? { cursor: n, evaluable: r } : null;
    };
}
const x6 = [
    ["**"],
    ["*", "/", "%"],
    ["+", "-"],
    ["<<", ">>>", ">>"],
    ["&"],
    ["^"],
    ["|"],
].reduce((s, e) => w6(s, e), R2);
function L2(s, e) {
    return (e += Xh(s, e).length), x6(s, e);
}
function C6(s) {
    const e = L2(s, 0);
    return !e || e.cursor + Xh(s, e.cursor).length !== s.length
        ? null
        : e.evaluable;
}
function Xr(s) {
    var e;
    const t = C6(s);
    return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0
        ? e
        : null;
}
function O2(s) {
    if (typeof s == "number") return s;
    if (typeof s == "string") {
        const e = Xr(s);
        if (!Ct(e)) return e;
    }
    return 0;
}
function Wn(s) {
    return (e) => e.toFixed(Math.max(Math.min(s, 20), 0));
}
function je(s, e, t, n, i) {
    const r = (s - e) / (t - e);
    return n + r * (i - n);
}
function Bb(s) {
    return String(s.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
}
function Yt(s, e, t) {
    return Math.min(Math.max(s, e), t);
}
function B2(s, e) {
    return ((s % e) + e) % e;
}
function A6(s, e) {
    return Ct(s.step) ? Math.max(Bb(e), 2) : Bb(s.step);
}
function F2(s) {
    var e;
    return (e = s.step) !== null && e !== void 0 ? e : 1;
}
function S6(s, e) {
    var t;
    const n = Math.abs((t = s.step) !== null && t !== void 0 ? t : e);
    return n === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(n)) - 1);
}
function $2(s, e) {
    return Ct(s.step) ? null : new Z4(s.step, e);
}
function D2(s) {
    return !Ct(s.max) && !Ct(s.min)
        ? new Ld({ max: s.max, min: s.min })
        : !Ct(s.max) || !Ct(s.min)
        ? new K4({ max: s.max, min: s.min })
        : null;
}
function N2(s, e) {
    var t, n, i;
    return {
        formatter: (t = s.format) !== null && t !== void 0 ? t : Wn(A6(s, e)),
        keyScale: (n = s.keyScale) !== null && n !== void 0 ? n : F2(s),
        pointerScale:
            (i = s.pointerScale) !== null && i !== void 0 ? i : S6(s, e),
    };
}
function V2(s) {
    return {
        format: s.optional.function,
        keyScale: s.optional.number,
        max: s.optional.number,
        min: s.optional.number,
        pointerScale: s.optional.number,
        step: s.optional.number,
    };
}
function Jg(s) {
    return {
        constraint: s.constraint,
        textProps: He.fromObject(N2(s.params, s.initialValue)),
    };
}
let e_ = class {
        constructor(e) {
            this.controller = e;
        }
        get element() {
            return this.controller.view.element;
        }
        get disabled() {
            return this.controller.viewProps.get("disabled");
        }
        set disabled(e) {
            this.controller.viewProps.set("disabled", e);
        }
        get hidden() {
            return this.controller.viewProps.get("hidden");
        }
        set hidden(e) {
            this.controller.viewProps.set("hidden", e);
        }
        dispose() {
            this.controller.viewProps.set("disposed", !0);
        }
        importState(e) {
            return this.controller.importState(e);
        }
        exportState() {
            return this.controller.exportState();
        }
    },
    Od = class {
        constructor(e) {
            this.target = e;
        }
    },
    U2 = class extends Od {
        constructor(e, t, n) {
            super(e), (this.value = t), (this.last = n ?? !0);
        }
    },
    E6 = class extends Od {
        constructor(e, t) {
            super(e), (this.expanded = t);
        }
    },
    P6 = class extends Od {
        constructor(e, t) {
            super(e), (this.index = t);
        }
    };
class k6 extends Od {
    constructor(e, t) {
        super(e), (this.native = t);
    }
}
let t_ = class extends e_ {
    constructor(e) {
        super(e),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.emitter_ = new ds()),
            this.controller.value.emitter.on("change", this.onValueChange_);
    }
    get label() {
        return this.controller.labelController.props.get("label");
    }
    set label(e) {
        this.controller.labelController.props.set("label", e);
    }
    get key() {
        return this.controller.value.binding.target.key;
    }
    get tag() {
        return this.controller.tag;
    }
    set tag(e) {
        this.controller.tag = e;
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(
                e,
                (i) => {
                    n(i);
                },
                { key: t }
            ),
            this
        );
    }
    off(e, t) {
        return this.emitter_.off(e, t), this;
    }
    refresh() {
        this.controller.value.fetch();
    }
    onValueChange_(e) {
        const t = this.controller.value;
        this.emitter_.emit(
            "change",
            new U2(this, t.binding.target.read(), e.options.last)
        );
    }
};
function T6(s, e) {
    const n = Object.keys(e).reduce((i, r) => {
        if (i === void 0) return;
        const a = e[r],
            o = a(s[r]);
        return o.succeeded
            ? Object.assign(Object.assign({}, i), { [r]: o.value })
            : void 0;
    }, {});
    return n;
}
function M6(s, e) {
    return s.reduce((t, n) => {
        if (t === void 0) return;
        const i = e(n);
        if (!(!i.succeeded || i.value === void 0)) return [...t, i.value];
    }, []);
}
function I6(s) {
    return s === null ? !1 : typeof s == "object";
}
function Vi(s) {
    return (e) => (t) => {
        if (!e && t === void 0) return { succeeded: !1, value: void 0 };
        if (e && t === void 0) return { succeeded: !0, value: void 0 };
        const n = s(t);
        return n !== void 0
            ? { succeeded: !0, value: n }
            : { succeeded: !1, value: void 0 };
    };
}
function Fb(s) {
    return {
        custom: (e) => Vi(e)(s),
        boolean: Vi((e) => (typeof e == "boolean" ? e : void 0))(s),
        number: Vi((e) => (typeof e == "number" ? e : void 0))(s),
        string: Vi((e) => (typeof e == "string" ? e : void 0))(s),
        function: Vi((e) => (typeof e == "function" ? e : void 0))(s),
        constant: (e) => Vi((t) => (t === e ? e : void 0))(s),
        raw: Vi((e) => e)(s),
        object: (e) =>
            Vi((t) => {
                if (I6(t)) return T6(t, e);
            })(s),
        array: (e) =>
            Vi((t) => {
                if (Array.isArray(t)) return M6(t, e);
            })(s),
    };
}
const Tm = { optional: Fb(!0), required: Fb(!1) };
function yn(s, e) {
    const t = e(Tm),
        n = Tm.required.object(t)(s);
    return n.succeeded ? n.value : void 0;
}
function Li(s, e, t, n) {
    if (e && !e(s)) return !1;
    const i = yn(s, t);
    return i ? n(i) : !1;
}
function Oi(s, e) {
    var t;
    return Da(
        (t = s == null ? void 0 : s()) !== null && t !== void 0 ? t : {},
        e
    );
}
function au(s) {
    return "value" in s;
}
function R6(s) {
    if (!Kg(s) || !("binding" in s)) return !1;
    const e = s.binding;
    return G4(e);
}
const yi = "http://www.w3.org/2000/svg";
function Hu(s) {
    s.offsetHeight;
}
function L6(s, e) {
    const t = s.style.transition;
    (s.style.transition = "none"), e(), (s.style.transition = t);
}
function n_(s) {
    return s.ontouchstart !== void 0;
}
function O6(s) {
    const e = s.ownerDocument.defaultView;
    return e && "document" in e
        ? s.getContext("2d", { willReadFrequently: !0 })
        : null;
}
const B6 = {
    check: '<path d="M2 8l4 4l8 -8"/>',
    dropdown: '<path d="M5 7h6l-3 3 z"/>',
    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function Bd(s, e) {
    const t = s.createElementNS(yi, "svg");
    return (t.innerHTML = B6[e]), t;
}
function z2(s, e, t) {
    s.insertBefore(e, s.children[t]);
}
function s_(s) {
    s.parentElement && s.parentElement.removeChild(s);
}
function Y2(s) {
    for (; s.children.length > 0; ) s.removeChild(s.children[0]);
}
function F6(s) {
    for (; s.childNodes.length > 0; ) s.removeChild(s.childNodes[0]);
}
function G2(s) {
    return s.relatedTarget
        ? s.relatedTarget
        : "explicitOriginalTarget" in s
        ? s.explicitOriginalTarget
        : null;
}
function er(s, e) {
    s.emitter.on("change", (t) => {
        e(t.rawValue);
    }),
        e(s.rawValue);
}
function Ei(s, e, t) {
    er(s.value(e), t);
}
const $6 = "tp";
function Ue(s) {
    return (t, n) =>
        [$6, "-", s, "v", t ? `_${t}` : "", n ? `-${n}` : ""].join("");
}
const Vl = Ue("lbl");
function D6(s, e) {
    const t = s.createDocumentFragment();
    return (
        e
            .split(
                `
`
            )
            .map((i) => s.createTextNode(i))
            .forEach((i, r) => {
                r > 0 && t.appendChild(s.createElement("br")), t.appendChild(i);
            }),
        t
    );
}
let N6 = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(Vl()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("div");
            n.classList.add(Vl("l")),
                Ei(t.props, "label", (r) => {
                    Ct(r)
                        ? this.element.classList.add(Vl(void 0, "nol"))
                        : (this.element.classList.remove(Vl(void 0, "nol")),
                          F6(n),
                          n.appendChild(D6(e, r)));
                }),
                this.element.appendChild(n),
                (this.labelElement = n);
            const i = e.createElement("div");
            i.classList.add(Vl("v")),
                this.element.appendChild(i),
                (this.valueElement = i);
        }
    },
    V6 = class {
        constructor(e, t) {
            (this.props = t.props),
                (this.valueController = t.valueController),
                (this.viewProps = t.valueController.viewProps),
                (this.view = new N6(e, {
                    props: t.props,
                    viewProps: this.viewProps,
                })),
                this.view.valueElement.appendChild(
                    this.valueController.view.element
                );
        }
        importProps(e) {
            return Li(
                e,
                null,
                (t) => ({ label: t.optional.string }),
                (t) => (this.props.set("label", t.label), !0)
            );
        }
        exportProps() {
            return Oi(null, { label: this.props.get("label") });
        }
    };
function U6() {
    return ["veryfirst", "first", "last", "verylast"];
}
const $b = Ue(""),
    Db = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
let j2 = class {
        constructor(e) {
            (this.parent_ = null),
                (this.blade = e.blade),
                (this.view = e.view),
                (this.viewProps = e.viewProps);
            const t = this.view.element;
            this.blade.value("positions").emitter.on("change", () => {
                U6().forEach((n) => {
                    t.classList.remove($b(void 0, Db[n]));
                }),
                    this.blade.get("positions").forEach((n) => {
                        t.classList.add($b(void 0, Db[n]));
                    });
            }),
                this.viewProps.handleDispose(() => {
                    s_(t);
                });
        }
        get parent() {
            return this.parent_;
        }
        set parent(e) {
            (this.parent_ = e),
                this.viewProps.set(
                    "parent",
                    this.parent_ ? this.parent_.viewProps : null
                );
        }
        importState(e) {
            return Li(
                e,
                null,
                (t) => ({
                    disabled: t.required.boolean,
                    hidden: t.required.boolean,
                }),
                (t) => (this.viewProps.importState(t), !0)
            );
        }
        exportState() {
            return Oi(null, Object.assign({}, this.viewProps.exportState()));
        }
    },
    z6 = class extends e_ {
        get label() {
            return this.controller.labelController.props.get("label");
        }
        set label(e) {
            this.controller.labelController.props.set("label", e);
        }
        get title() {
            var e;
            return (e = this.controller.buttonController.props.get("title")) !==
                null && e !== void 0
                ? e
                : "";
        }
        set title(e) {
            this.controller.buttonController.props.set("title", e);
        }
        on(e, t) {
            const n = t.bind(this);
            return (
                this.controller.buttonController.emitter.on(e, (r) => {
                    n(new k6(this, r.nativeEvent));
                }),
                this
            );
        }
        off(e, t) {
            return this.controller.buttonController.emitter.off(e, t), this;
        }
    };
function Y6(s, e, t) {
    t ? s.classList.add(e) : s.classList.remove(e);
}
function yl(s, e) {
    return (t) => {
        Y6(s, e, t);
    };
}
function i_(s, e) {
    er(s, (t) => {
        e.textContent = t ?? "";
    });
}
const ap = Ue("btn");
let G6 = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(ap()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("button");
            n.classList.add(ap("b")),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.buttonElement = n);
            const i = e.createElement("div");
            i.classList.add(ap("t")),
                i_(t.props.value("title"), i),
                this.buttonElement.appendChild(i);
        }
    },
    j6 = class {
        constructor(e, t) {
            (this.emitter = new ds()),
                (this.onClick_ = this.onClick_.bind(this)),
                (this.props = t.props),
                (this.viewProps = t.viewProps),
                (this.view = new G6(e, {
                    props: this.props,
                    viewProps: this.viewProps,
                })),
                this.view.buttonElement.addEventListener(
                    "click",
                    this.onClick_
                );
        }
        importProps(e) {
            return Li(
                e,
                null,
                (t) => ({ title: t.optional.string }),
                (t) => (this.props.set("title", t.title), !0)
            );
        }
        exportProps() {
            return Oi(null, { title: this.props.get("title") });
        }
        onClick_(e) {
            this.emitter.emit("click", { nativeEvent: e, sender: this });
        }
    },
    Nb = class extends j2 {
        constructor(e, t) {
            const n = new j6(e, {
                    props: t.buttonProps,
                    viewProps: t.viewProps,
                }),
                i = new V6(e, {
                    blade: t.blade,
                    props: t.labelProps,
                    valueController: n,
                });
            super({ blade: t.blade, view: i.view, viewProps: t.viewProps }),
                (this.buttonController = n),
                (this.labelController = i);
        }
        importState(e) {
            return Li(
                e,
                (t) =>
                    super.importState(t) &&
                    this.buttonController.importProps(t) &&
                    this.labelController.importProps(t),
                () => ({}),
                () => !0
            );
        }
        exportState() {
            return Oi(
                () => super.exportState(),
                Object.assign(
                    Object.assign({}, this.buttonController.exportProps()),
                    this.labelController.exportProps()
                )
            );
        }
    },
    W2 = class {
        constructor(e) {
            const [t, n] = e.split("-"),
                i = t.split(".");
            (this.major = parseInt(i[0], 10)),
                (this.minor = parseInt(i[1], 10)),
                (this.patch = parseInt(i[2], 10)),
                (this.prerelease = n ?? null);
        }
        toString() {
            const e = [this.major, this.minor, this.patch].join(".");
            return this.prerelease !== null
                ? [e, this.prerelease].join("-")
                : e;
        }
    };
const W6 = new W2("2.0.5");
function Mn(s) {
    return Object.assign({ core: W6 }, s);
}
Mn({
    id: "button",
    type: "blade",
    accept(s) {
        const e = yn(s, (t) => ({
            title: t.required.string,
            view: t.required.constant("button"),
            label: t.optional.string,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        return new Nb(s.document, {
            blade: s.blade,
            buttonProps: He.fromObject({ title: s.params.title }),
            labelProps: He.fromObject({ label: s.params.label }),
            viewProps: s.viewProps,
        });
    },
    api(s) {
        return s.controller instanceof Nb ? new z6(s.controller) : null;
    },
});
function X6(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
}
function q6(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
}
function H6(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
}
function K6(s) {
    return Kg(s) ? "refresh" in s && typeof s.refresh == "function" : !1;
}
function Z6(s, e) {
    if (!Ob.isBindable(s)) throw Na.notBindable();
    return new Ob(s, e);
}
let Q6 = class {
        constructor(e, t) {
            (this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
                (this.controller_ = e),
                (this.emitter_ = new ds()),
                (this.pool_ = t),
                this.controller_.rack.emitter.on(
                    "valuechange",
                    this.onRackValueChange_
                );
        }
        get children() {
            return this.controller_.rack.children.map((e) =>
                this.pool_.createApi(e)
            );
        }
        addBinding(e, t, n) {
            const i = n ?? {},
                r = this.controller_.element.ownerDocument,
                a = this.pool_.createBinding(r, Z6(e, t), i),
                o = this.pool_.createBindingApi(a);
            return this.add(o, i.index);
        }
        addFolder(e) {
            return q6(this, e);
        }
        addButton(e) {
            return X6(this, e);
        }
        addTab(e) {
            return H6(this, e);
        }
        add(e, t) {
            const n = e.controller;
            return this.controller_.rack.add(n, t), e;
        }
        remove(e) {
            this.controller_.rack.remove(e.controller);
        }
        addBlade(e) {
            const t = this.controller_.element.ownerDocument,
                n = this.pool_.createBlade(t, e),
                i = this.pool_.createApi(n);
            return this.add(i, e.index);
        }
        on(e, t) {
            const n = t.bind(this);
            return (
                this.emitter_.on(
                    e,
                    (i) => {
                        n(i);
                    },
                    { key: t }
                ),
                this
            );
        }
        off(e, t) {
            return this.emitter_.off(e, t), this;
        }
        refresh() {
            this.children.forEach((e) => {
                K6(e) && e.refresh();
            });
        }
        onRackValueChange_(e) {
            const t = e.bladeController,
                n = this.pool_.createApi(t),
                i = R6(t.value) ? t.value.binding : null;
            this.emitter_.emit(
                "change",
                new U2(
                    n,
                    i ? i.target.read() : t.value.rawValue,
                    e.options.last
                )
            );
        }
    },
    r_ = class extends e_ {
        constructor(e, t) {
            super(e), (this.rackApi_ = new Q6(e.rackController, t));
        }
        refresh() {
            this.rackApi_.refresh();
        }
    },
    a_ = class extends j2 {
        constructor(e) {
            super({
                blade: e.blade,
                view: e.view,
                viewProps: e.rackController.viewProps,
            }),
                (this.rackController = e.rackController);
        }
        importState(e) {
            return Li(
                e,
                (t) => super.importState(t),
                (t) => ({ children: t.required.array(t.required.raw) }),
                (t) =>
                    this.rackController.rack.children.every((n, i) =>
                        n.importState(t.children[i])
                    )
            );
        }
        exportState() {
            return Oi(() => super.exportState(), {
                children: this.rackController.rack.children.map((e) =>
                    e.exportState()
                ),
            });
        }
    };
function Mm(s) {
    return "rackController" in s;
}
let J6 = class {
    constructor(e) {
        (this.emitter = new ds()),
            (this.items_ = []),
            (this.cache_ = new Set()),
            (this.onSubListAdd_ = this.onSubListAdd_.bind(this)),
            (this.onSubListRemove_ = this.onSubListRemove_.bind(this)),
            (this.extract_ = e);
    }
    get items() {
        return this.items_;
    }
    allItems() {
        return Array.from(this.cache_);
    }
    find(e) {
        for (const t of this.allItems()) if (e(t)) return t;
        return null;
    }
    includes(e) {
        return this.cache_.has(e);
    }
    add(e, t) {
        if (this.includes(e)) throw Na.shouldNeverHappen();
        const n = t !== void 0 ? t : this.items_.length;
        this.items_.splice(n, 0, e), this.cache_.add(e);
        const i = this.extract_(e);
        i &&
            (i.emitter.on("add", this.onSubListAdd_),
            i.emitter.on("remove", this.onSubListRemove_),
            i.allItems().forEach((r) => {
                this.cache_.add(r);
            })),
            this.emitter.emit("add", {
                index: n,
                item: e,
                root: this,
                target: this,
            });
    }
    remove(e) {
        const t = this.items_.indexOf(e);
        if (t < 0) return;
        this.items_.splice(t, 1), this.cache_.delete(e);
        const n = this.extract_(e);
        n &&
            (n.allItems().forEach((i) => {
                this.cache_.delete(i);
            }),
            n.emitter.off("add", this.onSubListAdd_),
            n.emitter.off("remove", this.onSubListRemove_)),
            this.emitter.emit("remove", {
                index: t,
                item: e,
                root: this,
                target: this,
            });
    }
    onSubListAdd_(e) {
        this.cache_.add(e.item),
            this.emitter.emit("add", {
                index: e.index,
                item: e.item,
                root: this,
                target: e.target,
            });
    }
    onSubListRemove_(e) {
        this.cache_.delete(e.item),
            this.emitter.emit("remove", {
                index: e.index,
                item: e.item,
                root: this,
                target: e.target,
            });
    }
};
function eF(s, e) {
    for (let t = 0; t < s.length; t++) {
        const n = s[t];
        if (au(n) && n.value === e) return n;
    }
    return null;
}
function tF(s) {
    return Mm(s) ? s.rackController.rack.bcSet_ : null;
}
let nF = class {
        constructor(e) {
            var t, n;
            (this.emitter = new ds()),
                (this.onBladePositionsChange_ =
                    this.onBladePositionsChange_.bind(this)),
                (this.onSetAdd_ = this.onSetAdd_.bind(this)),
                (this.onSetRemove_ = this.onSetRemove_.bind(this)),
                (this.onChildDispose_ = this.onChildDispose_.bind(this)),
                (this.onChildPositionsChange_ =
                    this.onChildPositionsChange_.bind(this)),
                (this.onChildValueChange_ =
                    this.onChildValueChange_.bind(this)),
                (this.onChildViewPropsChange_ =
                    this.onChildViewPropsChange_.bind(this)),
                (this.onRackLayout_ = this.onRackLayout_.bind(this)),
                (this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
                (this.blade_ =
                    (t = e.blade) !== null && t !== void 0 ? t : null),
                (n = this.blade_) === null ||
                    n === void 0 ||
                    n
                        .value("positions")
                        .emitter.on("change", this.onBladePositionsChange_),
                (this.viewProps = e.viewProps),
                (this.bcSet_ = new J6(tF)),
                this.bcSet_.emitter.on("add", this.onSetAdd_),
                this.bcSet_.emitter.on("remove", this.onSetRemove_);
        }
        get children() {
            return this.bcSet_.items;
        }
        add(e, t) {
            var n;
            (n = e.parent) === null || n === void 0 || n.remove(e),
                (e.parent = this),
                this.bcSet_.add(e, t);
        }
        remove(e) {
            (e.parent = null), this.bcSet_.remove(e);
        }
        find(e) {
            return this.bcSet_.allItems().filter(e);
        }
        onSetAdd_(e) {
            this.updatePositions_();
            const t = e.target === e.root;
            if (
                (this.emitter.emit("add", {
                    bladeController: e.item,
                    index: e.index,
                    root: t,
                    sender: this,
                }),
                !t)
            )
                return;
            const n = e.item;
            if (
                (n.viewProps.emitter.on("change", this.onChildViewPropsChange_),
                n.blade
                    .value("positions")
                    .emitter.on("change", this.onChildPositionsChange_),
                n.viewProps.handleDispose(this.onChildDispose_),
                au(n))
            )
                n.value.emitter.on("change", this.onChildValueChange_);
            else if (Mm(n)) {
                const i = n.rackController.rack;
                if (i) {
                    const r = i.emitter;
                    r.on("layout", this.onRackLayout_),
                        r.on("valuechange", this.onRackValueChange_);
                }
            }
        }
        onSetRemove_(e) {
            this.updatePositions_();
            const t = e.target === e.root;
            if (
                (this.emitter.emit("remove", {
                    bladeController: e.item,
                    root: t,
                    sender: this,
                }),
                !t)
            )
                return;
            const n = e.item;
            if (au(n)) n.value.emitter.off("change", this.onChildValueChange_);
            else if (Mm(n)) {
                const i = n.rackController.rack;
                if (i) {
                    const r = i.emitter;
                    r.off("layout", this.onRackLayout_),
                        r.off("valuechange", this.onRackValueChange_);
                }
            }
        }
        updatePositions_() {
            const e = this.bcSet_.items.filter(
                    (i) => !i.viewProps.get("hidden")
                ),
                t = e[0],
                n = e[e.length - 1];
            this.bcSet_.items.forEach((i) => {
                const r = [];
                i === t &&
                    (r.push("first"),
                    (!this.blade_ ||
                        this.blade_.get("positions").includes("veryfirst")) &&
                        r.push("veryfirst")),
                    i === n &&
                        (r.push("last"),
                        (!this.blade_ ||
                            this.blade_
                                .get("positions")
                                .includes("verylast")) &&
                            r.push("verylast")),
                    i.blade.set("positions", r);
            });
        }
        onChildPositionsChange_() {
            this.updatePositions_(),
                this.emitter.emit("layout", { sender: this });
        }
        onChildViewPropsChange_(e) {
            this.updatePositions_(),
                this.emitter.emit("layout", { sender: this });
        }
        onChildDispose_() {
            this.bcSet_.items
                .filter((t) => t.viewProps.get("disposed"))
                .forEach((t) => {
                    this.bcSet_.remove(t);
                });
        }
        onChildValueChange_(e) {
            const t = eF(this.find(au), e.sender);
            if (!t) throw Na.alreadyDisposed();
            this.emitter.emit("valuechange", {
                bladeController: t,
                options: e.options,
                sender: this,
            });
        }
        onRackLayout_(e) {
            this.updatePositions_(),
                this.emitter.emit("layout", { sender: this });
        }
        onRackValueChange_(e) {
            this.emitter.emit("valuechange", {
                bladeController: e.bladeController,
                options: e.options,
                sender: this,
            });
        }
        onBladePositionsChange_() {
            this.updatePositions_();
        }
    },
    o_ = class {
        constructor(e) {
            (this.onRackAdd_ = this.onRackAdd_.bind(this)),
                (this.onRackRemove_ = this.onRackRemove_.bind(this)),
                (this.element = e.element),
                (this.viewProps = e.viewProps);
            const t = new nF({
                blade: e.root ? void 0 : e.blade,
                viewProps: e.viewProps,
            });
            t.emitter.on("add", this.onRackAdd_),
                t.emitter.on("remove", this.onRackRemove_),
                (this.rack = t),
                this.viewProps.handleDispose(() => {
                    for (let n = this.rack.children.length - 1; n >= 0; n--)
                        this.rack.children[n].viewProps.set("disposed", !0);
                });
        }
        onRackAdd_(e) {
            e.root && z2(this.element, e.bladeController.view.element, e.index);
        }
        onRackRemove_(e) {
            e.root && s_(e.bladeController.view.element);
        }
    };
function X2() {
    return new He({ positions: Qt([], { equals: Y4 }) });
}
let l_ = class q2 extends He {
    constructor(e) {
        super(e);
    }
    static create(e) {
        const t = {
                completed: !0,
                expanded: e,
                expandedHeight: null,
                shouldFixHeight: !1,
                temporaryExpanded: null,
            },
            n = He.createCore(t);
        return new q2(n);
    }
    get styleExpanded() {
        var e;
        return (e = this.get("temporaryExpanded")) !== null && e !== void 0
            ? e
            : this.get("expanded");
    }
    get styleHeight() {
        if (!this.styleExpanded) return "0";
        const e = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !Ct(e) ? `${e}px` : "auto";
    }
    bindExpandedClass(e, t) {
        const n = () => {
            this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
        };
        Ei(this, "expanded", n), Ei(this, "temporaryExpanded", n);
    }
    cleanUpTransition() {
        this.set("shouldFixHeight", !1),
            this.set("expandedHeight", null),
            this.set("completed", !0);
    }
};
function sF(s, e) {
    let t = 0;
    return (
        L6(e, () => {
            s.set("expandedHeight", null),
                s.set("temporaryExpanded", !0),
                Hu(e),
                (t = e.clientHeight),
                s.set("temporaryExpanded", null),
                Hu(e);
        }),
        t
    );
}
function Vb(s, e) {
    e.style.height = s.styleHeight;
}
function h_(s, e) {
    s.value("expanded").emitter.on("beforechange", () => {
        if ((s.set("completed", !1), Ct(s.get("expandedHeight")))) {
            const t = sF(s, e);
            t > 0 && s.set("expandedHeight", t);
        }
        s.set("shouldFixHeight", !0), Hu(e);
    }),
        s.emitter.on("change", () => {
            Vb(s, e);
        }),
        Vb(s, e),
        e.addEventListener("transitionend", (t) => {
            t.propertyName === "height" && s.cleanUpTransition();
        });
}
let iF = class extends r_ {
    constructor(e, t) {
        super(e, t),
            (this.emitter_ = new ds()),
            this.controller.foldable
                .value("expanded")
                .emitter.on("change", (n) => {
                    this.emitter_.emit("fold", new E6(this, n.sender.rawValue));
                }),
            this.rackApi_.on("change", (n) => {
                this.emitter_.emit("change", n);
            });
    }
    get expanded() {
        return this.controller.foldable.get("expanded");
    }
    set expanded(e) {
        this.controller.foldable.set("expanded", e);
    }
    get title() {
        return this.controller.props.get("title");
    }
    set title(e) {
        this.controller.props.set("title", e);
    }
    get children() {
        return this.rackApi_.children;
    }
    addBinding(e, t, n) {
        return this.rackApi_.addBinding(e, t, n);
    }
    addFolder(e) {
        return this.rackApi_.addFolder(e);
    }
    addButton(e) {
        return this.rackApi_.addButton(e);
    }
    addTab(e) {
        return this.rackApi_.addTab(e);
    }
    add(e, t) {
        return this.rackApi_.add(e, t);
    }
    remove(e) {
        this.rackApi_.remove(e);
    }
    addBlade(e) {
        return this.rackApi_.addBlade(e);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(
                e,
                (i) => {
                    n(i);
                },
                { key: t }
            ),
            this
        );
    }
    off(e, t) {
        return this.emitter_.off(e, t), this;
    }
};
const H2 = Ue("cnt");
let rF = class {
        constructor(e, t) {
            var n;
            (this.className_ = Ue(
                (n = t.viewName) !== null && n !== void 0 ? n : "fld"
            )),
                (this.element = e.createElement("div")),
                this.element.classList.add(this.className_(), H2()),
                t.viewProps.bindClassModifiers(this.element),
                (this.foldable_ = t.foldable),
                this.foldable_.bindExpandedClass(
                    this.element,
                    this.className_(void 0, "expanded")
                ),
                Ei(
                    this.foldable_,
                    "completed",
                    yl(this.element, this.className_(void 0, "cpl"))
                );
            const i = e.createElement("button");
            i.classList.add(this.className_("b")),
                Ei(t.props, "title", (l) => {
                    Ct(l)
                        ? this.element.classList.add(
                              this.className_(void 0, "not")
                          )
                        : this.element.classList.remove(
                              this.className_(void 0, "not")
                          );
                }),
                t.viewProps.bindDisabled(i),
                this.element.appendChild(i),
                (this.buttonElement = i);
            const r = e.createElement("div");
            r.classList.add(this.className_("i")), this.element.appendChild(r);
            const a = e.createElement("div");
            a.classList.add(this.className_("t")),
                i_(t.props.value("title"), a),
                this.buttonElement.appendChild(a),
                (this.titleElement = a);
            const o = e.createElement("div");
            o.classList.add(this.className_("m")),
                this.buttonElement.appendChild(o);
            const h = e.createElement("div");
            h.classList.add(this.className_("c")),
                this.element.appendChild(h),
                (this.containerElement = h);
        }
    },
    Ub = class extends a_ {
        constructor(e, t) {
            var n;
            const i = l_.create(
                    (n = t.expanded) !== null && n !== void 0 ? n : !0
                ),
                r = new rF(e, {
                    foldable: i,
                    props: t.props,
                    viewName: t.root ? "rot" : void 0,
                    viewProps: t.viewProps,
                });
            super(
                Object.assign(Object.assign({}, t), {
                    rackController: new o_({
                        blade: t.blade,
                        element: r.containerElement,
                        root: t.root,
                        viewProps: t.viewProps,
                    }),
                    view: r,
                })
            ),
                (this.onTitleClick_ = this.onTitleClick_.bind(this)),
                (this.props = t.props),
                (this.foldable = i),
                h_(this.foldable, this.view.containerElement),
                this.rackController.rack.emitter.on("add", () => {
                    this.foldable.cleanUpTransition();
                }),
                this.rackController.rack.emitter.on("remove", () => {
                    this.foldable.cleanUpTransition();
                }),
                this.view.buttonElement.addEventListener(
                    "click",
                    this.onTitleClick_
                );
        }
        get document() {
            return this.view.element.ownerDocument;
        }
        importState(e) {
            return Li(
                e,
                (t) => super.importState(t),
                (t) => ({
                    expanded: t.required.boolean,
                    title: t.optional.string,
                }),
                (t) => (
                    this.foldable.set("expanded", t.expanded),
                    this.props.set("title", t.title),
                    !0
                )
            );
        }
        exportState() {
            return Oi(() => super.exportState(), {
                expanded: this.foldable.get("expanded"),
                title: this.props.get("title"),
            });
        }
        onTitleClick_() {
            this.foldable.set("expanded", !this.foldable.get("expanded"));
        }
    };
Mn({
    id: "folder",
    type: "blade",
    accept(s) {
        const e = yn(s, (t) => ({
            title: t.required.string,
            view: t.required.constant("folder"),
            expanded: t.optional.boolean,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        return new Ub(s.document, {
            blade: s.blade,
            expanded: s.params.expanded,
            props: He.fromObject({ title: s.params.title }),
            viewProps: s.viewProps,
        });
    },
    api(s) {
        return s.controller instanceof Ub ? new iF(s.controller, s.pool) : null;
    },
});
const aF = Ue("");
function zb(s, e) {
    return yl(s, aF(void 0, e));
}
let c_ = class K2 extends He {
    constructor(e) {
        var t;
        super(e),
            (this.onDisabledChange_ = this.onDisabledChange_.bind(this)),
            (this.onParentChange_ = this.onParentChange_.bind(this)),
            (this.onParentGlobalDisabledChange_ =
                this.onParentGlobalDisabledChange_.bind(this)),
            ([this.globalDisabled_, this.setGlobalDisabled_] = H4(
                Qt(this.getGlobalDisabled_())
            )),
            this.value("disabled").emitter.on("change", this.onDisabledChange_),
            this.value("parent").emitter.on("change", this.onParentChange_),
            (t = this.get("parent")) === null ||
                t === void 0 ||
                t.globalDisabled.emitter.on(
                    "change",
                    this.onParentGlobalDisabledChange_
                );
    }
    static create(e) {
        var t, n, i;
        const r = e ?? {};
        return new K2(
            He.createCore({
                disabled: (t = r.disabled) !== null && t !== void 0 ? t : !1,
                disposed: !1,
                hidden: (n = r.hidden) !== null && n !== void 0 ? n : !1,
                parent: (i = r.parent) !== null && i !== void 0 ? i : null,
            })
        );
    }
    get globalDisabled() {
        return this.globalDisabled_;
    }
    bindClassModifiers(e) {
        er(this.globalDisabled_, zb(e, "disabled")),
            Ei(this, "hidden", zb(e, "hidden"));
    }
    bindDisabled(e) {
        er(this.globalDisabled_, (t) => {
            e.disabled = t;
        });
    }
    bindTabIndex(e) {
        er(this.globalDisabled_, (t) => {
            e.tabIndex = t ? -1 : 0;
        });
    }
    handleDispose(e) {
        this.value("disposed").emitter.on("change", (t) => {
            t && e();
        });
    }
    importState(e) {
        this.set("disabled", e.disabled), this.set("hidden", e.hidden);
    }
    exportState() {
        return { disabled: this.get("disabled"), hidden: this.get("hidden") };
    }
    getGlobalDisabled_() {
        const e = this.get("parent");
        return (e ? e.globalDisabled.rawValue : !1) || this.get("disabled");
    }
    updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
    }
    onDisabledChange_() {
        this.updateGlobalDisabled_();
    }
    onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
    }
    onParentChange_(e) {
        var t;
        const n = e.previousRawValue;
        n == null ||
            n.globalDisabled.emitter.off(
                "change",
                this.onParentGlobalDisabledChange_
            ),
            (t = this.get("parent")) === null ||
                t === void 0 ||
                t.globalDisabled.emitter.on(
                    "change",
                    this.onParentGlobalDisabledChange_
                ),
            this.updateGlobalDisabled_();
    }
};
const Yb = Ue("tbp");
let oF = class {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(Yb()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(Yb("c")),
            this.element.appendChild(n),
            (this.containerElement = n);
    }
};
const Ul = Ue("tbi");
let lF = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(Ul()),
                t.viewProps.bindClassModifiers(this.element),
                Ei(t.props, "selected", (r) => {
                    r
                        ? this.element.classList.add(Ul(void 0, "sel"))
                        : this.element.classList.remove(Ul(void 0, "sel"));
                });
            const n = e.createElement("button");
            n.classList.add(Ul("b")),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.buttonElement = n);
            const i = e.createElement("div");
            i.classList.add(Ul("t")),
                i_(t.props.value("title"), i),
                this.buttonElement.appendChild(i),
                (this.titleElement = i);
        }
    },
    hF = class {
        constructor(e, t) {
            (this.emitter = new ds()),
                (this.onClick_ = this.onClick_.bind(this)),
                (this.props = t.props),
                (this.viewProps = t.viewProps),
                (this.view = new lF(e, {
                    props: t.props,
                    viewProps: t.viewProps,
                })),
                this.view.buttonElement.addEventListener(
                    "click",
                    this.onClick_
                );
        }
        onClick_() {
            this.emitter.emit("click", { sender: this });
        }
    },
    Im = class extends a_ {
        constructor(e, t) {
            const n = new oF(e, { viewProps: t.viewProps });
            super(
                Object.assign(Object.assign({}, t), {
                    rackController: new o_({
                        blade: t.blade,
                        element: n.containerElement,
                        viewProps: t.viewProps,
                    }),
                    view: n,
                })
            ),
                (this.onItemClick_ = this.onItemClick_.bind(this)),
                (this.ic_ = new hF(e, {
                    props: t.itemProps,
                    viewProps: c_.create(),
                })),
                this.ic_.emitter.on("click", this.onItemClick_),
                (this.props = t.props),
                Ei(this.props, "selected", (i) => {
                    this.itemController.props.set("selected", i),
                        this.viewProps.set("hidden", !i);
                });
        }
        get itemController() {
            return this.ic_;
        }
        importState(e) {
            return Li(
                e,
                (t) => super.importState(t),
                (t) => ({
                    selected: t.required.boolean,
                    title: t.required.string,
                }),
                (t) => (
                    this.ic_.props.set("selected", t.selected),
                    this.ic_.props.set("title", t.title),
                    !0
                )
            );
        }
        exportState() {
            return Oi(() => super.exportState(), {
                selected: this.ic_.props.get("selected"),
                title: this.ic_.props.get("title"),
            });
        }
        onItemClick_() {
            this.props.set("selected", !0);
        }
    },
    cF = class extends r_ {
        constructor(e, t) {
            super(e, t),
                (this.emitter_ = new ds()),
                (this.onSelect_ = this.onSelect_.bind(this)),
                (this.pool_ = t),
                this.rackApi_.on("change", (n) => {
                    this.emitter_.emit("change", n);
                }),
                this.controller.tab.selectedIndex.emitter.on(
                    "change",
                    this.onSelect_
                );
        }
        get pages() {
            return this.rackApi_.children;
        }
        addPage(e) {
            const t = this.controller.view.element.ownerDocument,
                n = new Im(t, {
                    blade: X2(),
                    itemProps: He.fromObject({ selected: !1, title: e.title }),
                    props: He.fromObject({ selected: !1 }),
                    viewProps: c_.create(),
                }),
                i = this.pool_.createApi(n);
            return this.rackApi_.add(i, e.index);
        }
        removePage(e) {
            this.rackApi_.remove(this.rackApi_.children[e]);
        }
        on(e, t) {
            const n = t.bind(this);
            return (
                this.emitter_.on(
                    e,
                    (i) => {
                        n(i);
                    },
                    { key: t }
                ),
                this
            );
        }
        off(e, t) {
            return this.emitter_.off(e, t), this;
        }
        onSelect_(e) {
            this.emitter_.emit("select", new P6(this, e.rawValue));
        }
    },
    uF = class extends r_ {
        get title() {
            var e;
            return (e = this.controller.itemController.props.get("title")) !==
                null && e !== void 0
                ? e
                : "";
        }
        set title(e) {
            this.controller.itemController.props.set("title", e);
        }
        get selected() {
            return this.controller.props.get("selected");
        }
        set selected(e) {
            this.controller.props.set("selected", e);
        }
        get children() {
            return this.rackApi_.children;
        }
        addButton(e) {
            return this.rackApi_.addButton(e);
        }
        addFolder(e) {
            return this.rackApi_.addFolder(e);
        }
        addTab(e) {
            return this.rackApi_.addTab(e);
        }
        add(e, t) {
            this.rackApi_.add(e, t);
        }
        remove(e) {
            this.rackApi_.remove(e);
        }
        addBinding(e, t, n) {
            return this.rackApi_.addBinding(e, t, n);
        }
        addBlade(e) {
            return this.rackApi_.addBlade(e);
        }
    };
const Gb = -1;
let dF = class {
    constructor() {
        (this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this)),
            (this.empty = Qt(!0)),
            (this.selectedIndex = Qt(Gb)),
            (this.items_ = []);
    }
    add(e, t) {
        const n = t ?? this.items_.length;
        this.items_.splice(n, 0, e),
            e.emitter.on("change", this.onItemSelectedChange_),
            this.keepSelection_();
    }
    remove(e) {
        const t = this.items_.indexOf(e);
        t < 0 ||
            (this.items_.splice(t, 1),
            e.emitter.off("change", this.onItemSelectedChange_),
            this.keepSelection_());
    }
    keepSelection_() {
        if (this.items_.length === 0) {
            (this.selectedIndex.rawValue = Gb), (this.empty.rawValue = !0);
            return;
        }
        const e = this.items_.findIndex((t) => t.rawValue);
        e < 0
            ? (this.items_.forEach((t, n) => {
                  t.rawValue = n === 0;
              }),
              (this.selectedIndex.rawValue = 0))
            : (this.items_.forEach((t, n) => {
                  t.rawValue = n === e;
              }),
              (this.selectedIndex.rawValue = e)),
            (this.empty.rawValue = !1);
    }
    onItemSelectedChange_(e) {
        if (e.rawValue) {
            const t = this.items_.findIndex((n) => n === e.sender);
            this.items_.forEach((n, i) => {
                n.rawValue = i === t;
            }),
                (this.selectedIndex.rawValue = t);
        } else this.keepSelection_();
    }
};
const zl = Ue("tab");
let fF = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(zl(), H2()),
                t.viewProps.bindClassModifiers(this.element),
                er(t.empty, yl(this.element, zl(void 0, "nop")));
            const n = e.createElement("div");
            n.classList.add(zl("t")),
                this.element.appendChild(n),
                (this.itemsElement = n);
            const i = e.createElement("div");
            i.classList.add(zl("i")), this.element.appendChild(i);
            const r = e.createElement("div");
            r.classList.add(zl("c")),
                this.element.appendChild(r),
                (this.contentsElement = r);
        }
    },
    jb = class extends a_ {
        constructor(e, t) {
            const n = new dF(),
                i = new fF(e, { empty: n.empty, viewProps: t.viewProps });
            super({
                blade: t.blade,
                rackController: new o_({
                    blade: t.blade,
                    element: i.contentsElement,
                    viewProps: t.viewProps,
                }),
                view: i,
            }),
                (this.onRackAdd_ = this.onRackAdd_.bind(this)),
                (this.onRackRemove_ = this.onRackRemove_.bind(this));
            const r = this.rackController.rack;
            r.emitter.on("add", this.onRackAdd_),
                r.emitter.on("remove", this.onRackRemove_),
                (this.tab = n);
        }
        add(e, t) {
            this.rackController.rack.add(e, t);
        }
        remove(e) {
            this.rackController.rack.remove(
                this.rackController.rack.children[e]
            );
        }
        onRackAdd_(e) {
            if (!e.root) return;
            const t = e.bladeController;
            z2(this.view.itemsElement, t.itemController.view.element, e.index),
                t.itemController.viewProps.set("parent", this.viewProps),
                this.tab.add(t.props.value("selected"));
        }
        onRackRemove_(e) {
            if (!e.root) return;
            const t = e.bladeController;
            s_(t.itemController.view.element),
                t.itemController.viewProps.set("parent", null),
                this.tab.remove(t.props.value("selected"));
        }
    };
Mn({
    id: "tab",
    type: "blade",
    accept(s) {
        const e = yn(s, (t) => ({
            pages: t.required.array(
                t.required.object({ title: t.required.string })
            ),
            view: t.required.constant("tab"),
        }));
        return !e || e.pages.length === 0 ? null : { params: e };
    },
    controller(s) {
        const e = new jb(s.document, {
            blade: s.blade,
            viewProps: s.viewProps,
        });
        return (
            s.params.pages.forEach((t) => {
                const n = new Im(s.document, {
                    blade: X2(),
                    itemProps: He.fromObject({ selected: !1, title: t.title }),
                    props: He.fromObject({ selected: !1 }),
                    viewProps: c_.create(),
                });
                e.add(n);
            }),
            e
        );
    },
    api(s) {
        return s.controller instanceof jb
            ? new cF(s.controller, s.pool)
            : s.controller instanceof Im
            ? new uF(s.controller, s.pool)
            : null;
    },
});
let u_ = class extends t_ {
        get options() {
            return this.controller.valueController.props.get("options");
        }
        set options(e) {
            this.controller.valueController.props.set("options", e);
        }
    },
    fc = class {
        constructor(e) {
            this.constraints = e;
        }
        constrain(e) {
            return this.constraints.reduce((t, n) => n.constrain(t), e);
        }
    };
function Ku(s, e) {
    if (s instanceof e) return s;
    if (s instanceof fc) {
        const t = s.constraints.reduce(
            (n, i) => n || (i instanceof e ? i : null),
            null
        );
        if (t) return t;
    }
    return null;
}
let Fd = class {
    constructor(e) {
        this.values = He.fromObject({ options: e });
    }
    constrain(e) {
        const t = this.values.get("options");
        return t.length === 0 || t.filter((i) => i.value === e).length > 0
            ? e
            : t[0].value;
    }
};
function $d(s) {
    var e;
    const t = Tm;
    if (Array.isArray(s))
        return (e = yn({ items: s }, (n) => ({
            items: n.required.array(
                n.required.object({
                    text: n.required.string,
                    value: n.required.raw,
                })
            ),
        }))) === null || e === void 0
            ? void 0
            : e.items;
    if (typeof s == "object") return t.required.raw(s).value;
}
function Z2(s) {
    if (Array.isArray(s)) return s;
    const e = [];
    return (
        Object.keys(s).forEach((t) => {
            e.push({ text: t, value: s[t] });
        }),
        e
    );
}
function d_(s) {
    return Ct(s) ? null : new Fd(Z2(s));
}
const op = Ue("lst");
let pF = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.props_ = t.props),
                (this.element = e.createElement("div")),
                this.element.classList.add(op()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("select");
            n.classList.add(op("s")),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.selectElement = n);
            const i = e.createElement("div");
            i.classList.add(op("m")),
                i.appendChild(Bd(e, "dropdown")),
                this.element.appendChild(i),
                t.value.emitter.on("change", this.onValueChange_),
                (this.value_ = t.value),
                Ei(this.props_, "options", (r) => {
                    Y2(this.selectElement),
                        r.forEach((a) => {
                            const o = e.createElement("option");
                            (o.textContent = a.text),
                                this.selectElement.appendChild(o);
                        }),
                        this.update_();
                });
        }
        update_() {
            const e = this.props_.get("options").map((t) => t.value);
            this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue);
        }
        onValueChange_() {
            this.update_();
        }
    },
    ol = class {
        constructor(e, t) {
            (this.onSelectChange_ = this.onSelectChange_.bind(this)),
                (this.props = t.props),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new pF(e, {
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                this.view.selectElement.addEventListener(
                    "change",
                    this.onSelectChange_
                );
        }
        onSelectChange_(e) {
            const t = e.currentTarget;
            this.value.rawValue =
                this.props.get("options")[t.selectedIndex].value;
        }
        importProps(e) {
            return Li(
                e,
                null,
                (t) => ({ options: t.required.custom($d) }),
                (t) => (this.props.set("options", Z2(t.options)), !0)
            );
        }
        exportProps() {
            return Oi(null, { options: this.props.get("options") });
        }
    };
const Wb = Ue("pop");
let mF = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(Wb()),
                t.viewProps.bindClassModifiers(this.element),
                er(t.shows, yl(this.element, Wb(void 0, "v")));
        }
    },
    Q2 = class {
        constructor(e, t) {
            (this.shows = Qt(!1)),
                (this.viewProps = t.viewProps),
                (this.view = new mF(e, {
                    shows: this.shows,
                    viewProps: this.viewProps,
                }));
        }
    };
const Xb = Ue("txt");
let gF = class {
        constructor(e, t) {
            (this.onChange_ = this.onChange_.bind(this)),
                (this.element = e.createElement("div")),
                this.element.classList.add(Xb()),
                t.viewProps.bindClassModifiers(this.element),
                (this.props_ = t.props),
                this.props_.emitter.on("change", this.onChange_);
            const n = e.createElement("input");
            n.classList.add(Xb("i")),
                (n.type = "text"),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.inputElement = n),
                t.value.emitter.on("change", this.onChange_),
                (this.value_ = t.value),
                this.refresh();
        }
        refresh() {
            const e = this.props_.get("formatter");
            this.inputElement.value = e(this.value_.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    },
    f_ = class {
        constructor(e, t) {
            (this.onInputChange_ = this.onInputChange_.bind(this)),
                (this.parser_ = t.parser),
                (this.props = t.props),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new gF(e, {
                    props: t.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                this.view.inputElement.addEventListener(
                    "change",
                    this.onInputChange_
                );
        }
        onInputChange_(e) {
            const n = e.currentTarget.value,
                i = this.parser_(n);
            Ct(i) || (this.value.rawValue = i), this.view.refresh();
        }
    };
function _F(s) {
    return String(s);
}
function J2(s) {
    return s === "false" ? !1 : !!s;
}
function qb(s) {
    return _F(s);
}
function vF(s) {
    return (e) => s.reduce((t, n) => (t !== null ? t : n(e)), null);
}
const bF = Wn(0);
function Zu(s) {
    return bF(s) + "%";
}
function eA(s) {
    return String(s);
}
function Rm(s) {
    return s;
}
function wl({ primary: s, secondary: e, forward: t, backward: n }) {
    let i = !1;
    function r(a) {
        i || ((i = !0), a(), (i = !1));
    }
    s.emitter.on("change", (a) => {
        r(() => {
            e.setRawValue(t(s.rawValue, e.rawValue), a.options);
        });
    }),
        e.emitter.on("change", (a) => {
            r(() => {
                s.setRawValue(n(s.rawValue, e.rawValue), a.options);
            }),
                r(() => {
                    e.setRawValue(t(s.rawValue, e.rawValue), a.options);
                });
        }),
        r(() => {
            e.setRawValue(t(s.rawValue, e.rawValue), {
                forceEmit: !1,
                last: !0,
            });
        });
}
function Nn(s, e) {
    const t = s * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
    return e.upKey ? +t : e.downKey ? -t : 0;
}
function Hh(s) {
    return {
        altKey: s.altKey,
        downKey: s.key === "ArrowDown",
        shiftKey: s.shiftKey,
        upKey: s.key === "ArrowUp",
    };
}
function ar(s) {
    return {
        altKey: s.altKey,
        downKey: s.key === "ArrowLeft",
        shiftKey: s.shiftKey,
        upKey: s.key === "ArrowRight",
    };
}
function yF(s) {
    return s === "ArrowUp" || s === "ArrowDown";
}
function tA(s) {
    return yF(s) || s === "ArrowLeft" || s === "ArrowRight";
}
function lp(s, e) {
    var t, n;
    const i = e.ownerDocument.defaultView,
        r = e.getBoundingClientRect();
    return {
        x:
            s.pageX -
            (((t = i && i.scrollX) !== null && t !== void 0 ? t : 0) + r.left),
        y:
            s.pageY -
            (((n = i && i.scrollY) !== null && n !== void 0 ? n : 0) + r.top),
    };
}
let Za = class {
    constructor(e) {
        (this.lastTouch_ = null),
            (this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
            (this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
            (this.onMouseDown_ = this.onMouseDown_.bind(this)),
            (this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
            (this.onTouchMove_ = this.onTouchMove_.bind(this)),
            (this.onTouchStart_ = this.onTouchStart_.bind(this)),
            (this.elem_ = e),
            (this.emitter = new ds()),
            e.addEventListener("touchstart", this.onTouchStart_, {
                passive: !1,
            }),
            e.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }),
            e.addEventListener("touchend", this.onTouchEnd_),
            e.addEventListener("mousedown", this.onMouseDown_);
    }
    computePosition_(e) {
        const t = this.elem_.getBoundingClientRect();
        return {
            bounds: { width: t.width, height: t.height },
            point: e ? { x: e.x, y: e.y } : null,
        };
    }
    onMouseDown_(e) {
        var t;
        e.preventDefault(),
            (t = e.currentTarget) === null || t === void 0 || t.focus();
        const n = this.elem_.ownerDocument;
        n.addEventListener("mousemove", this.onDocumentMouseMove_),
            n.addEventListener("mouseup", this.onDocumentMouseUp_),
            this.emitter.emit("down", {
                altKey: e.altKey,
                data: this.computePosition_(lp(e, this.elem_)),
                sender: this,
                shiftKey: e.shiftKey,
            });
    }
    onDocumentMouseMove_(e) {
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(lp(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey,
        });
    }
    onDocumentMouseUp_(e) {
        const t = this.elem_.ownerDocument;
        t.removeEventListener("mousemove", this.onDocumentMouseMove_),
            t.removeEventListener("mouseup", this.onDocumentMouseUp_),
            this.emitter.emit("up", {
                altKey: e.altKey,
                data: this.computePosition_(lp(e, this.elem_)),
                sender: this,
                shiftKey: e.shiftKey,
            });
    }
    onTouchStart_(e) {
        e.preventDefault();
        const t = e.targetTouches.item(0),
            n = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(
                t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        }),
            (this.lastTouch_ = t);
    }
    onTouchMove_(e) {
        const t = e.targetTouches.item(0),
            n = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(
                t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        }),
            (this.lastTouch_ = t);
    }
    onTouchEnd_(e) {
        var t;
        const n =
                (t = e.targetTouches.item(0)) !== null && t !== void 0
                    ? t
                    : this.lastTouch_,
            i = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(
                n ? { x: n.clientX - i.left, y: n.clientY - i.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        });
    }
};
const gs = Ue("txt");
let wF = class {
        constructor(e, t) {
            (this.onChange_ = this.onChange_.bind(this)),
                (this.props_ = t.props),
                this.props_.emitter.on("change", this.onChange_),
                (this.element = e.createElement("div")),
                this.element.classList.add(gs(), gs(void 0, "num")),
                t.arrayPosition &&
                    this.element.classList.add(gs(void 0, t.arrayPosition)),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("input");
            n.classList.add(gs("i")),
                (n.type = "text"),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.inputElement = n),
                (this.onDraggingChange_ = this.onDraggingChange_.bind(this)),
                (this.dragging_ = t.dragging),
                this.dragging_.emitter.on("change", this.onDraggingChange_),
                this.element.classList.add(gs()),
                this.inputElement.classList.add(gs("i"));
            const i = e.createElement("div");
            i.classList.add(gs("k")),
                this.element.appendChild(i),
                (this.knobElement = i);
            const r = e.createElementNS(yi, "svg");
            r.classList.add(gs("g")), this.knobElement.appendChild(r);
            const a = e.createElementNS(yi, "path");
            a.classList.add(gs("gb")),
                r.appendChild(a),
                (this.guideBodyElem_ = a);
            const o = e.createElementNS(yi, "path");
            o.classList.add(gs("gh")),
                r.appendChild(o),
                (this.guideHeadElem_ = o);
            const h = e.createElement("div");
            h.classList.add(Ue("tt")()),
                this.knobElement.appendChild(h),
                (this.tooltipElem_ = h),
                t.value.emitter.on("change", this.onChange_),
                (this.value = t.value),
                this.refresh();
        }
        onDraggingChange_(e) {
            if (e.rawValue === null) {
                this.element.classList.remove(gs(void 0, "drg"));
                return;
            }
            this.element.classList.add(gs(void 0, "drg"));
            const t = e.rawValue / this.props_.get("pointerScale"),
                n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
                i = Yt(-n, -4, 4);
            this.guideHeadElem_.setAttributeNS(
                null,
                "d",
                [`M ${n + i},0 L${n},4 L${n + i},8`, `M ${t},-1 L${t},9`].join(
                    " "
                )
            ),
                this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
            const r = this.props_.get("formatter");
            (this.tooltipElem_.textContent = r(this.value.rawValue)),
                (this.tooltipElem_.style.left = `${t}px`);
        }
        refresh() {
            const e = this.props_.get("formatter");
            this.inputElement.value = e(this.value.rawValue);
        }
        onChange_() {
            this.refresh();
        }
    },
    pc = class {
        constructor(e, t) {
            var n;
            (this.originRawValue_ = 0),
                (this.onInputChange_ = this.onInputChange_.bind(this)),
                (this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
                (this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
                (this.onPointerDown_ = this.onPointerDown_.bind(this)),
                (this.onPointerMove_ = this.onPointerMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.parser_ = t.parser),
                (this.props = t.props),
                (this.sliderProps_ =
                    (n = t.sliderProps) !== null && n !== void 0 ? n : null),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.dragging_ = Qt(null)),
                (this.view = new wF(e, {
                    arrayPosition: t.arrayPosition,
                    dragging: this.dragging_,
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                this.view.inputElement.addEventListener(
                    "change",
                    this.onInputChange_
                ),
                this.view.inputElement.addEventListener(
                    "keydown",
                    this.onInputKeyDown_
                ),
                this.view.inputElement.addEventListener(
                    "keyup",
                    this.onInputKeyUp_
                );
            const i = new Za(this.view.knobElement);
            i.emitter.on("down", this.onPointerDown_),
                i.emitter.on("move", this.onPointerMove_),
                i.emitter.on("up", this.onPointerUp_);
        }
        constrainValue_(e) {
            var t, n;
            const i =
                    (t = this.sliderProps_) === null || t === void 0
                        ? void 0
                        : t.get("min"),
                r =
                    (n = this.sliderProps_) === null || n === void 0
                        ? void 0
                        : n.get("max");
            let a = e;
            return (
                i !== void 0 && (a = Math.max(a, i)),
                r !== void 0 && (a = Math.min(a, r)),
                a
            );
        }
        onInputChange_(e) {
            const n = e.currentTarget.value,
                i = this.parser_(n);
            Ct(i) || (this.value.rawValue = this.constrainValue_(i)),
                this.view.refresh();
        }
        onInputKeyDown_(e) {
            const t = Nn(this.props.get("keyScale"), Hh(e));
            t !== 0 &&
                this.value.setRawValue(
                    this.constrainValue_(this.value.rawValue + t),
                    { forceEmit: !1, last: !1 }
                );
        }
        onInputKeyUp_(e) {
            Nn(this.props.get("keyScale"), Hh(e)) !== 0 &&
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
        onPointerDown_() {
            (this.originRawValue_ = this.value.rawValue),
                (this.dragging_.rawValue = 0);
        }
        computeDraggingValue_(e) {
            if (!e.point) return null;
            const t = e.point.x - e.bounds.width / 2;
            return this.constrainValue_(
                this.originRawValue_ + t * this.props.get("pointerScale")
            );
        }
        onPointerMove_(e) {
            const t = this.computeDraggingValue_(e.data);
            t !== null &&
                (this.value.setRawValue(t, { forceEmit: !1, last: !1 }),
                (this.dragging_.rawValue =
                    this.value.rawValue - this.originRawValue_));
        }
        onPointerUp_(e) {
            const t = this.computeDraggingValue_(e.data);
            t !== null &&
                (this.value.setRawValue(t, { forceEmit: !0, last: !0 }),
                (this.dragging_.rawValue = null));
        }
    };
const hp = Ue("sld");
let xF = class {
        constructor(e, t) {
            (this.onChange_ = this.onChange_.bind(this)),
                (this.props_ = t.props),
                this.props_.emitter.on("change", this.onChange_),
                (this.element = e.createElement("div")),
                this.element.classList.add(hp()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("div");
            n.classList.add(hp("t")),
                t.viewProps.bindTabIndex(n),
                this.element.appendChild(n),
                (this.trackElement = n);
            const i = e.createElement("div");
            i.classList.add(hp("k")),
                this.trackElement.appendChild(i),
                (this.knobElement = i),
                t.value.emitter.on("change", this.onChange_),
                (this.value = t.value),
                this.update_();
        }
        update_() {
            const e = Yt(
                je(
                    this.value.rawValue,
                    this.props_.get("min"),
                    this.props_.get("max"),
                    0,
                    100
                ),
                0,
                100
            );
            this.knobElement.style.width = `${e}%`;
        }
        onChange_() {
            this.update_();
        }
    },
    CF = class {
        constructor(e, t) {
            (this.onKeyDown_ = this.onKeyDown_.bind(this)),
                (this.onKeyUp_ = this.onKeyUp_.bind(this)),
                (this.onPointerDownOrMove_ =
                    this.onPointerDownOrMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.props = t.props),
                (this.view = new xF(e, {
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.ptHandler_ = new Za(this.view.trackElement)),
                this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
                this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.trackElement.addEventListener(
                    "keydown",
                    this.onKeyDown_
                ),
                this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(e, t) {
            e.point &&
                this.value.setRawValue(
                    je(
                        Yt(e.point.x, 0, e.bounds.width),
                        0,
                        e.bounds.width,
                        this.props.get("min"),
                        this.props.get("max")
                    ),
                    t
                );
        }
        onPointerDownOrMove_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerUp_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
        }
        onKeyDown_(e) {
            const t = Nn(this.props.get("keyScale"), ar(e));
            t !== 0 &&
                this.value.setRawValue(this.value.rawValue + t, {
                    forceEmit: !1,
                    last: !1,
                });
        }
        onKeyUp_(e) {
            Nn(this.props.get("keyScale"), ar(e)) !== 0 &&
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
    };
const cp = Ue("sldtxt");
let AF = class {
        constructor(e, t) {
            (this.element = e.createElement("div")),
                this.element.classList.add(cp());
            const n = e.createElement("div");
            n.classList.add(cp("s")),
                (this.sliderView_ = t.sliderView),
                n.appendChild(this.sliderView_.element),
                this.element.appendChild(n);
            const i = e.createElement("div");
            i.classList.add(cp("t")),
                (this.textView_ = t.textView),
                i.appendChild(this.textView_.element),
                this.element.appendChild(i);
        }
    },
    Hb = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.sliderC_ = new CF(e, {
                    props: t.sliderProps,
                    value: t.value,
                    viewProps: this.viewProps,
                })),
                (this.textC_ = new pc(e, {
                    parser: t.parser,
                    props: t.textProps,
                    sliderProps: t.sliderProps,
                    value: t.value,
                    viewProps: t.viewProps,
                })),
                (this.view = new AF(e, {
                    sliderView: this.sliderC_.view,
                    textView: this.textC_.view,
                }));
        }
        get sliderController() {
            return this.sliderC_;
        }
        get textController() {
            return this.textC_;
        }
        importProps(e) {
            return Li(
                e,
                null,
                (t) => ({ max: t.required.number, min: t.required.number }),
                (t) => {
                    const n = this.sliderC_.props;
                    return n.set("max", t.max), n.set("min", t.min), !0;
                }
            );
        }
        exportProps() {
            const e = this.sliderC_.props;
            return Oi(null, { max: e.get("max"), min: e.get("min") });
        }
    };
function SF(s) {
    return {
        sliderProps: new He({ keyScale: s.keyScale, max: s.max, min: s.min }),
        textProps: new He({
            formatter: Qt(s.formatter),
            keyScale: s.keyScale,
            pointerScale: Qt(s.pointerScale),
        }),
    };
}
const EF = { containerUnitSize: "cnt-usz" };
function nA(s) {
    return `--${EF[s]}`;
}
function Kh(s) {
    return V2(s);
}
function Or(s) {
    if (km(s)) return yn(s, Kh);
}
function qi(s, e) {
    if (!s) return;
    const t = [],
        n = $2(s, e);
    n && t.push(n);
    const i = D2(s);
    return i && t.push(i), new fc(t);
}
function sA(s) {
    if (s === "inline" || s === "popup") return s;
}
function mc(s, e) {
    s.write(e);
}
const Xc = Ue("ckb");
let PF = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.element = e.createElement("div")),
                this.element.classList.add(Xc()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("label");
            n.classList.add(Xc("l")),
                this.element.appendChild(n),
                (this.labelElement = n);
            const i = e.createElement("input");
            i.classList.add(Xc("i")),
                (i.type = "checkbox"),
                this.labelElement.appendChild(i),
                (this.inputElement = i),
                t.viewProps.bindDisabled(this.inputElement);
            const r = e.createElement("div");
            r.classList.add(Xc("w")), this.labelElement.appendChild(r);
            const a = Bd(e, "check");
            r.appendChild(a),
                t.value.emitter.on("change", this.onValueChange_),
                (this.value = t.value),
                this.update_();
        }
        update_() {
            this.inputElement.checked = this.value.rawValue;
        }
        onValueChange_() {
            this.update_();
        }
    },
    kF = class {
        constructor(e, t) {
            (this.onInputChange_ = this.onInputChange_.bind(this)),
                (this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new PF(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                this.view.inputElement.addEventListener(
                    "change",
                    this.onInputChange_
                ),
                this.view.labelElement.addEventListener(
                    "mousedown",
                    this.onLabelMouseDown_
                );
        }
        onInputChange_(e) {
            const t = e.currentTarget;
            (this.value.rawValue = t.checked),
                e.preventDefault(),
                e.stopPropagation();
        }
        onLabelMouseDown_(e) {
            e.preventDefault();
        }
    };
function TF(s) {
    const e = [],
        t = d_(s.options);
    return t && e.push(t), new fc(e);
}
Mn({
    id: "input-bool",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "boolean") return null;
        const t = yn(e, (n) => ({
            options: n.optional.custom($d),
            readonly: n.optional.constant(!1),
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => J2,
        constraint: (s) => TF(s.params),
        writer: (s) => mc,
    },
    controller: (s) => {
        const e = s.document,
            t = s.value,
            n = s.constraint,
            i = n && Ku(n, Fd);
        return i
            ? new ol(e, {
                  props: new He({ options: i.values.value("options") }),
                  value: t,
                  viewProps: s.viewProps,
              })
            : new kF(e, { value: t, viewProps: s.viewProps });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "boolean"
            ? null
            : s.controller.valueController instanceof ol
            ? new u_(s.controller)
            : null;
    },
});
const na = Ue("col");
let MF = class {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(na()),
            t.foldable.bindExpandedClass(this.element, na(void 0, "expanded")),
            Ei(t.foldable, "completed", yl(this.element, na(void 0, "cpl")));
        const n = e.createElement("div");
        n.classList.add(na("h")), this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(na("s")), n.appendChild(i), (this.swatchElement = i);
        const r = e.createElement("div");
        if (
            (r.classList.add(na("t")),
            n.appendChild(r),
            (this.textElement = r),
            t.pickerLayout === "inline")
        ) {
            const a = e.createElement("div");
            a.classList.add(na("p")),
                this.element.appendChild(a),
                (this.pickerElement = a);
        } else this.pickerElement = null;
    }
};
function IF(s, e, t) {
    const n = Yt(s / 255, 0, 1),
        i = Yt(e / 255, 0, 1),
        r = Yt(t / 255, 0, 1),
        a = Math.max(n, i, r),
        o = Math.min(n, i, r),
        h = a - o;
    let l = 0,
        u = 0;
    const c = (o + a) / 2;
    return (
        h !== 0 &&
            ((u = h / (1 - Math.abs(a + o - 1))),
            n === a
                ? (l = (i - r) / h)
                : i === a
                ? (l = 2 + (r - n) / h)
                : (l = 4 + (n - i) / h),
            (l = l / 6 + (l < 0 ? 1 : 0))),
        [l * 360, u * 100, c * 100]
    );
}
function RF(s, e, t) {
    const n = ((s % 360) + 360) % 360,
        i = Yt(e / 100, 0, 1),
        r = Yt(t / 100, 0, 1),
        a = (1 - Math.abs(2 * r - 1)) * i,
        o = a * (1 - Math.abs(((n / 60) % 2) - 1)),
        h = r - a / 2;
    let l, u, c;
    return (
        n >= 0 && n < 60
            ? ([l, u, c] = [a, o, 0])
            : n >= 60 && n < 120
            ? ([l, u, c] = [o, a, 0])
            : n >= 120 && n < 180
            ? ([l, u, c] = [0, a, o])
            : n >= 180 && n < 240
            ? ([l, u, c] = [0, o, a])
            : n >= 240 && n < 300
            ? ([l, u, c] = [o, 0, a])
            : ([l, u, c] = [a, 0, o]),
        [(l + h) * 255, (u + h) * 255, (c + h) * 255]
    );
}
function LF(s, e, t) {
    const n = Yt(s / 255, 0, 1),
        i = Yt(e / 255, 0, 1),
        r = Yt(t / 255, 0, 1),
        a = Math.max(n, i, r),
        o = Math.min(n, i, r),
        h = a - o;
    let l;
    h === 0
        ? (l = 0)
        : a === n
        ? (l = 60 * (((((i - r) / h) % 6) + 6) % 6))
        : a === i
        ? (l = 60 * ((r - n) / h + 2))
        : (l = 60 * ((n - i) / h + 4));
    const u = a === 0 ? 0 : h / a,
        c = a;
    return [l, u * 100, c * 100];
}
function iA(s, e, t) {
    const n = B2(s, 360),
        i = Yt(e / 100, 0, 1),
        r = Yt(t / 100, 0, 1),
        a = r * i,
        o = a * (1 - Math.abs(((n / 60) % 2) - 1)),
        h = r - a;
    let l, u, c;
    return (
        n >= 0 && n < 60
            ? ([l, u, c] = [a, o, 0])
            : n >= 60 && n < 120
            ? ([l, u, c] = [o, a, 0])
            : n >= 120 && n < 180
            ? ([l, u, c] = [0, a, o])
            : n >= 180 && n < 240
            ? ([l, u, c] = [0, o, a])
            : n >= 240 && n < 300
            ? ([l, u, c] = [o, 0, a])
            : ([l, u, c] = [a, 0, o]),
        [(l + h) * 255, (u + h) * 255, (c + h) * 255]
    );
}
function OF(s, e, t) {
    const n = t + (e * (100 - Math.abs(2 * t - 100))) / 200;
    return [
        s,
        n !== 0 ? (e * (100 - Math.abs(2 * t - 100))) / n : 0,
        t + (e * (100 - Math.abs(2 * t - 100))) / 200,
    ];
}
function BF(s, e, t) {
    const n = 100 - Math.abs((t * (200 - e)) / 100 - 100);
    return [s, n !== 0 ? (e * t) / n : 0, (t * (200 - e)) / 200];
}
function Pi(s) {
    return [s[0], s[1], s[2]];
}
function Dd(s, e) {
    return [s[0], s[1], s[2], e];
}
const FF = {
    hsl: { hsl: (s, e, t) => [s, e, t], hsv: OF, rgb: RF },
    hsv: { hsl: BF, hsv: (s, e, t) => [s, e, t], rgb: iA },
    rgb: { hsl: IF, hsv: LF, rgb: (s, e, t) => [s, e, t] },
};
function ll(s, e) {
    return [
        e === "float" ? 1 : s === "rgb" ? 255 : 360,
        e === "float" ? 1 : s === "rgb" ? 255 : 100,
        e === "float" ? 1 : s === "rgb" ? 255 : 100,
    ];
}
function $F(s, e) {
    return s === e ? e : B2(s, e);
}
function rA(s, e, t) {
    var n;
    const i = ll(e, t);
    return [
        e === "rgb" ? Yt(s[0], 0, i[0]) : $F(s[0], i[0]),
        Yt(s[1], 0, i[1]),
        Yt(s[2], 0, i[2]),
        Yt((n = s[3]) !== null && n !== void 0 ? n : 1, 0, 1),
    ];
}
function Kb(s, e, t, n) {
    const i = ll(e, t),
        r = ll(e, n);
    return s.map((a, o) => (a / i[o]) * r[o]);
}
function aA(s, e, t) {
    const n = Kb(s, e.mode, e.type, "int"),
        i = FF[e.mode][t.mode](...n);
    return Kb(i, t.mode, "int", t.type);
}
let We = class oA {
    static black() {
        return new oA([0, 0, 0], "rgb");
    }
    constructor(e, t) {
        (this.type = "int"),
            (this.mode = t),
            (this.comps_ = rA(e, t, this.type));
    }
    getComponents(e) {
        return Dd(
            aA(
                Pi(this.comps_),
                { mode: this.mode, type: this.type },
                { mode: e ?? this.mode, type: this.type }
            ),
            this.comps_[3]
        );
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return { r: e[0], g: e[1], b: e[2], a: e[3] };
    }
};
const dr = Ue("colp");
let DF = class {
    constructor(e, t) {
        (this.alphaViews_ = null),
            (this.element = e.createElement("div")),
            this.element.classList.add(dr()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(dr("hsv"));
        const i = e.createElement("div");
        i.classList.add(dr("sv")),
            (this.svPaletteView_ = t.svPaletteView),
            i.appendChild(this.svPaletteView_.element),
            n.appendChild(i);
        const r = e.createElement("div");
        r.classList.add(dr("h")),
            (this.hPaletteView_ = t.hPaletteView),
            r.appendChild(this.hPaletteView_.element),
            n.appendChild(r),
            this.element.appendChild(n);
        const a = e.createElement("div");
        if (
            (a.classList.add(dr("rgb")),
            (this.textsView_ = t.textsView),
            a.appendChild(this.textsView_.element),
            this.element.appendChild(a),
            t.alphaViews)
        ) {
            this.alphaViews_ = {
                palette: t.alphaViews.palette,
                text: t.alphaViews.text,
            };
            const o = e.createElement("div");
            o.classList.add(dr("a"));
            const h = e.createElement("div");
            h.classList.add(dr("ap")),
                h.appendChild(this.alphaViews_.palette.element),
                o.appendChild(h);
            const l = e.createElement("div");
            l.classList.add(dr("at")),
                l.appendChild(this.alphaViews_.text.element),
                o.appendChild(l),
                this.element.appendChild(o);
        }
    }
    get allFocusableElements() {
        const e = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textsView_.modeSelectElement,
            ...this.textsView_.inputViews.map((t) => t.inputElement),
        ];
        return (
            this.alphaViews_ &&
                e.push(
                    this.alphaViews_.palette.element,
                    this.alphaViews_.text.inputElement
                ),
            e
        );
    }
};
function NF(s) {
    return s === "int" ? "int" : s === "float" ? "float" : void 0;
}
function p_(s) {
    return yn(s, (e) => ({
        color: e.optional.object({
            alpha: e.optional.boolean,
            type: e.optional.custom(NF),
        }),
        expanded: e.optional.boolean,
        picker: e.optional.custom(sA),
        readonly: e.optional.constant(!1),
    }));
}
function Va(s) {
    return s ? 0.1 : 1;
}
function lA(s) {
    var e;
    return (e = s.color) === null || e === void 0 ? void 0 : e.type;
}
let m_ = class {
    constructor(e, t) {
        (this.type = "float"),
            (this.mode = t),
            (this.comps_ = rA(e, t, this.type));
    }
    getComponents(e) {
        return Dd(
            aA(
                Pi(this.comps_),
                { mode: this.mode, type: this.type },
                { mode: e ?? this.mode, type: this.type }
            ),
            this.comps_[3]
        );
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return { r: e[0], g: e[1], b: e[2], a: e[3] };
    }
};
const VF = { int: (s, e) => new We(s, e), float: (s, e) => new m_(s, e) };
function g_(s, e, t) {
    return VF[t](s, e);
}
function UF(s) {
    return s.type === "float";
}
function zF(s) {
    return s.type === "int";
}
function YF(s) {
    const e = s.getComponents(),
        t = ll(s.mode, "int");
    return new We(
        [
            Math.round(je(e[0], 0, 1, 0, t[0])),
            Math.round(je(e[1], 0, 1, 0, t[1])),
            Math.round(je(e[2], 0, 1, 0, t[2])),
            e[3],
        ],
        s.mode
    );
}
function GF(s) {
    const e = s.getComponents(),
        t = ll(s.mode, "int");
    return new m_(
        [
            je(e[0], 0, t[0], 0, 1),
            je(e[1], 0, t[1], 0, 1),
            je(e[2], 0, t[2], 0, 1),
            e[3],
        ],
        s.mode
    );
}
function kn(s, e) {
    if (s.type === e) return s;
    if (zF(s) && e === "float") return GF(s);
    if (UF(s) && e === "int") return YF(s);
    throw Na.shouldNeverHappen();
}
function jF(s, e) {
    return (
        s.alpha === e.alpha &&
        s.mode === e.mode &&
        s.notation === e.notation &&
        s.type === e.type
    );
}
function Ps(s, e) {
    const t = s.match(/^(.+)%$/);
    return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(s), e);
}
const WF = {
    deg: (s) => s,
    grad: (s) => (s * 360) / 400,
    rad: (s) => (s * 360) / (2 * Math.PI),
    turn: (s) => s * 360,
};
function hA(s) {
    const e = s.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
    if (!e) return parseFloat(s);
    const t = parseFloat(e[1]),
        n = e[2];
    return WF[n](t);
}
function cA(s) {
    const e = s.match(
        /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [Ps(e[1], 255), Ps(e[2], 255), Ps(e[3], 255)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function XF(s) {
    const e = cA(s);
    return e ? new We(e, "rgb") : null;
}
function uA(s) {
    const e = s.match(
        /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [Ps(e[1], 255), Ps(e[2], 255), Ps(e[3], 255), Ps(e[4], 1)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function qF(s) {
    const e = uA(s);
    return e ? new We(e, "rgb") : null;
}
function dA(s) {
    const e = s.match(
        /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [hA(e[1]), Ps(e[2], 100), Ps(e[3], 100)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function HF(s) {
    const e = dA(s);
    return e ? new We(e, "hsl") : null;
}
function fA(s) {
    const e = s.match(
        /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [hA(e[1]), Ps(e[2], 100), Ps(e[3], 100), Ps(e[4], 1)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function KF(s) {
    const e = fA(s);
    return e ? new We(e, "hsl") : null;
}
function pA(s) {
    const e = s.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (e)
        return [
            parseInt(e[1] + e[1], 16),
            parseInt(e[2] + e[2], 16),
            parseInt(e[3] + e[3], 16),
        ];
    const t = s.match(
        /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
    );
    return t
        ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)]
        : null;
}
function ZF(s) {
    const e = pA(s);
    return e ? new We(e, "rgb") : null;
}
function mA(s) {
    const e = s.match(
        /^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/
    );
    if (e)
        return [
            parseInt(e[1] + e[1], 16),
            parseInt(e[2] + e[2], 16),
            parseInt(e[3] + e[3], 16),
            je(parseInt(e[4] + e[4], 16), 0, 255, 0, 1),
        ];
    const t = s.match(
        /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
    );
    return t
        ? [
              parseInt(t[1], 16),
              parseInt(t[2], 16),
              parseInt(t[3], 16),
              je(parseInt(t[4], 16), 0, 255, 0, 1),
          ]
        : null;
}
function QF(s) {
    const e = mA(s);
    return e ? new We(e, "rgb") : null;
}
function gA(s) {
    const e = s.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
    );
    if (!e) return null;
    const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function JF(s) {
    return (e) => {
        const t = gA(e);
        return t ? g_(t, "rgb", s) : null;
    };
}
function _A(s) {
    const e = s.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
    );
    if (!e) return null;
    const t = [
        parseFloat(e[1]),
        parseFloat(e[2]),
        parseFloat(e[3]),
        parseFloat(e[4]),
    ];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function e$(s) {
    return (e) => {
        const t = _A(e);
        return t ? g_(t, "rgb", s) : null;
    };
}
const t$ = [
    { parser: pA, result: { alpha: !1, mode: "rgb", notation: "hex" } },
    { parser: mA, result: { alpha: !0, mode: "rgb", notation: "hex" } },
    { parser: cA, result: { alpha: !1, mode: "rgb", notation: "func" } },
    { parser: uA, result: { alpha: !0, mode: "rgb", notation: "func" } },
    { parser: dA, result: { alpha: !1, mode: "hsl", notation: "func" } },
    { parser: fA, result: { alpha: !0, mode: "hsl", notation: "func" } },
    { parser: gA, result: { alpha: !1, mode: "rgb", notation: "object" } },
    { parser: _A, result: { alpha: !0, mode: "rgb", notation: "object" } },
];
function n$(s) {
    return t$.reduce(
        (e, { parser: t, result: n }) => e || (t(s) ? n : null),
        null
    );
}
function s$(s, e = "int") {
    const t = n$(s);
    return t
        ? t.notation === "hex" && e !== "float"
            ? Object.assign(Object.assign({}, t), { type: "int" })
            : t.notation === "func"
            ? Object.assign(Object.assign({}, t), { type: e })
            : null
        : null;
}
function gc(s) {
    const e = [ZF, QF, XF, qF, HF, KF];
    e.push(JF("int"), e$("int"));
    const t = vF(e);
    return (n) => {
        const i = t(n);
        return i ? kn(i, s) : null;
    };
}
function i$(s) {
    const e = gc("int");
    if (typeof s != "string") return We.black();
    const t = e(s);
    return t ?? We.black();
}
function vA(s) {
    const e = Yt(Math.floor(s), 0, 255).toString(16);
    return e.length === 1 ? `0${e}` : e;
}
function __(s, e = "#") {
    const t = Pi(s.getComponents("rgb")).map(vA).join("");
    return `${e}${t}`;
}
function v_(s, e = "#") {
    const t = s.getComponents("rgb"),
        n = [t[0], t[1], t[2], t[3] * 255].map(vA).join("");
    return `${e}${n}`;
}
function bA(s) {
    const e = Wn(0),
        t = kn(s, "int");
    return `rgb(${Pi(t.getComponents("rgb"))
        .map((i) => e(i))
        .join(", ")})`;
}
function ou(s) {
    const e = Wn(2),
        t = Wn(0);
    return `rgba(${kn(s, "int")
        .getComponents("rgb")
        .map((r, a) => (a === 3 ? e : t)(r))
        .join(", ")})`;
}
function r$(s) {
    const e = [Wn(0), Zu, Zu],
        t = kn(s, "int");
    return `hsl(${Pi(t.getComponents("hsl"))
        .map((i, r) => e[r](i))
        .join(", ")})`;
}
function a$(s) {
    const e = [Wn(0), Zu, Zu, Wn(2)];
    return `hsla(${kn(s, "int")
        .getComponents("hsl")
        .map((i, r) => e[r](i))
        .join(", ")})`;
}
function yA(s, e) {
    const t = Wn(e === "float" ? 2 : 0),
        n = ["r", "g", "b"],
        i = kn(s, e);
    return `{${Pi(i.getComponents("rgb"))
        .map((a, o) => `${n[o]}: ${t(a)}`)
        .join(", ")}}`;
}
function o$(s) {
    return (e) => yA(e, s);
}
function wA(s, e) {
    const t = Wn(2),
        n = Wn(e === "float" ? 2 : 0),
        i = ["r", "g", "b", "a"];
    return `{${kn(s, e)
        .getComponents("rgb")
        .map((o, h) => {
            const l = h === 3 ? t : n;
            return `${i[h]}: ${l(o)}`;
        })
        .join(", ")}}`;
}
function l$(s) {
    return (e) => wA(e, s);
}
const h$ = [
    {
        format: { alpha: !1, mode: "rgb", notation: "hex", type: "int" },
        stringifier: __,
    },
    {
        format: { alpha: !0, mode: "rgb", notation: "hex", type: "int" },
        stringifier: v_,
    },
    {
        format: { alpha: !1, mode: "rgb", notation: "func", type: "int" },
        stringifier: bA,
    },
    {
        format: { alpha: !0, mode: "rgb", notation: "func", type: "int" },
        stringifier: ou,
    },
    {
        format: { alpha: !1, mode: "hsl", notation: "func", type: "int" },
        stringifier: r$,
    },
    {
        format: { alpha: !0, mode: "hsl", notation: "func", type: "int" },
        stringifier: a$,
    },
    ...["int", "float"].reduce(
        (s, e) => [
            ...s,
            {
                format: { alpha: !1, mode: "rgb", notation: "object", type: e },
                stringifier: o$(e),
            },
            {
                format: { alpha: !0, mode: "rgb", notation: "object", type: e },
                stringifier: l$(e),
            },
        ],
        []
    ),
];
function xA(s) {
    return h$.reduce(
        (e, t) => e || (jF(t.format, s) ? t.stringifier : null),
        null
    );
}
const Yl = Ue("apl");
let c$ = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.value = t.value),
                this.value.emitter.on("change", this.onValueChange_),
                (this.element = e.createElement("div")),
                this.element.classList.add(Yl()),
                t.viewProps.bindClassModifiers(this.element),
                t.viewProps.bindTabIndex(this.element);
            const n = e.createElement("div");
            n.classList.add(Yl("b")), this.element.appendChild(n);
            const i = e.createElement("div");
            i.classList.add(Yl("c")), n.appendChild(i), (this.colorElem_ = i);
            const r = e.createElement("div");
            r.classList.add(Yl("m")),
                this.element.appendChild(r),
                (this.markerElem_ = r);
            const a = e.createElement("div");
            a.classList.add(Yl("p")),
                this.markerElem_.appendChild(a),
                (this.previewElem_ = a),
                this.update_();
        }
        update_() {
            const e = this.value.rawValue,
                t = e.getComponents("rgb"),
                n = new We([t[0], t[1], t[2], 0], "rgb"),
                i = new We([t[0], t[1], t[2], 255], "rgb"),
                r = ["to right", ou(n), ou(i)];
            (this.colorElem_.style.background = `linear-gradient(${r.join(
                ","
            )})`),
                (this.previewElem_.style.backgroundColor = ou(e));
            const a = je(t[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${a}%`;
        }
        onValueChange_() {
            this.update_();
        }
    },
    u$ = class {
        constructor(e, t) {
            (this.onKeyDown_ = this.onKeyDown_.bind(this)),
                (this.onKeyUp_ = this.onKeyUp_.bind(this)),
                (this.onPointerDown_ = this.onPointerDown_.bind(this)),
                (this.onPointerMove_ = this.onPointerMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new c$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.ptHandler_ = new Za(this.view.element)),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(e, t) {
            if (!e.point) return;
            const n = e.point.x / e.bounds.width,
                i = this.value.rawValue,
                [r, a, o] = i.getComponents("hsv");
            this.value.setRawValue(new We([r, a, o, n], "hsv"), t);
        }
        onPointerDown_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerMove_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerUp_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
        }
        onKeyDown_(e) {
            const t = Nn(Va(!0), ar(e));
            if (t === 0) return;
            const n = this.value.rawValue,
                [i, r, a, o] = n.getComponents("hsv");
            this.value.setRawValue(new We([i, r, a, o + t], "hsv"), {
                forceEmit: !1,
                last: !1,
            });
        }
        onKeyUp_(e) {
            Nn(Va(!0), ar(e)) !== 0 &&
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
    };
const co = Ue("coltxt");
function d$(s) {
    const e = s.createElement("select"),
        t = [
            { text: "RGB", value: "rgb" },
            { text: "HSL", value: "hsl" },
            { text: "HSV", value: "hsv" },
            { text: "HEX", value: "hex" },
        ];
    return (
        e.appendChild(
            t.reduce((n, i) => {
                const r = s.createElement("option");
                return (
                    (r.textContent = i.text),
                    (r.value = i.value),
                    n.appendChild(r),
                    n
                );
            }, s.createDocumentFragment())
        ),
        e
    );
}
let f$ = class {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(co()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(co("m")),
            (this.modeElem_ = d$(e)),
            this.modeElem_.classList.add(co("ms")),
            n.appendChild(this.modeSelectElement),
            t.viewProps.bindDisabled(this.modeElem_);
        const i = e.createElement("div");
        i.classList.add(co("mm")),
            i.appendChild(Bd(e, "dropdown")),
            n.appendChild(i),
            this.element.appendChild(n);
        const r = e.createElement("div");
        r.classList.add(co("w")),
            this.element.appendChild(r),
            (this.inputsElem_ = r),
            (this.inputViews_ = t.inputViews),
            this.applyInputViews_(),
            er(t.mode, (a) => {
                this.modeElem_.value = a;
            });
    }
    get modeSelectElement() {
        return this.modeElem_;
    }
    get inputViews() {
        return this.inputViews_;
    }
    set inputViews(e) {
        (this.inputViews_ = e), this.applyInputViews_();
    }
    applyInputViews_() {
        Y2(this.inputsElem_);
        const e = this.element.ownerDocument;
        this.inputViews_.forEach((t) => {
            const n = e.createElement("div");
            n.classList.add(co("c")),
                n.appendChild(t.element),
                this.inputsElem_.appendChild(n);
        });
    }
};
function p$(s) {
    return Wn(s === "float" ? 2 : 0);
}
function m$(s, e, t) {
    const n = ll(s, e)[t];
    return new Ld({ min: 0, max: n });
}
function g$(s, e, t) {
    return new pc(s, {
        arrayPosition: t === 0 ? "fst" : t === 2 ? "lst" : "mid",
        parser: e.parser,
        props: He.fromObject({
            formatter: p$(e.colorType),
            keyScale: Va(!1),
            pointerScale: e.colorType === "float" ? 0.01 : 1,
        }),
        value: Qt(0, { constraint: m$(e.colorMode, e.colorType, t) }),
        viewProps: e.viewProps,
    });
}
function _$(s, e) {
    const t = {
        colorMode: e.colorMode,
        colorType: e.colorType,
        parser: Xr,
        viewProps: e.viewProps,
    };
    return [0, 1, 2].map((n) => {
        const i = g$(s, t, n);
        return (
            wl({
                primary: e.value,
                secondary: i.value,
                forward(r) {
                    return kn(r, e.colorType).getComponents(e.colorMode)[n];
                },
                backward(r, a) {
                    const o = e.colorMode,
                        l = kn(r, e.colorType).getComponents(o);
                    l[n] = a;
                    const u = g_(Dd(Pi(l), l[3]), o, e.colorType);
                    return kn(u, "int");
                },
            }),
            i
        );
    });
}
function v$(s, e) {
    const t = new f_(s, {
        parser: gc("int"),
        props: He.fromObject({ formatter: __ }),
        value: Qt(We.black()),
        viewProps: e.viewProps,
    });
    return (
        wl({
            primary: e.value,
            secondary: t.value,
            forward: (n) => new We(Pi(n.getComponents()), n.mode),
            backward: (n, i) =>
                new We(
                    Dd(Pi(i.getComponents(n.mode)), n.getComponents()[3]),
                    n.mode
                ),
        }),
        [t]
    );
}
function b$(s) {
    return s !== "hex";
}
let y$ = class {
    constructor(e, t) {
        (this.onModeSelectChange_ = this.onModeSelectChange_.bind(this)),
            (this.colorType_ = t.colorType),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.colorMode = Qt(this.value.rawValue.mode)),
            (this.ccs_ = this.createComponentControllers_(e)),
            (this.view = new f$(e, {
                mode: this.colorMode,
                inputViews: [
                    this.ccs_[0].view,
                    this.ccs_[1].view,
                    this.ccs_[2].view,
                ],
                viewProps: this.viewProps,
            })),
            this.view.modeSelectElement.addEventListener(
                "change",
                this.onModeSelectChange_
            );
    }
    createComponentControllers_(e) {
        const t = this.colorMode.rawValue;
        return b$(t)
            ? _$(e, {
                  colorMode: t,
                  colorType: this.colorType_,
                  value: this.value,
                  viewProps: this.viewProps,
              })
            : v$(e, { value: this.value, viewProps: this.viewProps });
    }
    onModeSelectChange_(e) {
        const t = e.currentTarget;
        (this.colorMode.rawValue = t.value),
            (this.ccs_ = this.createComponentControllers_(
                this.view.element.ownerDocument
            )),
            (this.view.inputViews = this.ccs_.map((n) => n.view));
    }
};
const up = Ue("hpl");
let w$ = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.value = t.value),
                this.value.emitter.on("change", this.onValueChange_),
                (this.element = e.createElement("div")),
                this.element.classList.add(up()),
                t.viewProps.bindClassModifiers(this.element),
                t.viewProps.bindTabIndex(this.element);
            const n = e.createElement("div");
            n.classList.add(up("c")), this.element.appendChild(n);
            const i = e.createElement("div");
            i.classList.add(up("m")),
                this.element.appendChild(i),
                (this.markerElem_ = i),
                this.update_();
        }
        update_() {
            const e = this.value.rawValue,
                [t] = e.getComponents("hsv");
            this.markerElem_.style.backgroundColor = bA(
                new We([t, 100, 100], "hsv")
            );
            const n = je(t, 0, 360, 0, 100);
            this.markerElem_.style.left = `${n}%`;
        }
        onValueChange_() {
            this.update_();
        }
    },
    x$ = class {
        constructor(e, t) {
            (this.onKeyDown_ = this.onKeyDown_.bind(this)),
                (this.onKeyUp_ = this.onKeyUp_.bind(this)),
                (this.onPointerDown_ = this.onPointerDown_.bind(this)),
                (this.onPointerMove_ = this.onPointerMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new w$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.ptHandler_ = new Za(this.view.element)),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(e, t) {
            if (!e.point) return;
            const n = je(
                    Yt(e.point.x, 0, e.bounds.width),
                    0,
                    e.bounds.width,
                    0,
                    360
                ),
                i = this.value.rawValue,
                [, r, a, o] = i.getComponents("hsv");
            this.value.setRawValue(new We([n, r, a, o], "hsv"), t);
        }
        onPointerDown_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerMove_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerUp_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
        }
        onKeyDown_(e) {
            const t = Nn(Va(!1), ar(e));
            if (t === 0) return;
            const n = this.value.rawValue,
                [i, r, a, o] = n.getComponents("hsv");
            this.value.setRawValue(new We([i + t, r, a, o], "hsv"), {
                forceEmit: !1,
                last: !1,
            });
        }
        onKeyUp_(e) {
            Nn(Va(!1), ar(e)) !== 0 &&
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
    };
const dp = Ue("svp"),
    Zb = 64;
let C$ = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                (this.value = t.value),
                this.value.emitter.on("change", this.onValueChange_),
                (this.element = e.createElement("div")),
                this.element.classList.add(dp()),
                t.viewProps.bindClassModifiers(this.element),
                t.viewProps.bindTabIndex(this.element);
            const n = e.createElement("canvas");
            (n.height = Zb),
                (n.width = Zb),
                n.classList.add(dp("c")),
                this.element.appendChild(n),
                (this.canvasElement = n);
            const i = e.createElement("div");
            i.classList.add(dp("m")),
                this.element.appendChild(i),
                (this.markerElem_ = i),
                this.update_();
        }
        update_() {
            const e = O6(this.canvasElement);
            if (!e) return;
            const n = this.value.rawValue.getComponents("hsv"),
                i = this.canvasElement.width,
                r = this.canvasElement.height,
                a = e.getImageData(0, 0, i, r),
                o = a.data;
            for (let u = 0; u < r; u++)
                for (let c = 0; c < i; c++) {
                    const d = je(c, 0, i, 0, 100),
                        f = je(u, 0, r, 100, 0),
                        p = iA(n[0], d, f),
                        m = (u * i + c) * 4;
                    (o[m] = p[0]),
                        (o[m + 1] = p[1]),
                        (o[m + 2] = p[2]),
                        (o[m + 3] = 255);
                }
            e.putImageData(a, 0, 0);
            const h = je(n[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${h}%`;
            const l = je(n[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${l}%`;
        }
        onValueChange_() {
            this.update_();
        }
    },
    A$ = class {
        constructor(e, t) {
            (this.onKeyDown_ = this.onKeyDown_.bind(this)),
                (this.onKeyUp_ = this.onKeyUp_.bind(this)),
                (this.onPointerDown_ = this.onPointerDown_.bind(this)),
                (this.onPointerMove_ = this.onPointerMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new C$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.ptHandler_ = new Za(this.view.element)),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_);
        }
        handlePointerEvent_(e, t) {
            if (!e.point) return;
            const n = je(e.point.x, 0, e.bounds.width, 0, 100),
                i = je(e.point.y, 0, e.bounds.height, 100, 0),
                [r, , , a] = this.value.rawValue.getComponents("hsv");
            this.value.setRawValue(new We([r, n, i, a], "hsv"), t);
        }
        onPointerDown_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerMove_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerUp_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
        }
        onKeyDown_(e) {
            tA(e.key) && e.preventDefault();
            const [t, n, i, r] = this.value.rawValue.getComponents("hsv"),
                a = Va(!1),
                o = Nn(a, ar(e)),
                h = Nn(a, Hh(e));
            (o === 0 && h === 0) ||
                this.value.setRawValue(new We([t, n + o, i + h, r], "hsv"), {
                    forceEmit: !1,
                    last: !1,
                });
        }
        onKeyUp_(e) {
            const t = Va(!1),
                n = Nn(t, ar(e)),
                i = Nn(t, Hh(e));
            (n === 0 && i === 0) ||
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
    },
    S$ = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.hPaletteC_ = new x$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.svPaletteC_ = new A$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.alphaIcs_ = t.supportsAlpha
                    ? {
                          palette: new u$(e, {
                              value: this.value,
                              viewProps: this.viewProps,
                          }),
                          text: new pc(e, {
                              parser: Xr,
                              props: He.fromObject({
                                  pointerScale: 0.01,
                                  keyScale: 0.1,
                                  formatter: Wn(2),
                              }),
                              value: Qt(0, {
                                  constraint: new Ld({ min: 0, max: 1 }),
                              }),
                              viewProps: this.viewProps,
                          }),
                      }
                    : null),
                this.alphaIcs_ &&
                    wl({
                        primary: this.value,
                        secondary: this.alphaIcs_.text.value,
                        forward: (n) => n.getComponents()[3],
                        backward: (n, i) => {
                            const r = n.getComponents();
                            return (r[3] = i), new We(r, n.mode);
                        },
                    }),
                (this.textsC_ = new y$(e, {
                    colorType: t.colorType,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.view = new DF(e, {
                    alphaViews: this.alphaIcs_
                        ? {
                              palette: this.alphaIcs_.palette.view,
                              text: this.alphaIcs_.text.view,
                          }
                        : null,
                    hPaletteView: this.hPaletteC_.view,
                    supportsAlpha: t.supportsAlpha,
                    svPaletteView: this.svPaletteC_.view,
                    textsView: this.textsC_.view,
                    viewProps: this.viewProps,
                }));
        }
        get textsController() {
            return this.textsC_;
        }
    };
const fp = Ue("colsw");
let E$ = class {
        constructor(e, t) {
            (this.onValueChange_ = this.onValueChange_.bind(this)),
                t.value.emitter.on("change", this.onValueChange_),
                (this.value = t.value),
                (this.element = e.createElement("div")),
                this.element.classList.add(fp()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("div");
            n.classList.add(fp("sw")),
                this.element.appendChild(n),
                (this.swatchElem_ = n);
            const i = e.createElement("button");
            i.classList.add(fp("b")),
                t.viewProps.bindDisabled(i),
                this.element.appendChild(i),
                (this.buttonElement = i),
                this.update_();
        }
        update_() {
            const e = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = v_(e);
        }
        onValueChange_() {
            this.update_();
        }
    },
    P$ = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new E$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                }));
        }
    },
    b_ = class {
        constructor(e, t) {
            (this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
                (this.onButtonClick_ = this.onButtonClick_.bind(this)),
                (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
                (this.onPopupChildKeydown_ =
                    this.onPopupChildKeydown_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.foldable_ = l_.create(t.expanded)),
                (this.swatchC_ = new P$(e, {
                    value: this.value,
                    viewProps: this.viewProps,
                }));
            const n = this.swatchC_.view.buttonElement;
            n.addEventListener("blur", this.onButtonBlur_),
                n.addEventListener("click", this.onButtonClick_),
                (this.textC_ = new f_(e, {
                    parser: t.parser,
                    props: He.fromObject({ formatter: t.formatter }),
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.view = new MF(e, {
                    foldable: this.foldable_,
                    pickerLayout: t.pickerLayout,
                })),
                this.view.swatchElement.appendChild(this.swatchC_.view.element),
                this.view.textElement.appendChild(this.textC_.view.element),
                (this.popC_ =
                    t.pickerLayout === "popup"
                        ? new Q2(e, { viewProps: this.viewProps })
                        : null);
            const i = new S$(e, {
                colorType: t.colorType,
                supportsAlpha: t.supportsAlpha,
                value: this.value,
                viewProps: this.viewProps,
            });
            i.view.allFocusableElements.forEach((r) => {
                r.addEventListener("blur", this.onPopupChildBlur_),
                    r.addEventListener("keydown", this.onPopupChildKeydown_);
            }),
                (this.pickerC_ = i),
                this.popC_
                    ? (this.view.element.appendChild(this.popC_.view.element),
                      this.popC_.view.element.appendChild(i.view.element),
                      wl({
                          primary: this.foldable_.value("expanded"),
                          secondary: this.popC_.shows,
                          forward: (r) => r,
                          backward: (r, a) => a,
                      }))
                    : this.view.pickerElement &&
                      (this.view.pickerElement.appendChild(
                          this.pickerC_.view.element
                      ),
                      h_(this.foldable_, this.view.pickerElement));
        }
        get textController() {
            return this.textC_;
        }
        onButtonBlur_(e) {
            if (!this.popC_) return;
            const t = this.view.element,
                n = e.relatedTarget;
            (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
        }
        onButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                this.foldable_.get("expanded") &&
                    this.pickerC_.view.allFocusableElements[0].focus();
        }
        onPopupChildBlur_(e) {
            if (!this.popC_) return;
            const t = this.popC_.view.element,
                n = G2(e);
            (n && t.contains(n)) ||
                (n &&
                    n === this.swatchC_.view.buttonElement &&
                    !n_(t.ownerDocument)) ||
                (this.popC_.shows.rawValue = !1);
        }
        onPopupChildKeydown_(e) {
            this.popC_
                ? e.key === "Escape" && (this.popC_.shows.rawValue = !1)
                : this.view.pickerElement &&
                  e.key === "Escape" &&
                  this.swatchC_.view.buttonElement.focus();
        }
    };
function k$(s) {
    return Pi(s.getComponents("rgb")).reduce(
        (e, t) => (e << 8) | (Math.floor(t) & 255),
        0
    );
}
function T$(s) {
    return (
        s.getComponents("rgb").reduce((e, t, n) => {
            const i = Math.floor(n === 3 ? t * 255 : t) & 255;
            return (e << 8) | i;
        }, 0) >>> 0
    );
}
function M$(s) {
    return new We([(s >> 16) & 255, (s >> 8) & 255, s & 255], "rgb");
}
function I$(s) {
    return new We(
        [
            (s >> 24) & 255,
            (s >> 16) & 255,
            (s >> 8) & 255,
            je(s & 255, 0, 255, 0, 1),
        ],
        "rgb"
    );
}
function R$(s) {
    return typeof s != "number" ? We.black() : M$(s);
}
function L$(s) {
    return typeof s != "number" ? We.black() : I$(s);
}
function lu(s, e) {
    return typeof s != "object" || Ct(s)
        ? !1
        : e in s && typeof s[e] == "number";
}
function CA(s) {
    return lu(s, "r") && lu(s, "g") && lu(s, "b");
}
function AA(s) {
    return CA(s) && lu(s, "a");
}
function SA(s) {
    return CA(s);
}
function y_(s, e) {
    if (s.mode !== e.mode || s.type !== e.type) return !1;
    const t = s.getComponents(),
        n = e.getComponents();
    for (let i = 0; i < t.length; i++) if (t[i] !== n[i]) return !1;
    return !0;
}
function Qb(s) {
    return "a" in s ? [s.r, s.g, s.b, s.a] : [s.r, s.g, s.b];
}
function O$(s) {
    const e = xA(s);
    return e
        ? (t, n) => {
              mc(t, e(n));
          }
        : null;
}
function B$(s) {
    const e = s ? T$ : k$;
    return (t, n) => {
        mc(t, e(n));
    };
}
function F$(s, e, t) {
    const i = kn(e, t).toRgbaObject();
    s.writeProperty("r", i.r),
        s.writeProperty("g", i.g),
        s.writeProperty("b", i.b),
        s.writeProperty("a", i.a);
}
function $$(s, e, t) {
    const i = kn(e, t).toRgbaObject();
    s.writeProperty("r", i.r),
        s.writeProperty("g", i.g),
        s.writeProperty("b", i.b);
}
function D$(s, e) {
    return (t, n) => {
        s ? F$(t, n, e) : $$(t, n, e);
    };
}
function N$(s) {
    var e;
    return !!(
        !((e = s == null ? void 0 : s.color) === null || e === void 0) &&
        e.alpha
    );
}
function V$(s) {
    return s ? (e) => v_(e, "0x") : (e) => __(e, "0x");
}
function U$(s) {
    return "color" in s || s.view === "color";
}
Mn({
    id: "input-color-number",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "number" || !U$(e)) return null;
        const t = p_(e);
        return t
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, t), {
                      supportsAlpha: N$(e),
                  }),
              }
            : null;
    },
    binding: {
        reader: (s) => (s.params.supportsAlpha ? L$ : R$),
        equals: y_,
        writer: (s) => B$(s.params.supportsAlpha),
    },
    controller: (s) => {
        var e, t;
        return new b_(s.document, {
            colorType: "int",
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: V$(s.params.supportsAlpha),
            parser: gc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: s.params.supportsAlpha,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
function z$(s, e) {
    if (!SA(s)) return kn(We.black(), e);
    if (e === "int") {
        const t = Qb(s);
        return new We(t, "rgb");
    }
    if (e === "float") {
        const t = Qb(s);
        return new m_(t, "rgb");
    }
    return kn(We.black(), "int");
}
function Y$(s) {
    return AA(s);
}
function G$(s) {
    return (e) => {
        const t = z$(e, s);
        return kn(t, "int");
    };
}
function j$(s, e) {
    return (t) => (s ? wA(t, e) : yA(t, e));
}
Mn({
    id: "input-color-object",
    type: "input",
    accept: (s, e) => {
        var t;
        if (!SA(s)) return null;
        const n = p_(e);
        return n
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, n), {
                      colorType:
                          (t = lA(e)) !== null && t !== void 0 ? t : "int",
                  }),
              }
            : null;
    },
    binding: {
        reader: (s) => G$(s.params.colorType),
        equals: y_,
        writer: (s) => D$(Y$(s.initialValue), s.params.colorType),
    },
    controller: (s) => {
        var e, t;
        const n = AA(s.initialValue);
        return new b_(s.document, {
            colorType: s.params.colorType,
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: j$(n, s.params.colorType),
            parser: gc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: n,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
Mn({
    id: "input-color-string",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "string" || e.view === "text") return null;
        const t = s$(s, lA(e));
        if (!t) return null;
        const n = xA(t);
        if (!n) return null;
        const i = p_(e);
        return i
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, i), {
                      format: t,
                      stringifier: n,
                  }),
              }
            : null;
    },
    binding: {
        reader: () => i$,
        equals: y_,
        writer: (s) => {
            const e = O$(s.params.format);
            if (!e) throw Na.notBindable();
            return e;
        },
    },
    controller: (s) => {
        var e, t;
        return new b_(s.document, {
            colorType: s.params.format.type,
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: s.params.stringifier,
            parser: gc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: s.params.format.alpha,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
let w_ = class {
    constructor(e) {
        (this.components = e.components), (this.asm_ = e.assembly);
    }
    constrain(e) {
        const t = this.asm_.toComponents(e).map((n, i) => {
            var r, a;
            return (a =
                (r = this.components[i]) === null || r === void 0
                    ? void 0
                    : r.constrain(n)) !== null && a !== void 0
                ? a
                : n;
        });
        return this.asm_.fromComponents(t);
    }
};
const Jb = Ue("pndtxt");
let W$ = class {
    constructor(e, t) {
        (this.textViews = t.textViews),
            (this.element = e.createElement("div")),
            this.element.classList.add(Jb()),
            this.textViews.forEach((n) => {
                const i = e.createElement("div");
                i.classList.add(Jb("a")),
                    i.appendChild(n.element),
                    this.element.appendChild(i);
            });
    }
};
function X$(s, e, t) {
    return new pc(s, {
        arrayPosition:
            t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
        parser: e.parser,
        props: e.axes[t].textProps,
        value: Qt(0, { constraint: e.axes[t].constraint }),
        viewProps: e.viewProps,
    });
}
let x_ = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.acs_ = t.axes.map((n, i) => X$(e, t, i))),
                this.acs_.forEach((n, i) => {
                    wl({
                        primary: this.value,
                        secondary: n.value,
                        forward: (r) => t.assembly.toComponents(r)[i],
                        backward: (r, a) => {
                            const o = t.assembly.toComponents(r);
                            return (o[i] = a), t.assembly.fromComponents(o);
                        },
                    });
                }),
                (this.view = new W$(e, {
                    textViews: this.acs_.map((n) => n.view),
                }));
        }
        get textControllers() {
            return this.acs_;
        }
    },
    q$ = class extends t_ {
        get max() {
            return this.controller.valueController.sliderController.props.get(
                "max"
            );
        }
        set max(e) {
            this.controller.valueController.sliderController.props.set(
                "max",
                e
            );
        }
        get min() {
            return this.controller.valueController.sliderController.props.get(
                "min"
            );
        }
        set min(e) {
            this.controller.valueController.sliderController.props.set(
                "min",
                e
            );
        }
    };
function H$(s, e) {
    const t = [],
        n = $2(s, e);
    n && t.push(n);
    const i = D2(s);
    i && t.push(i);
    const r = d_(s.options);
    return r && t.push(r), new fc(t);
}
Mn({
    id: "input-number",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "number") return null;
        const t = yn(e, (n) =>
            Object.assign(Object.assign({}, V2(n)), {
                options: n.optional.custom($d),
                readonly: n.optional.constant(!1),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => O2,
        constraint: (s) => H$(s.params, s.initialValue),
        writer: (s) => mc,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = t && Ku(t, Fd);
        if (n)
            return new ol(s.document, {
                props: new He({ options: n.values.value("options") }),
                value: e,
                viewProps: s.viewProps,
            });
        const i = N2(s.params, e.rawValue),
            r = t && Ku(t, Ld);
        return r
            ? new Hb(
                  s.document,
                  Object.assign(
                      Object.assign(
                          {},
                          SF(
                              Object.assign(Object.assign({}, i), {
                                  keyScale: Qt(i.keyScale),
                                  max: r.values.value("max"),
                                  min: r.values.value("min"),
                              })
                          )
                      ),
                      { parser: Xr, value: e, viewProps: s.viewProps }
                  )
              )
            : new pc(s.document, {
                  parser: Xr,
                  props: He.fromObject(i),
                  value: e,
                  viewProps: s.viewProps,
              });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "number"
            ? null
            : s.controller.valueController instanceof Hb
            ? new q$(s.controller)
            : s.controller.valueController instanceof ol
            ? new u_(s.controller)
            : null;
    },
});
let Nr = class {
    constructor(e = 0, t = 0) {
        (this.x = e), (this.y = t);
    }
    getComponents() {
        return [this.x, this.y];
    }
    static isObject(e) {
        if (Ct(e)) return !1;
        const t = e.x,
            n = e.y;
        return !(typeof t != "number" || typeof n != "number");
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y;
    }
    toObject() {
        return { x: this.x, y: this.y };
    }
};
const EA = {
        toComponents: (s) => s.getComponents(),
        fromComponents: (s) => new Nr(...s),
    },
    uo = Ue("p2d");
let K$ = class {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(uo()),
            t.viewProps.bindClassModifiers(this.element),
            er(t.expanded, yl(this.element, uo(void 0, "expanded")));
        const n = e.createElement("div");
        n.classList.add(uo("h")), this.element.appendChild(n);
        const i = e.createElement("button");
        i.classList.add(uo("b")),
            i.appendChild(Bd(e, "p2dpad")),
            t.viewProps.bindDisabled(i),
            n.appendChild(i),
            (this.buttonElement = i);
        const r = e.createElement("div");
        if (
            (r.classList.add(uo("t")),
            n.appendChild(r),
            (this.textElement = r),
            t.pickerLayout === "inline")
        ) {
            const a = e.createElement("div");
            a.classList.add(uo("p")),
                this.element.appendChild(a),
                (this.pickerElement = a);
        } else this.pickerElement = null;
    }
};
const fr = Ue("p2dp");
let Z$ = class {
    constructor(e, t) {
        (this.onFoldableChange_ = this.onFoldableChange_.bind(this)),
            (this.onPropsChange_ = this.onPropsChange_.bind(this)),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.props_ = t.props),
            this.props_.emitter.on("change", this.onPropsChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(fr()),
            t.layout === "popup" && this.element.classList.add(fr(void 0, "p")),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(fr("p")),
            t.viewProps.bindTabIndex(n),
            this.element.appendChild(n),
            (this.padElement = n);
        const i = e.createElementNS(yi, "svg");
        i.classList.add(fr("g")),
            this.padElement.appendChild(i),
            (this.svgElem_ = i);
        const r = e.createElementNS(yi, "line");
        r.classList.add(fr("ax")),
            r.setAttributeNS(null, "x1", "0"),
            r.setAttributeNS(null, "y1", "50%"),
            r.setAttributeNS(null, "x2", "100%"),
            r.setAttributeNS(null, "y2", "50%"),
            this.svgElem_.appendChild(r);
        const a = e.createElementNS(yi, "line");
        a.classList.add(fr("ax")),
            a.setAttributeNS(null, "x1", "50%"),
            a.setAttributeNS(null, "y1", "0"),
            a.setAttributeNS(null, "x2", "50%"),
            a.setAttributeNS(null, "y2", "100%"),
            this.svgElem_.appendChild(a);
        const o = e.createElementNS(yi, "line");
        o.classList.add(fr("l")),
            o.setAttributeNS(null, "x1", "50%"),
            o.setAttributeNS(null, "y1", "50%"),
            this.svgElem_.appendChild(o),
            (this.lineElem_ = o);
        const h = e.createElement("div");
        h.classList.add(fr("m")),
            this.padElement.appendChild(h),
            (this.markerElem_ = h),
            t.value.emitter.on("change", this.onValueChange_),
            (this.value = t.value),
            this.update_();
    }
    get allFocusableElements() {
        return [this.padElement];
    }
    update_() {
        const [e, t] = this.value.rawValue.getComponents(),
            n = this.props_.get("max"),
            i = je(e, -n, +n, 0, 100),
            r = je(t, -n, +n, 0, 100),
            a = this.props_.get("invertsY") ? 100 - r : r;
        this.lineElem_.setAttributeNS(null, "x2", `${i}%`),
            this.lineElem_.setAttributeNS(null, "y2", `${a}%`),
            (this.markerElem_.style.left = `${i}%`),
            (this.markerElem_.style.top = `${a}%`);
    }
    onValueChange_() {
        this.update_();
    }
    onPropsChange_() {
        this.update_();
    }
    onFoldableChange_() {
        this.update_();
    }
};
function ey(s, e, t) {
    return [Nn(e[0], ar(s)), Nn(e[1], Hh(s)) * (t ? 1 : -1)];
}
let Q$ = class {
        constructor(e, t) {
            (this.onPadKeyDown_ = this.onPadKeyDown_.bind(this)),
                (this.onPadKeyUp_ = this.onPadKeyUp_.bind(this)),
                (this.onPointerDown_ = this.onPointerDown_.bind(this)),
                (this.onPointerMove_ = this.onPointerMove_.bind(this)),
                (this.onPointerUp_ = this.onPointerUp_.bind(this)),
                (this.props = t.props),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new Z$(e, {
                    layout: t.layout,
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.ptHandler_ = new Za(this.view.padElement)),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.padElement.addEventListener(
                    "keydown",
                    this.onPadKeyDown_
                ),
                this.view.padElement.addEventListener(
                    "keyup",
                    this.onPadKeyUp_
                );
        }
        handlePointerEvent_(e, t) {
            if (!e.point) return;
            const n = this.props.get("max"),
                i = je(e.point.x, 0, e.bounds.width, -n, +n),
                r = je(
                    this.props.get("invertsY")
                        ? e.bounds.height - e.point.y
                        : e.point.y,
                    0,
                    e.bounds.height,
                    -n,
                    +n
                );
            this.value.setRawValue(new Nr(i, r), t);
        }
        onPointerDown_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerMove_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
        }
        onPointerUp_(e) {
            this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
        }
        onPadKeyDown_(e) {
            tA(e.key) && e.preventDefault();
            const [t, n] = ey(
                e,
                [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
                this.props.get("invertsY")
            );
            (t === 0 && n === 0) ||
                this.value.setRawValue(
                    new Nr(
                        this.value.rawValue.x + t,
                        this.value.rawValue.y + n
                    ),
                    { forceEmit: !1, last: !1 }
                );
        }
        onPadKeyUp_(e) {
            const [t, n] = ey(
                e,
                [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
                this.props.get("invertsY")
            );
            (t === 0 && n === 0) ||
                this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0,
                });
        }
    },
    J$ = class {
        constructor(e, t) {
            var n, i;
            (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
                (this.onPopupChildKeydown_ =
                    this.onPopupChildKeydown_.bind(this)),
                (this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this)),
                (this.onPadButtonClick_ = this.onPadButtonClick_.bind(this)),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.foldable_ = l_.create(t.expanded)),
                (this.popC_ =
                    t.pickerLayout === "popup"
                        ? new Q2(e, { viewProps: this.viewProps })
                        : null);
            const r = new Q$(e, {
                layout: t.pickerLayout,
                props: new He({
                    invertsY: Qt(t.invertsY),
                    max: Qt(t.max),
                    xKeyScale: t.axes[0].textProps.value("keyScale"),
                    yKeyScale: t.axes[1].textProps.value("keyScale"),
                }),
                value: this.value,
                viewProps: this.viewProps,
            });
            r.view.allFocusableElements.forEach((a) => {
                a.addEventListener("blur", this.onPopupChildBlur_),
                    a.addEventListener("keydown", this.onPopupChildKeydown_);
            }),
                (this.pickerC_ = r),
                (this.textC_ = new x_(e, {
                    assembly: EA,
                    axes: t.axes,
                    parser: t.parser,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                (this.view = new K$(e, {
                    expanded: this.foldable_.value("expanded"),
                    pickerLayout: t.pickerLayout,
                    viewProps: this.viewProps,
                })),
                this.view.textElement.appendChild(this.textC_.view.element),
                (n = this.view.buttonElement) === null ||
                    n === void 0 ||
                    n.addEventListener("blur", this.onPadButtonBlur_),
                (i = this.view.buttonElement) === null ||
                    i === void 0 ||
                    i.addEventListener("click", this.onPadButtonClick_),
                this.popC_
                    ? (this.view.element.appendChild(this.popC_.view.element),
                      this.popC_.view.element.appendChild(
                          this.pickerC_.view.element
                      ),
                      wl({
                          primary: this.foldable_.value("expanded"),
                          secondary: this.popC_.shows,
                          forward: (a) => a,
                          backward: (a, o) => o,
                      }))
                    : this.view.pickerElement &&
                      (this.view.pickerElement.appendChild(
                          this.pickerC_.view.element
                      ),
                      h_(this.foldable_, this.view.pickerElement));
        }
        get textController() {
            return this.textC_;
        }
        onPadButtonBlur_(e) {
            if (!this.popC_) return;
            const t = this.view.element,
                n = e.relatedTarget;
            (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
        }
        onPadButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                this.foldable_.get("expanded") &&
                    this.pickerC_.view.allFocusableElements[0].focus();
        }
        onPopupChildBlur_(e) {
            if (!this.popC_) return;
            const t = this.popC_.view.element,
                n = G2(e);
            (n && t.contains(n)) ||
                (n && n === this.view.buttonElement && !n_(t.ownerDocument)) ||
                (this.popC_.shows.rawValue = !1);
        }
        onPopupChildKeydown_(e) {
            this.popC_
                ? e.key === "Escape" && (this.popC_.shows.rawValue = !1)
                : this.view.pickerElement &&
                  e.key === "Escape" &&
                  this.view.buttonElement.focus();
        }
    };
function eD(s) {
    return Nr.isObject(s) ? new Nr(s.x, s.y) : new Nr();
}
function tD(s, e) {
    s.writeProperty("x", e.x), s.writeProperty("y", e.y);
}
function nD(s, e) {
    return new w_({
        assembly: EA,
        components: [
            qi(Object.assign(Object.assign({}, s), s.x), e.x),
            qi(Object.assign(Object.assign({}, s), s.y), e.y),
        ],
    });
}
function ty(s, e) {
    var t, n;
    if (!Ct(s.min) || !Ct(s.max))
        return Math.max(
            Math.abs((t = s.min) !== null && t !== void 0 ? t : 0),
            Math.abs((n = s.max) !== null && n !== void 0 ? n : 0)
        );
    const i = F2(s);
    return Math.max(Math.abs(i) * 10, Math.abs(e) * 10);
}
function sD(s, e) {
    var t, n;
    const i = ty(Da(s, (t = s.x) !== null && t !== void 0 ? t : {}), e.x),
        r = ty(Da(s, (n = s.y) !== null && n !== void 0 ? n : {}), e.y);
    return Math.max(i, r);
}
function iD(s) {
    if (!("y" in s)) return !1;
    const e = s.y;
    return e && "inverted" in e ? !!e.inverted : !1;
}
Mn({
    id: "input-point2d",
    type: "input",
    accept: (s, e) => {
        if (!Nr.isObject(s)) return null;
        const t = yn(e, (n) =>
            Object.assign(Object.assign({}, Kh(n)), {
                expanded: n.optional.boolean,
                picker: n.optional.custom(sA),
                readonly: n.optional.constant(!1),
                x: n.optional.custom(Or),
                y: n.optional.object(
                    Object.assign(Object.assign({}, Kh(n)), {
                        inverted: n.optional.boolean,
                    })
                ),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: () => eD,
        constraint: (s) => nD(s.params, s.initialValue),
        equals: Nr.equals,
        writer: () => tD,
    },
    controller: (s) => {
        var e, t;
        const n = s.document,
            i = s.value,
            r = s.constraint,
            a = [s.params.x, s.params.y];
        return new J$(n, {
            axes: i.rawValue.getComponents().map((o, h) => {
                var l;
                return Jg({
                    constraint: r.components[h],
                    initialValue: o,
                    params: Da(
                        s.params,
                        (l = a[h]) !== null && l !== void 0 ? l : {}
                    ),
                });
            }),
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            invertsY: iD(s.params),
            max: sD(s.params, i.rawValue),
            parser: Xr,
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            value: i,
            viewProps: s.viewProps,
        });
    },
});
let No = class {
    constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
    }
    getComponents() {
        return [this.x, this.y, this.z];
    }
    static isObject(e) {
        if (Ct(e)) return !1;
        const t = e.x,
            n = e.y,
            i = e.z;
        return !(
            typeof t != "number" ||
            typeof n != "number" ||
            typeof i != "number"
        );
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z;
    }
    toObject() {
        return { x: this.x, y: this.y, z: this.z };
    }
};
const PA = {
    toComponents: (s) => s.getComponents(),
    fromComponents: (s) => new No(...s),
};
function rD(s) {
    return No.isObject(s) ? new No(s.x, s.y, s.z) : new No();
}
function aD(s, e) {
    s.writeProperty("x", e.x),
        s.writeProperty("y", e.y),
        s.writeProperty("z", e.z);
}
function oD(s, e) {
    return new w_({
        assembly: PA,
        components: [
            qi(Object.assign(Object.assign({}, s), s.x), e.x),
            qi(Object.assign(Object.assign({}, s), s.y), e.y),
            qi(Object.assign(Object.assign({}, s), s.z), e.z),
        ],
    });
}
Mn({
    id: "input-point3d",
    type: "input",
    accept: (s, e) => {
        if (!No.isObject(s)) return null;
        const t = yn(e, (n) =>
            Object.assign(Object.assign({}, Kh(n)), {
                readonly: n.optional.constant(!1),
                x: n.optional.custom(Or),
                y: n.optional.custom(Or),
                z: n.optional.custom(Or),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => rD,
        constraint: (s) => oD(s.params, s.initialValue),
        equals: No.equals,
        writer: (s) => aD,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = [s.params.x, s.params.y, s.params.z];
        return new x_(s.document, {
            assembly: PA,
            axes: e.rawValue.getComponents().map((i, r) => {
                var a;
                return Jg({
                    constraint: t.components[r],
                    initialValue: i,
                    params: Da(
                        s.params,
                        (a = n[r]) !== null && a !== void 0 ? a : {}
                    ),
                });
            }),
            parser: Xr,
            value: e,
            viewProps: s.viewProps,
        });
    },
});
let Vo = class {
    constructor(e = 0, t = 0, n = 0, i = 0) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = i);
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w];
    }
    static isObject(e) {
        if (Ct(e)) return !1;
        const t = e.x,
            n = e.y,
            i = e.z,
            r = e.w;
        return !(
            typeof t != "number" ||
            typeof n != "number" ||
            typeof i != "number" ||
            typeof r != "number"
        );
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
    }
    toObject() {
        return { x: this.x, y: this.y, z: this.z, w: this.w };
    }
};
const kA = {
    toComponents: (s) => s.getComponents(),
    fromComponents: (s) => new Vo(...s),
};
function lD(s) {
    return Vo.isObject(s) ? new Vo(s.x, s.y, s.z, s.w) : new Vo();
}
function hD(s, e) {
    s.writeProperty("x", e.x),
        s.writeProperty("y", e.y),
        s.writeProperty("z", e.z),
        s.writeProperty("w", e.w);
}
function cD(s, e) {
    return new w_({
        assembly: kA,
        components: [
            qi(Object.assign(Object.assign({}, s), s.x), e.x),
            qi(Object.assign(Object.assign({}, s), s.y), e.y),
            qi(Object.assign(Object.assign({}, s), s.z), e.z),
            qi(Object.assign(Object.assign({}, s), s.w), e.w),
        ],
    });
}
Mn({
    id: "input-point4d",
    type: "input",
    accept: (s, e) => {
        if (!Vo.isObject(s)) return null;
        const t = yn(e, (n) =>
            Object.assign(Object.assign({}, Kh(n)), {
                readonly: n.optional.constant(!1),
                w: n.optional.custom(Or),
                x: n.optional.custom(Or),
                y: n.optional.custom(Or),
                z: n.optional.custom(Or),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => lD,
        constraint: (s) => cD(s.params, s.initialValue),
        equals: Vo.equals,
        writer: (s) => hD,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = [s.params.x, s.params.y, s.params.z, s.params.w];
        return new x_(s.document, {
            assembly: kA,
            axes: e.rawValue.getComponents().map((i, r) => {
                var a;
                return Jg({
                    constraint: t.components[r],
                    initialValue: i,
                    params: Da(
                        s.params,
                        (a = n[r]) !== null && a !== void 0 ? a : {}
                    ),
                });
            }),
            parser: Xr,
            value: e,
            viewProps: s.viewProps,
        });
    },
});
function uD(s) {
    const e = [],
        t = d_(s.options);
    return t && e.push(t), new fc(e);
}
Mn({
    id: "input-string",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "string") return null;
        const t = yn(e, (n) => ({
            readonly: n.optional.constant(!1),
            options: n.optional.custom($d),
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => eA,
        constraint: (s) => uD(s.params),
        writer: (s) => mc,
    },
    controller: (s) => {
        const e = s.document,
            t = s.value,
            n = s.constraint,
            i = n && Ku(n, Fd);
        return i
            ? new ol(e, {
                  props: new He({ options: i.values.value("options") }),
                  value: t,
                  viewProps: s.viewProps,
              })
            : new f_(e, {
                  parser: (r) => r,
                  props: He.fromObject({ formatter: Rm }),
                  value: t,
                  viewProps: s.viewProps,
              });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "string"
            ? null
            : s.controller.valueController instanceof ol
            ? new u_(s.controller)
            : null;
    },
});
const Nd = { monitor: { defaultRows: 3 } },
    ny = Ue("mll");
let dD = class {
        constructor(e, t) {
            (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
                (this.formatter_ = t.formatter),
                (this.element = e.createElement("div")),
                this.element.classList.add(ny()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("textarea");
            n.classList.add(ny("i")),
                (n.style.height = `calc(var(${nA("containerUnitSize")}) * ${
                    t.rows
                })`),
                (n.readOnly = !0),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.textareaElem_ = n),
                t.value.emitter.on("change", this.onValueUpdate_),
                (this.value = t.value),
                this.update_();
        }
        update_() {
            const e = this.textareaElem_,
                t = e.scrollTop === e.scrollHeight - e.clientHeight,
                n = [];
            this.value.rawValue.forEach((i) => {
                i !== void 0 && n.push(this.formatter_(i));
            }),
                (e.textContent = n.join(`
`)),
                t && (e.scrollTop = e.scrollHeight);
        }
        onValueUpdate_() {
            this.update_();
        }
    },
    C_ = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new dD(e, {
                    formatter: t.formatter,
                    rows: t.rows,
                    value: this.value,
                    viewProps: this.viewProps,
                }));
        }
    };
const sy = Ue("sgl");
let fD = class {
        constructor(e, t) {
            (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
                (this.formatter_ = t.formatter),
                (this.element = e.createElement("div")),
                this.element.classList.add(sy()),
                t.viewProps.bindClassModifiers(this.element);
            const n = e.createElement("input");
            n.classList.add(sy("i")),
                (n.readOnly = !0),
                (n.type = "text"),
                t.viewProps.bindDisabled(n),
                this.element.appendChild(n),
                (this.inputElement = n),
                t.value.emitter.on("change", this.onValueUpdate_),
                (this.value = t.value),
                this.update_();
        }
        update_() {
            const e = this.value.rawValue,
                t = e[e.length - 1];
            this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
        }
        onValueUpdate_() {
            this.update_();
        }
    },
    A_ = class {
        constructor(e, t) {
            (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.view = new fD(e, {
                    formatter: t.formatter,
                    value: this.value,
                    viewProps: this.viewProps,
                }));
        }
    };
Mn({
    id: "monitor-bool",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "boolean") return null;
        const t = yn(e, (n) => ({
            readonly: n.required.constant(!0),
            rows: n.optional.number,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { reader: (s) => J2 },
    controller: (s) => {
        var e;
        return s.value.rawValue.length === 1
            ? new A_(s.document, {
                  formatter: qb,
                  value: s.value,
                  viewProps: s.viewProps,
              })
            : new C_(s.document, {
                  formatter: qb,
                  rows:
                      (e = s.params.rows) !== null && e !== void 0
                          ? e
                          : Nd.monitor.defaultRows,
                  value: s.value,
                  viewProps: s.viewProps,
              });
    },
});
let pD = class extends t_ {
    get max() {
        return this.controller.valueController.props.get("max");
    }
    set max(e) {
        this.controller.valueController.props.set("max", e);
    }
    get min() {
        return this.controller.valueController.props.get("min");
    }
    set min(e) {
        this.controller.valueController.props.set("min", e);
    }
};
const pr = Ue("grl");
let mD = class {
        constructor(e, t) {
            (this.onCursorChange_ = this.onCursorChange_.bind(this)),
                (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
                (this.element = e.createElement("div")),
                this.element.classList.add(pr()),
                t.viewProps.bindClassModifiers(this.element),
                (this.formatter_ = t.formatter),
                (this.props_ = t.props),
                (this.cursor_ = t.cursor),
                this.cursor_.emitter.on("change", this.onCursorChange_);
            const n = e.createElementNS(yi, "svg");
            n.classList.add(pr("g")),
                (n.style.height = `calc(var(${nA("containerUnitSize")}) * ${
                    t.rows
                })`),
                this.element.appendChild(n),
                (this.svgElem_ = n);
            const i = e.createElementNS(yi, "polyline");
            this.svgElem_.appendChild(i), (this.lineElem_ = i);
            const r = e.createElement("div");
            r.classList.add(pr("t"), Ue("tt")()),
                this.element.appendChild(r),
                (this.tooltipElem_ = r),
                t.value.emitter.on("change", this.onValueUpdate_),
                (this.value = t.value),
                this.update_();
        }
        get graphElement() {
            return this.svgElem_;
        }
        update_() {
            const { clientWidth: e, clientHeight: t } = this.element,
                n = this.value.rawValue.length - 1,
                i = this.props_.get("min"),
                r = this.props_.get("max"),
                a = [];
            this.value.rawValue.forEach((c, d) => {
                if (c === void 0) return;
                const f = je(d, 0, n, 0, e),
                    p = je(c, i, r, t, 0);
                a.push([f, p].join(","));
            }),
                this.lineElem_.setAttributeNS(null, "points", a.join(" "));
            const o = this.tooltipElem_,
                h = this.value.rawValue[this.cursor_.rawValue];
            if (h === void 0) {
                o.classList.remove(pr("t", "a"));
                return;
            }
            const l = je(this.cursor_.rawValue, 0, n, 0, e),
                u = je(h, i, r, t, 0);
            (o.style.left = `${l}px`),
                (o.style.top = `${u}px`),
                (o.textContent = `${this.formatter_(h)}`),
                o.classList.contains(pr("t", "a")) ||
                    (o.classList.add(pr("t", "a"), pr("t", "in")),
                    Hu(o),
                    o.classList.remove(pr("t", "in")));
        }
        onValueUpdate_() {
            this.update_();
        }
        onCursorChange_() {
            this.update_();
        }
    },
    TA = class {
        constructor(e, t) {
            if (
                ((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
                (this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
                (this.onGraphPointerDown_ =
                    this.onGraphPointerDown_.bind(this)),
                (this.onGraphPointerMove_ =
                    this.onGraphPointerMove_.bind(this)),
                (this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
                (this.props = t.props),
                (this.value = t.value),
                (this.viewProps = t.viewProps),
                (this.cursor_ = Qt(-1)),
                (this.view = new mD(e, {
                    cursor: this.cursor_,
                    formatter: t.formatter,
                    rows: t.rows,
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps,
                })),
                !n_(e))
            )
                this.view.element.addEventListener(
                    "mousemove",
                    this.onGraphMouseMove_
                ),
                    this.view.element.addEventListener(
                        "mouseleave",
                        this.onGraphMouseLeave_
                    );
            else {
                const n = new Za(this.view.element);
                n.emitter.on("down", this.onGraphPointerDown_),
                    n.emitter.on("move", this.onGraphPointerMove_),
                    n.emitter.on("up", this.onGraphPointerUp_);
            }
        }
        importProps(e) {
            return Li(
                e,
                null,
                (t) => ({ max: t.required.number, min: t.required.number }),
                (t) => (
                    this.props.set("max", t.max),
                    this.props.set("min", t.min),
                    !0
                )
            );
        }
        exportProps() {
            return Oi(null, {
                max: this.props.get("max"),
                min: this.props.get("min"),
            });
        }
        onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
        }
        onGraphMouseMove_(e) {
            const { clientWidth: t } = this.view.element;
            this.cursor_.rawValue = Math.floor(
                je(e.offsetX, 0, t, 0, this.value.rawValue.length)
            );
        }
        onGraphPointerDown_(e) {
            this.onGraphPointerMove_(e);
        }
        onGraphPointerMove_(e) {
            if (!e.data.point) {
                this.cursor_.rawValue = -1;
                return;
            }
            this.cursor_.rawValue = Math.floor(
                je(
                    e.data.point.x,
                    0,
                    e.data.bounds.width,
                    0,
                    this.value.rawValue.length
                )
            );
        }
        onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
        }
    };
function Lm(s) {
    return Ct(s.format) ? Wn(2) : s.format;
}
function gD(s) {
    var e;
    return s.value.rawValue.length === 1
        ? new A_(s.document, {
              formatter: Lm(s.params),
              value: s.value,
              viewProps: s.viewProps,
          })
        : new C_(s.document, {
              formatter: Lm(s.params),
              rows:
                  (e = s.params.rows) !== null && e !== void 0
                      ? e
                      : Nd.monitor.defaultRows,
              value: s.value,
              viewProps: s.viewProps,
          });
}
function _D(s) {
    var e, t, n;
    return new TA(s.document, {
        formatter: Lm(s.params),
        rows:
            (e = s.params.rows) !== null && e !== void 0
                ? e
                : Nd.monitor.defaultRows,
        props: He.fromObject({
            max: (t = s.params.max) !== null && t !== void 0 ? t : 100,
            min: (n = s.params.min) !== null && n !== void 0 ? n : 0,
        }),
        value: s.value,
        viewProps: s.viewProps,
    });
}
function iy(s) {
    return s.view === "graph";
}
Mn({
    id: "monitor-number",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "number") return null;
        const t = yn(e, (n) => ({
            format: n.optional.function,
            max: n.optional.number,
            min: n.optional.number,
            readonly: n.required.constant(!0),
            rows: n.optional.number,
            view: n.optional.string,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { defaultBufferSize: (s) => (iy(s) ? 64 : 1), reader: (s) => O2 },
    controller: (s) => (iy(s.params) ? _D(s) : gD(s)),
    api: (s) =>
        s.controller.valueController instanceof TA
            ? new pD(s.controller)
            : null,
});
Mn({
    id: "monitor-string",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "string") return null;
        const t = yn(e, (n) => ({
            multiline: n.optional.boolean,
            readonly: n.required.constant(!0),
            rows: n.optional.number,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { reader: (s) => eA },
    controller: (s) => {
        var e;
        const t = s.value;
        return t.rawValue.length > 1 || s.params.multiline
            ? new C_(s.document, {
                  formatter: Rm,
                  rows:
                      (e = s.params.rows) !== null && e !== void 0
                          ? e
                          : Nd.monitor.defaultRows,
                  value: t,
                  viewProps: s.viewProps,
              })
            : new A_(s.document, {
                  formatter: Rm,
                  value: t,
                  viewProps: s.viewProps,
              });
    },
});
new W2("4.0.5");
function vt(s) {
    return s == null;
}
function S_(s) {
    return s !== null && typeof s == "object";
}
function Om(s) {
    return s !== null && typeof s == "object";
}
function vD(s, e) {
    if (s.length !== e.length) return !1;
    for (let t = 0; t < s.length; t++) if (s[t] !== e[t]) return !1;
    return !0;
}
function Ua(s, e) {
    return Array.from(new Set([...Object.keys(s), ...Object.keys(e)])).reduce(
        (n, i) => {
            const r = s[i],
                a = e[i];
            return Om(r) && Om(a)
                ? Object.assign(Object.assign({}, n), { [i]: Ua(r, a) })
                : Object.assign(Object.assign({}, n), { [i]: i in e ? a : r });
        },
        {}
    );
}
function bD(s) {
    return S_(s) ? "target" in s : !1;
}
const yD = {
    alreadydisposed: () => "View has been already disposed",
    invalidparams: (s) => `Invalid parameters for '${s.name}'`,
    nomatchingcontroller: (s) => `No matching controller for '${s.key}'`,
    nomatchingview: (s) => `No matching view for '${JSON.stringify(s.params)}'`,
    notbindable: () => "Value is not bindable",
    notcompatible: (s) => `Not compatible with  plugin '${s.id}'`,
    propertynotfound: (s) => `Property '${s.name}' not found`,
    shouldneverhappen: () => "This error should never happen",
};
class An {
    static alreadyDisposed() {
        return new An({ type: "alreadydisposed" });
    }
    static notBindable() {
        return new An({ type: "notbindable" });
    }
    static notCompatible(e, t) {
        return new An({ type: "notcompatible", context: { id: `${e}.${t}` } });
    }
    static propertyNotFound(e) {
        return new An({ type: "propertynotfound", context: { name: e } });
    }
    static shouldNeverHappen() {
        return new An({ type: "shouldneverhappen" });
    }
    constructor(e) {
        var t;
        (this.message =
            (t = yD[e.type](e.context)) !== null && t !== void 0
                ? t
                : "Unexpected error"),
            (this.name = this.constructor.name),
            (this.stack = new Error(this.message).stack),
            (this.type = e.type);
    }
    toString() {
        return this.message;
    }
}
class Qu {
    constructor(e, t) {
        (this.obj_ = e), (this.key = t);
    }
    static isBindable(e) {
        return !(
            e === null ||
            (typeof e != "object" && typeof e != "function")
        );
    }
    read() {
        return this.obj_[this.key];
    }
    write(e) {
        this.obj_[this.key] = e;
    }
    writeProperty(e, t) {
        const n = this.read();
        if (!Qu.isBindable(n)) throw An.notBindable();
        if (!(e in n)) throw An.propertyNotFound(e);
        n[e] = t;
    }
}
class wn {
    constructor() {
        this.observers_ = {};
    }
    on(e, t) {
        let n = this.observers_[e];
        return n || (n = this.observers_[e] = []), n.push({ handler: t }), this;
    }
    off(e, t) {
        const n = this.observers_[e];
        return (
            n && (this.observers_[e] = n.filter((i) => i.handler !== t)), this
        );
    }
    emit(e, t) {
        const n = this.observers_[e];
        n &&
            n.forEach((i) => {
                i.handler(t);
            });
    }
}
class wD {
    constructor(e, t) {
        var n;
        (this.constraint_ = t == null ? void 0 : t.constraint),
            (this.equals_ =
                (n = t == null ? void 0 : t.equals) !== null && n !== void 0
                    ? n
                    : (i, r) => i === r),
            (this.emitter = new wn()),
            (this.rawValue_ = e);
    }
    get constraint() {
        return this.constraint_;
    }
    get rawValue() {
        return this.rawValue_;
    }
    set rawValue(e) {
        this.setRawValue(e, { forceEmit: !1, last: !0 });
    }
    setRawValue(e, t) {
        const n = t ?? { forceEmit: !1, last: !0 },
            i = this.constraint_ ? this.constraint_.constrain(e) : e,
            r = this.rawValue_;
        (this.equals_(r, i) && !n.forceEmit) ||
            (this.emitter.emit("beforechange", { sender: this }),
            (this.rawValue_ = i),
            this.emitter.emit("change", {
                options: n,
                previousRawValue: r,
                rawValue: i,
                sender: this,
            }));
    }
}
class xD {
    constructor(e) {
        (this.emitter = new wn()), (this.value_ = e);
    }
    get rawValue() {
        return this.value_;
    }
    set rawValue(e) {
        this.setRawValue(e, { forceEmit: !1, last: !0 });
    }
    setRawValue(e, t) {
        const n = t ?? { forceEmit: !1, last: !0 },
            i = this.value_;
        (i === e && !n.forceEmit) ||
            (this.emitter.emit("beforechange", { sender: this }),
            (this.value_ = e),
            this.emitter.emit("change", {
                options: n,
                previousRawValue: i,
                rawValue: this.value_,
                sender: this,
            }));
    }
}
class CD {
    constructor(e) {
        (this.emitter = new wn()),
            (this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this)),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.value_ = e),
            this.value_.emitter.on("beforechange", this.onValueBeforeChange_),
            this.value_.emitter.on("change", this.onValueChange_);
    }
    get rawValue() {
        return this.value_.rawValue;
    }
    onValueBeforeChange_(e) {
        this.emitter.emit(
            "beforechange",
            Object.assign(Object.assign({}, e), { sender: this })
        );
    }
    onValueChange_(e) {
        this.emitter.emit(
            "change",
            Object.assign(Object.assign({}, e), { sender: this })
        );
    }
}
function kt(s, e) {
    const t = e == null ? void 0 : e.constraint,
        n = e == null ? void 0 : e.equals;
    return !t && !n ? new xD(s) : new wD(s, e);
}
function AD(s) {
    return [
        new CD(s),
        (e, t) => {
            s.setRawValue(e, t);
        },
    ];
}
class de {
    constructor(e) {
        (this.emitter = new wn()), (this.valMap_ = e);
        for (const t in this.valMap_)
            this.valMap_[t].emitter.on("change", () => {
                this.emitter.emit("change", { key: t, sender: this });
            });
    }
    static createCore(e) {
        return Object.keys(e).reduce(
            (n, i) => Object.assign(n, { [i]: kt(e[i]) }),
            {}
        );
    }
    static fromObject(e) {
        const t = this.createCore(e);
        return new de(t);
    }
    get(e) {
        return this.valMap_[e].rawValue;
    }
    set(e, t) {
        this.valMap_[e].rawValue = t;
    }
    value(e) {
        return this.valMap_[e];
    }
}
class _c {
    constructor(e) {
        this.values = de.fromObject({ max: e.max, min: e.min });
    }
    constrain(e) {
        const t = this.values.get("max"),
            n = this.values.get("min");
        return Math.min(Math.max(e, n), t);
    }
}
class E_ {
    constructor(e) {
        this.values = de.fromObject({ max: e.max, min: e.min });
    }
    constrain(e) {
        const t = this.values.get("max"),
            n = this.values.get("min");
        let i = e;
        return vt(n) || (i = Math.max(i, n)), vt(t) || (i = Math.min(i, t)), i;
    }
}
class SD {
    constructor(e, t = 0) {
        (this.step = e), (this.origin = t);
    }
    constrain(e) {
        const t = this.origin % this.step,
            n = Math.round((e - t) / this.step);
        return t + n * this.step;
    }
}
class ED {
    constructor(e) {
        this.text = e;
    }
    evaluate() {
        return Number(this.text);
    }
    toString() {
        return this.text;
    }
}
const PD = {
    "**": (s, e) => Math.pow(s, e),
    "*": (s, e) => s * e,
    "/": (s, e) => s / e,
    "%": (s, e) => s % e,
    "+": (s, e) => s + e,
    "-": (s, e) => s - e,
    "<<": (s, e) => s << e,
    ">>": (s, e) => s >> e,
    ">>>": (s, e) => s >>> e,
    "&": (s, e) => s & e,
    "^": (s, e) => s ^ e,
    "|": (s, e) => s | e,
};
class kD {
    constructor(e, t, n) {
        (this.left = t), (this.operator = e), (this.right = n);
    }
    evaluate() {
        const e = PD[this.operator];
        if (!e)
            throw new Error(`unexpected binary operator: '${this.operator}`);
        return e(this.left.evaluate(), this.right.evaluate());
    }
    toString() {
        return [
            "b(",
            this.left.toString(),
            this.operator,
            this.right.toString(),
            ")",
        ].join(" ");
    }
}
const TD = { "+": (s) => s, "-": (s) => -s, "~": (s) => ~s };
class MD {
    constructor(e, t) {
        (this.operator = e), (this.expression = t);
    }
    evaluate() {
        const e = TD[this.operator];
        if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
        return e(this.expression.evaluate());
    }
    toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
    }
}
function P_(s) {
    return (e, t) => {
        for (let n = 0; n < s.length; n++) {
            const i = s[n](e, t);
            if (i !== "") return i;
        }
        return "";
    };
}
function Zh(s, e) {
    var t;
    const n = s.substr(e).match(/^\s+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function ID(s, e) {
    const t = s.substr(e, 1);
    return t.match(/^[1-9]$/) ? t : "";
}
function Qh(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-9]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function RD(s, e) {
    const t = Qh(s, e);
    if (t !== "") return t;
    const n = s.substr(e, 1);
    if (((e += 1), n !== "-" && n !== "+")) return "";
    const i = Qh(s, e);
    return i === "" ? "" : n + i;
}
function k_(s, e) {
    const t = s.substr(e, 1);
    if (((e += 1), t.toLowerCase() !== "e")) return "";
    const n = RD(s, e);
    return n === "" ? "" : t + n;
}
function MA(s, e) {
    const t = s.substr(e, 1);
    if (t === "0") return t;
    const n = ID(s, e);
    return (e += n.length), n === "" ? "" : n + Qh(s, e);
}
function LD(s, e) {
    const t = MA(s, e);
    if (((e += t.length), t === "")) return "";
    const n = s.substr(e, 1);
    if (((e += n.length), n !== ".")) return "";
    const i = Qh(s, e);
    return (e += i.length), t + n + i + k_(s, e);
}
function OD(s, e) {
    const t = s.substr(e, 1);
    if (((e += t.length), t !== ".")) return "";
    const n = Qh(s, e);
    return (e += n.length), n === "" ? "" : t + n + k_(s, e);
}
function BD(s, e) {
    const t = MA(s, e);
    return (e += t.length), t === "" ? "" : t + k_(s, e);
}
const FD = P_([LD, OD, BD]);
function $D(s, e) {
    var t;
    const n = s.substr(e).match(/^[01]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function DD(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0b")) return "";
    const n = $D(s, e);
    return n === "" ? "" : t + n;
}
function ND(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-7]+/);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function VD(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0o")) return "";
    const n = ND(s, e);
    return n === "" ? "" : t + n;
}
function UD(s, e) {
    var t;
    const n = s.substr(e).match(/^[0-9a-f]+/i);
    return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function zD(s, e) {
    const t = s.substr(e, 2);
    if (((e += t.length), t.toLowerCase() !== "0x")) return "";
    const n = UD(s, e);
    return n === "" ? "" : t + n;
}
const YD = P_([DD, VD, zD]),
    GD = P_([YD, FD]);
function jD(s, e) {
    const t = GD(s, e);
    return (
        (e += t.length), t === "" ? null : { evaluable: new ED(t), cursor: e }
    );
}
function WD(s, e) {
    const t = s.substr(e, 1);
    if (((e += t.length), t !== "(")) return null;
    const n = RA(s, e);
    if (!n) return null;
    (e = n.cursor), (e += Zh(s, e).length);
    const i = s.substr(e, 1);
    return (
        (e += i.length),
        i !== ")" ? null : { evaluable: n.evaluable, cursor: e }
    );
}
function XD(s, e) {
    var t;
    return (t = jD(s, e)) !== null && t !== void 0 ? t : WD(s, e);
}
function IA(s, e) {
    const t = XD(s, e);
    if (t) return t;
    const n = s.substr(e, 1);
    if (((e += n.length), n !== "+" && n !== "-" && n !== "~")) return null;
    const i = IA(s, e);
    return i
        ? ((e = i.cursor), { cursor: e, evaluable: new MD(n, i.evaluable) })
        : null;
}
function qD(s, e, t) {
    t += Zh(e, t).length;
    const n = s.filter((i) => e.startsWith(i, t))[0];
    return n
        ? ((t += n.length), (t += Zh(e, t).length), { cursor: t, operator: n })
        : null;
}
function HD(s, e) {
    return (t, n) => {
        const i = s(t, n);
        if (!i) return null;
        n = i.cursor;
        let r = i.evaluable;
        for (;;) {
            const a = qD(e, t, n);
            if (!a) break;
            n = a.cursor;
            const o = s(t, n);
            if (!o) return null;
            (n = o.cursor), (r = new kD(a.operator, r, o.evaluable));
        }
        return r ? { cursor: n, evaluable: r } : null;
    };
}
const KD = [
    ["**"],
    ["*", "/", "%"],
    ["+", "-"],
    ["<<", ">>>", ">>"],
    ["&"],
    ["^"],
    ["|"],
].reduce((s, e) => HD(s, e), IA);
function RA(s, e) {
    return (e += Zh(s, e).length), KD(s, e);
}
function ZD(s) {
    const e = RA(s, 0);
    return !e || e.cursor + Zh(s, e.cursor).length !== s.length
        ? null
        : e.evaluable;
}
function Zs(s) {
    var e;
    const t = ZD(s);
    return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0
        ? e
        : null;
}
function T_(s) {
    if (typeof s == "number") return s;
    if (typeof s == "string") {
        const e = Zs(s);
        if (!vt(e)) return e;
    }
    return 0;
}
function cn(s) {
    return (e) => e.toFixed(Math.max(Math.min(s, 20), 0));
}
function ue(s, e, t, n, i) {
    const r = (s - e) / (t - e);
    return n + r * (i - n);
}
function ry(s) {
    return String(s.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
}
function At(s, e, t) {
    return Math.min(Math.max(s, e), t);
}
function LA(s, e) {
    return ((s % e) + e) % e;
}
function QD(s, e) {
    return vt(s.step) ? Math.max(ry(e), 2) : ry(s.step);
}
function OA(s) {
    var e;
    return (e = s.step) !== null && e !== void 0 ? e : 1;
}
function JD(s, e) {
    var t;
    const n = Math.abs((t = s.step) !== null && t !== void 0 ? t : e);
    return n === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(n)) - 1);
}
function M_(s, e) {
    return vt(s.step) ? null : new SD(s.step, e);
}
function I_(s) {
    return !vt(s.max) && !vt(s.min)
        ? new _c({ max: s.max, min: s.min })
        : !vt(s.max) || !vt(s.min)
        ? new E_({ max: s.max, min: s.min })
        : null;
}
function R_(s, e) {
    var t, n, i;
    return {
        formatter: (t = s.format) !== null && t !== void 0 ? t : cn(QD(s, e)),
        keyScale: (n = s.keyScale) !== null && n !== void 0 ? n : OA(s),
        pointerScale:
            (i = s.pointerScale) !== null && i !== void 0 ? i : JD(s, e),
    };
}
function L_(s) {
    return {
        format: s.optional.function,
        keyScale: s.optional.number,
        max: s.optional.number,
        min: s.optional.number,
        pointerScale: s.optional.number,
        step: s.optional.number,
    };
}
function O_(s) {
    return {
        constraint: s.constraint,
        textProps: de.fromObject(R_(s.params, s.initialValue)),
    };
}
class Qa {
    constructor(e) {
        this.controller = e;
    }
    get element() {
        return this.controller.view.element;
    }
    get disabled() {
        return this.controller.viewProps.get("disabled");
    }
    set disabled(e) {
        this.controller.viewProps.set("disabled", e);
    }
    get hidden() {
        return this.controller.viewProps.get("hidden");
    }
    set hidden(e) {
        this.controller.viewProps.set("hidden", e);
    }
    dispose() {
        this.controller.viewProps.set("disposed", !0);
    }
    importState(e) {
        return this.controller.importState(e);
    }
    exportState() {
        return this.controller.exportState();
    }
}
class Ja {
    constructor(e) {
        this.target = e;
    }
}
class Vd extends Ja {
    constructor(e, t, n) {
        super(e), (this.value = t), (this.last = n ?? !0);
    }
}
class eN extends Ja {
    constructor(e, t) {
        super(e), (this.expanded = t);
    }
}
class tN extends Ja {
    constructor(e, t) {
        super(e), (this.index = t);
    }
}
class B_ extends Qa {
    constructor(e) {
        super(e),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.emitter_ = new wn()),
            this.controller.value.emitter.on("change", this.onValueChange_);
    }
    get label() {
        return this.controller.labelController.props.get("label");
    }
    set label(e) {
        this.controller.labelController.props.set("label", e);
    }
    get key() {
        return this.controller.value.binding.target.key;
    }
    get tag() {
        return this.controller.tag;
    }
    set tag(e) {
        this.controller.tag = e;
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(e, (i) => {
                n(i);
            }),
            this
        );
    }
    refresh() {
        this.controller.value.fetch();
    }
    onValueChange_(e) {
        const t = this.controller.value;
        this.emitter_.emit(
            "change",
            new Vd(this, t.binding.target.read(), e.options.last)
        );
    }
}
function nN(s, e) {
    const n = Object.keys(e).reduce((i, r) => {
        if (i === void 0) return;
        const a = e[r],
            o = a(s[r]);
        return o.succeeded
            ? Object.assign(Object.assign({}, i), { [r]: o.value })
            : void 0;
    }, {});
    return n;
}
function sN(s, e) {
    return s.reduce((t, n) => {
        if (t === void 0) return;
        const i = e(n);
        if (!(!i.succeeded || i.value === void 0)) return [...t, i.value];
    }, []);
}
function iN(s) {
    return s === null ? !1 : typeof s == "object";
}
function Ui(s) {
    return (e) => (t) => {
        if (!e && t === void 0) return { succeeded: !1, value: void 0 };
        if (e && t === void 0) return { succeeded: !0, value: void 0 };
        const n = s(t);
        return n !== void 0
            ? { succeeded: !0, value: n }
            : { succeeded: !1, value: void 0 };
    };
}
function ay(s) {
    return {
        custom: (e) => Ui(e)(s),
        boolean: Ui((e) => (typeof e == "boolean" ? e : void 0))(s),
        number: Ui((e) => (typeof e == "number" ? e : void 0))(s),
        string: Ui((e) => (typeof e == "string" ? e : void 0))(s),
        function: Ui((e) => (typeof e == "function" ? e : void 0))(s),
        constant: (e) => Ui((t) => (t === e ? e : void 0))(s),
        raw: Ui((e) => e)(s),
        object: (e) =>
            Ui((t) => {
                if (iN(t)) return nN(t, e);
            })(s),
        array: (e) =>
            Ui((t) => {
                if (Array.isArray(t)) return sN(t, e);
            })(s),
    };
}
const Bm = { optional: ay(!0), required: ay(!1) };
function Tt(s, e) {
    const t = e(Bm),
        n = Bm.required.object(t)(s);
    return n.succeeded ? n.value : void 0;
}
function ii(s, e, t, n) {
    if (e && !e(s)) return !1;
    const i = Tt(s, t);
    return i ? n(i) : !1;
}
function ri(s, e) {
    var t;
    return Ua(
        (t = s == null ? void 0 : s()) !== null && t !== void 0 ? t : {},
        e
    );
}
function hu(s) {
    return "value" in s;
}
function rN(s) {
    if (!S_(s) || !("binding" in s)) return !1;
    const e = s.binding;
    return bD(e);
}
const Ht = "http://www.w3.org/2000/svg";
function Ju(s) {
    s.offsetHeight;
}
function aN(s, e) {
    const t = s.style.transition;
    (s.style.transition = "none"), e(), (s.style.transition = t);
}
function Ud(s) {
    return s.ontouchstart !== void 0;
}
function oN(s) {
    const e = s.ownerDocument.defaultView;
    return e && "document" in e
        ? s.getContext("2d", { willReadFrequently: !0 })
        : null;
}
const lN = {
    check: '<path d="M2 8l4 4l8 -8"/>',
    dropdown: '<path d="M5 7h6l-3 3 z"/>',
    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function zd(s, e) {
    const t = s.createElementNS(Ht, "svg");
    return (t.innerHTML = lN[e]), t;
}
function BA(s, e, t) {
    s.insertBefore(e, s.children[t]);
}
function F_(s) {
    s.parentElement && s.parentElement.removeChild(s);
}
function FA(s) {
    for (; s.children.length > 0; ) s.removeChild(s.children[0]);
}
function hN(s) {
    for (; s.childNodes.length > 0; ) s.removeChild(s.childNodes[0]);
}
function $_(s) {
    return s.relatedTarget
        ? s.relatedTarget
        : "explicitOriginalTarget" in s
        ? s.explicitOriginalTarget
        : null;
}
function Rs(s, e) {
    s.emitter.on("change", (t) => {
        e(t.rawValue);
    }),
        e(s.rawValue);
}
function Bs(s, e, t) {
    Rs(s.value(e), t);
}
const cN = "tp";
function be(s) {
    return (t, n) =>
        [cN, "-", s, "v", t ? `_${t}` : "", n ? `-${n}` : ""].join("");
}
const Gl = be("lbl");
function uN(s, e) {
    const t = s.createDocumentFragment();
    return (
        e
            .split(
                `
`
            )
            .map((i) => s.createTextNode(i))
            .forEach((i, r) => {
                r > 0 && t.appendChild(s.createElement("br")), t.appendChild(i);
            }),
        t
    );
}
class $A {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(Gl()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(Gl("l")),
            Bs(t.props, "label", (r) => {
                vt(r)
                    ? this.element.classList.add(Gl(void 0, "nol"))
                    : (this.element.classList.remove(Gl(void 0, "nol")),
                      hN(n),
                      n.appendChild(uN(e, r)));
            }),
            this.element.appendChild(n),
            (this.labelElement = n);
        const i = e.createElement("div");
        i.classList.add(Gl("v")),
            this.element.appendChild(i),
            (this.valueElement = i);
    }
}
class Yd {
    constructor(e, t) {
        (this.props = t.props),
            (this.valueController = t.valueController),
            (this.viewProps = t.valueController.viewProps),
            (this.view = new $A(e, {
                props: t.props,
                viewProps: this.viewProps,
            })),
            this.view.valueElement.appendChild(
                this.valueController.view.element
            );
    }
    importProps(e) {
        return ii(
            e,
            null,
            (t) => ({ label: t.optional.string }),
            (t) => (this.props.set("label", t.label), !0)
        );
    }
    exportProps() {
        return ri(null, { label: this.props.get("label") });
    }
}
function dN() {
    return ["veryfirst", "first", "last", "verylast"];
}
const oy = be(""),
    ly = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
class vc {
    constructor(e) {
        (this.parent_ = null),
            (this.blade = e.blade),
            (this.view = e.view),
            (this.viewProps = e.viewProps);
        const t = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
            dN().forEach((n) => {
                t.classList.remove(oy(void 0, ly[n]));
            }),
                this.blade.get("positions").forEach((n) => {
                    t.classList.add(oy(void 0, ly[n]));
                });
        }),
            this.viewProps.handleDispose(() => {
                F_(t);
            });
    }
    get parent() {
        return this.parent_;
    }
    set parent(e) {
        (this.parent_ = e),
            this.viewProps.set(
                "parent",
                this.parent_ ? this.parent_.viewProps : null
            );
    }
    importState(e) {
        return ii(
            e,
            null,
            (t) => ({
                disabled: t.required.boolean,
                hidden: t.required.boolean,
            }),
            (t) => (this.viewProps.importState(t), !0)
        );
    }
    exportState() {
        return ri(null, Object.assign({}, this.viewProps.exportState()));
    }
}
class ed extends vc {
    constructor(e, t) {
        if (t.value !== t.valueController.value) throw An.shouldNeverHappen();
        const n = t.valueController.viewProps,
            i = new Yd(e, {
                blade: t.blade,
                props: t.props,
                valueController: t.valueController,
            });
        super(
            Object.assign(Object.assign({}, t), {
                view: new $A(e, { props: t.props, viewProps: n }),
                viewProps: n,
            })
        ),
            (this.labelController = i),
            (this.value = t.value),
            (this.valueController = t.valueController),
            this.view.valueElement.appendChild(
                this.valueController.view.element
            );
    }
    importState(e) {
        return ii(
            e,
            (t) => {
                var n, i, r;
                return (
                    super.importState(t) &&
                    this.labelController.importProps(t) &&
                    ((r =
                        (i = (n = this.valueController).importProps) === null ||
                        i === void 0
                            ? void 0
                            : i.call(n, e)) !== null && r !== void 0
                        ? r
                        : !0)
                );
            },
            (t) => ({ value: t.optional.raw }),
            (t) => (t.value && (this.value.rawValue = t.value), !0)
        );
    }
    exportState() {
        var e, t, n;
        return ri(
            () => super.exportState(),
            Object.assign(
                Object.assign(
                    { value: this.value.rawValue },
                    this.labelController.exportProps()
                ),
                (n =
                    (t = (e = this.valueController).exportProps) === null ||
                    t === void 0
                        ? void 0
                        : t.call(e)) !== null && n !== void 0
                    ? n
                    : {}
            )
        );
    }
}
function DA(s, e) {
    for (; s.length < e; ) s.push(void 0);
}
function fN(s) {
    const e = [];
    return DA(e, s), e;
}
function pN(s) {
    const e = s.indexOf(void 0);
    return e < 0 ? s : s.slice(0, e);
}
function mN(s, e) {
    const t = [...pN(s), e];
    return (
        t.length > s.length
            ? t.splice(0, t.length - s.length)
            : DA(t, s.length),
        t
    );
}
class gN extends Qa {
    get label() {
        return this.controller.labelController.props.get("label");
    }
    set label(e) {
        this.controller.labelController.props.set("label", e);
    }
    get title() {
        var e;
        return (e = this.controller.buttonController.props.get("title")) !==
            null && e !== void 0
            ? e
            : "";
    }
    set title(e) {
        this.controller.buttonController.props.set("title", e);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.controller.buttonController.emitter.on(e, () => {
                n(new Ja(this));
            }),
            this
        );
    }
}
function _N(s, e, t) {
    t ? s.classList.add(e) : s.classList.remove(e);
}
function Kr(s, e) {
    return (t) => {
        _N(s, e, t);
    };
}
function D_(s, e) {
    Rs(s, (t) => {
        e.textContent = t ?? "";
    });
}
const pp = be("btn");
class vN {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(pp()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("button");
        n.classList.add(pp("b")),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.buttonElement = n);
        const i = e.createElement("div");
        i.classList.add(pp("t")),
            D_(t.props.value("title"), i),
            this.buttonElement.appendChild(i);
    }
}
class NA {
    constructor(e, t) {
        (this.emitter = new wn()),
            (this.onClick_ = this.onClick_.bind(this)),
            (this.props = t.props),
            (this.viewProps = t.viewProps),
            (this.view = new vN(e, {
                props: this.props,
                viewProps: this.viewProps,
            })),
            this.view.buttonElement.addEventListener("click", this.onClick_);
    }
    importProps(e) {
        return ii(
            e,
            null,
            (t) => ({ title: t.optional.string }),
            (t) => (this.props.set("title", t.title), !0)
        );
    }
    exportProps() {
        return ri(null, { title: this.props.get("title") });
    }
    onClick_() {
        this.emitter.emit("click", { sender: this });
    }
}
class hy extends vc {
    constructor(e, t) {
        const n = new NA(e, { props: t.buttonProps, viewProps: t.viewProps }),
            i = new Yd(e, {
                blade: t.blade,
                props: t.labelProps,
                valueController: n,
            });
        super({ blade: t.blade, view: i.view, viewProps: t.viewProps }),
            (this.buttonController = n),
            (this.labelController = i);
    }
    importState(e) {
        return ii(
            e,
            (t) =>
                super.importState(t) &&
                this.buttonController.importProps(t) &&
                this.labelController.importProps(t),
            () => ({}),
            () => !0
        );
    }
    exportState() {
        return ri(
            () => super.exportState(),
            Object.assign(
                Object.assign({}, this.buttonController.exportProps()),
                this.labelController.exportProps()
            )
        );
    }
}
class bN {
    constructor(e) {
        const [t, n] = e.split("-"),
            i = t.split(".");
        (this.major = parseInt(i[0], 10)),
            (this.minor = parseInt(i[1], 10)),
            (this.patch = parseInt(i[2], 10)),
            (this.prerelease = n ?? null);
    }
    toString() {
        const e = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [e, this.prerelease].join("-") : e;
    }
}
const yN = new bN("2.0.0-beta.2");
function Bt(s) {
    return Object.assign({ core: yN }, s);
}
Bt({
    id: "button",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            title: t.required.string,
            view: t.required.constant("button"),
            label: t.optional.string,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        return new hy(s.document, {
            blade: s.blade,
            buttonProps: de.fromObject({ title: s.params.title }),
            labelProps: de.fromObject({ label: s.params.label }),
            viewProps: s.viewProps,
        });
    },
    api(s) {
        return s.controller instanceof hy ? new gN(s.controller) : null;
    },
});
function wN(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
}
function xN(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
}
function CN(s, e) {
    return s.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
}
function AN(s) {
    return S_(s) ? "refresh" in s && typeof s.refresh == "function" : !1;
}
function SN(s, e) {
    if (!Qu.isBindable(s)) throw An.notBindable();
    return new Qu(s, e);
}
class EN {
    constructor(e, t) {
        (this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
            (this.controller_ = e),
            (this.emitter_ = new wn()),
            (this.pool_ = t),
            this.controller_.rack.emitter.on(
                "valuechange",
                this.onRackValueChange_
            );
    }
    get children() {
        return this.controller_.rack.children.map((e) =>
            this.pool_.createApi(e)
        );
    }
    addBinding(e, t, n) {
        const i = n ?? {},
            r = this.controller_.element.ownerDocument,
            a = this.pool_.createBinding(r, SN(e, t), i),
            o = this.pool_.createBindingApi(a);
        return this.add(o, i.index);
    }
    addFolder(e) {
        return xN(this, e);
    }
    addButton(e) {
        return wN(this, e);
    }
    addTab(e) {
        return CN(this, e);
    }
    add(e, t) {
        const n = e.controller;
        return this.controller_.rack.add(n, t), e;
    }
    remove(e) {
        this.controller_.rack.remove(e.controller);
    }
    addBlade(e) {
        const t = this.controller_.element.ownerDocument,
            n = this.pool_.createBlade(t, e),
            i = this.pool_.createApi(n);
        return this.add(i, e.index);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(e, (i) => {
                n(i);
            }),
            this
        );
    }
    refresh() {
        this.children.forEach((e) => {
            AN(e) && e.refresh();
        });
    }
    onRackValueChange_(e) {
        const t = e.bladeController,
            n = this.pool_.createApi(t),
            i = rN(t.value) ? t.value.binding : null;
        this.emitter_.emit(
            "change",
            new Vd(n, i ? i.target.read() : t.value.rawValue, e.options.last)
        );
    }
}
class N_ extends Qa {
    constructor(e, t) {
        super(e), (this.rackApi_ = new EN(e.rackController, t));
    }
}
class V_ extends vc {
    constructor(e) {
        super({
            blade: e.blade,
            view: e.view,
            viewProps: e.rackController.viewProps,
        }),
            (this.rackController = e.rackController);
    }
    importState(e) {
        return ii(
            e,
            (t) => super.importState(t),
            (t) => ({ children: t.required.array(t.required.raw) }),
            (t) =>
                this.rackController.rack.children.every((n, i) =>
                    n.importState(t.children[i])
                )
        );
    }
    exportState() {
        return ri(() => super.exportState(), {
            children: this.rackController.rack.children.map((e) =>
                e.exportState()
            ),
        });
    }
}
function Fm(s) {
    return "rackController" in s;
}
class PN {
    constructor(e) {
        (this.emitter = new wn()),
            (this.items_ = []),
            (this.cache_ = new Set()),
            (this.onSubListAdd_ = this.onSubListAdd_.bind(this)),
            (this.onSubListRemove_ = this.onSubListRemove_.bind(this)),
            (this.extract_ = e);
    }
    get items() {
        return this.items_;
    }
    allItems() {
        return Array.from(this.cache_);
    }
    find(e) {
        for (const t of this.allItems()) if (e(t)) return t;
        return null;
    }
    includes(e) {
        return this.cache_.has(e);
    }
    add(e, t) {
        if (this.includes(e)) throw An.shouldNeverHappen();
        const n = t !== void 0 ? t : this.items_.length;
        this.items_.splice(n, 0, e), this.cache_.add(e);
        const i = this.extract_(e);
        i &&
            (i.emitter.on("add", this.onSubListAdd_),
            i.emitter.on("remove", this.onSubListRemove_),
            i.allItems().forEach((r) => {
                this.cache_.add(r);
            })),
            this.emitter.emit("add", {
                index: n,
                item: e,
                root: this,
                target: this,
            });
    }
    remove(e) {
        const t = this.items_.indexOf(e);
        if (t < 0) return;
        this.items_.splice(t, 1), this.cache_.delete(e);
        const n = this.extract_(e);
        n &&
            (n.allItems().forEach((i) => {
                this.cache_.delete(i);
            }),
            n.emitter.off("add", this.onSubListAdd_),
            n.emitter.off("remove", this.onSubListRemove_)),
            this.emitter.emit("remove", {
                index: t,
                item: e,
                root: this,
                target: this,
            });
    }
    onSubListAdd_(e) {
        this.cache_.add(e.item),
            this.emitter.emit("add", {
                index: e.index,
                item: e.item,
                root: this,
                target: e.target,
            });
    }
    onSubListRemove_(e) {
        this.cache_.delete(e.item),
            this.emitter.emit("remove", {
                index: e.index,
                item: e.item,
                root: this,
                target: e.target,
            });
    }
}
function kN(s, e) {
    for (let t = 0; t < s.length; t++) {
        const n = s[t];
        if (hu(n) && n.value === e) return n;
    }
    return null;
}
function TN(s) {
    return Fm(s) ? s.rackController.rack.bcSet_ : null;
}
class MN {
    constructor(e) {
        var t, n;
        (this.emitter = new wn()),
            (this.onBladePositionsChange_ =
                this.onBladePositionsChange_.bind(this)),
            (this.onSetAdd_ = this.onSetAdd_.bind(this)),
            (this.onSetRemove_ = this.onSetRemove_.bind(this)),
            (this.onChildDispose_ = this.onChildDispose_.bind(this)),
            (this.onChildPositionsChange_ =
                this.onChildPositionsChange_.bind(this)),
            (this.onChildValueChange_ = this.onChildValueChange_.bind(this)),
            (this.onChildViewPropsChange_ =
                this.onChildViewPropsChange_.bind(this)),
            (this.onRackLayout_ = this.onRackLayout_.bind(this)),
            (this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
            (this.blade_ = (t = e.blade) !== null && t !== void 0 ? t : null),
            (n = this.blade_) === null ||
                n === void 0 ||
                n
                    .value("positions")
                    .emitter.on("change", this.onBladePositionsChange_),
            (this.viewProps = e.viewProps),
            (this.bcSet_ = new PN(TN)),
            this.bcSet_.emitter.on("add", this.onSetAdd_),
            this.bcSet_.emitter.on("remove", this.onSetRemove_);
    }
    get children() {
        return this.bcSet_.items;
    }
    add(e, t) {
        var n;
        (n = e.parent) === null || n === void 0 || n.remove(e),
            (e.parent = this),
            this.bcSet_.add(e, t);
    }
    remove(e) {
        (e.parent = null), this.bcSet_.remove(e);
    }
    find(e) {
        return this.bcSet_.allItems().filter(e);
    }
    onSetAdd_(e) {
        this.updatePositions_();
        const t = e.target === e.root;
        if (
            (this.emitter.emit("add", {
                bladeController: e.item,
                index: e.index,
                root: t,
                sender: this,
            }),
            !t)
        )
            return;
        const n = e.item;
        if (
            (n.viewProps.emitter.on("change", this.onChildViewPropsChange_),
            n.blade
                .value("positions")
                .emitter.on("change", this.onChildPositionsChange_),
            n.viewProps.handleDispose(this.onChildDispose_),
            hu(n))
        )
            n.value.emitter.on("change", this.onChildValueChange_);
        else if (Fm(n)) {
            const i = n.rackController.rack;
            if (i) {
                const r = i.emitter;
                r.on("layout", this.onRackLayout_),
                    r.on("valuechange", this.onRackValueChange_);
            }
        }
    }
    onSetRemove_(e) {
        this.updatePositions_();
        const t = e.target === e.root;
        if (
            (this.emitter.emit("remove", {
                bladeController: e.item,
                root: t,
                sender: this,
            }),
            !t)
        )
            return;
        const n = e.item;
        if (hu(n)) n.value.emitter.off("change", this.onChildValueChange_);
        else if (Fm(n)) {
            const i = n.rackController.rack;
            if (i) {
                const r = i.emitter;
                r.off("layout", this.onRackLayout_),
                    r.off("valuechange", this.onRackValueChange_);
            }
        }
    }
    updatePositions_() {
        const e = this.bcSet_.items.filter((i) => !i.viewProps.get("hidden")),
            t = e[0],
            n = e[e.length - 1];
        this.bcSet_.items.forEach((i) => {
            const r = [];
            i === t &&
                (r.push("first"),
                (!this.blade_ ||
                    this.blade_.get("positions").includes("veryfirst")) &&
                    r.push("veryfirst")),
                i === n &&
                    (r.push("last"),
                    (!this.blade_ ||
                        this.blade_.get("positions").includes("verylast")) &&
                        r.push("verylast")),
                i.blade.set("positions", r);
        });
    }
    onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
    }
    onChildViewPropsChange_(e) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
    }
    onChildDispose_() {
        this.bcSet_.items
            .filter((t) => t.viewProps.get("disposed"))
            .forEach((t) => {
                this.bcSet_.remove(t);
            });
    }
    onChildValueChange_(e) {
        const t = kN(this.find(hu), e.sender);
        if (!t) throw An.alreadyDisposed();
        this.emitter.emit("valuechange", {
            bladeController: t,
            options: e.options,
            sender: this,
        });
    }
    onRackLayout_(e) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
    }
    onRackValueChange_(e) {
        this.emitter.emit("valuechange", {
            bladeController: e.bladeController,
            options: e.options,
            sender: this,
        });
    }
    onBladePositionsChange_() {
        this.updatePositions_();
    }
}
class U_ {
    constructor(e) {
        (this.onRackAdd_ = this.onRackAdd_.bind(this)),
            (this.onRackRemove_ = this.onRackRemove_.bind(this)),
            (this.element = e.element),
            (this.viewProps = e.viewProps);
        const t = new MN({
            blade: e.root ? void 0 : e.blade,
            viewProps: e.viewProps,
        });
        t.emitter.on("add", this.onRackAdd_),
            t.emitter.on("remove", this.onRackRemove_),
            (this.rack = t),
            this.viewProps.handleDispose(() => {
                for (let n = this.rack.children.length - 1; n >= 0; n--)
                    this.rack.children[n].viewProps.set("disposed", !0);
            });
    }
    onRackAdd_(e) {
        e.root && BA(this.element, e.bladeController.view.element, e.index);
    }
    onRackRemove_(e) {
        e.root && F_(e.bladeController.view.element);
    }
}
function VA() {
    return new de({ positions: kt([], { equals: vD }) });
}
class xl extends de {
    constructor(e) {
        super(e);
    }
    static create(e) {
        const t = {
                completed: !0,
                expanded: e,
                expandedHeight: null,
                shouldFixHeight: !1,
                temporaryExpanded: null,
            },
            n = de.createCore(t);
        return new xl(n);
    }
    get styleExpanded() {
        var e;
        return (e = this.get("temporaryExpanded")) !== null && e !== void 0
            ? e
            : this.get("expanded");
    }
    get styleHeight() {
        if (!this.styleExpanded) return "0";
        const e = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !vt(e) ? `${e}px` : "auto";
    }
    bindExpandedClass(e, t) {
        const n = () => {
            this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
        };
        Bs(this, "expanded", n), Bs(this, "temporaryExpanded", n);
    }
    cleanUpTransition() {
        this.set("shouldFixHeight", !1),
            this.set("expandedHeight", null),
            this.set("completed", !0);
    }
}
function IN(s, e) {
    let t = 0;
    return (
        aN(e, () => {
            s.set("expandedHeight", null),
                s.set("temporaryExpanded", !0),
                Ju(e),
                (t = e.clientHeight),
                s.set("temporaryExpanded", null),
                Ju(e);
        }),
        t
    );
}
function cy(s, e) {
    e.style.height = s.styleHeight;
}
function Gd(s, e) {
    s.value("expanded").emitter.on("beforechange", () => {
        if ((s.set("completed", !1), vt(s.get("expandedHeight")))) {
            const t = IN(s, e);
            t > 0 && s.set("expandedHeight", t);
        }
        s.set("shouldFixHeight", !0), Ju(e);
    }),
        s.emitter.on("change", () => {
            cy(s, e);
        }),
        cy(s, e),
        e.addEventListener("transitionend", (t) => {
            t.propertyName === "height" && s.cleanUpTransition();
        });
}
class RN extends N_ {
    constructor(e, t) {
        super(e, t),
            (this.emitter_ = new wn()),
            this.controller.foldable
                .value("expanded")
                .emitter.on("change", (n) => {
                    this.emitter_.emit("fold", new eN(this, n.sender.rawValue));
                }),
            this.rackApi_.on("change", (n) => {
                this.emitter_.emit("change", n);
            });
    }
    get expanded() {
        return this.controller.foldable.get("expanded");
    }
    set expanded(e) {
        this.controller.foldable.set("expanded", e);
    }
    get title() {
        return this.controller.props.get("title");
    }
    set title(e) {
        this.controller.props.set("title", e);
    }
    get children() {
        return this.rackApi_.children;
    }
    addBinding(e, t, n) {
        return this.rackApi_.addBinding(e, t, n);
    }
    addFolder(e) {
        return this.rackApi_.addFolder(e);
    }
    addButton(e) {
        return this.rackApi_.addButton(e);
    }
    addTab(e) {
        return this.rackApi_.addTab(e);
    }
    add(e, t) {
        return this.rackApi_.add(e, t);
    }
    remove(e) {
        this.rackApi_.remove(e);
    }
    addBlade(e) {
        return this.rackApi_.addBlade(e);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(e, (i) => {
                n(i);
            }),
            this
        );
    }
    refresh() {
        this.rackApi_.refresh();
    }
}
const UA = be("cnt");
class LN {
    constructor(e, t) {
        var n;
        (this.className_ = be(
            (n = t.viewName) !== null && n !== void 0 ? n : "fld"
        )),
            (this.element = e.createElement("div")),
            this.element.classList.add(this.className_(), UA()),
            t.viewProps.bindClassModifiers(this.element),
            (this.foldable_ = t.foldable),
            this.foldable_.bindExpandedClass(
                this.element,
                this.className_(void 0, "expanded")
            ),
            Bs(
                this.foldable_,
                "completed",
                Kr(this.element, this.className_(void 0, "cpl"))
            );
        const i = e.createElement("button");
        i.classList.add(this.className_("b")),
            Bs(t.props, "title", (l) => {
                vt(l)
                    ? this.element.classList.add(this.className_(void 0, "not"))
                    : this.element.classList.remove(
                          this.className_(void 0, "not")
                      );
            }),
            t.viewProps.bindDisabled(i),
            this.element.appendChild(i),
            (this.buttonElement = i);
        const r = e.createElement("div");
        r.classList.add(this.className_("i")), this.element.appendChild(r);
        const a = e.createElement("div");
        a.classList.add(this.className_("t")),
            D_(t.props.value("title"), a),
            this.buttonElement.appendChild(a),
            (this.titleElement = a);
        const o = e.createElement("div");
        o.classList.add(this.className_("m")),
            this.buttonElement.appendChild(o);
        const h = e.createElement("div");
        h.classList.add(this.className_("c")),
            this.element.appendChild(h),
            (this.containerElement = h);
    }
}
class uy extends V_ {
    constructor(e, t) {
        var n;
        const i = xl.create((n = t.expanded) !== null && n !== void 0 ? n : !0),
            r = new LN(e, {
                foldable: i,
                props: t.props,
                viewName: t.root ? "rot" : void 0,
                viewProps: t.viewProps,
            });
        super(
            Object.assign(Object.assign({}, t), {
                rackController: new U_({
                    blade: t.blade,
                    element: r.containerElement,
                    root: t.root,
                    viewProps: t.viewProps,
                }),
                view: r,
            })
        ),
            (this.onTitleClick_ = this.onTitleClick_.bind(this)),
            (this.props = t.props),
            (this.foldable = i),
            Gd(this.foldable, this.view.containerElement),
            this.rackController.rack.emitter.on("add", () => {
                this.foldable.cleanUpTransition();
            }),
            this.rackController.rack.emitter.on("remove", () => {
                this.foldable.cleanUpTransition();
            }),
            this.view.buttonElement.addEventListener(
                "click",
                this.onTitleClick_
            );
    }
    get document() {
        return this.view.element.ownerDocument;
    }
    importState(e) {
        return ii(
            e,
            (t) => super.importState(t),
            (t) => ({ expanded: t.required.boolean, title: t.optional.string }),
            (t) => (
                this.foldable.set("expanded", t.expanded),
                this.props.set("title", t.title),
                !0
            )
        );
    }
    exportState() {
        return ri(() => super.exportState(), {
            expanded: this.foldable.get("expanded"),
            title: this.props.get("title"),
        });
    }
    onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
    }
}
Bt({
    id: "folder",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            title: t.required.string,
            view: t.required.constant("folder"),
            expanded: t.optional.boolean,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        return new uy(s.document, {
            blade: s.blade,
            expanded: s.params.expanded,
            props: de.fromObject({ title: s.params.title }),
            viewProps: s.viewProps,
        });
    },
    api(s) {
        return s.controller instanceof uy ? new RN(s.controller, s.pool) : null;
    },
});
const ON = be("");
function dy(s, e) {
    return Kr(s, ON(void 0, e));
}
class or extends de {
    constructor(e) {
        var t;
        super(e),
            (this.onDisabledChange_ = this.onDisabledChange_.bind(this)),
            (this.onParentChange_ = this.onParentChange_.bind(this)),
            (this.onParentGlobalDisabledChange_ =
                this.onParentGlobalDisabledChange_.bind(this)),
            ([this.globalDisabled_, this.setGlobalDisabled_] = AD(
                kt(this.getGlobalDisabled_())
            )),
            this.value("disabled").emitter.on("change", this.onDisabledChange_),
            this.value("parent").emitter.on("change", this.onParentChange_),
            (t = this.get("parent")) === null ||
                t === void 0 ||
                t.globalDisabled.emitter.on(
                    "change",
                    this.onParentGlobalDisabledChange_
                );
    }
    static create(e) {
        var t, n, i;
        const r = e ?? {};
        return new or(
            de.createCore({
                disabled: (t = r.disabled) !== null && t !== void 0 ? t : !1,
                disposed: !1,
                hidden: (n = r.hidden) !== null && n !== void 0 ? n : !1,
                parent: (i = r.parent) !== null && i !== void 0 ? i : null,
            })
        );
    }
    get globalDisabled() {
        return this.globalDisabled_;
    }
    bindClassModifiers(e) {
        Rs(this.globalDisabled_, dy(e, "disabled")),
            Bs(this, "hidden", dy(e, "hidden"));
    }
    bindDisabled(e) {
        Rs(this.globalDisabled_, (t) => {
            e.disabled = t;
        });
    }
    bindTabIndex(e) {
        Rs(this.globalDisabled_, (t) => {
            e.tabIndex = t ? -1 : 0;
        });
    }
    handleDispose(e) {
        this.value("disposed").emitter.on("change", (t) => {
            t && e();
        });
    }
    importState(e) {
        this.set("disabled", e.disabled), this.set("hidden", e.hidden);
    }
    exportState() {
        return { disabled: this.get("disabled"), hidden: this.get("hidden") };
    }
    getGlobalDisabled_() {
        const e = this.get("parent");
        return (e ? e.globalDisabled.rawValue : !1) || this.get("disabled");
    }
    updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
    }
    onDisabledChange_() {
        this.updateGlobalDisabled_();
    }
    onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
    }
    onParentChange_(e) {
        var t;
        const n = e.previousRawValue;
        n == null ||
            n.globalDisabled.emitter.off(
                "change",
                this.onParentGlobalDisabledChange_
            ),
            (t = this.get("parent")) === null ||
                t === void 0 ||
                t.globalDisabled.emitter.on(
                    "change",
                    this.onParentGlobalDisabledChange_
                ),
            this.updateGlobalDisabled_();
    }
}
const fy = be("tbp");
class BN {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(fy()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(fy("c")),
            this.element.appendChild(n),
            (this.containerElement = n);
    }
}
const jl = be("tbi");
class FN {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(jl()),
            t.viewProps.bindClassModifiers(this.element),
            Bs(t.props, "selected", (r) => {
                r
                    ? this.element.classList.add(jl(void 0, "sel"))
                    : this.element.classList.remove(jl(void 0, "sel"));
            });
        const n = e.createElement("button");
        n.classList.add(jl("b")),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.buttonElement = n);
        const i = e.createElement("div");
        i.classList.add(jl("t")),
            D_(t.props.value("title"), i),
            this.buttonElement.appendChild(i),
            (this.titleElement = i);
    }
}
class $N {
    constructor(e, t) {
        (this.emitter = new wn()),
            (this.onClick_ = this.onClick_.bind(this)),
            (this.props = t.props),
            (this.viewProps = t.viewProps),
            (this.view = new FN(e, { props: t.props, viewProps: t.viewProps })),
            this.view.buttonElement.addEventListener("click", this.onClick_);
    }
    onClick_() {
        this.emitter.emit("click", { sender: this });
    }
}
class $m extends V_ {
    constructor(e, t) {
        const n = new BN(e, { viewProps: t.viewProps });
        super(
            Object.assign(Object.assign({}, t), {
                rackController: new U_({
                    blade: t.blade,
                    element: n.containerElement,
                    viewProps: t.viewProps,
                }),
                view: n,
            })
        ),
            (this.onItemClick_ = this.onItemClick_.bind(this)),
            (this.ic_ = new $N(e, {
                props: t.itemProps,
                viewProps: or.create(),
            })),
            this.ic_.emitter.on("click", this.onItemClick_),
            (this.props = t.props),
            Bs(this.props, "selected", (i) => {
                this.itemController.props.set("selected", i),
                    this.viewProps.set("hidden", !i);
            });
    }
    get itemController() {
        return this.ic_;
    }
    importState(e) {
        return ii(
            e,
            (t) => super.importState(t),
            (t) => ({ selected: t.required.boolean, title: t.required.string }),
            (t) => (
                this.ic_.props.set("selected", t.selected),
                this.ic_.props.set("title", t.title),
                !0
            )
        );
    }
    exportState() {
        return ri(() => super.exportState(), {
            selected: this.ic_.props.get("selected"),
            title: this.ic_.props.get("title"),
        });
    }
    onItemClick_() {
        this.props.set("selected", !0);
    }
}
class DN extends N_ {
    constructor(e, t) {
        super(e, t),
            (this.emitter_ = new wn()),
            (this.onSelect_ = this.onSelect_.bind(this)),
            (this.pool_ = t),
            this.rackApi_.on("change", (n) => {
                this.emitter_.emit("change", n);
            }),
            this.controller.tab.selectedIndex.emitter.on(
                "change",
                this.onSelect_
            );
    }
    get pages() {
        return this.rackApi_.children;
    }
    addPage(e) {
        const t = this.controller.view.element.ownerDocument,
            n = new $m(t, {
                blade: VA(),
                itemProps: de.fromObject({ selected: !1, title: e.title }),
                props: de.fromObject({ selected: !1 }),
                viewProps: or.create(),
            }),
            i = this.pool_.createApi(n);
        return this.rackApi_.add(i, e.index);
    }
    removePage(e) {
        this.rackApi_.remove(this.rackApi_.children[e]);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(e, (i) => {
                n(i);
            }),
            this
        );
    }
    onSelect_(e) {
        this.emitter_.emit("select", new tN(this, e.rawValue));
    }
}
class NN extends N_ {
    get title() {
        var e;
        return (e = this.controller.itemController.props.get("title")) !==
            null && e !== void 0
            ? e
            : "";
    }
    set title(e) {
        this.controller.itemController.props.set("title", e);
    }
    get selected() {
        return this.controller.props.get("selected");
    }
    set selected(e) {
        this.controller.props.set("selected", e);
    }
    get children() {
        return this.rackApi_.children;
    }
    addButton(e) {
        return this.rackApi_.addButton(e);
    }
    addFolder(e) {
        return this.rackApi_.addFolder(e);
    }
    addTab(e) {
        return this.rackApi_.addTab(e);
    }
    add(e, t) {
        this.rackApi_.add(e, t);
    }
    remove(e) {
        this.rackApi_.remove(e);
    }
    addBinding(e, t, n) {
        return this.rackApi_.addBinding(e, t, n);
    }
    addBlade(e) {
        return this.rackApi_.addBlade(e);
    }
    refresh() {
        this.rackApi_.refresh();
    }
}
const py = -1;
class VN {
    constructor() {
        (this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this)),
            (this.empty = kt(!0)),
            (this.selectedIndex = kt(py)),
            (this.items_ = []);
    }
    add(e, t) {
        const n = t ?? this.items_.length;
        this.items_.splice(n, 0, e),
            e.emitter.on("change", this.onItemSelectedChange_),
            this.keepSelection_();
    }
    remove(e) {
        const t = this.items_.indexOf(e);
        t < 0 ||
            (this.items_.splice(t, 1),
            e.emitter.off("change", this.onItemSelectedChange_),
            this.keepSelection_());
    }
    keepSelection_() {
        if (this.items_.length === 0) {
            (this.selectedIndex.rawValue = py), (this.empty.rawValue = !0);
            return;
        }
        const e = this.items_.findIndex((t) => t.rawValue);
        e < 0
            ? (this.items_.forEach((t, n) => {
                  t.rawValue = n === 0;
              }),
              (this.selectedIndex.rawValue = 0))
            : (this.items_.forEach((t, n) => {
                  t.rawValue = n === e;
              }),
              (this.selectedIndex.rawValue = e)),
            (this.empty.rawValue = !1);
    }
    onItemSelectedChange_(e) {
        if (e.rawValue) {
            const t = this.items_.findIndex((n) => n === e.sender);
            this.items_.forEach((n, i) => {
                n.rawValue = i === t;
            }),
                (this.selectedIndex.rawValue = t);
        } else this.keepSelection_();
    }
}
const Wl = be("tab");
class UN {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(Wl(), UA()),
            t.viewProps.bindClassModifiers(this.element),
            Rs(t.empty, Kr(this.element, Wl(void 0, "nop")));
        const n = e.createElement("div");
        n.classList.add(Wl("t")),
            this.element.appendChild(n),
            (this.itemsElement = n);
        const i = e.createElement("div");
        i.classList.add(Wl("i")), this.element.appendChild(i);
        const r = e.createElement("div");
        r.classList.add(Wl("c")),
            this.element.appendChild(r),
            (this.contentsElement = r);
    }
}
class my extends V_ {
    constructor(e, t) {
        const n = new VN(),
            i = new UN(e, { empty: n.empty, viewProps: t.viewProps });
        super({
            blade: t.blade,
            rackController: new U_({
                blade: t.blade,
                element: i.contentsElement,
                viewProps: t.viewProps,
            }),
            view: i,
        }),
            (this.onRackAdd_ = this.onRackAdd_.bind(this)),
            (this.onRackRemove_ = this.onRackRemove_.bind(this));
        const r = this.rackController.rack;
        r.emitter.on("add", this.onRackAdd_),
            r.emitter.on("remove", this.onRackRemove_),
            (this.tab = n);
    }
    add(e, t) {
        this.rackController.rack.add(e, t);
    }
    remove(e) {
        this.rackController.rack.remove(this.rackController.rack.children[e]);
    }
    onRackAdd_(e) {
        if (!e.root) return;
        const t = e.bladeController;
        BA(this.view.itemsElement, t.itemController.view.element, e.index),
            t.itemController.viewProps.set("parent", this.viewProps),
            this.tab.add(t.props.value("selected"));
    }
    onRackRemove_(e) {
        if (!e.root) return;
        const t = e.bladeController;
        F_(t.itemController.view.element),
            t.itemController.viewProps.set("parent", null),
            this.tab.remove(t.props.value("selected"));
    }
}
Bt({
    id: "tab",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            pages: t.required.array(
                t.required.object({ title: t.required.string })
            ),
            view: t.required.constant("tab"),
        }));
        return !e || e.pages.length === 0 ? null : { params: e };
    },
    controller(s) {
        const e = new my(s.document, {
            blade: s.blade,
            viewProps: s.viewProps,
        });
        return (
            s.params.pages.forEach((t) => {
                const n = new $m(s.document, {
                    blade: VA(),
                    itemProps: de.fromObject({ selected: !1, title: t.title }),
                    props: de.fromObject({ selected: !1 }),
                    viewProps: or.create(),
                });
                e.add(n);
            }),
            e
        );
    },
    api(s) {
        return s.controller instanceof my
            ? new DN(s.controller, s.pool)
            : s.controller instanceof $m
            ? new NN(s.controller, s.pool)
            : null;
    },
});
class z_ extends B_ {
    get options() {
        return this.controller.valueController.props.get("options");
    }
    set options(e) {
        this.controller.valueController.props.set("options", e);
    }
}
class zN {
    constructor() {
        (this.disabled = !1), (this.emitter = new wn());
    }
    dispose() {}
    tick() {
        this.disabled || this.emitter.emit("tick", { sender: this });
    }
}
class YN {
    constructor(e, t) {
        (this.disabled_ = !1),
            (this.timerId_ = null),
            (this.onTick_ = this.onTick_.bind(this)),
            (this.doc_ = e),
            (this.emitter = new wn()),
            (this.interval_ = t),
            this.setTimer_();
    }
    get disabled() {
        return this.disabled_;
    }
    set disabled(e) {
        (this.disabled_ = e),
            this.disabled_ ? this.clearTimer_() : this.setTimer_();
    }
    dispose() {
        this.clearTimer_();
    }
    clearTimer_() {
        if (this.timerId_ === null) return;
        const e = this.doc_.defaultView;
        e && e.clearInterval(this.timerId_), (this.timerId_ = null);
    }
    setTimer_() {
        if ((this.clearTimer_(), this.interval_ <= 0)) return;
        const e = this.doc_.defaultView;
        e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
    }
    onTick_() {
        this.disabled_ || this.emitter.emit("tick", { sender: this });
    }
}
class Cl {
    constructor(e) {
        this.constraints = e;
    }
    constrain(e) {
        return this.constraints.reduce((t, n) => n.constrain(t), e);
    }
}
function Jh(s, e) {
    if (s instanceof e) return s;
    if (s instanceof Cl) {
        const t = s.constraints.reduce(
            (n, i) => n || (i instanceof e ? i : null),
            null
        );
        if (t) return t;
    }
    return null;
}
class jd {
    constructor(e) {
        this.values = de.fromObject({ options: e });
    }
    constrain(e) {
        const t = this.values.get("options");
        return t.length === 0 || t.filter((i) => i.value === e).length > 0
            ? e
            : t[0].value;
    }
}
function Wd(s) {
    var e;
    const t = Bm;
    if (Array.isArray(s))
        return (e = Tt({ items: s }, (n) => ({
            items: n.required.array(
                n.required.object({
                    text: n.required.string,
                    value: n.required.raw,
                })
            ),
        }))) === null || e === void 0
            ? void 0
            : e.items;
    if (typeof s == "object") return t.required.raw(s).value;
}
function zA(s) {
    if (Array.isArray(s)) return s;
    const e = [];
    return (
        Object.keys(s).forEach((t) => {
            e.push({ text: t, value: s[t] });
        }),
        e
    );
}
function Y_(s) {
    return vt(s) ? null : new jd(zA(s));
}
const mp = be("lst");
class GN {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.props_ = t.props),
            (this.element = e.createElement("div")),
            this.element.classList.add(mp()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("select");
        n.classList.add(mp("s")),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.selectElement = n);
        const i = e.createElement("div");
        i.classList.add(mp("m")),
            i.appendChild(zd(e, "dropdown")),
            this.element.appendChild(i),
            t.value.emitter.on("change", this.onValueChange_),
            (this.value_ = t.value),
            Bs(this.props_, "options", (r) => {
                FA(this.selectElement),
                    r.forEach((a) => {
                        const o = e.createElement("option");
                        (o.textContent = a.text),
                            this.selectElement.appendChild(o);
                    }),
                    this.update_();
            });
    }
    update_() {
        const e = this.props_.get("options").map((t) => t.value);
        this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue);
    }
    onValueChange_() {
        this.update_();
    }
}
class hl {
    constructor(e, t) {
        (this.onSelectChange_ = this.onSelectChange_.bind(this)),
            (this.props = t.props),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new GN(e, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.selectElement.addEventListener(
                "change",
                this.onSelectChange_
            );
    }
    onSelectChange_(e) {
        const t = e.currentTarget;
        this.value.rawValue = this.props.get("options")[t.selectedIndex].value;
    }
    importProps(e) {
        return ii(
            e,
            null,
            (t) => ({ options: t.required.custom(Wd) }),
            (t) => (this.props.set("options", zA(t.options)), !0)
        );
    }
    exportProps() {
        return ri(null, { options: this.props.get("options") });
    }
}
const gy = be("pop");
class jN {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(gy()),
            t.viewProps.bindClassModifiers(this.element),
            Rs(t.shows, Kr(this.element, gy(void 0, "v")));
    }
}
class G_ {
    constructor(e, t) {
        (this.shows = kt(!1)),
            (this.viewProps = t.viewProps),
            (this.view = new jN(e, {
                shows: this.shows,
                viewProps: this.viewProps,
            }));
    }
}
const _y = be("txt");
class WN {
    constructor(e, t) {
        (this.onChange_ = this.onChange_.bind(this)),
            (this.element = e.createElement("div")),
            this.element.classList.add(_y()),
            t.viewProps.bindClassModifiers(this.element),
            (this.props_ = t.props),
            this.props_.emitter.on("change", this.onChange_);
        const n = e.createElement("input");
        n.classList.add(_y("i")),
            (n.type = "text"),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.inputElement = n),
            t.value.emitter.on("change", this.onChange_),
            (this.value_ = t.value),
            this.refresh();
    }
    refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value_.rawValue);
    }
    onChange_() {
        this.refresh();
    }
}
class Xd {
    constructor(e, t) {
        (this.onInputChange_ = this.onInputChange_.bind(this)),
            (this.parser_ = t.parser),
            (this.props = t.props),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new WN(e, {
                props: t.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.inputElement.addEventListener(
                "change",
                this.onInputChange_
            );
    }
    onInputChange_(e) {
        const n = e.currentTarget.value,
            i = this.parser_(n);
        vt(i) || (this.value.rawValue = i), this.view.refresh();
    }
}
function XN(s) {
    return String(s);
}
function j_(s) {
    return s === "false" ? !1 : !!s;
}
function vy(s) {
    return XN(s);
}
function qN(s) {
    return (e) => s.reduce((t, n) => (t !== null ? t : n(e)), null);
}
const HN = cn(0);
function td(s) {
    return HN(s) + "%";
}
function W_(s) {
    return String(s);
}
function Dm(s) {
    return s;
}
function eo({ primary: s, secondary: e, forward: t, backward: n }) {
    let i = !1;
    function r(a) {
        i || ((i = !0), a(), (i = !1));
    }
    s.emitter.on("change", (a) => {
        r(() => {
            e.setRawValue(t(s.rawValue, e.rawValue), a.options);
        });
    }),
        e.emitter.on("change", (a) => {
            r(() => {
                s.setRawValue(n(s.rawValue, e.rawValue), a.options);
            }),
                r(() => {
                    e.setRawValue(t(s.rawValue, e.rawValue), a.options);
                });
        }),
        r(() => {
            e.setRawValue(t(s.rawValue, e.rawValue), {
                forceEmit: !1,
                last: !0,
            });
        });
}
function Kt(s, e) {
    const t = s * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
    return e.upKey ? +t : e.downKey ? -t : 0;
}
function za(s) {
    return {
        altKey: s.altKey,
        downKey: s.key === "ArrowDown",
        shiftKey: s.shiftKey,
        upKey: s.key === "ArrowUp",
    };
}
function Qs(s) {
    return {
        altKey: s.altKey,
        downKey: s.key === "ArrowLeft",
        shiftKey: s.shiftKey,
        upKey: s.key === "ArrowRight",
    };
}
function KN(s) {
    return s === "ArrowUp" || s === "ArrowDown";
}
function nd(s) {
    return KN(s) || s === "ArrowLeft" || s === "ArrowRight";
}
function gp(s, e) {
    var t, n;
    const i = e.ownerDocument.defaultView,
        r = e.getBoundingClientRect();
    return {
        x:
            s.pageX -
            (((t = i && i.scrollX) !== null && t !== void 0 ? t : 0) + r.left),
        y:
            s.pageY -
            (((n = i && i.scrollY) !== null && n !== void 0 ? n : 0) + r.top),
    };
}
class cr {
    constructor(e) {
        (this.lastTouch_ = null),
            (this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
            (this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
            (this.onMouseDown_ = this.onMouseDown_.bind(this)),
            (this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
            (this.onTouchMove_ = this.onTouchMove_.bind(this)),
            (this.onTouchStart_ = this.onTouchStart_.bind(this)),
            (this.elem_ = e),
            (this.emitter = new wn()),
            e.addEventListener("touchstart", this.onTouchStart_, {
                passive: !1,
            }),
            e.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }),
            e.addEventListener("touchend", this.onTouchEnd_),
            e.addEventListener("mousedown", this.onMouseDown_);
    }
    computePosition_(e) {
        const t = this.elem_.getBoundingClientRect();
        return {
            bounds: { width: t.width, height: t.height },
            point: e ? { x: e.x, y: e.y } : null,
        };
    }
    onMouseDown_(e) {
        var t;
        e.preventDefault(),
            (t = e.currentTarget) === null || t === void 0 || t.focus();
        const n = this.elem_.ownerDocument;
        n.addEventListener("mousemove", this.onDocumentMouseMove_),
            n.addEventListener("mouseup", this.onDocumentMouseUp_),
            this.emitter.emit("down", {
                altKey: e.altKey,
                data: this.computePosition_(gp(e, this.elem_)),
                sender: this,
                shiftKey: e.shiftKey,
            });
    }
    onDocumentMouseMove_(e) {
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(gp(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey,
        });
    }
    onDocumentMouseUp_(e) {
        const t = this.elem_.ownerDocument;
        t.removeEventListener("mousemove", this.onDocumentMouseMove_),
            t.removeEventListener("mouseup", this.onDocumentMouseUp_),
            this.emitter.emit("up", {
                altKey: e.altKey,
                data: this.computePosition_(gp(e, this.elem_)),
                sender: this,
                shiftKey: e.shiftKey,
            });
    }
    onTouchStart_(e) {
        e.preventDefault();
        const t = e.targetTouches.item(0),
            n = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(
                t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        }),
            (this.lastTouch_ = t);
    }
    onTouchMove_(e) {
        const t = e.targetTouches.item(0),
            n = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(
                t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        }),
            (this.lastTouch_ = t);
    }
    onTouchEnd_(e) {
        var t;
        const n =
                (t = e.targetTouches.item(0)) !== null && t !== void 0
                    ? t
                    : this.lastTouch_,
            i = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(
                n ? { x: n.clientX - i.left, y: n.clientY - i.top } : void 0
            ),
            sender: this,
            shiftKey: e.shiftKey,
        });
    }
}
const _s = be("txt");
class ZN {
    constructor(e, t) {
        (this.onChange_ = this.onChange_.bind(this)),
            (this.props_ = t.props),
            this.props_.emitter.on("change", this.onChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(_s(), _s(void 0, "num")),
            t.arrayPosition &&
                this.element.classList.add(_s(void 0, t.arrayPosition)),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("input");
        n.classList.add(_s("i")),
            (n.type = "text"),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.inputElement = n),
            (this.onDraggingChange_ = this.onDraggingChange_.bind(this)),
            (this.dragging_ = t.dragging),
            this.dragging_.emitter.on("change", this.onDraggingChange_),
            this.element.classList.add(_s()),
            this.inputElement.classList.add(_s("i"));
        const i = e.createElement("div");
        i.classList.add(_s("k")),
            this.element.appendChild(i),
            (this.knobElement = i);
        const r = e.createElementNS(Ht, "svg");
        r.classList.add(_s("g")), this.knobElement.appendChild(r);
        const a = e.createElementNS(Ht, "path");
        a.classList.add(_s("gb")), r.appendChild(a), (this.guideBodyElem_ = a);
        const o = e.createElementNS(Ht, "path");
        o.classList.add(_s("gh")), r.appendChild(o), (this.guideHeadElem_ = o);
        const h = e.createElement("div");
        h.classList.add(be("tt")()),
            this.knobElement.appendChild(h),
            (this.tooltipElem_ = h),
            t.value.emitter.on("change", this.onChange_),
            (this.value = t.value),
            this.refresh();
    }
    onDraggingChange_(e) {
        if (e.rawValue === null) {
            this.element.classList.remove(_s(void 0, "drg"));
            return;
        }
        this.element.classList.add(_s(void 0, "drg"));
        const t = e.rawValue / this.props_.get("pointerScale"),
            n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
            i = At(-n, -4, 4);
        this.guideHeadElem_.setAttributeNS(
            null,
            "d",
            [`M ${n + i},0 L${n},4 L${n + i},8`, `M ${t},-1 L${t},9`].join(" ")
        ),
            this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
        const r = this.props_.get("formatter");
        (this.tooltipElem_.textContent = r(this.value.rawValue)),
            (this.tooltipElem_.style.left = `${t}px`);
    }
    refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value.rawValue);
    }
    onChange_() {
        this.refresh();
    }
}
class bc {
    constructor(e, t) {
        var n;
        (this.originRawValue_ = 0),
            (this.onInputChange_ = this.onInputChange_.bind(this)),
            (this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
            (this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.parser_ = t.parser),
            (this.props = t.props),
            (this.sliderProps_ =
                (n = t.sliderProps) !== null && n !== void 0 ? n : null),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.dragging_ = kt(null)),
            (this.view = new ZN(e, {
                arrayPosition: t.arrayPosition,
                dragging: this.dragging_,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.inputElement.addEventListener(
                "change",
                this.onInputChange_
            ),
            this.view.inputElement.addEventListener(
                "keydown",
                this.onInputKeyDown_
            ),
            this.view.inputElement.addEventListener(
                "keyup",
                this.onInputKeyUp_
            );
        const i = new cr(this.view.knobElement);
        i.emitter.on("down", this.onPointerDown_),
            i.emitter.on("move", this.onPointerMove_),
            i.emitter.on("up", this.onPointerUp_);
    }
    constrainValue_(e) {
        var t, n;
        const i =
                (t = this.sliderProps_) === null || t === void 0
                    ? void 0
                    : t.get("min"),
            r =
                (n = this.sliderProps_) === null || n === void 0
                    ? void 0
                    : n.get("max");
        let a = e;
        return (
            i !== void 0 && (a = Math.max(a, i)),
            r !== void 0 && (a = Math.min(a, r)),
            a
        );
    }
    onInputChange_(e) {
        const n = e.currentTarget.value,
            i = this.parser_(n);
        vt(i) || (this.value.rawValue = this.constrainValue_(i)),
            this.view.refresh();
    }
    onInputKeyDown_(e) {
        const t = Kt(this.props.get("keyScale"), za(e));
        t !== 0 &&
            this.value.setRawValue(
                this.constrainValue_(this.value.rawValue + t),
                { forceEmit: !1, last: !1 }
            );
    }
    onInputKeyUp_(e) {
        Kt(this.props.get("keyScale"), za(e)) !== 0 &&
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
    onPointerDown_() {
        (this.originRawValue_ = this.value.rawValue),
            (this.dragging_.rawValue = 0);
    }
    computeDraggingValue_(e) {
        if (!e.point) return null;
        const t = e.point.x - e.bounds.width / 2;
        return this.constrainValue_(
            this.originRawValue_ + t * this.props.get("pointerScale")
        );
    }
    onPointerMove_(e) {
        const t = this.computeDraggingValue_(e.data);
        t !== null &&
            (this.value.setRawValue(t, { forceEmit: !1, last: !1 }),
            (this.dragging_.rawValue =
                this.value.rawValue - this.originRawValue_));
    }
    onPointerUp_(e) {
        const t = this.computeDraggingValue_(e.data);
        t !== null &&
            (this.value.setRawValue(t, { forceEmit: !0, last: !0 }),
            (this.dragging_.rawValue = null));
    }
}
const _p = be("sld");
class QN {
    constructor(e, t) {
        (this.onChange_ = this.onChange_.bind(this)),
            (this.props_ = t.props),
            this.props_.emitter.on("change", this.onChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(_p()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(_p("t")),
            t.viewProps.bindTabIndex(n),
            this.element.appendChild(n),
            (this.trackElement = n);
        const i = e.createElement("div");
        i.classList.add(_p("k")),
            this.trackElement.appendChild(i),
            (this.knobElement = i),
            t.value.emitter.on("change", this.onChange_),
            (this.value = t.value),
            this.update_();
    }
    update_() {
        const e = At(
            ue(
                this.value.rawValue,
                this.props_.get("min"),
                this.props_.get("max"),
                0,
                100
            ),
            0,
            100
        );
        this.knobElement.style.width = `${e}%`;
    }
    onChange_() {
        this.update_();
    }
}
class JN {
    constructor(e, t) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
            (this.onKeyUp_ = this.onKeyUp_.bind(this)),
            (this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.props = t.props),
            (this.view = new QN(e, {
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.ptHandler_ = new cr(this.view.trackElement)),
            this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
            this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
            this.ptHandler_.emitter.on("up", this.onPointerUp_),
            this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
            this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
    }
    handlePointerEvent_(e, t) {
        e.point &&
            this.value.setRawValue(
                ue(
                    At(e.point.x, 0, e.bounds.width),
                    0,
                    e.bounds.width,
                    this.props.get("min"),
                    this.props.get("max")
                ),
                t
            );
    }
    onPointerDownOrMove_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
    }
    onKeyDown_(e) {
        const t = Kt(this.props.get("keyScale"), Qs(e));
        t !== 0 &&
            this.value.setRawValue(this.value.rawValue + t, {
                forceEmit: !1,
                last: !1,
            });
    }
    onKeyUp_(e) {
        Kt(this.props.get("keyScale"), Qs(e)) !== 0 &&
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
const vp = be("sldtxt");
class e9 {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(vp());
        const n = e.createElement("div");
        n.classList.add(vp("s")),
            (this.sliderView_ = t.sliderView),
            n.appendChild(this.sliderView_.element),
            this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(vp("t")),
            (this.textView_ = t.textView),
            i.appendChild(this.textView_.element),
            this.element.appendChild(i);
    }
}
class by {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.sliderC_ = new JN(e, {
                props: t.sliderProps,
                value: t.value,
                viewProps: this.viewProps,
            })),
            (this.textC_ = new bc(e, {
                parser: t.parser,
                props: t.textProps,
                sliderProps: t.sliderProps,
                value: t.value,
                viewProps: t.viewProps,
            })),
            (this.view = new e9(e, {
                sliderView: this.sliderC_.view,
                textView: this.textC_.view,
            }));
    }
    get sliderController() {
        return this.sliderC_;
    }
    get textController() {
        return this.textC_;
    }
    importProps(e) {
        return ii(
            e,
            null,
            (t) => ({ max: t.required.number, min: t.required.number }),
            (t) => {
                const n = this.sliderC_.props;
                return n.set("max", t.max), n.set("min", t.min), !0;
            }
        );
    }
    exportProps() {
        const e = this.sliderC_.props;
        return ri(null, { max: e.get("max"), min: e.get("min") });
    }
}
function t9(s) {
    return {
        sliderProps: new de({ keyScale: s.keyScale, max: s.max, min: s.min }),
        textProps: new de({
            formatter: kt(s.formatter),
            keyScale: s.keyScale,
            pointerScale: kt(s.pointerScale),
        }),
    };
}
const n9 = { containerUnitSize: "cnt-usz" };
function YA(s) {
    return `--${n9[s]}`;
}
class GA {
    constructor(e, t) {
        const n = be(t.viewName);
        (this.element = e.createElement("div")),
            this.element.classList.add(n()),
            t.viewProps.bindClassModifiers(this.element);
    }
}
function ec(s) {
    return L_(s);
}
function Br(s) {
    if (Om(s)) return Tt(s, ec);
}
function Hi(s, e) {
    if (!s) return;
    const t = [],
        n = M_(s, e);
    n && t.push(n);
    const i = I_(s);
    return i && t.push(i), new Cl(t);
}
function jA(s) {
    if (s === "inline" || s === "popup") return s;
}
function Zr(s, e) {
    s.write(e);
}
const qc = be("ckb");
class s9 {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.element = e.createElement("div")),
            this.element.classList.add(qc()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("label");
        n.classList.add(qc("l")), this.element.appendChild(n);
        const i = e.createElement("input");
        i.classList.add(qc("i")),
            (i.type = "checkbox"),
            n.appendChild(i),
            (this.inputElement = i),
            t.viewProps.bindDisabled(this.inputElement);
        const r = e.createElement("div");
        r.classList.add(qc("w")), n.appendChild(r);
        const a = zd(e, "check");
        r.appendChild(a),
            t.value.emitter.on("change", this.onValueChange_),
            (this.value = t.value),
            this.update_();
    }
    update_() {
        this.inputElement.checked = this.value.rawValue;
    }
    onValueChange_() {
        this.update_();
    }
}
class i9 {
    constructor(e, t) {
        (this.onInputChange_ = this.onInputChange_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new s9(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.inputElement.addEventListener(
                "change",
                this.onInputChange_
            );
    }
    onInputChange_(e) {
        const t = e.currentTarget;
        this.value.rawValue = t.checked;
    }
}
function r9(s) {
    const e = [],
        t = Y_(s.options);
    return t && e.push(t), new Cl(e);
}
Bt({
    id: "input-bool",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "boolean") return null;
        const t = Tt(e, (n) => ({
            options: n.optional.custom(Wd),
            readonly: n.optional.constant(!1),
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => j_,
        constraint: (s) => r9(s.params),
        writer: (s) => Zr,
    },
    controller: (s) => {
        const e = s.document,
            t = s.value,
            n = s.constraint,
            i = n && Jh(n, jd);
        return i
            ? new hl(e, {
                  props: new de({ options: i.values.value("options") }),
                  value: t,
                  viewProps: s.viewProps,
              })
            : new i9(e, { value: t, viewProps: s.viewProps });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "boolean"
            ? null
            : s.controller.valueController instanceof hl
            ? new z_(s.controller)
            : null;
    },
});
const sa = be("col");
class a9 {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(sa()),
            t.foldable.bindExpandedClass(this.element, sa(void 0, "expanded")),
            Bs(t.foldable, "completed", Kr(this.element, sa(void 0, "cpl")));
        const n = e.createElement("div");
        n.classList.add(sa("h")), this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(sa("s")), n.appendChild(i), (this.swatchElement = i);
        const r = e.createElement("div");
        if (
            (r.classList.add(sa("t")),
            n.appendChild(r),
            (this.textElement = r),
            t.pickerLayout === "inline")
        ) {
            const a = e.createElement("div");
            a.classList.add(sa("p")),
                this.element.appendChild(a),
                (this.pickerElement = a);
        } else this.pickerElement = null;
    }
}
function o9(s, e, t) {
    const n = At(s / 255, 0, 1),
        i = At(e / 255, 0, 1),
        r = At(t / 255, 0, 1),
        a = Math.max(n, i, r),
        o = Math.min(n, i, r),
        h = a - o;
    let l = 0,
        u = 0;
    const c = (o + a) / 2;
    return (
        h !== 0 &&
            ((u = h / (1 - Math.abs(a + o - 1))),
            n === a
                ? (l = (i - r) / h)
                : i === a
                ? (l = 2 + (r - n) / h)
                : (l = 4 + (n - i) / h),
            (l = l / 6 + (l < 0 ? 1 : 0))),
        [l * 360, u * 100, c * 100]
    );
}
function l9(s, e, t) {
    const n = ((s % 360) + 360) % 360,
        i = At(e / 100, 0, 1),
        r = At(t / 100, 0, 1),
        a = (1 - Math.abs(2 * r - 1)) * i,
        o = a * (1 - Math.abs(((n / 60) % 2) - 1)),
        h = r - a / 2;
    let l, u, c;
    return (
        n >= 0 && n < 60
            ? ([l, u, c] = [a, o, 0])
            : n >= 60 && n < 120
            ? ([l, u, c] = [o, a, 0])
            : n >= 120 && n < 180
            ? ([l, u, c] = [0, a, o])
            : n >= 180 && n < 240
            ? ([l, u, c] = [0, o, a])
            : n >= 240 && n < 300
            ? ([l, u, c] = [o, 0, a])
            : ([l, u, c] = [a, 0, o]),
        [(l + h) * 255, (u + h) * 255, (c + h) * 255]
    );
}
function h9(s, e, t) {
    const n = At(s / 255, 0, 1),
        i = At(e / 255, 0, 1),
        r = At(t / 255, 0, 1),
        a = Math.max(n, i, r),
        o = Math.min(n, i, r),
        h = a - o;
    let l;
    h === 0
        ? (l = 0)
        : a === n
        ? (l = 60 * (((((i - r) / h) % 6) + 6) % 6))
        : a === i
        ? (l = 60 * ((r - n) / h + 2))
        : (l = 60 * ((n - i) / h + 4));
    const u = a === 0 ? 0 : h / a,
        c = a;
    return [l, u * 100, c * 100];
}
function WA(s, e, t) {
    const n = LA(s, 360),
        i = At(e / 100, 0, 1),
        r = At(t / 100, 0, 1),
        a = r * i,
        o = a * (1 - Math.abs(((n / 60) % 2) - 1)),
        h = r - a;
    let l, u, c;
    return (
        n >= 0 && n < 60
            ? ([l, u, c] = [a, o, 0])
            : n >= 60 && n < 120
            ? ([l, u, c] = [o, a, 0])
            : n >= 120 && n < 180
            ? ([l, u, c] = [0, a, o])
            : n >= 180 && n < 240
            ? ([l, u, c] = [0, o, a])
            : n >= 240 && n < 300
            ? ([l, u, c] = [o, 0, a])
            : ([l, u, c] = [a, 0, o]),
        [(l + h) * 255, (u + h) * 255, (c + h) * 255]
    );
}
function c9(s, e, t) {
    const n = t + (e * (100 - Math.abs(2 * t - 100))) / 200;
    return [
        s,
        n !== 0 ? (e * (100 - Math.abs(2 * t - 100))) / n : 0,
        t + (e * (100 - Math.abs(2 * t - 100))) / 200,
    ];
}
function u9(s, e, t) {
    const n = 100 - Math.abs((t * (200 - e)) / 100 - 100);
    return [s, n !== 0 ? (e * t) / n : 0, (t * (200 - e)) / 200];
}
function ki(s) {
    return [s[0], s[1], s[2]];
}
function qd(s, e) {
    return [s[0], s[1], s[2], e];
}
const d9 = {
    hsl: { hsl: (s, e, t) => [s, e, t], hsv: c9, rgb: l9 },
    hsv: { hsl: u9, hsv: (s, e, t) => [s, e, t], rgb: WA },
    rgb: { hsl: o9, hsv: h9, rgb: (s, e, t) => [s, e, t] },
};
function cl(s, e) {
    return [
        e === "float" ? 1 : s === "rgb" ? 255 : 360,
        e === "float" ? 1 : s === "rgb" ? 255 : 100,
        e === "float" ? 1 : s === "rgb" ? 255 : 100,
    ];
}
function f9(s, e) {
    return s === e ? e : LA(s, e);
}
function XA(s, e, t) {
    var n;
    const i = cl(e, t);
    return [
        e === "rgb" ? At(s[0], 0, i[0]) : f9(s[0], i[0]),
        At(s[1], 0, i[1]),
        At(s[2], 0, i[2]),
        At((n = s[3]) !== null && n !== void 0 ? n : 1, 0, 1),
    ];
}
function yy(s, e, t, n) {
    const i = cl(e, t),
        r = cl(e, n);
    return s.map((a, o) => (a / i[o]) * r[o]);
}
function qA(s, e, t) {
    const n = yy(s, e.mode, e.type, "int"),
        i = d9[e.mode][t.mode](...n);
    return yy(i, t.mode, "int", t.type);
}
class Be {
    static black() {
        return new Be([0, 0, 0], "rgb");
    }
    constructor(e, t) {
        (this.type = "int"),
            (this.mode = t),
            (this.comps_ = XA(e, t, this.type));
    }
    getComponents(e) {
        return qd(
            qA(
                ki(this.comps_),
                { mode: this.mode, type: this.type },
                { mode: e ?? this.mode, type: this.type }
            ),
            this.comps_[3]
        );
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return { r: e[0], g: e[1], b: e[2], a: e[3] };
    }
}
const mr = be("colp");
class p9 {
    constructor(e, t) {
        (this.alphaViews_ = null),
            (this.element = e.createElement("div")),
            this.element.classList.add(mr()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(mr("hsv"));
        const i = e.createElement("div");
        i.classList.add(mr("sv")),
            (this.svPaletteView_ = t.svPaletteView),
            i.appendChild(this.svPaletteView_.element),
            n.appendChild(i);
        const r = e.createElement("div");
        r.classList.add(mr("h")),
            (this.hPaletteView_ = t.hPaletteView),
            r.appendChild(this.hPaletteView_.element),
            n.appendChild(r),
            this.element.appendChild(n);
        const a = e.createElement("div");
        if (
            (a.classList.add(mr("rgb")),
            (this.textsView_ = t.textsView),
            a.appendChild(this.textsView_.element),
            this.element.appendChild(a),
            t.alphaViews)
        ) {
            this.alphaViews_ = {
                palette: t.alphaViews.palette,
                text: t.alphaViews.text,
            };
            const o = e.createElement("div");
            o.classList.add(mr("a"));
            const h = e.createElement("div");
            h.classList.add(mr("ap")),
                h.appendChild(this.alphaViews_.palette.element),
                o.appendChild(h);
            const l = e.createElement("div");
            l.classList.add(mr("at")),
                l.appendChild(this.alphaViews_.text.element),
                o.appendChild(l),
                this.element.appendChild(o);
        }
    }
    get allFocusableElements() {
        const e = [
            this.svPaletteView_.element,
            this.hPaletteView_.element,
            this.textsView_.modeSelectElement,
            ...this.textsView_.inputViews.map((t) => t.inputElement),
        ];
        return (
            this.alphaViews_ &&
                e.push(
                    this.alphaViews_.palette.element,
                    this.alphaViews_.text.inputElement
                ),
            e
        );
    }
}
function m9(s) {
    return s === "int" ? "int" : s === "float" ? "float" : void 0;
}
function X_(s) {
    return Tt(s, (e) => ({
        color: e.optional.object({
            alpha: e.optional.boolean,
            type: e.optional.custom(m9),
        }),
        expanded: e.optional.boolean,
        picker: e.optional.custom(jA),
        readonly: e.optional.constant(!1),
    }));
}
function Ya(s) {
    return s ? 0.1 : 1;
}
function HA(s) {
    var e;
    return (e = s.color) === null || e === void 0 ? void 0 : e.type;
}
class q_ {
    constructor(e, t) {
        (this.type = "float"),
            (this.mode = t),
            (this.comps_ = XA(e, t, this.type));
    }
    getComponents(e) {
        return qd(
            qA(
                ki(this.comps_),
                { mode: this.mode, type: this.type },
                { mode: e ?? this.mode, type: this.type }
            ),
            this.comps_[3]
        );
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return { r: e[0], g: e[1], b: e[2], a: e[3] };
    }
}
const g9 = { int: (s, e) => new Be(s, e), float: (s, e) => new q_(s, e) };
function H_(s, e, t) {
    return g9[t](s, e);
}
function _9(s) {
    return s.type === "float";
}
function v9(s) {
    return s.type === "int";
}
function b9(s) {
    const e = s.getComponents(),
        t = cl(s.mode, "int");
    return new Be(
        [
            Math.round(ue(e[0], 0, 1, 0, t[0])),
            Math.round(ue(e[1], 0, 1, 0, t[1])),
            Math.round(ue(e[2], 0, 1, 0, t[2])),
            e[3],
        ],
        s.mode
    );
}
function y9(s) {
    const e = s.getComponents(),
        t = cl(s.mode, "int");
    return new q_(
        [
            ue(e[0], 0, t[0], 0, 1),
            ue(e[1], 0, t[1], 0, 1),
            ue(e[2], 0, t[2], 0, 1),
            e[3],
        ],
        s.mode
    );
}
function Tn(s, e) {
    if (s.type === e) return s;
    if (v9(s) && e === "float") return y9(s);
    if (_9(s) && e === "int") return b9(s);
    throw An.shouldNeverHappen();
}
function w9(s, e) {
    return (
        s.alpha === e.alpha &&
        s.mode === e.mode &&
        s.notation === e.notation &&
        s.type === e.type
    );
}
function ks(s, e) {
    const t = s.match(/^(.+)%$/);
    return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(s), e);
}
const x9 = {
    deg: (s) => s,
    grad: (s) => (s * 360) / 400,
    rad: (s) => (s * 360) / (2 * Math.PI),
    turn: (s) => s * 360,
};
function KA(s) {
    const e = s.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
    if (!e) return parseFloat(s);
    const t = parseFloat(e[1]),
        n = e[2];
    return x9[n](t);
}
function ZA(s) {
    const e = s.match(
        /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [ks(e[1], 255), ks(e[2], 255), ks(e[3], 255)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function C9(s) {
    const e = ZA(s);
    return e ? new Be(e, "rgb") : null;
}
function QA(s) {
    const e = s.match(
        /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [ks(e[1], 255), ks(e[2], 255), ks(e[3], 255), ks(e[4], 1)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function A9(s) {
    const e = QA(s);
    return e ? new Be(e, "rgb") : null;
}
function JA(s) {
    const e = s.match(
        /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [KA(e[1]), ks(e[2], 100), ks(e[3], 100)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function S9(s) {
    const e = JA(s);
    return e ? new Be(e, "hsl") : null;
}
function eS(s) {
    const e = s.match(
        /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
    );
    if (!e) return null;
    const t = [KA(e[1]), ks(e[2], 100), ks(e[3], 100), ks(e[4], 1)];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function E9(s) {
    const e = eS(s);
    return e ? new Be(e, "hsl") : null;
}
function tS(s) {
    const e = s.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (e)
        return [
            parseInt(e[1] + e[1], 16),
            parseInt(e[2] + e[2], 16),
            parseInt(e[3] + e[3], 16),
        ];
    const t = s.match(
        /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
    );
    return t
        ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)]
        : null;
}
function P9(s) {
    const e = tS(s);
    return e ? new Be(e, "rgb") : null;
}
function nS(s) {
    const e = s.match(
        /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/
    );
    if (e)
        return [
            parseInt(e[1] + e[1], 16),
            parseInt(e[2] + e[2], 16),
            parseInt(e[3] + e[3], 16),
            ue(parseInt(e[4] + e[4], 16), 0, 255, 0, 1),
        ];
    const t = s.match(
        /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
    );
    return t
        ? [
              parseInt(t[1], 16),
              parseInt(t[2], 16),
              parseInt(t[3], 16),
              ue(parseInt(t[4], 16), 0, 255, 0, 1),
          ]
        : null;
}
function k9(s) {
    const e = nS(s);
    return e ? new Be(e, "rgb") : null;
}
function sS(s) {
    const e = s.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
    );
    if (!e) return null;
    const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function T9(s) {
    return (e) => {
        const t = sS(e);
        return t ? H_(t, "rgb", s) : null;
    };
}
function iS(s) {
    const e = s.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
    );
    if (!e) return null;
    const t = [
        parseFloat(e[1]),
        parseFloat(e[2]),
        parseFloat(e[3]),
        parseFloat(e[4]),
    ];
    return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function M9(s) {
    return (e) => {
        const t = iS(e);
        return t ? H_(t, "rgb", s) : null;
    };
}
const I9 = [
    { parser: tS, result: { alpha: !1, mode: "rgb", notation: "hex" } },
    { parser: nS, result: { alpha: !0, mode: "rgb", notation: "hex" } },
    { parser: ZA, result: { alpha: !1, mode: "rgb", notation: "func" } },
    { parser: QA, result: { alpha: !0, mode: "rgb", notation: "func" } },
    { parser: JA, result: { alpha: !1, mode: "hsl", notation: "func" } },
    { parser: eS, result: { alpha: !0, mode: "hsl", notation: "func" } },
    { parser: sS, result: { alpha: !1, mode: "rgb", notation: "object" } },
    { parser: iS, result: { alpha: !0, mode: "rgb", notation: "object" } },
];
function R9(s) {
    return I9.reduce(
        (e, { parser: t, result: n }) => e || (t(s) ? n : null),
        null
    );
}
function L9(s, e = "int") {
    const t = R9(s);
    return t
        ? t.notation === "hex" && e !== "float"
            ? Object.assign(Object.assign({}, t), { type: "int" })
            : t.notation === "func"
            ? Object.assign(Object.assign({}, t), { type: e })
            : null
        : null;
}
function yc(s) {
    const e = [P9, k9, C9, A9, S9, E9];
    e.push(T9("int"), M9("int"));
    const t = qN(e);
    return (n) => {
        const i = t(n);
        return i ? Tn(i, s) : null;
    };
}
function O9(s) {
    const e = yc("int");
    if (typeof s != "string") return Be.black();
    const t = e(s);
    return t ?? Be.black();
}
function rS(s) {
    const e = At(Math.floor(s), 0, 255).toString(16);
    return e.length === 1 ? `0${e}` : e;
}
function K_(s, e = "#") {
    const t = ki(s.getComponents("rgb")).map(rS).join("");
    return `${e}${t}`;
}
function Z_(s, e = "#") {
    const t = s.getComponents("rgb"),
        n = [t[0], t[1], t[2], t[3] * 255].map(rS).join("");
    return `${e}${n}`;
}
function aS(s) {
    const e = cn(0),
        t = Tn(s, "int");
    return `rgb(${ki(t.getComponents("rgb"))
        .map((i) => e(i))
        .join(", ")})`;
}
function cu(s) {
    const e = cn(2),
        t = cn(0);
    return `rgba(${Tn(s, "int")
        .getComponents("rgb")
        .map((r, a) => (a === 3 ? e : t)(r))
        .join(", ")})`;
}
function B9(s) {
    const e = [cn(0), td, td],
        t = Tn(s, "int");
    return `hsl(${ki(t.getComponents("hsl"))
        .map((i, r) => e[r](i))
        .join(", ")})`;
}
function F9(s) {
    const e = [cn(0), td, td, cn(2)];
    return `hsla(${Tn(s, "int")
        .getComponents("hsl")
        .map((i, r) => e[r](i))
        .join(", ")})`;
}
function oS(s, e) {
    const t = cn(e === "float" ? 2 : 0),
        n = ["r", "g", "b"],
        i = Tn(s, e);
    return `{${ki(i.getComponents("rgb"))
        .map((a, o) => `${n[o]}: ${t(a)}`)
        .join(", ")}}`;
}
function $9(s) {
    return (e) => oS(e, s);
}
function lS(s, e) {
    const t = cn(2),
        n = cn(e === "float" ? 2 : 0),
        i = ["r", "g", "b", "a"];
    return `{${Tn(s, e)
        .getComponents("rgb")
        .map((o, h) => {
            const l = h === 3 ? t : n;
            return `${i[h]}: ${l(o)}`;
        })
        .join(", ")}}`;
}
function D9(s) {
    return (e) => lS(e, s);
}
const N9 = [
    {
        format: { alpha: !1, mode: "rgb", notation: "hex", type: "int" },
        stringifier: K_,
    },
    {
        format: { alpha: !0, mode: "rgb", notation: "hex", type: "int" },
        stringifier: Z_,
    },
    {
        format: { alpha: !1, mode: "rgb", notation: "func", type: "int" },
        stringifier: aS,
    },
    {
        format: { alpha: !0, mode: "rgb", notation: "func", type: "int" },
        stringifier: cu,
    },
    {
        format: { alpha: !1, mode: "hsl", notation: "func", type: "int" },
        stringifier: B9,
    },
    {
        format: { alpha: !0, mode: "hsl", notation: "func", type: "int" },
        stringifier: F9,
    },
    ...["int", "float"].reduce(
        (s, e) => [
            ...s,
            {
                format: { alpha: !1, mode: "rgb", notation: "object", type: e },
                stringifier: $9(e),
            },
            {
                format: { alpha: !0, mode: "rgb", notation: "object", type: e },
                stringifier: D9(e),
            },
        ],
        []
    ),
];
function hS(s) {
    return N9.reduce(
        (e, t) => e || (w9(t.format, s) ? t.stringifier : null),
        null
    );
}
const Xl = be("apl");
class V9 {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.value = t.value),
            this.value.emitter.on("change", this.onValueChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(Xl()),
            t.viewProps.bindClassModifiers(this.element),
            t.viewProps.bindTabIndex(this.element);
        const n = e.createElement("div");
        n.classList.add(Xl("b")), this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(Xl("c")), n.appendChild(i), (this.colorElem_ = i);
        const r = e.createElement("div");
        r.classList.add(Xl("m")),
            this.element.appendChild(r),
            (this.markerElem_ = r);
        const a = e.createElement("div");
        a.classList.add(Xl("p")),
            this.markerElem_.appendChild(a),
            (this.previewElem_ = a),
            this.update_();
    }
    update_() {
        const e = this.value.rawValue,
            t = e.getComponents("rgb"),
            n = new Be([t[0], t[1], t[2], 0], "rgb"),
            i = new Be([t[0], t[1], t[2], 255], "rgb"),
            r = ["to right", cu(n), cu(i)];
        (this.colorElem_.style.background = `linear-gradient(${r.join(",")})`),
            (this.previewElem_.style.backgroundColor = cu(e));
        const a = ue(t[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${a}%`;
    }
    onValueChange_() {
        this.update_();
    }
}
class U9 {
    constructor(e, t) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
            (this.onKeyUp_ = this.onKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new V9(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.ptHandler_ = new cr(this.view.element)),
            this.ptHandler_.emitter.on("down", this.onPointerDown_),
            this.ptHandler_.emitter.on("move", this.onPointerMove_),
            this.ptHandler_.emitter.on("up", this.onPointerUp_),
            this.view.element.addEventListener("keydown", this.onKeyDown_),
            this.view.element.addEventListener("keyup", this.onKeyUp_);
    }
    handlePointerEvent_(e, t) {
        if (!e.point) return;
        const n = e.point.x / e.bounds.width,
            i = this.value.rawValue,
            [r, a, o] = i.getComponents("hsv");
        this.value.setRawValue(new Be([r, a, o, n], "hsv"), t);
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
    }
    onKeyDown_(e) {
        const t = Kt(Ya(!0), Qs(e));
        if (t === 0) return;
        const n = this.value.rawValue,
            [i, r, a, o] = n.getComponents("hsv");
        this.value.setRawValue(new Be([i, r, a, o + t], "hsv"), {
            forceEmit: !1,
            last: !1,
        });
    }
    onKeyUp_(e) {
        Kt(Ya(!0), Qs(e)) !== 0 &&
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
const fo = be("coltxt");
function z9(s) {
    const e = s.createElement("select"),
        t = [
            { text: "RGB", value: "rgb" },
            { text: "HSL", value: "hsl" },
            { text: "HSV", value: "hsv" },
            { text: "HEX", value: "hex" },
        ];
    return (
        e.appendChild(
            t.reduce((n, i) => {
                const r = s.createElement("option");
                return (
                    (r.textContent = i.text),
                    (r.value = i.value),
                    n.appendChild(r),
                    n
                );
            }, s.createDocumentFragment())
        ),
        e
    );
}
class Y9 {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(fo()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(fo("m")),
            (this.modeElem_ = z9(e)),
            this.modeElem_.classList.add(fo("ms")),
            n.appendChild(this.modeSelectElement),
            t.viewProps.bindDisabled(this.modeElem_);
        const i = e.createElement("div");
        i.classList.add(fo("mm")),
            i.appendChild(zd(e, "dropdown")),
            n.appendChild(i),
            this.element.appendChild(n);
        const r = e.createElement("div");
        r.classList.add(fo("w")),
            this.element.appendChild(r),
            (this.inputsElem_ = r),
            (this.inputViews_ = t.inputViews),
            this.applyInputViews_(),
            Rs(t.mode, (a) => {
                this.modeElem_.value = a;
            });
    }
    get modeSelectElement() {
        return this.modeElem_;
    }
    get inputViews() {
        return this.inputViews_;
    }
    set inputViews(e) {
        (this.inputViews_ = e), this.applyInputViews_();
    }
    applyInputViews_() {
        FA(this.inputsElem_);
        const e = this.element.ownerDocument;
        this.inputViews_.forEach((t) => {
            const n = e.createElement("div");
            n.classList.add(fo("c")),
                n.appendChild(t.element),
                this.inputsElem_.appendChild(n);
        });
    }
}
function G9(s) {
    return cn(s === "float" ? 2 : 0);
}
function j9(s, e, t) {
    const n = cl(s, e)[t];
    return new _c({ min: 0, max: n });
}
function W9(s, e, t) {
    return new bc(s, {
        arrayPosition: t === 0 ? "fst" : t === 2 ? "lst" : "mid",
        parser: e.parser,
        props: de.fromObject({
            formatter: G9(e.colorType),
            keyScale: Ya(!1),
            pointerScale: e.colorType === "float" ? 0.01 : 1,
        }),
        value: kt(0, { constraint: j9(e.colorMode, e.colorType, t) }),
        viewProps: e.viewProps,
    });
}
function X9(s, e) {
    const t = {
        colorMode: e.colorMode,
        colorType: e.colorType,
        parser: Zs,
        viewProps: e.viewProps,
    };
    return [0, 1, 2].map((n) => {
        const i = W9(s, t, n);
        return (
            eo({
                primary: e.value,
                secondary: i.value,
                forward(r) {
                    return Tn(r, e.colorType).getComponents(e.colorMode)[n];
                },
                backward(r, a) {
                    const o = e.colorMode,
                        l = Tn(r, e.colorType).getComponents(o);
                    l[n] = a;
                    const u = H_(qd(ki(l), l[3]), o, e.colorType);
                    return Tn(u, "int");
                },
            }),
            i
        );
    });
}
function q9(s, e) {
    const t = new Xd(s, {
        parser: yc("int"),
        props: de.fromObject({ formatter: K_ }),
        value: kt(Be.black()),
        viewProps: e.viewProps,
    });
    return (
        eo({
            primary: e.value,
            secondary: t.value,
            forward: (n) => new Be(ki(n.getComponents()), n.mode),
            backward: (n, i) =>
                new Be(
                    qd(ki(i.getComponents(n.mode)), n.getComponents()[3]),
                    n.mode
                ),
        }),
        [t]
    );
}
function H9(s) {
    return s !== "hex";
}
class K9 {
    constructor(e, t) {
        (this.onModeSelectChange_ = this.onModeSelectChange_.bind(this)),
            (this.colorType_ = t.colorType),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.colorMode = kt(this.value.rawValue.mode)),
            (this.ccs_ = this.createComponentControllers_(e)),
            (this.view = new Y9(e, {
                mode: this.colorMode,
                inputViews: [
                    this.ccs_[0].view,
                    this.ccs_[1].view,
                    this.ccs_[2].view,
                ],
                viewProps: this.viewProps,
            })),
            this.view.modeSelectElement.addEventListener(
                "change",
                this.onModeSelectChange_
            );
    }
    createComponentControllers_(e) {
        const t = this.colorMode.rawValue;
        return H9(t)
            ? X9(e, {
                  colorMode: t,
                  colorType: this.colorType_,
                  value: this.value,
                  viewProps: this.viewProps,
              })
            : q9(e, { value: this.value, viewProps: this.viewProps });
    }
    onModeSelectChange_(e) {
        const t = e.currentTarget;
        (this.colorMode.rawValue = t.value),
            (this.ccs_ = this.createComponentControllers_(
                this.view.element.ownerDocument
            )),
            (this.view.inputViews = this.ccs_.map((n) => n.view));
    }
}
const bp = be("hpl");
class Z9 {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.value = t.value),
            this.value.emitter.on("change", this.onValueChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(bp()),
            t.viewProps.bindClassModifiers(this.element),
            t.viewProps.bindTabIndex(this.element);
        const n = e.createElement("div");
        n.classList.add(bp("c")), this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(bp("m")),
            this.element.appendChild(i),
            (this.markerElem_ = i),
            this.update_();
    }
    update_() {
        const e = this.value.rawValue,
            [t] = e.getComponents("hsv");
        this.markerElem_.style.backgroundColor = aS(
            new Be([t, 100, 100], "hsv")
        );
        const n = ue(t, 0, 360, 0, 100);
        this.markerElem_.style.left = `${n}%`;
    }
    onValueChange_() {
        this.update_();
    }
}
class Q9 {
    constructor(e, t) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
            (this.onKeyUp_ = this.onKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new Z9(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.ptHandler_ = new cr(this.view.element)),
            this.ptHandler_.emitter.on("down", this.onPointerDown_),
            this.ptHandler_.emitter.on("move", this.onPointerMove_),
            this.ptHandler_.emitter.on("up", this.onPointerUp_),
            this.view.element.addEventListener("keydown", this.onKeyDown_),
            this.view.element.addEventListener("keyup", this.onKeyUp_);
    }
    handlePointerEvent_(e, t) {
        if (!e.point) return;
        const n = ue(
                At(e.point.x, 0, e.bounds.width),
                0,
                e.bounds.width,
                0,
                360
            ),
            i = this.value.rawValue,
            [, r, a, o] = i.getComponents("hsv");
        this.value.setRawValue(new Be([n, r, a, o], "hsv"), t);
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
    }
    onKeyDown_(e) {
        const t = Kt(Ya(!1), Qs(e));
        if (t === 0) return;
        const n = this.value.rawValue,
            [i, r, a, o] = n.getComponents("hsv");
        this.value.setRawValue(new Be([i + t, r, a, o], "hsv"), {
            forceEmit: !1,
            last: !1,
        });
    }
    onKeyUp_(e) {
        Kt(Ya(!1), Qs(e)) !== 0 &&
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
const yp = be("svp"),
    wy = 64;
class J9 {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.value = t.value),
            this.value.emitter.on("change", this.onValueChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(yp()),
            t.viewProps.bindClassModifiers(this.element),
            t.viewProps.bindTabIndex(this.element);
        const n = e.createElement("canvas");
        (n.height = wy),
            (n.width = wy),
            n.classList.add(yp("c")),
            this.element.appendChild(n),
            (this.canvasElement = n);
        const i = e.createElement("div");
        i.classList.add(yp("m")),
            this.element.appendChild(i),
            (this.markerElem_ = i),
            this.update_();
    }
    update_() {
        const e = oN(this.canvasElement);
        if (!e) return;
        const n = this.value.rawValue.getComponents("hsv"),
            i = this.canvasElement.width,
            r = this.canvasElement.height,
            a = e.getImageData(0, 0, i, r),
            o = a.data;
        for (let u = 0; u < r; u++)
            for (let c = 0; c < i; c++) {
                const d = ue(c, 0, i, 0, 100),
                    f = ue(u, 0, r, 100, 0),
                    p = WA(n[0], d, f),
                    m = (u * i + c) * 4;
                (o[m] = p[0]),
                    (o[m + 1] = p[1]),
                    (o[m + 2] = p[2]),
                    (o[m + 3] = 255);
            }
        e.putImageData(a, 0, 0);
        const h = ue(n[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${h}%`;
        const l = ue(n[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${l}%`;
    }
    onValueChange_() {
        this.update_();
    }
}
class e8 {
    constructor(e, t) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
            (this.onKeyUp_ = this.onKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new J9(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.ptHandler_ = new cr(this.view.element)),
            this.ptHandler_.emitter.on("down", this.onPointerDown_),
            this.ptHandler_.emitter.on("move", this.onPointerMove_),
            this.ptHandler_.emitter.on("up", this.onPointerUp_),
            this.view.element.addEventListener("keydown", this.onKeyDown_),
            this.view.element.addEventListener("keyup", this.onKeyUp_);
    }
    handlePointerEvent_(e, t) {
        if (!e.point) return;
        const n = ue(e.point.x, 0, e.bounds.width, 0, 100),
            i = ue(e.point.y, 0, e.bounds.height, 100, 0),
            [r, , , a] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Be([r, n, i, a], "hsv"), t);
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
    }
    onKeyDown_(e) {
        nd(e.key) && e.preventDefault();
        const [t, n, i, r] = this.value.rawValue.getComponents("hsv"),
            a = Ya(!1),
            o = Kt(a, Qs(e)),
            h = Kt(a, za(e));
        (o === 0 && h === 0) ||
            this.value.setRawValue(new Be([t, n + o, i + h, r], "hsv"), {
                forceEmit: !1,
                last: !1,
            });
    }
    onKeyUp_(e) {
        const t = Ya(!1),
            n = Kt(t, Qs(e)),
            i = Kt(t, za(e));
        (n === 0 && i === 0) ||
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
class t8 {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.hPaletteC_ = new Q9(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.svPaletteC_ = new e8(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.alphaIcs_ = t.supportsAlpha
                ? {
                      palette: new U9(e, {
                          value: this.value,
                          viewProps: this.viewProps,
                      }),
                      text: new bc(e, {
                          parser: Zs,
                          props: de.fromObject({
                              pointerScale: 0.01,
                              keyScale: 0.1,
                              formatter: cn(2),
                          }),
                          value: kt(0, {
                              constraint: new _c({ min: 0, max: 1 }),
                          }),
                          viewProps: this.viewProps,
                      }),
                  }
                : null),
            this.alphaIcs_ &&
                eo({
                    primary: this.value,
                    secondary: this.alphaIcs_.text.value,
                    forward: (n) => n.getComponents()[3],
                    backward: (n, i) => {
                        const r = n.getComponents();
                        return (r[3] = i), new Be(r, n.mode);
                    },
                }),
            (this.textsC_ = new K9(e, {
                colorType: t.colorType,
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.view = new p9(e, {
                alphaViews: this.alphaIcs_
                    ? {
                          palette: this.alphaIcs_.palette.view,
                          text: this.alphaIcs_.text.view,
                      }
                    : null,
                hPaletteView: this.hPaletteC_.view,
                supportsAlpha: t.supportsAlpha,
                svPaletteView: this.svPaletteC_.view,
                textsView: this.textsC_.view,
                viewProps: this.viewProps,
            }));
    }
    get textsController() {
        return this.textsC_;
    }
}
const wp = be("colsw");
class n8 {
    constructor(e, t) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
            t.value.emitter.on("change", this.onValueChange_),
            (this.value = t.value),
            (this.element = e.createElement("div")),
            this.element.classList.add(wp()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(wp("sw")),
            this.element.appendChild(n),
            (this.swatchElem_ = n);
        const i = e.createElement("button");
        i.classList.add(wp("b")),
            t.viewProps.bindDisabled(i),
            this.element.appendChild(i),
            (this.buttonElement = i),
            this.update_();
    }
    update_() {
        const e = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Z_(e);
    }
    onValueChange_() {
        this.update_();
    }
}
class s8 {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new n8(e, {
                value: this.value,
                viewProps: this.viewProps,
            }));
    }
}
class Q_ {
    constructor(e, t) {
        (this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
            (this.onButtonClick_ = this.onButtonClick_.bind(this)),
            (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
            (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.foldable_ = xl.create(t.expanded)),
            (this.swatchC_ = new s8(e, {
                value: this.value,
                viewProps: this.viewProps,
            }));
        const n = this.swatchC_.view.buttonElement;
        n.addEventListener("blur", this.onButtonBlur_),
            n.addEventListener("click", this.onButtonClick_),
            (this.textC_ = new Xd(e, {
                parser: t.parser,
                props: de.fromObject({ formatter: t.formatter }),
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.view = new a9(e, {
                foldable: this.foldable_,
                pickerLayout: t.pickerLayout,
            })),
            this.view.swatchElement.appendChild(this.swatchC_.view.element),
            this.view.textElement.appendChild(this.textC_.view.element),
            (this.popC_ =
                t.pickerLayout === "popup"
                    ? new G_(e, { viewProps: this.viewProps })
                    : null);
        const i = new t8(e, {
            colorType: t.colorType,
            supportsAlpha: t.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps,
        });
        i.view.allFocusableElements.forEach((r) => {
            r.addEventListener("blur", this.onPopupChildBlur_),
                r.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
            (this.pickerC_ = i),
            this.popC_
                ? (this.view.element.appendChild(this.popC_.view.element),
                  this.popC_.view.element.appendChild(i.view.element),
                  eo({
                      primary: this.foldable_.value("expanded"),
                      secondary: this.popC_.shows,
                      forward: (r) => r,
                      backward: (r, a) => a,
                  }))
                : this.view.pickerElement &&
                  (this.view.pickerElement.appendChild(
                      this.pickerC_.view.element
                  ),
                  Gd(this.foldable_, this.view.pickerElement));
    }
    get textController() {
        return this.textC_;
    }
    onButtonBlur_(e) {
        if (!this.popC_) return;
        const t = this.view.element,
            n = e.relatedTarget;
        (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
    }
    onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
            this.foldable_.get("expanded") &&
                this.pickerC_.view.allFocusableElements[0].focus();
    }
    onPopupChildBlur_(e) {
        if (!this.popC_) return;
        const t = this.popC_.view.element,
            n = $_(e);
        (n && t.contains(n)) ||
            (n &&
                n === this.swatchC_.view.buttonElement &&
                !Ud(t.ownerDocument)) ||
            (this.popC_.shows.rawValue = !1);
    }
    onPopupChildKeydown_(e) {
        this.popC_
            ? e.key === "Escape" && (this.popC_.shows.rawValue = !1)
            : this.view.pickerElement &&
              e.key === "Escape" &&
              this.swatchC_.view.buttonElement.focus();
    }
}
function i8(s) {
    return ki(s.getComponents("rgb")).reduce(
        (e, t) => (e << 8) | (Math.floor(t) & 255),
        0
    );
}
function r8(s) {
    return (
        s.getComponents("rgb").reduce((e, t, n) => {
            const i = Math.floor(n === 3 ? t * 255 : t) & 255;
            return (e << 8) | i;
        }, 0) >>> 0
    );
}
function a8(s) {
    return new Be([(s >> 16) & 255, (s >> 8) & 255, s & 255], "rgb");
}
function o8(s) {
    return new Be(
        [
            (s >> 24) & 255,
            (s >> 16) & 255,
            (s >> 8) & 255,
            ue(s & 255, 0, 255, 0, 1),
        ],
        "rgb"
    );
}
function l8(s) {
    return typeof s != "number" ? Be.black() : a8(s);
}
function h8(s) {
    return typeof s != "number" ? Be.black() : o8(s);
}
function uu(s, e) {
    return typeof s != "object" || vt(s)
        ? !1
        : e in s && typeof s[e] == "number";
}
function cS(s) {
    return uu(s, "r") && uu(s, "g") && uu(s, "b");
}
function uS(s) {
    return cS(s) && uu(s, "a");
}
function dS(s) {
    return cS(s);
}
function J_(s, e) {
    if (s.mode !== e.mode || s.type !== e.type) return !1;
    const t = s.getComponents(),
        n = e.getComponents();
    for (let i = 0; i < t.length; i++) if (t[i] !== n[i]) return !1;
    return !0;
}
function xy(s) {
    return "a" in s ? [s.r, s.g, s.b, s.a] : [s.r, s.g, s.b];
}
function c8(s) {
    const e = hS(s);
    return e
        ? (t, n) => {
              Zr(t, e(n));
          }
        : null;
}
function u8(s) {
    const e = s ? r8 : i8;
    return (t, n) => {
        Zr(t, e(n));
    };
}
function d8(s, e, t) {
    const i = Tn(e, t).toRgbaObject();
    s.writeProperty("r", i.r),
        s.writeProperty("g", i.g),
        s.writeProperty("b", i.b),
        s.writeProperty("a", i.a);
}
function f8(s, e, t) {
    const i = Tn(e, t).toRgbaObject();
    s.writeProperty("r", i.r),
        s.writeProperty("g", i.g),
        s.writeProperty("b", i.b);
}
function p8(s, e) {
    return (t, n) => {
        s ? d8(t, n, e) : f8(t, n, e);
    };
}
function m8(s) {
    var e;
    return !!(
        !((e = s == null ? void 0 : s.color) === null || e === void 0) &&
        e.alpha
    );
}
function g8(s) {
    return s ? (e) => Z_(e, "0x") : (e) => K_(e, "0x");
}
function _8(s) {
    return "color" in s || s.view === "color";
}
Bt({
    id: "input-color-number",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "number" || !_8(e)) return null;
        const t = X_(e);
        return t
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, t), {
                      supportsAlpha: m8(e),
                  }),
              }
            : null;
    },
    binding: {
        reader: (s) => (s.params.supportsAlpha ? h8 : l8),
        equals: J_,
        writer: (s) => u8(s.params.supportsAlpha),
    },
    controller: (s) => {
        var e, t;
        return new Q_(s.document, {
            colorType: "int",
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: g8(s.params.supportsAlpha),
            parser: yc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: s.params.supportsAlpha,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
function v8(s, e) {
    if (!dS(s)) return Tn(Be.black(), e);
    if (e === "int") {
        const t = xy(s);
        return new Be(t, "rgb");
    }
    if (e === "float") {
        const t = xy(s);
        return new q_(t, "rgb");
    }
    return Tn(Be.black(), "int");
}
function b8(s) {
    return uS(s);
}
function y8(s) {
    return (e) => {
        const t = v8(e, s);
        return Tn(t, "int");
    };
}
function w8(s, e) {
    return (t) => (s ? lS(t, e) : oS(t, e));
}
Bt({
    id: "input-color-object",
    type: "input",
    accept: (s, e) => {
        var t;
        if (!dS(s)) return null;
        const n = X_(e);
        return n
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, n), {
                      colorType:
                          (t = HA(e)) !== null && t !== void 0 ? t : "int",
                  }),
              }
            : null;
    },
    binding: {
        reader: (s) => y8(s.params.colorType),
        equals: J_,
        writer: (s) => p8(b8(s.initialValue), s.params.colorType),
    },
    controller: (s) => {
        var e, t;
        const n = uS(s.initialValue);
        return new Q_(s.document, {
            colorType: s.params.colorType,
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: w8(n, s.params.colorType),
            parser: yc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: n,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
Bt({
    id: "input-color-string",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "string" || e.view === "text") return null;
        const t = L9(s, HA(e));
        if (!t) return null;
        const n = hS(t);
        if (!n) return null;
        const i = X_(e);
        return i
            ? {
                  initialValue: s,
                  params: Object.assign(Object.assign({}, i), {
                      format: t,
                      stringifier: n,
                  }),
              }
            : null;
    },
    binding: {
        reader: () => O9,
        equals: J_,
        writer: (s) => {
            const e = c8(s.params.format);
            if (!e) throw An.notBindable();
            return e;
        },
    },
    controller: (s) => {
        var e, t;
        return new Q_(s.document, {
            colorType: s.params.format.type,
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: s.params.stringifier,
            parser: yc("int"),
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            supportsAlpha: s.params.format.alpha,
            value: s.value,
            viewProps: s.viewProps,
        });
    },
});
class Hd {
    constructor(e) {
        (this.components = e.components), (this.asm_ = e.assembly);
    }
    constrain(e) {
        const t = this.asm_.toComponents(e).map((n, i) => {
            var r, a;
            return (a =
                (r = this.components[i]) === null || r === void 0
                    ? void 0
                    : r.constrain(n)) !== null && a !== void 0
                ? a
                : n;
        });
        return this.asm_.fromComponents(t);
    }
}
const Cy = be("pndtxt");
class x8 {
    constructor(e, t) {
        (this.textViews = t.textViews),
            (this.element = e.createElement("div")),
            this.element.classList.add(Cy()),
            this.textViews.forEach((n) => {
                const i = e.createElement("div");
                i.classList.add(Cy("a")),
                    i.appendChild(n.element),
                    this.element.appendChild(i);
            });
    }
}
function C8(s, e, t) {
    return new bc(s, {
        arrayPosition:
            t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
        parser: e.parser,
        props: e.axes[t].textProps,
        value: kt(0, { constraint: e.axes[t].constraint }),
        viewProps: e.viewProps,
    });
}
class Al {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.acs_ = t.axes.map((n, i) => C8(e, t, i))),
            this.acs_.forEach((n, i) => {
                eo({
                    primary: this.value,
                    secondary: n.value,
                    forward: (r) => t.assembly.toComponents(r)[i],
                    backward: (r, a) => {
                        const o = t.assembly.toComponents(r);
                        return (o[i] = a), t.assembly.fromComponents(o);
                    },
                });
            }),
            (this.view = new x8(e, {
                textViews: this.acs_.map((n) => n.view),
            }));
    }
    get textControllers() {
        return this.acs_;
    }
}
class A8 extends B_ {
    get max() {
        return this.controller.valueController.sliderController.props.get(
            "max"
        );
    }
    set max(e) {
        this.controller.valueController.sliderController.props.set("max", e);
    }
    get min() {
        return this.controller.valueController.sliderController.props.get(
            "min"
        );
    }
    set min(e) {
        this.controller.valueController.sliderController.props.set("min", e);
    }
}
function S8(s, e) {
    const t = [],
        n = M_(s, e);
    n && t.push(n);
    const i = I_(s);
    i && t.push(i);
    const r = Y_(s.options);
    return r && t.push(r), new Cl(t);
}
Bt({
    id: "input-number",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "number") return null;
        const t = Tt(e, (n) =>
            Object.assign(Object.assign({}, L_(n)), {
                options: n.optional.custom(Wd),
                readonly: n.optional.constant(!1),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => T_,
        constraint: (s) => S8(s.params, s.initialValue),
        writer: (s) => Zr,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = t && Jh(t, jd);
        if (n)
            return new hl(s.document, {
                props: new de({ options: n.values.value("options") }),
                value: e,
                viewProps: s.viewProps,
            });
        const i = R_(s.params, e.rawValue),
            r = t && Jh(t, _c);
        return r
            ? new by(
                  s.document,
                  Object.assign(
                      Object.assign(
                          {},
                          t9(
                              Object.assign(Object.assign({}, i), {
                                  keyScale: kt(i.keyScale),
                                  max: r.values.value("max"),
                                  min: r.values.value("min"),
                              })
                          )
                      ),
                      { parser: Zs, value: e, viewProps: s.viewProps }
                  )
              )
            : new bc(s.document, {
                  parser: Zs,
                  props: de.fromObject(i),
                  value: e,
                  viewProps: s.viewProps,
              });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "number"
            ? null
            : s.controller.valueController instanceof by
            ? new A8(s.controller)
            : s.controller.valueController instanceof hl
            ? new z_(s.controller)
            : null;
    },
});
class Vr {
    constructor(e = 0, t = 0) {
        (this.x = e), (this.y = t);
    }
    getComponents() {
        return [this.x, this.y];
    }
    static isObject(e) {
        if (vt(e)) return !1;
        const t = e.x,
            n = e.y;
        return !(typeof t != "number" || typeof n != "number");
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y;
    }
    toObject() {
        return { x: this.x, y: this.y };
    }
}
const fS = {
        toComponents: (s) => s.getComponents(),
        fromComponents: (s) => new Vr(...s),
    },
    po = be("p2d");
class E8 {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(po()),
            t.viewProps.bindClassModifiers(this.element),
            Rs(t.expanded, Kr(this.element, po(void 0, "expanded")));
        const n = e.createElement("div");
        n.classList.add(po("h")), this.element.appendChild(n);
        const i = e.createElement("button");
        i.classList.add(po("b")),
            i.appendChild(zd(e, "p2dpad")),
            t.viewProps.bindDisabled(i),
            n.appendChild(i),
            (this.buttonElement = i);
        const r = e.createElement("div");
        if (
            (r.classList.add(po("t")),
            n.appendChild(r),
            (this.textElement = r),
            t.pickerLayout === "inline")
        ) {
            const a = e.createElement("div");
            a.classList.add(po("p")),
                this.element.appendChild(a),
                (this.pickerElement = a);
        } else this.pickerElement = null;
    }
}
const gr = be("p2dp");
class P8 {
    constructor(e, t) {
        (this.onFoldableChange_ = this.onFoldableChange_.bind(this)),
            (this.onPropsChange_ = this.onPropsChange_.bind(this)),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.props_ = t.props),
            this.props_.emitter.on("change", this.onPropsChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(gr()),
            t.layout === "popup" && this.element.classList.add(gr(void 0, "p")),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(gr("p")),
            t.viewProps.bindTabIndex(n),
            this.element.appendChild(n),
            (this.padElement = n);
        const i = e.createElementNS(Ht, "svg");
        i.classList.add(gr("g")),
            this.padElement.appendChild(i),
            (this.svgElem_ = i);
        const r = e.createElementNS(Ht, "line");
        r.classList.add(gr("ax")),
            r.setAttributeNS(null, "x1", "0"),
            r.setAttributeNS(null, "y1", "50%"),
            r.setAttributeNS(null, "x2", "100%"),
            r.setAttributeNS(null, "y2", "50%"),
            this.svgElem_.appendChild(r);
        const a = e.createElementNS(Ht, "line");
        a.classList.add(gr("ax")),
            a.setAttributeNS(null, "x1", "50%"),
            a.setAttributeNS(null, "y1", "0"),
            a.setAttributeNS(null, "x2", "50%"),
            a.setAttributeNS(null, "y2", "100%"),
            this.svgElem_.appendChild(a);
        const o = e.createElementNS(Ht, "line");
        o.classList.add(gr("l")),
            o.setAttributeNS(null, "x1", "50%"),
            o.setAttributeNS(null, "y1", "50%"),
            this.svgElem_.appendChild(o),
            (this.lineElem_ = o);
        const h = e.createElement("div");
        h.classList.add(gr("m")),
            this.padElement.appendChild(h),
            (this.markerElem_ = h),
            t.value.emitter.on("change", this.onValueChange_),
            (this.value = t.value),
            this.update_();
    }
    get allFocusableElements() {
        return [this.padElement];
    }
    update_() {
        const [e, t] = this.value.rawValue.getComponents(),
            n = this.props_.get("max"),
            i = ue(e, -n, +n, 0, 100),
            r = ue(t, -n, +n, 0, 100),
            a = this.props_.get("invertsY") ? 100 - r : r;
        this.lineElem_.setAttributeNS(null, "x2", `${i}%`),
            this.lineElem_.setAttributeNS(null, "y2", `${a}%`),
            (this.markerElem_.style.left = `${i}%`),
            (this.markerElem_.style.top = `${a}%`);
    }
    onValueChange_() {
        this.update_();
    }
    onPropsChange_() {
        this.update_();
    }
    onFoldableChange_() {
        this.update_();
    }
}
function Ay(s, e, t) {
    return [Kt(e[0], Qs(s)), Kt(e[1], za(s)) * (t ? 1 : -1)];
}
class k8 {
    constructor(e, t) {
        (this.onPadKeyDown_ = this.onPadKeyDown_.bind(this)),
            (this.onPadKeyUp_ = this.onPadKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.props = t.props),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new P8(e, {
                layout: t.layout,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.ptHandler_ = new cr(this.view.padElement)),
            this.ptHandler_.emitter.on("down", this.onPointerDown_),
            this.ptHandler_.emitter.on("move", this.onPointerMove_),
            this.ptHandler_.emitter.on("up", this.onPointerUp_),
            this.view.padElement.addEventListener(
                "keydown",
                this.onPadKeyDown_
            ),
            this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
    }
    handlePointerEvent_(e, t) {
        if (!e.point) return;
        const n = this.props.get("max"),
            i = ue(e.point.x, 0, e.bounds.width, -n, +n),
            r = ue(
                this.props.get("invertsY")
                    ? e.bounds.height - e.point.y
                    : e.point.y,
                0,
                e.bounds.height,
                -n,
                +n
            );
        this.value.setRawValue(new Vr(i, r), t);
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
    }
    onPadKeyDown_(e) {
        nd(e.key) && e.preventDefault();
        const [t, n] = Ay(
            e,
            [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
            this.props.get("invertsY")
        );
        (t === 0 && n === 0) ||
            this.value.setRawValue(
                new Vr(this.value.rawValue.x + t, this.value.rawValue.y + n),
                { forceEmit: !1, last: !1 }
            );
    }
    onPadKeyUp_(e) {
        const [t, n] = Ay(
            e,
            [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
            this.props.get("invertsY")
        );
        (t === 0 && n === 0) ||
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
class T8 {
    constructor(e, t) {
        var n, i;
        (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
            (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
            (this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this)),
            (this.onPadButtonClick_ = this.onPadButtonClick_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.foldable_ = xl.create(t.expanded)),
            (this.popC_ =
                t.pickerLayout === "popup"
                    ? new G_(e, { viewProps: this.viewProps })
                    : null);
        const r = new k8(e, {
            layout: t.pickerLayout,
            props: new de({
                invertsY: kt(t.invertsY),
                max: kt(t.max),
                xKeyScale: t.axes[0].textProps.value("keyScale"),
                yKeyScale: t.axes[1].textProps.value("keyScale"),
            }),
            value: this.value,
            viewProps: this.viewProps,
        });
        r.view.allFocusableElements.forEach((a) => {
            a.addEventListener("blur", this.onPopupChildBlur_),
                a.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
            (this.pickerC_ = r),
            (this.textC_ = new Al(e, {
                assembly: fS,
                axes: t.axes,
                parser: t.parser,
                value: this.value,
                viewProps: this.viewProps,
            })),
            (this.view = new E8(e, {
                expanded: this.foldable_.value("expanded"),
                pickerLayout: t.pickerLayout,
                viewProps: this.viewProps,
            })),
            this.view.textElement.appendChild(this.textC_.view.element),
            (n = this.view.buttonElement) === null ||
                n === void 0 ||
                n.addEventListener("blur", this.onPadButtonBlur_),
            (i = this.view.buttonElement) === null ||
                i === void 0 ||
                i.addEventListener("click", this.onPadButtonClick_),
            this.popC_
                ? (this.view.element.appendChild(this.popC_.view.element),
                  this.popC_.view.element.appendChild(
                      this.pickerC_.view.element
                  ),
                  eo({
                      primary: this.foldable_.value("expanded"),
                      secondary: this.popC_.shows,
                      forward: (a) => a,
                      backward: (a, o) => o,
                  }))
                : this.view.pickerElement &&
                  (this.view.pickerElement.appendChild(
                      this.pickerC_.view.element
                  ),
                  Gd(this.foldable_, this.view.pickerElement));
    }
    get textController() {
        return this.textC_;
    }
    onPadButtonBlur_(e) {
        if (!this.popC_) return;
        const t = this.view.element,
            n = e.relatedTarget;
        (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
    }
    onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
            this.foldable_.get("expanded") &&
                this.pickerC_.view.allFocusableElements[0].focus();
    }
    onPopupChildBlur_(e) {
        if (!this.popC_) return;
        const t = this.popC_.view.element,
            n = $_(e);
        (n && t.contains(n)) ||
            (n && n === this.view.buttonElement && !Ud(t.ownerDocument)) ||
            (this.popC_.shows.rawValue = !1);
    }
    onPopupChildKeydown_(e) {
        this.popC_
            ? e.key === "Escape" && (this.popC_.shows.rawValue = !1)
            : this.view.pickerElement &&
              e.key === "Escape" &&
              this.view.buttonElement.focus();
    }
}
function M8(s) {
    return Vr.isObject(s) ? new Vr(s.x, s.y) : new Vr();
}
function I8(s, e) {
    s.writeProperty("x", e.x), s.writeProperty("y", e.y);
}
function R8(s, e) {
    return new Hd({
        assembly: fS,
        components: [
            Hi(Object.assign(Object.assign({}, s), s.x), e.x),
            Hi(Object.assign(Object.assign({}, s), s.y), e.y),
        ],
    });
}
function Sy(s, e) {
    var t, n;
    if (!vt(s.min) || !vt(s.max))
        return Math.max(
            Math.abs((t = s.min) !== null && t !== void 0 ? t : 0),
            Math.abs((n = s.max) !== null && n !== void 0 ? n : 0)
        );
    const i = OA(s);
    return Math.max(Math.abs(i) * 10, Math.abs(e) * 10);
}
function L8(s, e) {
    var t, n;
    const i = Sy(Ua(s, (t = s.x) !== null && t !== void 0 ? t : {}), e.x),
        r = Sy(Ua(s, (n = s.y) !== null && n !== void 0 ? n : {}), e.y);
    return Math.max(i, r);
}
function O8(s) {
    if (!("y" in s)) return !1;
    const e = s.y;
    return e && "inverted" in e ? !!e.inverted : !1;
}
Bt({
    id: "input-point2d",
    type: "input",
    accept: (s, e) => {
        if (!Vr.isObject(s)) return null;
        const t = Tt(e, (n) =>
            Object.assign(Object.assign({}, ec(n)), {
                expanded: n.optional.boolean,
                picker: n.optional.custom(jA),
                readonly: n.optional.constant(!1),
                x: n.optional.custom(Br),
                y: n.optional.object(
                    Object.assign(Object.assign({}, ec(n)), {
                        inverted: n.optional.boolean,
                    })
                ),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: () => M8,
        constraint: (s) => R8(s.params, s.initialValue),
        equals: Vr.equals,
        writer: () => I8,
    },
    controller: (s) => {
        var e, t;
        const n = s.document,
            i = s.value,
            r = s.constraint,
            a = [s.params.x, s.params.y];
        return new T8(n, {
            axes: i.rawValue.getComponents().map((o, h) => {
                var l;
                return O_({
                    constraint: r.components[h],
                    initialValue: o,
                    params: Ua(
                        s.params,
                        (l = a[h]) !== null && l !== void 0 ? l : {}
                    ),
                });
            }),
            expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
            invertsY: O8(s.params),
            max: L8(s.params, i.rawValue),
            parser: Zs,
            pickerLayout:
                (t = s.params.picker) !== null && t !== void 0 ? t : "popup",
            value: i,
            viewProps: s.viewProps,
        });
    },
});
class Uo {
    constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
    }
    getComponents() {
        return [this.x, this.y, this.z];
    }
    static isObject(e) {
        if (vt(e)) return !1;
        const t = e.x,
            n = e.y,
            i = e.z;
        return !(
            typeof t != "number" ||
            typeof n != "number" ||
            typeof i != "number"
        );
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z;
    }
    toObject() {
        return { x: this.x, y: this.y, z: this.z };
    }
}
const pS = {
    toComponents: (s) => s.getComponents(),
    fromComponents: (s) => new Uo(...s),
};
function B8(s) {
    return Uo.isObject(s) ? new Uo(s.x, s.y, s.z) : new Uo();
}
function F8(s, e) {
    s.writeProperty("x", e.x),
        s.writeProperty("y", e.y),
        s.writeProperty("z", e.z);
}
function $8(s, e) {
    return new Hd({
        assembly: pS,
        components: [
            Hi(Object.assign(Object.assign({}, s), s.x), e.x),
            Hi(Object.assign(Object.assign({}, s), s.y), e.y),
            Hi(Object.assign(Object.assign({}, s), s.z), e.z),
        ],
    });
}
Bt({
    id: "input-point3d",
    type: "input",
    accept: (s, e) => {
        if (!Uo.isObject(s)) return null;
        const t = Tt(e, (n) =>
            Object.assign(Object.assign({}, ec(n)), {
                readonly: n.optional.constant(!1),
                x: n.optional.custom(Br),
                y: n.optional.custom(Br),
                z: n.optional.custom(Br),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => B8,
        constraint: (s) => $8(s.params, s.initialValue),
        equals: Uo.equals,
        writer: (s) => F8,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = [s.params.x, s.params.y, s.params.z];
        return new Al(s.document, {
            assembly: pS,
            axes: e.rawValue.getComponents().map((i, r) => {
                var a;
                return O_({
                    constraint: t.components[r],
                    initialValue: i,
                    params: Ua(
                        s.params,
                        (a = n[r]) !== null && a !== void 0 ? a : {}
                    ),
                });
            }),
            parser: Zs,
            value: e,
            viewProps: s.viewProps,
        });
    },
});
class zo {
    constructor(e = 0, t = 0, n = 0, i = 0) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = i);
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w];
    }
    static isObject(e) {
        if (vt(e)) return !1;
        const t = e.x,
            n = e.y,
            i = e.z,
            r = e.w;
        return !(
            typeof t != "number" ||
            typeof n != "number" ||
            typeof i != "number" ||
            typeof r != "number"
        );
    }
    static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
    }
    toObject() {
        return { x: this.x, y: this.y, z: this.z, w: this.w };
    }
}
const mS = {
    toComponents: (s) => s.getComponents(),
    fromComponents: (s) => new zo(...s),
};
function D8(s) {
    return zo.isObject(s) ? new zo(s.x, s.y, s.z, s.w) : new zo();
}
function N8(s, e) {
    s.writeProperty("x", e.x),
        s.writeProperty("y", e.y),
        s.writeProperty("z", e.z),
        s.writeProperty("w", e.w);
}
function V8(s, e) {
    return new Hd({
        assembly: mS,
        components: [
            Hi(Object.assign(Object.assign({}, s), s.x), e.x),
            Hi(Object.assign(Object.assign({}, s), s.y), e.y),
            Hi(Object.assign(Object.assign({}, s), s.z), e.z),
            Hi(Object.assign(Object.assign({}, s), s.w), e.w),
        ],
    });
}
Bt({
    id: "input-point4d",
    type: "input",
    accept: (s, e) => {
        if (!zo.isObject(s)) return null;
        const t = Tt(e, (n) =>
            Object.assign(Object.assign({}, ec(n)), {
                readonly: n.optional.constant(!1),
                w: n.optional.custom(Br),
                x: n.optional.custom(Br),
                y: n.optional.custom(Br),
                z: n.optional.custom(Br),
            })
        );
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => D8,
        constraint: (s) => V8(s.params, s.initialValue),
        equals: zo.equals,
        writer: (s) => N8,
    },
    controller: (s) => {
        const e = s.value,
            t = s.constraint,
            n = [s.params.x, s.params.y, s.params.z, s.params.w];
        return new Al(s.document, {
            assembly: mS,
            axes: e.rawValue.getComponents().map((i, r) => {
                var a;
                return O_({
                    constraint: t.components[r],
                    initialValue: i,
                    params: Ua(
                        s.params,
                        (a = n[r]) !== null && a !== void 0 ? a : {}
                    ),
                });
            }),
            parser: Zs,
            value: e,
            viewProps: s.viewProps,
        });
    },
});
function U8(s) {
    const e = [],
        t = Y_(s.options);
    return t && e.push(t), new Cl(e);
}
Bt({
    id: "input-string",
    type: "input",
    accept: (s, e) => {
        if (typeof s != "string") return null;
        const t = Tt(e, (n) => ({
            readonly: n.optional.constant(!1),
            options: n.optional.custom(Wd),
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: {
        reader: (s) => W_,
        constraint: (s) => U8(s.params),
        writer: (s) => Zr,
    },
    controller: (s) => {
        const e = s.document,
            t = s.value,
            n = s.constraint,
            i = n && Jh(n, jd);
        return i
            ? new hl(e, {
                  props: new de({ options: i.values.value("options") }),
                  value: t,
                  viewProps: s.viewProps,
              })
            : new Xd(e, {
                  parser: (r) => r,
                  props: de.fromObject({ formatter: Dm }),
                  value: t,
                  viewProps: s.viewProps,
              });
    },
    api(s) {
        return typeof s.controller.value.rawValue != "string"
            ? null
            : s.controller.valueController instanceof hl
            ? new z_(s.controller)
            : null;
    },
});
const wc = { monitor: { defaultInterval: 200, defaultRows: 3 } },
    Ey = be("mll");
class z8 {
    constructor(e, t) {
        (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
            (this.formatter_ = t.formatter),
            (this.element = e.createElement("div")),
            this.element.classList.add(Ey()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("textarea");
        n.classList.add(Ey("i")),
            (n.style.height = `calc(var(${YA("containerUnitSize")}) * ${
                t.rows
            })`),
            (n.readOnly = !0),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.textareaElem_ = n),
            t.value.emitter.on("change", this.onValueUpdate_),
            (this.value = t.value),
            this.update_();
    }
    update_() {
        const e = this.textareaElem_,
            t = e.scrollTop === e.scrollHeight - e.clientHeight,
            n = [];
        this.value.rawValue.forEach((i) => {
            i !== void 0 && n.push(this.formatter_(i));
        }),
            (e.textContent = n.join(`
`)),
            t && (e.scrollTop = e.scrollHeight);
    }
    onValueUpdate_() {
        this.update_();
    }
}
class e0 {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new z8(e, {
                formatter: t.formatter,
                rows: t.rows,
                value: this.value,
                viewProps: this.viewProps,
            }));
    }
}
const Py = be("sgl");
class Y8 {
    constructor(e, t) {
        (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
            (this.formatter_ = t.formatter),
            (this.element = e.createElement("div")),
            this.element.classList.add(Py()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("input");
        n.classList.add(Py("i")),
            (n.readOnly = !0),
            (n.type = "text"),
            t.viewProps.bindDisabled(n),
            this.element.appendChild(n),
            (this.inputElement = n),
            t.value.emitter.on("change", this.onValueUpdate_),
            (this.value = t.value),
            this.update_();
    }
    update_() {
        const e = this.value.rawValue,
            t = e[e.length - 1];
        this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
    }
    onValueUpdate_() {
        this.update_();
    }
}
class t0 {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new Y8(e, {
                formatter: t.formatter,
                value: this.value,
                viewProps: this.viewProps,
            }));
    }
}
Bt({
    id: "monitor-bool",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "boolean") return null;
        const t = Tt(e, (n) => ({
            readonly: n.required.constant(!0),
            rows: n.optional.number,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { reader: (s) => j_ },
    controller: (s) => {
        var e;
        return s.value.rawValue.length === 1
            ? new t0(s.document, {
                  formatter: vy,
                  value: s.value,
                  viewProps: s.viewProps,
              })
            : new e0(s.document, {
                  formatter: vy,
                  rows:
                      (e = s.params.rows) !== null && e !== void 0
                          ? e
                          : wc.monitor.defaultRows,
                  value: s.value,
                  viewProps: s.viewProps,
              });
    },
});
class G8 extends B_ {
    get max() {
        return this.controller.valueController.props.get("max");
    }
    set max(e) {
        this.controller.valueController.props.set("max", e);
    }
    get min() {
        return this.controller.valueController.props.get("min");
    }
    set min(e) {
        this.controller.valueController.props.set("min", e);
    }
}
const _r = be("grl");
class j8 {
    constructor(e, t) {
        (this.onCursorChange_ = this.onCursorChange_.bind(this)),
            (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
            (this.element = e.createElement("div")),
            this.element.classList.add(_r()),
            t.viewProps.bindClassModifiers(this.element),
            (this.formatter_ = t.formatter),
            (this.props_ = t.props),
            (this.cursor_ = t.cursor),
            this.cursor_.emitter.on("change", this.onCursorChange_);
        const n = e.createElementNS(Ht, "svg");
        n.classList.add(_r("g")),
            (n.style.height = `calc(var(${YA("containerUnitSize")}) * ${
                t.rows
            })`),
            this.element.appendChild(n),
            (this.svgElem_ = n);
        const i = e.createElementNS(Ht, "polyline");
        this.svgElem_.appendChild(i), (this.lineElem_ = i);
        const r = e.createElement("div");
        r.classList.add(_r("t"), be("tt")()),
            this.element.appendChild(r),
            (this.tooltipElem_ = r),
            t.value.emitter.on("change", this.onValueUpdate_),
            (this.value = t.value),
            this.update_();
    }
    get graphElement() {
        return this.svgElem_;
    }
    update_() {
        const e = this.svgElem_.getBoundingClientRect(),
            t = this.value.rawValue.length - 1,
            n = this.props_.get("min"),
            i = this.props_.get("max"),
            r = [];
        this.value.rawValue.forEach((u, c) => {
            if (u === void 0) return;
            const d = ue(c, 0, t, 0, e.width),
                f = ue(u, n, i, e.height, 0);
            r.push([d, f].join(","));
        }),
            this.lineElem_.setAttributeNS(null, "points", r.join(" "));
        const a = this.tooltipElem_,
            o = this.value.rawValue[this.cursor_.rawValue];
        if (o === void 0) {
            a.classList.remove(_r("t", "a"));
            return;
        }
        const h = ue(this.cursor_.rawValue, 0, t, 0, e.width),
            l = ue(o, n, i, e.height, 0);
        (a.style.left = `${h}px`),
            (a.style.top = `${l}px`),
            (a.textContent = `${this.formatter_(o)}`),
            a.classList.contains(_r("t", "a")) ||
                (a.classList.add(_r("t", "a"), _r("t", "in")),
                Ju(a),
                a.classList.remove(_r("t", "in")));
    }
    onValueUpdate_() {
        this.update_();
    }
    onCursorChange_() {
        this.update_();
    }
}
class n0 {
    constructor(e, t) {
        if (
            ((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
            (this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
            (this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this)),
            (this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this)),
            (this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
            (this.props = t.props),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.cursor_ = kt(-1)),
            (this.view = new j8(e, {
                cursor: this.cursor_,
                formatter: t.formatter,
                rows: t.rows,
                props: this.props,
                value: this.value,
                viewProps: this.viewProps,
            })),
            !Ud(e))
        )
            this.view.element.addEventListener(
                "mousemove",
                this.onGraphMouseMove_
            ),
                this.view.element.addEventListener(
                    "mouseleave",
                    this.onGraphMouseLeave_
                );
        else {
            const n = new cr(this.view.element);
            n.emitter.on("down", this.onGraphPointerDown_),
                n.emitter.on("move", this.onGraphPointerMove_),
                n.emitter.on("up", this.onGraphPointerUp_);
        }
    }
    importProps(e) {
        return ii(
            e,
            null,
            (t) => ({ max: t.required.number, min: t.required.number }),
            (t) => (
                this.props.set("max", t.max), this.props.set("min", t.min), !0
            )
        );
    }
    exportProps() {
        return ri(null, {
            max: this.props.get("max"),
            min: this.props.get("min"),
        });
    }
    onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
    }
    onGraphMouseMove_(e) {
        const t = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(
            ue(e.offsetX, 0, t.width, 0, this.value.rawValue.length)
        );
    }
    onGraphPointerDown_(e) {
        this.onGraphPointerMove_(e);
    }
    onGraphPointerMove_(e) {
        if (!e.data.point) {
            this.cursor_.rawValue = -1;
            return;
        }
        this.cursor_.rawValue = Math.floor(
            ue(
                e.data.point.x,
                0,
                e.data.bounds.width,
                0,
                this.value.rawValue.length
            )
        );
    }
    onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
    }
}
function Nm(s) {
    return vt(s.format) ? cn(2) : s.format;
}
function W8(s) {
    var e;
    return s.value.rawValue.length === 1
        ? new t0(s.document, {
              formatter: Nm(s.params),
              value: s.value,
              viewProps: s.viewProps,
          })
        : new e0(s.document, {
              formatter: Nm(s.params),
              rows:
                  (e = s.params.rows) !== null && e !== void 0
                      ? e
                      : wc.monitor.defaultRows,
              value: s.value,
              viewProps: s.viewProps,
          });
}
function X8(s) {
    var e, t, n;
    return new n0(s.document, {
        formatter: Nm(s.params),
        rows:
            (e = s.params.rows) !== null && e !== void 0
                ? e
                : wc.monitor.defaultRows,
        props: de.fromObject({
            max: (t = s.params.max) !== null && t !== void 0 ? t : 100,
            min: (n = s.params.min) !== null && n !== void 0 ? n : 0,
        }),
        value: s.value,
        viewProps: s.viewProps,
    });
}
function ky(s) {
    return s.view === "graph";
}
Bt({
    id: "monitor-number",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "number") return null;
        const t = Tt(e, (n) => ({
            format: n.optional.function,
            max: n.optional.number,
            min: n.optional.number,
            readonly: n.required.constant(!0),
            rows: n.optional.number,
            view: n.optional.string,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { defaultBufferSize: (s) => (ky(s) ? 64 : 1), reader: (s) => T_ },
    controller: (s) => (ky(s.params) ? X8(s) : W8(s)),
    api: (s) =>
        s.controller.valueController instanceof n0
            ? new G8(s.controller)
            : null,
});
Bt({
    id: "monitor-string",
    type: "monitor",
    accept: (s, e) => {
        if (typeof s != "string") return null;
        const t = Tt(e, (n) => ({
            multiline: n.optional.boolean,
            readonly: n.required.constant(!0),
            rows: n.optional.number,
        }));
        return t ? { initialValue: s, params: t } : null;
    },
    binding: { reader: (s) => W_ },
    controller: (s) => {
        var e;
        const t = s.value;
        return t.rawValue.length > 1 || s.params.multiline
            ? new e0(s.document, {
                  formatter: Dm,
                  rows:
                      (e = s.params.rows) !== null && e !== void 0
                          ? e
                          : wc.monitor.defaultRows,
                  value: t,
                  viewProps: s.viewProps,
              })
            : new t0(s.document, {
                  formatter: Dm,
                  value: t,
                  viewProps: s.viewProps,
              });
    },
});
class q8 {
    constructor(e) {
        this.controller_ = e;
    }
    get disabled() {
        return this.controller_.viewProps.get("disabled");
    }
    set disabled(e) {
        this.controller_.viewProps.set("disabled", e);
    }
    get title() {
        var e;
        return (e = this.controller_.props.get("title")) !== null &&
            e !== void 0
            ? e
            : "";
    }
    set title(e) {
        this.controller_.props.set("title", e);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.controller_.emitter.on(e, () => {
                n(new Ja(this));
            }),
            this
        );
    }
}
class H8 extends Ja {
    constructor(e, t, n) {
        super(e), (this.cell = t), (this.index = n);
    }
}
class K8 extends Qa {
    constructor(e) {
        super(e), (this.cellToApiMap_ = new Map()), (this.emitter_ = new wn());
        const t = this.controller.valueController;
        t.cellControllers.forEach((n, i) => {
            const r = new q8(n);
            this.cellToApiMap_.set(n, r),
                n.emitter.on("click", () => {
                    const a = i % t.size[0],
                        o = Math.floor(i / t.size[0]);
                    this.emitter_.emit("click", {
                        event: new H8(this, r, [a, o]),
                    });
                });
        });
    }
    cell(e, t) {
        const n = this.controller.valueController,
            i = n.cellControllers[t * n.size[0] + e];
        return this.cellToApiMap_.get(i);
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.emitter_.on(e, (i) => {
                n(i.event);
            }),
            this
        );
    }
}
class Z8 {
    constructor(e, t) {
        this.size = t.size;
        const [n, i] = this.size,
            r = [];
        for (let a = 0; a < i; a++)
            for (let o = 0; o < n; o++) {
                const h = new NA(e, {
                    props: de.fromObject(Object.assign({}, t.cellConfig(o, a))),
                    viewProps: or.create(),
                });
                r.push(h);
            }
        (this.cellCs_ = r),
            (this.viewProps = or.create()),
            this.viewProps.handleDispose(() => {
                this.cellCs_.forEach((a) => {
                    a.viewProps.set("disposed", !0);
                });
            }),
            (this.view = new GA(e, {
                viewProps: this.viewProps,
                viewName: "btngrid",
            })),
            (this.view.element.style.gridTemplateColumns = `repeat(${n}, 1fr)`),
            this.cellCs_.forEach((a) => {
                this.view.element.appendChild(a.view.element);
            });
    }
    get cellControllers() {
        return this.cellCs_;
    }
}
class Ty extends vc {
    constructor(e, t) {
        const n = t.valueController,
            i = new Yd(e, {
                blade: t.blade,
                props: t.labelProps,
                valueController: n,
            });
        super({ blade: t.blade, view: i.view, viewProps: n.viewProps }),
            (this.valueController = n),
            (this.labelController = i);
    }
}
Bt({
    id: "buttongrid",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            cells: t.required.function,
            size: t.required.array(t.required.number),
            view: t.required.constant("buttongrid"),
            label: t.optional.string,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        return new Ty(s.document, {
            blade: s.blade,
            labelProps: de.fromObject({ label: s.params.label }),
            valueController: new Z8(s.document, {
                cellConfig: s.params.cells,
                size: s.params.size,
            }),
        });
    },
    api(s) {
        return s.controller instanceof Ty ? new K8(s.controller) : null;
    },
});
class Q8 extends Qa {
    get label() {
        return this.controller.labelController.props.get("label");
    }
    set label(e) {
        this.controller.labelController.props.set("label", e);
    }
    get value() {
        return this.controller.valueController.value.rawValue;
    }
    set value(e) {
        this.controller.valueController.value.rawValue = e;
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.controller.valueController.value.emitter.on(e, (i) => {
                n(new Vd(this, i.rawValue, i.options.last));
            }),
            this
        );
    }
}
function vs(s, e, t) {
    return s * (1 - t) + e * t;
}
const J8 = 20,
    eV = 0.001,
    xp = 100;
function tV(s, e) {
    let t = 0.25,
        n = 0.5,
        i = -1;
    for (let r = 0; r < J8; r++) {
        const [a, o] = s.curve(n);
        if (
            ((n += t * (a < e ? 1 : -1)),
            (i = o),
            (t *= 0.5),
            Math.abs(e - a) < eV)
        )
            break;
    }
    return i;
}
class Ga {
    constructor(e = 0, t = 0, n = 1, i = 1) {
        (this.cache_ = []), (this.comps_ = [e, t, n, i]);
    }
    get x1() {
        return this.comps_[0];
    }
    get y1() {
        return this.comps_[1];
    }
    get x2() {
        return this.comps_[2];
    }
    get y2() {
        return this.comps_[3];
    }
    static isObject(e) {
        return vt(e) || !Array.isArray(e)
            ? !1
            : typeof e[0] == "number" &&
                  typeof e[1] == "number" &&
                  typeof e[2] == "number" &&
                  typeof e[3] == "number";
    }
    static equals(e, t) {
        return e.x1 === t.x1 && e.y1 === t.y1 && e.x2 === t.x2 && e.y2 === t.y2;
    }
    curve(e) {
        const t = vs(0, this.x1, e),
            n = vs(0, this.y1, e),
            i = vs(this.x1, this.x2, e),
            r = vs(this.y1, this.y2, e),
            a = vs(this.x2, 1, e),
            o = vs(this.y2, 1, e),
            h = vs(t, i, e),
            l = vs(n, r, e),
            u = vs(i, a, e),
            c = vs(r, o, e);
        return [vs(h, u, e), vs(l, c, e)];
    }
    y(e) {
        if (this.cache_.length === 0) {
            const t = [];
            for (let n = 0; n < xp; n++)
                t.push(tV(this, ue(n, 0, xp - 1, 0, 1)));
            this.cache_ = t;
        }
        return this.cache_[Math.round(ue(At(e, 0, 1), 0, 1, 0, xp - 1))];
    }
    toObject() {
        return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]];
    }
}
const gS = {
    toComponents: (s) => s.toObject(),
    fromComponents: (s) => new Ga(...s),
};
function nV(s) {
    const e = cn(2);
    return `cubic-bezier(${s
        .toObject()
        .map((n) => e(n))
        .join(", ")})`;
}
const My = [0, 0.5, 0.5, 1];
function sV(s) {
    const e = s.match(
        /^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/
    );
    if (!e) return new Ga(...My);
    const t = [e[1], e[2], e[3], e[4]].reduce((n, i) => {
        if (!n) return null;
        const r = Number(i);
        return isNaN(r) ? null : [...n, r];
    }, []);
    return new Ga(...(t ?? My));
}
const ia = be("cbz");
class iV {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(ia()),
            t.viewProps.bindClassModifiers(this.element),
            t.foldable.bindExpandedClass(this.element, ia(void 0, "expanded")),
            Bs(t.foldable, "completed", Kr(this.element, ia(void 0, "cpl")));
        const n = e.createElement("div");
        n.classList.add(ia("h")), this.element.appendChild(n);
        const i = e.createElement("button");
        i.classList.add(ia("b")), t.viewProps.bindDisabled(i);
        const r = e.createElementNS(Ht, "svg");
        (r.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>'),
            i.appendChild(r),
            n.appendChild(i),
            (this.buttonElement = i);
        const a = e.createElement("div");
        if (
            (a.classList.add(ia("t")),
            n.appendChild(a),
            (this.textElement = a),
            t.pickerLayout === "inline")
        ) {
            const o = e.createElement("div");
            o.classList.add(ia("p")),
                this.element.appendChild(o),
                (this.pickerElement = o);
        } else this.pickerElement = null;
    }
}
const Cp = be("cbzp");
class rV {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(Cp()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("div");
        n.classList.add(Cp("g")),
            this.element.appendChild(n),
            (this.graphElement = n);
        const i = e.createElement("div");
        i.classList.add(Cp("t")),
            this.element.appendChild(i),
            (this.textElement = i);
    }
}
function _S(s, e) {
    const t = new MutationObserver((i) => {
            for (const r of i)
                r.type === "childList" &&
                    r.addedNodes.forEach((a) => {
                        a.contains(a) && (e(), t.disconnect());
                    });
        }),
        n = s.ownerDocument;
    t.observe(n.body, { attributes: !0, childList: !0, subtree: !0 });
}
const vr = be("cbzg");
function aV(s, e) {
    return (t) => e(s(t));
}
class oV {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(vr()),
            t.viewProps.bindClassModifiers(this.element),
            t.viewProps.bindTabIndex(this.element);
        const n = e.createElement("div");
        n.classList.add(vr("p")),
            this.element.appendChild(n),
            (this.previewElement = n);
        const i = e.createElementNS(Ht, "svg");
        i.classList.add(vr("g")),
            this.element.appendChild(i),
            (this.svgElem_ = i);
        const r = e.createElementNS(Ht, "path");
        r.classList.add(vr("u")),
            this.svgElem_.appendChild(r),
            (this.guideElem_ = r);
        const a = e.createElementNS(Ht, "polyline");
        a.classList.add(vr("l")),
            this.svgElem_.appendChild(a),
            (this.lineElem_ = a),
            (this.handleElems_ = [
                e.createElement("div"),
                e.createElement("div"),
            ]),
            this.handleElems_.forEach((o) => {
                o.classList.add(vr("h")), this.element.appendChild(o);
            }),
            (this.vectorElems_ = [
                e.createElementNS(Ht, "line"),
                e.createElementNS(Ht, "line"),
            ]),
            this.vectorElems_.forEach((o) => {
                o.classList.add(vr("v")), this.svgElem_.appendChild(o);
            }),
            (this.value_ = t.value),
            this.value_.emitter.on("change", this.onValueChange_.bind(this)),
            (this.sel_ = t.selection),
            this.handleElems_.forEach((o, h) => {
                Rs(
                    this.sel_,
                    aV((l) => l === h, Kr(o, vr("h", "sel")))
                );
            }),
            _S(this.element, () => {
                this.refresh();
            });
    }
    getVertMargin_(e) {
        return e * 0.25;
    }
    valueToPosition(e, t) {
        const { clientWidth: n, clientHeight: i } = this.element,
            r = this.getVertMargin_(i);
        return { x: ue(e, 0, 1, 0, n), y: ue(t, 0, 1, i - r, r) };
    }
    positionToValue(e, t) {
        const n = this.element.getBoundingClientRect(),
            i = n.width,
            r = n.height,
            a = this.getVertMargin_(r);
        return { x: At(ue(e, 0, i, 0, 1), 0, 1), y: ue(t, r - a, a, 0, 1) };
    }
    refresh() {
        this.guideElem_.setAttributeNS(
            null,
            "d",
            [0, 1]
                .map((r) => {
                    const a = this.valueToPosition(0, r),
                        o = this.valueToPosition(1, r);
                    return [`M ${a.x},${a.y}`, `L ${o.x},${o.y}`].join(" ");
                })
                .join(" ")
        );
        const e = this.value_.rawValue,
            t = [];
        let n = 0;
        for (;;) {
            const r = this.valueToPosition(...e.curve(n));
            if ((t.push([r.x, r.y].join(",")), n >= 1)) break;
            n = Math.min(n + 0.05, 1);
        }
        this.lineElem_.setAttributeNS(null, "points", t.join(" "));
        const i = e.toObject();
        [0, 1].forEach((r) => {
            const a = this.valueToPosition(r, r),
                o = this.valueToPosition(i[r * 2], i[r * 2 + 1]),
                h = this.vectorElems_[r];
            h.setAttributeNS(null, "x1", String(a.x)),
                h.setAttributeNS(null, "y1", String(a.y)),
                h.setAttributeNS(null, "x2", String(o.x)),
                h.setAttributeNS(null, "y2", String(o.y));
            const l = this.handleElems_[r];
            (l.style.left = `${o.x}px`), (l.style.top = `${o.y}px`);
        });
    }
    onValueChange_() {
        this.refresh();
    }
}
const Iy = 24,
    Ry = 400,
    Ly = 1e3,
    mo = be("cbzprv");
class lV {
    constructor(e, t) {
        (this.stopped_ = !0),
            (this.startTime_ = -1),
            (this.onDispose_ = this.onDispose_.bind(this)),
            (this.onTimer_ = this.onTimer_.bind(this)),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.element = e.createElement("div")),
            this.element.classList.add(mo()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElementNS(Ht, "svg");
        n.classList.add(mo("g")),
            this.element.appendChild(n),
            (this.svgElem_ = n);
        const i = e.createElementNS(Ht, "path");
        i.classList.add(mo("t")),
            this.svgElem_.appendChild(i),
            (this.ticksElem_ = i);
        const r = e.createElement("div");
        r.classList.add(mo("m")),
            this.element.appendChild(r),
            (this.markerElem_ = r),
            (this.value_ = t.value),
            this.value_.emitter.on("change", this.onValueChange_),
            t.viewProps.handleDispose(this.onDispose_),
            _S(this.element, () => {
                this.refresh();
            });
    }
    play() {
        this.stop(),
            this.updateMarker_(0),
            this.markerElem_.classList.add(mo("m", "a")),
            (this.startTime_ = new Date().getTime() + Ry),
            (this.stopped_ = !1),
            requestAnimationFrame(this.onTimer_);
    }
    stop() {
        (this.stopped_ = !0), this.markerElem_.classList.remove(mo("m", "a"));
    }
    onDispose_() {
        this.stop();
    }
    updateMarker_(e) {
        const t = this.value_.rawValue.y(At(e, 0, 1));
        this.markerElem_.style.left = `${t * 100}%`;
    }
    refresh() {
        const { clientWidth: e, clientHeight: t } = this.svgElem_,
            n = [],
            i = this.value_.rawValue;
        for (let r = 0; r < Iy; r++) {
            const a = ue(r, 0, Iy - 1, 0, 1),
                o = ue(i.y(a), 0, 1, 0, e);
            n.push(`M ${o},0 v${t}`);
        }
        this.ticksElem_.setAttributeNS(null, "d", n.join(" "));
    }
    onTimer_() {
        if (this.startTime_ === null) return;
        const e = new Date().getTime() - this.startTime_,
            t = e / Ly;
        this.updateMarker_(t),
            e > Ly + Ry && this.stop(),
            this.stopped_ || requestAnimationFrame(this.onTimer_);
    }
    onValueChange_() {
        this.refresh(), this.play();
    }
}
function Vm(s, e, t, n) {
    const i = t - s,
        r = n - e;
    return Math.sqrt(i * i + r * r);
}
function hV(s, e, t, n) {
    const i = Vm(s, e, t, n),
        r = Math.atan2(n - e, t - s),
        a = (Math.round(r / (Math.PI / 4)) * Math.PI) / 4;
    return { x: s + Math.cos(a) * i, y: e + Math.sin(a) * i };
}
class cV {
    constructor(e, t) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
            (this.onKeyUp_ = this.onKeyUp_.bind(this)),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.keyScale_ = t.keyScale),
            (this.value = t.value),
            (this.sel_ = kt(0)),
            (this.viewProps = t.viewProps),
            (this.view = new oV(e, {
                selection: this.sel_,
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.element.addEventListener("keydown", this.onKeyDown_),
            this.view.element.addEventListener("keyup", this.onKeyUp_),
            (this.prevView_ = new lV(e, {
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.prevView_.element.addEventListener("mousedown", (i) => {
                i.stopImmediatePropagation(),
                    i.preventDefault(),
                    this.prevView_.play();
            }),
            this.view.previewElement.appendChild(this.prevView_.element);
        const n = new cr(this.view.element);
        n.emitter.on("down", this.onPointerDown_),
            n.emitter.on("move", this.onPointerMove_),
            n.emitter.on("up", this.onPointerUp_);
    }
    refresh() {
        this.view.refresh(), this.prevView_.refresh(), this.prevView_.play();
    }
    updateValue_(e, t, n) {
        const i = this.sel_.rawValue,
            r = this.value.rawValue.toObject(),
            a = this.view.positionToValue(e.x, e.y),
            o = t ? hV(i, i, a.x, a.y) : a;
        (r[i * 2] = o.x),
            (r[i * 2 + 1] = o.y),
            this.value.setRawValue(new Ga(...r), n);
    }
    onPointerDown_(e) {
        const t = e.data;
        if (!t.point) return;
        const n = this.value.rawValue,
            i = this.view.valueToPosition(n.x1, n.y1),
            r = Vm(t.point.x, t.point.y, i.x, i.y),
            a = this.view.valueToPosition(n.x2, n.y2),
            o = Vm(t.point.x, t.point.y, a.x, a.y);
        (this.sel_.rawValue = r <= o ? 0 : 1),
            this.updateValue_(t.point, e.shiftKey, { forceEmit: !1, last: !1 });
    }
    onPointerMove_(e) {
        const t = e.data;
        t.point &&
            this.updateValue_(t.point, e.shiftKey, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        const t = e.data;
        t.point &&
            this.updateValue_(t.point, e.shiftKey, { forceEmit: !0, last: !0 });
    }
    onKeyDown_(e) {
        nd(e.key) && e.preventDefault();
        const t = this.sel_.rawValue,
            n = this.value.rawValue.toObject(),
            i = this.keyScale_.rawValue;
        (n[t * 2] += Kt(i, Qs(e))),
            (n[t * 2 + 1] += Kt(i, za(e))),
            this.value.setRawValue(new Ga(...n), { forceEmit: !1, last: !1 });
    }
    onKeyUp_(e) {
        nd(e.key) && e.preventDefault();
        const t = this.keyScale_.rawValue,
            n = Kt(t, Qs(e)),
            i = Kt(t, za(e));
        (n === 0 && i === 0) ||
            this.value.setRawValue(this.value.rawValue, {
                forceEmit: !0,
                last: !0,
            });
    }
}
class uV {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new rV(e, { viewProps: this.viewProps })),
            (this.gc_ = new cV(e, {
                keyScale: t.axis.textProps.value("keyScale"),
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.graphElement.appendChild(this.gc_.view.element);
        const n = Object.assign(Object.assign({}, t.axis), {
                constraint: new E_({ max: 1, min: 0 }),
            }),
            i = Object.assign(Object.assign({}, t.axis), {
                constraint: void 0,
            });
        (this.tc_ = new Al(e, {
            assembly: gS,
            axes: [n, i, n, i],
            parser: Zs,
            value: this.value,
            viewProps: this.viewProps,
        })),
            this.view.textElement.appendChild(this.tc_.view.element);
    }
    get allFocusableElements() {
        return [
            this.gc_.view.element,
            ...this.tc_.view.textViews.map((e) => e.inputElement),
        ];
    }
    refresh() {
        this.gc_.refresh();
    }
}
class Oy {
    constructor(e, t) {
        (this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
            (this.onButtonClick_ = this.onButtonClick_.bind(this)),
            (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
            (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
            (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.foldable_ = xl.create(t.expanded)),
            (this.view = new iV(e, {
                foldable: this.foldable_,
                pickerLayout: t.pickerLayout,
                viewProps: this.viewProps,
            })),
            this.view.buttonElement.addEventListener(
                "blur",
                this.onButtonBlur_
            ),
            this.view.buttonElement.addEventListener(
                "click",
                this.onButtonClick_
            ),
            (this.tc_ = new Xd(e, {
                parser: sV,
                props: de.fromObject({ formatter: nV }),
                value: this.value,
                viewProps: this.viewProps,
            })),
            this.view.textElement.appendChild(this.tc_.view.element),
            (this.popC_ =
                t.pickerLayout === "popup"
                    ? new G_(e, { viewProps: this.viewProps })
                    : null);
        const n = new uV(e, {
            axis: t.axis,
            value: this.value,
            viewProps: this.viewProps,
        });
        n.allFocusableElements.forEach((i) => {
            i.addEventListener("blur", this.onPopupChildBlur_),
                i.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
            (this.pickerC_ = n),
            this.popC_
                ? (this.view.element.appendChild(this.popC_.view.element),
                  this.popC_.view.element.appendChild(
                      this.pickerC_.view.element
                  ),
                  Rs(this.popC_.shows, (i) => {
                      i && n.refresh();
                  }),
                  eo({
                      primary: this.foldable_.value("expanded"),
                      secondary: this.popC_.shows,
                      forward: (i) => i,
                      backward: (i, r) => r,
                  }))
                : this.view.pickerElement &&
                  (this.view.pickerElement.appendChild(
                      this.pickerC_.view.element
                  ),
                  Gd(this.foldable_, this.view.pickerElement));
    }
    onButtonBlur_(e) {
        if (!this.popC_) return;
        const t = e.relatedTarget;
        (!t || !this.popC_.view.element.contains(t)) &&
            (this.popC_.shows.rawValue = !1);
    }
    onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
            this.foldable_.get("expanded") &&
                this.pickerC_.allFocusableElements[0].focus();
    }
    onPopupChildBlur_(e) {
        if (!this.popC_) return;
        const t = this.popC_.view.element,
            n = $_(e);
        (n && t.contains(n)) ||
            (n && n === this.view.buttonElement && !Ud(t.ownerDocument)) ||
            (this.popC_.shows.rawValue = !1);
    }
    onPopupChildKeydown_(e) {
        this.popC_ && e.key === "Escape" && (this.popC_.shows.rawValue = !1);
    }
}
function dV() {
    return new Hd({
        assembly: gS,
        components: [0, 1, 2, 3].map((s) =>
            s % 2 === 0 ? new E_({ min: 0, max: 1 }) : void 0
        ),
    });
}
Bt({
    id: "cubicbezier",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            value: t.required.array(t.required.number),
            view: t.required.constant("cubicbezier"),
            expanded: t.optional.boolean,
            label: t.optional.string,
            picker: t.optional.custom((n) =>
                n === "inline" || n === "popup" ? n : void 0
            ),
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        var e, t;
        const n = new Ga(...s.params.value),
            i = kt(n, { constraint: dV(), equals: Ga.equals }),
            r = new Oy(s.document, {
                axis: {
                    textProps: de.fromObject({
                        keyScale: 0.1,
                        pointerScale: 0.01,
                        formatter: cn(2),
                    }),
                },
                expanded:
                    (e = s.params.expanded) !== null && e !== void 0 ? e : !1,
                pickerLayout:
                    (t = s.params.picker) !== null && t !== void 0
                        ? t
                        : "popup",
                value: i,
                viewProps: s.viewProps,
            });
        return new ed(s.document, {
            blade: s.blade,
            props: de.fromObject({ label: s.params.label }),
            value: i,
            valueController: r,
        });
    },
    api(s) {
        return !(s.controller instanceof ed) ||
            !(s.controller.valueController instanceof Oy)
            ? null
            : new Q8(s.controller);
    },
});
class fV extends Qa {
    get fps() {
        return this.controller.valueController.fps;
    }
    get max() {
        return this.controller.valueController.props.get("max");
    }
    set max(e) {
        this.controller.valueController.props.set("max", e);
    }
    get min() {
        return this.controller.valueController.props.get("min");
    }
    set min(e) {
        this.controller.valueController.props.set("min", e);
    }
    begin() {
        this.controller.valueController.begin();
    }
    end() {
        this.controller.valueController.end();
    }
    on(e, t) {
        const n = t.bind(this);
        return (
            this.controller.valueController.ticker.emitter.on(e, () => {
                n(new Ja(this));
            }),
            this
        );
    }
}
const By = 20;
class pV {
    constructor() {
        (this.start_ = null),
            (this.duration_ = 0),
            (this.fps_ = null),
            (this.frameCount_ = 0),
            (this.timestamps_ = []);
    }
    get duration() {
        return this.duration_;
    }
    get fps() {
        return this.fps_;
    }
    begin(e) {
        this.start_ = e.getTime();
    }
    calculateFps_(e) {
        if (this.timestamps_.length === 0) return null;
        const t = this.timestamps_[0];
        return (1e3 * (this.frameCount_ - t.frameCount)) / (e - t.time);
    }
    compactTimestamps_() {
        if (this.timestamps_.length <= By) return;
        const e = this.timestamps_.length - By;
        this.timestamps_.splice(0, e);
        const t = this.timestamps_[0].frameCount;
        this.timestamps_.forEach((n) => {
            n.frameCount -= t;
        }),
            (this.frameCount_ -= t);
    }
    end(e) {
        if (this.start_ === null) return;
        const t = e.getTime();
        (this.duration_ = t - this.start_),
            (this.start_ = null),
            (this.fps_ = this.calculateFps_(t)),
            this.timestamps_.push({ frameCount: this.frameCount_, time: t }),
            ++this.frameCount_,
            this.compactTimestamps_();
    }
}
const ql = be("fps");
class mV {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(ql()),
            t.viewProps.bindClassModifiers(this.element),
            (this.graphElement = e.createElement("div")),
            this.graphElement.classList.add(ql("g")),
            this.element.appendChild(this.graphElement);
        const n = e.createElement("div");
        n.classList.add(ql("l")), this.element.appendChild(n);
        const i = e.createElement("span");
        i.classList.add(ql("v")),
            (i.textContent = "--"),
            n.appendChild(i),
            (this.valueElement = i);
        const r = e.createElement("span");
        r.classList.add(ql("u")), (r.textContent = "FPS"), n.appendChild(r);
    }
}
class gV {
    constructor(e, t) {
        (this.stopwatch_ = new pV()),
            (this.onTick_ = this.onTick_.bind(this)),
            (this.ticker = t.ticker),
            this.ticker.emitter.on("tick", this.onTick_),
            (this.props = t.props),
            (this.value_ = t.value),
            (this.viewProps = t.viewProps),
            (this.view = new mV(e, { viewProps: this.viewProps })),
            (this.graphC_ = new n0(e, {
                formatter: cn(0),
                props: this.props,
                rows: t.rows,
                value: this.value_,
                viewProps: this.viewProps,
            })),
            this.view.graphElement.appendChild(this.graphC_.view.element),
            this.viewProps.handleDispose(() => {
                this.graphC_.viewProps.set("disposed", !0),
                    this.ticker.dispose();
            });
    }
    get fps() {
        return this.stopwatch_.fps;
    }
    begin() {
        this.stopwatch_.begin(new Date());
    }
    end() {
        this.stopwatch_.end(new Date());
    }
    onTick_() {
        const e = this.fps;
        if (e !== null) {
            const t = this.value_.rawValue;
            (this.value_.rawValue = mN(t, e)),
                (this.view.valueElement.textContent = e.toFixed(0));
        }
    }
}
class Fy extends vc {
    constructor(e, t) {
        const n = t.valueController,
            i = new Yd(e, {
                blade: t.blade,
                props: t.labelProps,
                valueController: n,
            });
        super({ blade: t.blade, view: i.view, viewProps: n.viewProps }),
            (this.valueController = n),
            (this.labelController = i);
    }
}
function _V(s, e) {
    return e === 0 ? new zN() : new YN(s, e ?? wc.monitor.defaultInterval);
}
Bt({
    id: "fpsgraph",
    type: "blade",
    accept(s) {
        const e = Tt(s, (t) => ({
            view: t.required.constant("fpsgraph"),
            interval: t.optional.number,
            label: t.optional.string,
            rows: t.optional.number,
            max: t.optional.number,
            min: t.optional.number,
        }));
        return e ? { params: e } : null;
    },
    controller(s) {
        var e, t, n, i;
        const r = (e = s.params.interval) !== null && e !== void 0 ? e : 500;
        return new Fy(s.document, {
            blade: s.blade,
            labelProps: de.fromObject({ label: s.params.label }),
            valueController: new gV(s.document, {
                props: de.fromObject({
                    max: (t = s.params.max) !== null && t !== void 0 ? t : 90,
                    min: (n = s.params.min) !== null && n !== void 0 ? n : 0,
                }),
                rows: (i = s.params.rows) !== null && i !== void 0 ? i : 2,
                ticker: _V(s.document, r),
                value: kt(fN(80)),
                viewProps: s.viewProps,
            }),
        });
    },
    api(s) {
        return s.controller instanceof Fy ? new fV(s.controller) : null;
    },
});
class Ls {
    constructor(e, t) {
        (this.min = e), (this.max = t);
    }
    static isObject(e) {
        if (typeof e != "object" || e === null) return !1;
        const t = e.min,
            n = e.max;
        return !(typeof t != "number" || typeof n != "number");
    }
    static equals(e, t) {
        return e.min === t.min && e.max === t.max;
    }
    get length() {
        return this.max - this.min;
    }
    toObject() {
        return { min: this.min, max: this.max };
    }
}
const vS = {
    fromComponents: (s) => new Ls(s[0], s[1]),
    toComponents: (s) => [s.min, s.max],
};
class bS {
    constructor(e) {
        this.edge = e;
    }
    constrain(e) {
        var t, n, i, r, a, o, h, l;
        if (e.min <= e.max)
            return new Ls(
                (n =
                    (t = this.edge) === null || t === void 0
                        ? void 0
                        : t.constrain(e.min)) !== null && n !== void 0
                    ? n
                    : e.min,
                (r =
                    (i = this.edge) === null || i === void 0
                        ? void 0
                        : i.constrain(e.max)) !== null && r !== void 0
                    ? r
                    : e.max
            );
        const u = (e.min + e.max) / 2;
        return new Ls(
            (o =
                (a = this.edge) === null || a === void 0
                    ? void 0
                    : a.constrain(u)) !== null && o !== void 0
                ? o
                : u,
            (l =
                (h = this.edge) === null || h === void 0
                    ? void 0
                    : h.constrain(u)) !== null && l !== void 0
                ? l
                : u
        );
    }
}
const Ap = be("rsltxt");
class vV {
    constructor(e, t) {
        (this.sliderView_ = t.sliderView),
            (this.textView_ = t.textView),
            (this.element = e.createElement("div")),
            this.element.classList.add(Ap());
        const n = e.createElement("div");
        n.classList.add(Ap("s")),
            n.appendChild(this.sliderView_.element),
            this.element.appendChild(n);
        const i = e.createElement("div");
        i.classList.add(Ap("t")),
            i.appendChild(this.textView_.element),
            this.element.appendChild(i);
    }
}
const ra = be("rsl");
class bV {
    constructor(e, t) {
        (this.onSliderPropsChange_ = this.onSliderPropsChange_.bind(this)),
            (this.onValueChange_ = this.onValueChange_.bind(this)),
            (this.sliderProps_ = t.sliderProps),
            this.sliderProps_.emitter.on("change", this.onSliderPropsChange_),
            (this.element = e.createElement("div")),
            this.element.classList.add(ra()),
            t.viewProps.bindClassModifiers(this.element),
            (this.value_ = t.value),
            this.value_.emitter.on("change", this.onValueChange_);
        const n = e.createElement("div");
        n.classList.add(ra("t")),
            this.element.appendChild(n),
            (this.trackElement = n);
        const i = e.createElement("div");
        i.classList.add(ra("b")), n.appendChild(i), (this.barElement = i);
        const r = ["min", "max"].map((a) => {
            const o = e.createElement("div");
            return o.classList.add(ra("k"), ra("k", a)), n.appendChild(o), o;
        });
        (this.knobElements = [r[0], r[1]]), this.update_();
    }
    valueToX_(e) {
        const t = this.sliderProps_.get("min"),
            n = this.sliderProps_.get("max");
        return At(ue(e, t, n, 0, 1), 0, 1) * 100;
    }
    update_() {
        const e = this.value_.rawValue;
        e.length === 0
            ? this.element.classList.add(ra(void 0, "zero"))
            : this.element.classList.remove(ra(void 0, "zero"));
        const t = [this.valueToX_(e.min), this.valueToX_(e.max)];
        (this.barElement.style.left = `${t[0]}%`),
            (this.barElement.style.right = `${100 - t[1]}%`),
            this.knobElements.forEach((n, i) => {
                n.style.left = `${t[i]}%`;
            });
    }
    onSliderPropsChange_() {
        this.update_();
    }
    onValueChange_() {
        this.update_();
    }
}
class yV {
    constructor(e, t) {
        (this.grabbing_ = null),
            (this.grabOffset_ = 0),
            (this.onPointerDown_ = this.onPointerDown_.bind(this)),
            (this.onPointerMove_ = this.onPointerMove_.bind(this)),
            (this.onPointerUp_ = this.onPointerUp_.bind(this)),
            (this.sliderProps = t.sliderProps),
            (this.viewProps = t.viewProps),
            (this.value = t.value),
            (this.view = new bV(e, {
                sliderProps: this.sliderProps,
                value: this.value,
                viewProps: t.viewProps,
            }));
        const n = new cr(this.view.trackElement);
        n.emitter.on("down", this.onPointerDown_),
            n.emitter.on("move", this.onPointerMove_),
            n.emitter.on("up", this.onPointerUp_);
    }
    ofs_() {
        return this.grabbing_ === "min"
            ? this.view.knobElements[0].getBoundingClientRect().width / 2
            : this.grabbing_ === "max"
            ? -this.view.knobElements[1].getBoundingClientRect().width / 2
            : 0;
    }
    valueFromData_(e) {
        if (!e.point) return null;
        const t = (e.point.x + this.ofs_()) / e.bounds.width,
            n = this.sliderProps.get("min"),
            i = this.sliderProps.get("max");
        return ue(t, 0, 1, n, i);
    }
    onPointerDown_(e) {
        if (!e.data.point) return;
        const t = e.data.point.x / e.data.bounds.width,
            n = this.value.rawValue,
            i = this.sliderProps.get("min"),
            r = this.sliderProps.get("max"),
            a = ue(n.min, i, r, 0, 1),
            o = ue(n.max, i, r, 0, 1);
        Math.abs(o - t) <= 0.025
            ? (this.grabbing_ = "max")
            : Math.abs(a - t) <= 0.025
            ? (this.grabbing_ = "min")
            : t >= a && t <= o
            ? ((this.grabbing_ = "length"),
              (this.grabOffset_ = ue(t - a, 0, 1, 0, r - i)))
            : t < a
            ? ((this.grabbing_ = "min"), this.onPointerMove_(e))
            : t > o && ((this.grabbing_ = "max"), this.onPointerMove_(e));
    }
    applyPointToValue_(e, t) {
        const n = this.valueFromData_(e);
        if (n === null) return;
        const i = this.sliderProps.get("min"),
            r = this.sliderProps.get("max");
        if (this.grabbing_ === "min")
            this.value.setRawValue(new Ls(n, this.value.rawValue.max), t);
        else if (this.grabbing_ === "max")
            this.value.setRawValue(new Ls(this.value.rawValue.min, n), t);
        else if (this.grabbing_ === "length") {
            const a = this.value.rawValue.length;
            let o = n - this.grabOffset_,
                h = o + a;
            o < i ? ((o = i), (h = i + a)) : h > r && ((o = r - a), (h = r)),
                this.value.setRawValue(new Ls(o, h), t);
        }
    }
    onPointerMove_(e) {
        this.applyPointToValue_(e.data, { forceEmit: !1, last: !1 });
    }
    onPointerUp_(e) {
        this.applyPointToValue_(e.data, { forceEmit: !0, last: !0 }),
            (this.grabbing_ = null);
    }
}
class wV {
    constructor(e, t) {
        (this.value = t.value),
            (this.viewProps = t.viewProps),
            (this.sc_ = new yV(e, t));
        const n = { constraint: t.constraint, textProps: t.textProps };
        (this.tc_ = new Al(e, {
            assembly: vS,
            axes: [n, n],
            parser: t.parser,
            value: this.value,
            viewProps: t.viewProps,
        })),
            (this.view = new vV(e, {
                sliderView: this.sc_.view,
                textView: this.tc_.view,
            }));
    }
    get textController() {
        return this.tc_;
    }
}
function xV(s) {
    return Ls.isObject(s) ? new Ls(s.min, s.max) : new Ls(0, 0);
}
function CV(s, e) {
    s.writeProperty("max", e.max), s.writeProperty("min", e.min);
}
function AV(s) {
    const e = [],
        t = I_(s);
    t && e.push(t);
    const n = M_(s);
    return n && e.push(n), new bS(new Cl(e));
}
Bt({
    id: "input-interval",
    type: "input",
    accept: (s, e) => {
        if (!Ls.isObject(s)) return null;
        const t = Tt(e, (n) =>
            Object.assign(Object.assign({}, L_(n)), {
                readonly: n.optional.constant(!1),
            })
        );
        return t ? { initialValue: new Ls(s.min, s.max), params: t } : null;
    },
    binding: {
        reader: (s) => xV,
        constraint: (s) => AV(s.params),
        equals: Ls.equals,
        writer: (s) => CV,
    },
    controller(s) {
        const e = s.value,
            t = s.constraint;
        if (!(t instanceof bS)) throw An.shouldNeverHappen();
        const n = (e.rawValue.min + e.rawValue.max) / 2,
            i = de.fromObject(R_(s.params, n)),
            r = t.edge && Jh(t.edge, _c);
        if (r)
            return new wV(s.document, {
                constraint: t.edge,
                parser: Zs,
                sliderProps: new de({
                    keyScale: i.value("keyScale"),
                    max: r.values.value("max"),
                    min: r.values.value("min"),
                }),
                textProps: i,
                value: e,
                viewProps: s.viewProps,
            });
        const a = { constraint: t.edge, textProps: i };
        return new Al(s.document, {
            assembly: vS,
            axes: [a, a],
            parser: Zs,
            value: e,
            viewProps: s.viewProps,
        });
    },
});
class SV {
    constructor(e) {
        this.controller_ = e;
    }
    get disabled() {
        return this.controller_.viewProps.get("disabled");
    }
    set disabled(e) {
        this.controller_.viewProps.set("disabled", e);
    }
    get title() {
        var e;
        return (e = this.controller_.props.get("title")) !== null &&
            e !== void 0
            ? e
            : "";
    }
    set title(e) {
        this.controller_.props.set("title", e);
    }
}
class EV extends Vd {
    constructor(e, t, n, i, r) {
        super(e, i, r), (this.cell = t), (this.index = n);
    }
}
class PV extends Qa {
    constructor(e) {
        super(e),
            (this.cellToApiMap_ = new Map()),
            this.controller.valueController.cellControllers.forEach((n) => {
                const i = new SV(n);
                this.cellToApiMap_.set(n, i);
            });
    }
    get value() {
        return this.controller.value;
    }
    cell(e, t) {
        const n = this.controller.valueController,
            i = n.cellControllers[t * n.size[0] + e];
        return this.cellToApiMap_.get(i);
    }
    on(e, t) {
        const n = t.bind(this);
        this.controller.value.emitter.on(e, (i) => {
            const r = this.controller.valueController,
                a = r.findCellByValue(i.rawValue);
            if (!a) return;
            const o = this.cellToApiMap_.get(a);
            if (!o) return;
            const h = r.cellControllers.indexOf(a);
            n(
                new EV(
                    this,
                    o,
                    [h % r.size[0], Math.floor(h / r.size[0])],
                    i.rawValue
                )
            );
        });
    }
}
const Hl = be("rad");
class kV {
    constructor(e, t) {
        (this.element = e.createElement("div")),
            this.element.classList.add(Hl()),
            t.viewProps.bindClassModifiers(this.element);
        const n = e.createElement("label");
        n.classList.add(Hl("l")), this.element.appendChild(n);
        const i = e.createElement("input");
        i.classList.add(Hl("i")),
            (i.name = t.name),
            (i.type = "radio"),
            t.viewProps.bindDisabled(i),
            n.appendChild(i),
            (this.inputElement = i);
        const r = e.createElement("div");
        r.classList.add(Hl("b")), n.appendChild(r);
        const a = e.createElement("div");
        a.classList.add(Hl("t")),
            r.appendChild(a),
            Bs(t.props, "title", (o) => {
                a.textContent = o;
            });
    }
}
class TV {
    constructor(e, t) {
        (this.props = t.props),
            (this.viewProps = t.viewProps),
            (this.view = new kV(e, {
                name: t.name,
                props: this.props,
                viewProps: this.viewProps,
            }));
    }
}
class Um {
    constructor(e, t) {
        (this.cellCs_ = []),
            (this.cellValues_ = []),
            (this.onCellInputChange_ = this.onCellInputChange_.bind(this)),
            (this.size = t.size);
        const [n, i] = this.size;
        for (let r = 0; r < i; r++)
            for (let a = 0; a < n; a++) {
                const o = new TV(e, {
                    name: t.groupName,
                    props: de.fromObject(Object.assign({}, t.cellConfig(a, r))),
                    viewProps: or.create(),
                });
                this.cellCs_.push(o),
                    this.cellValues_.push(t.cellConfig(a, r).value);
            }
        (this.value = t.value),
            Rs(this.value, (r) => {
                const a = this.findCellByValue(r);
                a && (a.view.inputElement.checked = !0);
            }),
            (this.viewProps = or.create()),
            (this.view = new GA(e, {
                viewProps: this.viewProps,
                viewName: "radgrid",
            })),
            (this.view.element.style.gridTemplateColumns = `repeat(${n}, 1fr)`),
            this.cellCs_.forEach((r) => {
                r.view.inputElement.addEventListener(
                    "change",
                    this.onCellInputChange_
                ),
                    this.view.element.appendChild(r.view.element);
            });
    }
    get cellControllers() {
        return this.cellCs_;
    }
    findCellByValue(e) {
        const t = this.cellValues_.findIndex((n) => n === e);
        return t < 0 ? null : this.cellCs_[t];
    }
    onCellInputChange_(e) {
        const t = e.currentTarget,
            n = this.cellCs_.findIndex((i) => i.view.inputElement === t);
        n < 0 || (this.value.rawValue = this.cellValues_[n]);
    }
}
(function () {
    return Bt({
        id: "radiogrid",
        type: "blade",
        accept(s) {
            const e = Tt(s, (t) => ({
                cells: t.required.function,
                groupName: t.required.string,
                size: t.required.array(t.required.number),
                value: t.required.raw,
                view: t.required.constant("radiogrid"),
                label: t.optional.string,
            }));
            return e ? { params: e } : null;
        },
        controller(s) {
            const e = kt(s.params.value);
            return new ed(s.document, {
                blade: s.blade,
                props: de.fromObject({ label: s.params.label }),
                value: e,
                valueController: new Um(s.document, {
                    groupName: s.params.groupName,
                    cellConfig: s.params.cells,
                    size: s.params.size,
                    value: e,
                }),
            });
        },
        api(s) {
            return !(s.controller instanceof ed) ||
                !(s.controller.valueController instanceof Um)
                ? null
                : new PV(s.controller);
        },
    });
})();
function s0(s) {
    return Bt({
        id: "input-radiogrid",
        type: "input",
        accept(e, t) {
            if (!s.isType(e)) return null;
            const n = Tt(t, (i) => ({
                cells: i.required.function,
                groupName: i.required.string,
                size: i.required.array(i.required.number),
                view: i.required.constant("radiogrid"),
            }));
            return n ? { initialValue: e, params: n } : null;
        },
        binding: s.binding,
        controller: (e) =>
            new Um(e.document, {
                cellConfig: e.params.cells,
                groupName: e.params.groupName,
                size: e.params.size,
                value: e.value,
            }),
    });
}
s0({
    isType: (s) => typeof s == "number",
    binding: { reader: (s) => T_, writer: (s) => Zr },
});
s0({
    isType: (s) => typeof s == "string",
    binding: { reader: (s) => W_, writer: (s) => Zr },
});
s0({
    isType: (s) => typeof s == "boolean",
    binding: { reader: (s) => j_, writer: (s) => Zr },
});
Jt(["mousedown"]);
const MV = (s, e, t) => {
    e !== "production" && Re(t, !$(t));
};
var IV = X('<div class="fade-wrap svelte-47ihl5"><!></div>'),
    RV = X(
        '<div><div class="wrap svelte-47ihl5"><div class="title svelte-47ihl5"> </div> <div class="title-logo svelte-47ihl5"><!></div></div> <!></div>'
    ),
    LV = X(
        '<!> <!> <!> <div class="main-wrap svelte-47ihl5"><!> <!> <!> <!> <!> <!></div>',
        1
    );
function OV(s, e) {
    Ne(e, !0);
    const t = () => U(ba, "$rgsUrl", l),
        n = () => U(ei, "$eventEmitter", l),
        i = () => U(us, "$layoutType", l),
        r = () => U(Ye, "$windowSizes", l),
        a = () => U(gl, "$loaded", l),
        o = () => U(_l, "$startGame", l),
        h = () => U(Wi, "$hideUI", l),
        [l, u] = tt(),
        c = "production";
    let d = gt(!1),
        f = gt(!1),
        p = gt(rn(new Date())),
        m = Me(() =>
            $(p).toLocaleTimeString("en-US", {
                hour12: !1,
                hour: "2-digit",
                minute: "2-digit",
            })
        );
    const g = async () => {
        (gi.loading = !0), (gi.error = null);
        try {
            const L = await t4({
                rgsUrl: t(),
                mode: Qe.mode,
                version: Qe.version,
                game: Qe.game,
                event: Qe.event,
            });
            gi.data = L;
        } catch (L) {
            console.error("Failed to fetch replay data:", L), (gi.error = L);
        } finally {
            gi.loading = !1;
        }
    };
    Fs(() => {
        Rb(), f4(), r4(), Re(d, !Qe.replay, !0), Qe.replay && g(), Re(f, !0);
        const L = setInterval(() => {
                Re(p, new Date(), !0);
            }, 6e4),
            F = setInterval(() => {
                Qe.replay || (n() && n().next({ type: "pollBalance" }));
            }, 5e3);
        return (
            document.addEventListener("visibilitychange", () => {
                document.visibilityState === "visible" && Rb();
            }),
            window.addEventListener(
                "click",
                (Y) => {
                    Y.isTrusted ||
                        (Y.stopImmediatePropagation(), Y.preventDefault());
                },
                !0
            ),
            () => {
                clearInterval(L), clearInterval(F);
            }
        );
    });
    let _ = gt(!1),
        v = Me(() =>
            i() === "portrait"
                ? Math.min(r().width <= 400 ? (r().width * 15) / 400 : 15)
                : Math.min(
                      r().height <= 500 ? (r().height * 18) / 500 : 18,
                      r().width <= 1040 ? (r().width * 18) / 1040 : 18
                  )
        );
    var b = LV(),
        y = me(b);
    ne(y, (L) => {});
    var C = N(y, 2);
    {
        var w = (L) => {
            T4(L, {});
        };
        ne(C, (L) => {
            $(d) && L(w);
        });
    }
    var A = N(C, 2);
    z4(A, {});
    var E = N(A, 2),
        S = I(E);
    V4(S, {});
    var P = N(S, 2);
    O4(P, {});
    var k = N(P, 2);
    I4(k, {});
    var R = N(k, 2);
    k4(R, {});
    var M = N(R, 2);
    P2(M, {});
    var T = N(M, 2);
    {
        var O = (L) => {
            var F = Oe(),
                Y = me(F);
            {
                var V = (W) => {
                    var Z = RV(),
                        J = I(Z),
                        G = I(J),
                        j = I(G),
                        H = N(G, 2);
                    H.__click = [MV, c, _];
                    var pe = I(H);
                    C2(pe);
                    var _e = N(J, 2);
                    {
                        var ve = (re) => {
                            var le = IV(),
                                at = I(le);
                            HB(at, {}),
                                Vn(
                                    3,
                                    le,
                                    () => Wr,
                                    () => ({ duration: 150 })
                                ),
                                D(re, le);
                        };
                        ne(_e, (re) => {
                            h() || re(ve);
                        });
                    }
                    ie(() => {
                        an(G, `font-size: ${$(v) ?? ""}px;`),
                            se(j, `${$(m)} | ${e.gameName}`);
                    }),
                        Vn(
                            3,
                            Z,
                            () => Wr,
                            () => ({ duration: 400, delay: 150 })
                        ),
                        D(W, Z);
                };
                ne(Y, (W) => {
                    a() && o() && W(V);
                });
            }
            D(L, F);
        };
        ne(T, (L) => {
            $(f) && (Mw.authenticated || Qe.replay) && L(O);
        });
    }
    OE(
        E,
        (L, F) => (sp == null ? void 0 : sp(L, F)),
        () => i4
    ),
        D(s, b),
        Ve(),
        u();
}
Jt(["click"]);
const $y = {
    betModes: {
        BASE: { mode: "BASE", costMultiplier: 1, type: "default" },
        ANTE: {
            mode: "ANTE",
            costMultiplier: 3,
            type: "ACTIVATE",
            image: "./assets/md_ante.webp",
            title: "EXTRA CHANCE",
            dialog: "5x the chance to trigger FREE SPINS.",
            volatility: 3,
        },
        BONUS: {
            mode: "BONUS",
            costMultiplier: 100,
            type: "BUY",
            image: "./assets/md_bonus.webp",
            title: "BLOCK BONUS",
            dialog: "Enter a Bonus game with 5 free spins. Blocks are persistent for the bonus game.",
            volatility: 4,
        },
    },
    gameRules: {
        version: "v1.0.0",
        payType: "custom",
        paytable: [
            {
                symbols: [
                    { image: "./assets/block_dirt.webp", customText: "0x" },
                    { image: "./assets/block_stone.webp", customText: "0.1x" },
                    { image: "./assets/block_ruby.webp", customText: "1x" },
                ],
            },
            {
                symbols: [
                    { image: "./assets/block_gold.webp", customText: "3x" },
                    { image: "./assets/block_diamond.webp", customText: "5x" },
                    {
                        image: "./assets/block_obsidian.webp",
                        customText: "25x",
                    },
                ],
            },
        ],
    },
};
Ow.set(["bonusEnter"]);
const BV = {
        reveal: async (s) => {
            Zc.set(0, { duration: 0 }),
                Sh.set(0, { duration: 0 }),
                await De.asyncNext({ ...s });
        },
        bonusReveal: async (s) => {
            await De.asyncNext({ ...s });
        },
        mine: async (s) => {
            await De.asyncNext({ ...s });
        },
        enhance: async (s) => {
            await De.asyncNext({ ...s });
        },
        bonusEnter: async (s) => {
            lg.set(4), await De.asyncNext({ ...s });
        },
        bonusExit: async (s) => {
            await De.asyncNext({ ...s });
        },
        totalWin: (s) => {
            De.next({ ...s }), Zc.set(Q(af(s.totalWin)));
        },
        finalWin: async (s) => {
            await De.asyncNext({ ...s }),
                Sh.set(Q(af(s.finalWin))),
                Zc.set(Q(af(s.finalWin)));
        },
    },
    FV = n4(De, BV);
var Sp = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */ var Dy;
function $V() {
    return (
        Dy ||
            ((Dy = 1),
            (function (s) {
                (function () {
                    var e = function () {
                        this.init();
                    };
                    e.prototype = {
                        init: function () {
                            var c = this || t;
                            return (
                                (c._counter = 1e3),
                                (c._html5AudioPool = []),
                                (c.html5PoolSize = 10),
                                (c._codecs = {}),
                                (c._howls = []),
                                (c._muted = !1),
                                (c._volume = 1),
                                (c._canPlayEvent = "canplaythrough"),
                                (c._navigator =
                                    typeof window < "u" && window.navigator
                                        ? window.navigator
                                        : null),
                                (c.masterGain = null),
                                (c.noAudio = !1),
                                (c.usingWebAudio = !0),
                                (c.autoSuspend = !0),
                                (c.ctx = null),
                                (c.autoUnlock = !0),
                                c._setup(),
                                c
                            );
                        },
                        volume: function (c) {
                            var d = this || t;
                            if (
                                ((c = parseFloat(c)),
                                d.ctx || u(),
                                typeof c < "u" && c >= 0 && c <= 1)
                            ) {
                                if (((d._volume = c), d._muted)) return d;
                                d.usingWebAudio &&
                                    d.masterGain.gain.setValueAtTime(
                                        c,
                                        t.ctx.currentTime
                                    );
                                for (var f = 0; f < d._howls.length; f++)
                                    if (!d._howls[f]._webAudio)
                                        for (
                                            var p = d._howls[f]._getSoundIds(),
                                                m = 0;
                                            m < p.length;
                                            m++
                                        ) {
                                            var g = d._howls[f]._soundById(
                                                p[m]
                                            );
                                            g &&
                                                g._node &&
                                                (g._node.volume =
                                                    g._volume * c);
                                        }
                                return d;
                            }
                            return d._volume;
                        },
                        mute: function (c) {
                            var d = this || t;
                            d.ctx || u(),
                                (d._muted = c),
                                d.usingWebAudio &&
                                    d.masterGain.gain.setValueAtTime(
                                        c ? 0 : d._volume,
                                        t.ctx.currentTime
                                    );
                            for (var f = 0; f < d._howls.length; f++)
                                if (!d._howls[f]._webAudio)
                                    for (
                                        var p = d._howls[f]._getSoundIds(),
                                            m = 0;
                                        m < p.length;
                                        m++
                                    ) {
                                        var g = d._howls[f]._soundById(p[m]);
                                        g &&
                                            g._node &&
                                            (g._node.muted = c ? !0 : g._muted);
                                    }
                            return d;
                        },
                        stop: function () {
                            for (
                                var c = this || t, d = 0;
                                d < c._howls.length;
                                d++
                            )
                                c._howls[d].stop();
                            return c;
                        },
                        unload: function () {
                            for (
                                var c = this || t, d = c._howls.length - 1;
                                d >= 0;
                                d--
                            )
                                c._howls[d].unload();
                            return (
                                c.usingWebAudio &&
                                    c.ctx &&
                                    typeof c.ctx.close < "u" &&
                                    (c.ctx.close(), (c.ctx = null), u()),
                                c
                            );
                        },
                        codecs: function (c) {
                            return (this || t)._codecs[c.replace(/^x-/, "")];
                        },
                        _setup: function () {
                            var c = this || t;
                            if (
                                ((c.state =
                                    (c.ctx && c.ctx.state) || "suspended"),
                                c._autoSuspend(),
                                !c.usingWebAudio)
                            )
                                if (typeof Audio < "u")
                                    try {
                                        var d = new Audio();
                                        typeof d.oncanplaythrough > "u" &&
                                            (c._canPlayEvent = "canplay");
                                    } catch {
                                        c.noAudio = !0;
                                    }
                                else c.noAudio = !0;
                            try {
                                var d = new Audio();
                                d.muted && (c.noAudio = !0);
                            } catch {}
                            return c.noAudio || c._setupCodecs(), c;
                        },
                        _setupCodecs: function () {
                            var c = this || t,
                                d = null;
                            try {
                                d = typeof Audio < "u" ? new Audio() : null;
                            } catch {
                                return c;
                            }
                            if (!d || typeof d.canPlayType != "function")
                                return c;
                            var f = d
                                    .canPlayType("audio/mpeg;")
                                    .replace(/^no$/, ""),
                                p = c._navigator ? c._navigator.userAgent : "",
                                m = p.match(/OPR\/(\d+)/g),
                                g = m && parseInt(m[0].split("/")[1], 10) < 33,
                                _ =
                                    p.indexOf("Safari") !== -1 &&
                                    p.indexOf("Chrome") === -1,
                                v = p.match(/Version\/(.*?) /),
                                b = _ && v && parseInt(v[1], 10) < 15;
                            return (
                                (c._codecs = {
                                    mp3: !!(
                                        !g &&
                                        (f ||
                                            d
                                                .canPlayType("audio/mp3;")
                                                .replace(/^no$/, ""))
                                    ),
                                    mpeg: !!f,
                                    opus: !!d
                                        .canPlayType('audio/ogg; codecs="opus"')
                                        .replace(/^no$/, ""),
                                    ogg: !!d
                                        .canPlayType(
                                            'audio/ogg; codecs="vorbis"'
                                        )
                                        .replace(/^no$/, ""),
                                    oga: !!d
                                        .canPlayType(
                                            'audio/ogg; codecs="vorbis"'
                                        )
                                        .replace(/^no$/, ""),
                                    wav: !!(
                                        d.canPlayType(
                                            'audio/wav; codecs="1"'
                                        ) || d.canPlayType("audio/wav")
                                    ).replace(/^no$/, ""),
                                    aac: !!d
                                        .canPlayType("audio/aac;")
                                        .replace(/^no$/, ""),
                                    caf: !!d
                                        .canPlayType("audio/x-caf;")
                                        .replace(/^no$/, ""),
                                    m4a: !!(
                                        d.canPlayType("audio/x-m4a;") ||
                                        d.canPlayType("audio/m4a;") ||
                                        d.canPlayType("audio/aac;")
                                    ).replace(/^no$/, ""),
                                    m4b: !!(
                                        d.canPlayType("audio/x-m4b;") ||
                                        d.canPlayType("audio/m4b;") ||
                                        d.canPlayType("audio/aac;")
                                    ).replace(/^no$/, ""),
                                    mp4: !!(
                                        d.canPlayType("audio/x-mp4;") ||
                                        d.canPlayType("audio/mp4;") ||
                                        d.canPlayType("audio/aac;")
                                    ).replace(/^no$/, ""),
                                    weba: !!(
                                        !b &&
                                        d
                                            .canPlayType(
                                                'audio/webm; codecs="vorbis"'
                                            )
                                            .replace(/^no$/, "")
                                    ),
                                    webm: !!(
                                        !b &&
                                        d
                                            .canPlayType(
                                                'audio/webm; codecs="vorbis"'
                                            )
                                            .replace(/^no$/, "")
                                    ),
                                    dolby: !!d
                                        .canPlayType('audio/mp4; codecs="ec-3"')
                                        .replace(/^no$/, ""),
                                    flac: !!(
                                        d.canPlayType("audio/x-flac;") ||
                                        d.canPlayType("audio/flac;")
                                    ).replace(/^no$/, ""),
                                }),
                                c
                            );
                        },
                        _unlockAudio: function () {
                            var c = this || t;
                            if (!(c._audioUnlocked || !c.ctx)) {
                                (c._audioUnlocked = !1),
                                    (c.autoUnlock = !1),
                                    !c._mobileUnloaded &&
                                        c.ctx.sampleRate !== 44100 &&
                                        ((c._mobileUnloaded = !0), c.unload()),
                                    (c._scratchBuffer = c.ctx.createBuffer(
                                        1,
                                        1,
                                        22050
                                    ));
                                var d = function (f) {
                                    for (
                                        ;
                                        c._html5AudioPool.length <
                                        c.html5PoolSize;

                                    )
                                        try {
                                            var p = new Audio();
                                            (p._unlocked = !0),
                                                c._releaseHtml5Audio(p);
                                        } catch {
                                            c.noAudio = !0;
                                            break;
                                        }
                                    for (var m = 0; m < c._howls.length; m++)
                                        if (!c._howls[m]._webAudio)
                                            for (
                                                var g =
                                                        c._howls[
                                                            m
                                                        ]._getSoundIds(),
                                                    _ = 0;
                                                _ < g.length;
                                                _++
                                            ) {
                                                var v = c._howls[m]._soundById(
                                                    g[_]
                                                );
                                                v &&
                                                    v._node &&
                                                    !v._node._unlocked &&
                                                    ((v._node._unlocked = !0),
                                                    v._node.load());
                                            }
                                    c._autoResume();
                                    var b = c.ctx.createBufferSource();
                                    (b.buffer = c._scratchBuffer),
                                        b.connect(c.ctx.destination),
                                        typeof b.start > "u"
                                            ? b.noteOn(0)
                                            : b.start(0),
                                        typeof c.ctx.resume == "function" &&
                                            c.ctx.resume(),
                                        (b.onended = function () {
                                            b.disconnect(0),
                                                (c._audioUnlocked = !0),
                                                document.removeEventListener(
                                                    "touchstart",
                                                    d,
                                                    !0
                                                ),
                                                document.removeEventListener(
                                                    "touchend",
                                                    d,
                                                    !0
                                                ),
                                                document.removeEventListener(
                                                    "click",
                                                    d,
                                                    !0
                                                ),
                                                document.removeEventListener(
                                                    "keydown",
                                                    d,
                                                    !0
                                                );
                                            for (
                                                var y = 0;
                                                y < c._howls.length;
                                                y++
                                            )
                                                c._howls[y]._emit("unlock");
                                        });
                                };
                                return (
                                    document.addEventListener(
                                        "touchstart",
                                        d,
                                        !0
                                    ),
                                    document.addEventListener(
                                        "touchend",
                                        d,
                                        !0
                                    ),
                                    document.addEventListener("click", d, !0),
                                    document.addEventListener("keydown", d, !0),
                                    c
                                );
                            }
                        },
                        _obtainHtml5Audio: function () {
                            var c = this || t;
                            if (c._html5AudioPool.length)
                                return c._html5AudioPool.pop();
                            var d = new Audio().play();
                            return (
                                d &&
                                    typeof Promise < "u" &&
                                    (d instanceof Promise ||
                                        typeof d.then == "function") &&
                                    d.catch(function () {
                                        console.warn(
                                            "HTML5 Audio pool exhausted, returning potentially locked audio object."
                                        );
                                    }),
                                new Audio()
                            );
                        },
                        _releaseHtml5Audio: function (c) {
                            var d = this || t;
                            return c._unlocked && d._html5AudioPool.push(c), d;
                        },
                        _autoSuspend: function () {
                            var c = this;
                            if (
                                !(
                                    !c.autoSuspend ||
                                    !c.ctx ||
                                    typeof c.ctx.suspend > "u" ||
                                    !t.usingWebAudio
                                )
                            ) {
                                for (var d = 0; d < c._howls.length; d++)
                                    if (c._howls[d]._webAudio) {
                                        for (
                                            var f = 0;
                                            f < c._howls[d]._sounds.length;
                                            f++
                                        )
                                            if (!c._howls[d]._sounds[f]._paused)
                                                return c;
                                    }
                                return (
                                    c._suspendTimer &&
                                        clearTimeout(c._suspendTimer),
                                    (c._suspendTimer = setTimeout(function () {
                                        if (c.autoSuspend) {
                                            (c._suspendTimer = null),
                                                (c.state = "suspending");
                                            var p = function () {
                                                (c.state = "suspended"),
                                                    c._resumeAfterSuspend &&
                                                        (delete c._resumeAfterSuspend,
                                                        c._autoResume());
                                            };
                                            c.ctx.suspend().then(p, p);
                                        }
                                    }, 3e4)),
                                    c
                                );
                            }
                        },
                        _autoResume: function () {
                            var c = this;
                            if (
                                !(
                                    !c.ctx ||
                                    typeof c.ctx.resume > "u" ||
                                    !t.usingWebAudio
                                )
                            )
                                return (
                                    c.state === "running" &&
                                    c.ctx.state !== "interrupted" &&
                                    c._suspendTimer
                                        ? (clearTimeout(c._suspendTimer),
                                          (c._suspendTimer = null))
                                        : c.state === "suspended" ||
                                          (c.state === "running" &&
                                              c.ctx.state === "interrupted")
                                        ? (c.ctx.resume().then(function () {
                                              c.state = "running";
                                              for (
                                                  var d = 0;
                                                  d < c._howls.length;
                                                  d++
                                              )
                                                  c._howls[d]._emit("resume");
                                          }),
                                          c._suspendTimer &&
                                              (clearTimeout(c._suspendTimer),
                                              (c._suspendTimer = null)))
                                        : c.state === "suspending" &&
                                          (c._resumeAfterSuspend = !0),
                                    c
                                );
                        },
                    };
                    var t = new e(),
                        n = function (c) {
                            var d = this;
                            if (!c.src || c.src.length === 0) {
                                console.error(
                                    "An array of source files must be passed with any new Howl."
                                );
                                return;
                            }
                            d.init(c);
                        };
                    n.prototype = {
                        init: function (c) {
                            var d = this;
                            return (
                                t.ctx || u(),
                                (d._autoplay = c.autoplay || !1),
                                (d._format =
                                    typeof c.format != "string"
                                        ? c.format
                                        : [c.format]),
                                (d._html5 = c.html5 || !1),
                                (d._muted = c.mute || !1),
                                (d._loop = c.loop || !1),
                                (d._pool = c.pool || 5),
                                (d._preload =
                                    typeof c.preload == "boolean" ||
                                    c.preload === "metadata"
                                        ? c.preload
                                        : !0),
                                (d._rate = c.rate || 1),
                                (d._sprite = c.sprite || {}),
                                (d._src =
                                    typeof c.src != "string" ? c.src : [c.src]),
                                (d._volume =
                                    c.volume !== void 0 ? c.volume : 1),
                                (d._xhr = {
                                    method:
                                        c.xhr && c.xhr.method
                                            ? c.xhr.method
                                            : "GET",
                                    headers:
                                        c.xhr && c.xhr.headers
                                            ? c.xhr.headers
                                            : null,
                                    withCredentials:
                                        c.xhr && c.xhr.withCredentials
                                            ? c.xhr.withCredentials
                                            : !1,
                                }),
                                (d._duration = 0),
                                (d._state = "unloaded"),
                                (d._sounds = []),
                                (d._endTimers = {}),
                                (d._queue = []),
                                (d._playLock = !1),
                                (d._onend = c.onend ? [{ fn: c.onend }] : []),
                                (d._onfade = c.onfade
                                    ? [{ fn: c.onfade }]
                                    : []),
                                (d._onload = c.onload
                                    ? [{ fn: c.onload }]
                                    : []),
                                (d._onloaderror = c.onloaderror
                                    ? [{ fn: c.onloaderror }]
                                    : []),
                                (d._onplayerror = c.onplayerror
                                    ? [{ fn: c.onplayerror }]
                                    : []),
                                (d._onpause = c.onpause
                                    ? [{ fn: c.onpause }]
                                    : []),
                                (d._onplay = c.onplay
                                    ? [{ fn: c.onplay }]
                                    : []),
                                (d._onstop = c.onstop
                                    ? [{ fn: c.onstop }]
                                    : []),
                                (d._onmute = c.onmute
                                    ? [{ fn: c.onmute }]
                                    : []),
                                (d._onvolume = c.onvolume
                                    ? [{ fn: c.onvolume }]
                                    : []),
                                (d._onrate = c.onrate
                                    ? [{ fn: c.onrate }]
                                    : []),
                                (d._onseek = c.onseek
                                    ? [{ fn: c.onseek }]
                                    : []),
                                (d._onunlock = c.onunlock
                                    ? [{ fn: c.onunlock }]
                                    : []),
                                (d._onresume = []),
                                (d._webAudio = t.usingWebAudio && !d._html5),
                                typeof t.ctx < "u" &&
                                    t.ctx &&
                                    t.autoUnlock &&
                                    t._unlockAudio(),
                                t._howls.push(d),
                                d._autoplay &&
                                    d._queue.push({
                                        event: "play",
                                        action: function () {
                                            d.play();
                                        },
                                    }),
                                d._preload && d._preload !== "none" && d.load(),
                                d
                            );
                        },
                        load: function () {
                            var c = this,
                                d = null;
                            if (t.noAudio) {
                                c._emit("loaderror", null, "No audio support.");
                                return;
                            }
                            typeof c._src == "string" && (c._src = [c._src]);
                            for (var f = 0; f < c._src.length; f++) {
                                var p, m;
                                if (c._format && c._format[f]) p = c._format[f];
                                else {
                                    if (
                                        ((m = c._src[f]), typeof m != "string")
                                    ) {
                                        c._emit(
                                            "loaderror",
                                            null,
                                            "Non-string found in selected audio sources - ignoring."
                                        );
                                        continue;
                                    }
                                    (p = /^data:audio\/([^;,]+);/i.exec(m)),
                                        p ||
                                            (p = /\.([^.]+)$/.exec(
                                                m.split("?", 1)[0]
                                            )),
                                        p && (p = p[1].toLowerCase());
                                }
                                if (
                                    (p ||
                                        console.warn(
                                            'No file extension was found. Consider using the "format" property or specify an extension.'
                                        ),
                                    p && t.codecs(p))
                                ) {
                                    d = c._src[f];
                                    break;
                                }
                            }
                            if (!d) {
                                c._emit(
                                    "loaderror",
                                    null,
                                    "No codec support for selected audio sources."
                                );
                                return;
                            }
                            return (
                                (c._src = d),
                                (c._state = "loading"),
                                window.location.protocol === "https:" &&
                                    d.slice(0, 5) === "http:" &&
                                    ((c._html5 = !0), (c._webAudio = !1)),
                                new i(c),
                                c._webAudio && a(c),
                                c
                            );
                        },
                        play: function (c, d) {
                            var f = this,
                                p = null;
                            if (typeof c == "number") (p = c), (c = null);
                            else {
                                if (
                                    typeof c == "string" &&
                                    f._state === "loaded" &&
                                    !f._sprite[c]
                                )
                                    return null;
                                if (
                                    typeof c > "u" &&
                                    ((c = "__default"), !f._playLock)
                                ) {
                                    for (
                                        var m = 0, g = 0;
                                        g < f._sounds.length;
                                        g++
                                    )
                                        f._sounds[g]._paused &&
                                            !f._sounds[g]._ended &&
                                            (m++, (p = f._sounds[g]._id));
                                    m === 1 ? (c = null) : (p = null);
                                }
                            }
                            var _ = p ? f._soundById(p) : f._inactiveSound();
                            if (!_) return null;
                            if (
                                (p && !c && (c = _._sprite || "__default"),
                                f._state !== "loaded")
                            ) {
                                (_._sprite = c), (_._ended = !1);
                                var v = _._id;
                                return (
                                    f._queue.push({
                                        event: "play",
                                        action: function () {
                                            f.play(v);
                                        },
                                    }),
                                    v
                                );
                            }
                            if (p && !_._paused)
                                return d || f._loadQueue("play"), _._id;
                            f._webAudio && t._autoResume();
                            var b = Math.max(
                                    0,
                                    _._seek > 0
                                        ? _._seek
                                        : f._sprite[c][0] / 1e3
                                ),
                                y = Math.max(
                                    0,
                                    (f._sprite[c][0] + f._sprite[c][1]) / 1e3 -
                                        b
                                ),
                                C = (y * 1e3) / Math.abs(_._rate),
                                w = f._sprite[c][0] / 1e3,
                                A = (f._sprite[c][0] + f._sprite[c][1]) / 1e3;
                            (_._sprite = c), (_._ended = !1);
                            var E = function () {
                                (_._paused = !1),
                                    (_._seek = b),
                                    (_._start = w),
                                    (_._stop = A),
                                    (_._loop = !!(_._loop || f._sprite[c][2]));
                            };
                            if (b >= A) {
                                f._ended(_);
                                return;
                            }
                            var S = _._node;
                            if (f._webAudio) {
                                var P = function () {
                                    (f._playLock = !1),
                                        E(),
                                        f._refreshBuffer(_);
                                    var T =
                                        _._muted || f._muted ? 0 : _._volume;
                                    S.gain.setValueAtTime(T, t.ctx.currentTime),
                                        (_._playStart = t.ctx.currentTime),
                                        typeof S.bufferSource.start > "u"
                                            ? _._loop
                                                ? S.bufferSource.noteGrainOn(
                                                      0,
                                                      b,
                                                      86400
                                                  )
                                                : S.bufferSource.noteGrainOn(
                                                      0,
                                                      b,
                                                      y
                                                  )
                                            : _._loop
                                            ? S.bufferSource.start(0, b, 86400)
                                            : S.bufferSource.start(0, b, y),
                                        C !== 1 / 0 &&
                                            (f._endTimers[_._id] = setTimeout(
                                                f._ended.bind(f, _),
                                                C
                                            )),
                                        d ||
                                            setTimeout(function () {
                                                f._emit("play", _._id),
                                                    f._loadQueue();
                                            }, 0);
                                };
                                t.state === "running" &&
                                t.ctx.state !== "interrupted"
                                    ? P()
                                    : ((f._playLock = !0),
                                      f.once("resume", P),
                                      f._clearTimer(_._id));
                            } else {
                                var k = function () {
                                    (S.currentTime = b),
                                        (S.muted =
                                            _._muted ||
                                            f._muted ||
                                            t._muted ||
                                            S.muted),
                                        (S.volume = _._volume * t.volume()),
                                        (S.playbackRate = _._rate);
                                    try {
                                        var T = S.play();
                                        if (
                                            (T &&
                                            typeof Promise < "u" &&
                                            (T instanceof Promise ||
                                                typeof T.then == "function")
                                                ? ((f._playLock = !0),
                                                  E(),
                                                  T.then(function () {
                                                      (f._playLock = !1),
                                                          (S._unlocked = !0),
                                                          d
                                                              ? f._loadQueue()
                                                              : f._emit(
                                                                    "play",
                                                                    _._id
                                                                );
                                                  }).catch(function () {
                                                      (f._playLock = !1),
                                                          f._emit(
                                                              "playerror",
                                                              _._id,
                                                              "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                                          ),
                                                          (_._ended = !0),
                                                          (_._paused = !0);
                                                  }))
                                                : d ||
                                                  ((f._playLock = !1),
                                                  E(),
                                                  f._emit("play", _._id)),
                                            (S.playbackRate = _._rate),
                                            S.paused)
                                        ) {
                                            f._emit(
                                                "playerror",
                                                _._id,
                                                "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                            );
                                            return;
                                        }
                                        c !== "__default" || _._loop
                                            ? (f._endTimers[_._id] = setTimeout(
                                                  f._ended.bind(f, _),
                                                  C
                                              ))
                                            : ((f._endTimers[_._id] =
                                                  function () {
                                                      f._ended(_),
                                                          S.removeEventListener(
                                                              "ended",
                                                              f._endTimers[
                                                                  _._id
                                                              ],
                                                              !1
                                                          );
                                                  }),
                                              S.addEventListener(
                                                  "ended",
                                                  f._endTimers[_._id],
                                                  !1
                                              ));
                                    } catch (O) {
                                        f._emit("playerror", _._id, O);
                                    }
                                };
                                S.src ===
                                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
                                    ((S.src = f._src), S.load());
                                var R =
                                    (window && window.ejecta) ||
                                    (!S.readyState && t._navigator.isCocoonJS);
                                if (S.readyState >= 3 || R) k();
                                else {
                                    (f._playLock = !0), (f._state = "loading");
                                    var M = function () {
                                        (f._state = "loaded"),
                                            k(),
                                            S.removeEventListener(
                                                t._canPlayEvent,
                                                M,
                                                !1
                                            );
                                    };
                                    S.addEventListener(t._canPlayEvent, M, !1),
                                        f._clearTimer(_._id);
                                }
                            }
                            return _._id;
                        },
                        pause: function (c) {
                            var d = this;
                            if (d._state !== "loaded" || d._playLock)
                                return (
                                    d._queue.push({
                                        event: "pause",
                                        action: function () {
                                            d.pause(c);
                                        },
                                    }),
                                    d
                                );
                            for (
                                var f = d._getSoundIds(c), p = 0;
                                p < f.length;
                                p++
                            ) {
                                d._clearTimer(f[p]);
                                var m = d._soundById(f[p]);
                                if (
                                    m &&
                                    !m._paused &&
                                    ((m._seek = d.seek(f[p])),
                                    (m._rateSeek = 0),
                                    (m._paused = !0),
                                    d._stopFade(f[p]),
                                    m._node)
                                )
                                    if (d._webAudio) {
                                        if (!m._node.bufferSource) continue;
                                        typeof m._node.bufferSource.stop > "u"
                                            ? m._node.bufferSource.noteOff(0)
                                            : m._node.bufferSource.stop(0),
                                            d._cleanBuffer(m._node);
                                    } else
                                        (!isNaN(m._node.duration) ||
                                            m._node.duration === 1 / 0) &&
                                            m._node.pause();
                                arguments[1] ||
                                    d._emit("pause", m ? m._id : null);
                            }
                            return d;
                        },
                        stop: function (c, d) {
                            var f = this;
                            if (f._state !== "loaded" || f._playLock)
                                return (
                                    f._queue.push({
                                        event: "stop",
                                        action: function () {
                                            f.stop(c);
                                        },
                                    }),
                                    f
                                );
                            for (
                                var p = f._getSoundIds(c), m = 0;
                                m < p.length;
                                m++
                            ) {
                                f._clearTimer(p[m]);
                                var g = f._soundById(p[m]);
                                g &&
                                    ((g._seek = g._start || 0),
                                    (g._rateSeek = 0),
                                    (g._paused = !0),
                                    (g._ended = !0),
                                    f._stopFade(p[m]),
                                    g._node &&
                                        (f._webAudio
                                            ? g._node.bufferSource &&
                                              (typeof g._node.bufferSource
                                                  .stop > "u"
                                                  ? g._node.bufferSource.noteOff(
                                                        0
                                                    )
                                                  : g._node.bufferSource.stop(
                                                        0
                                                    ),
                                              f._cleanBuffer(g._node))
                                            : (!isNaN(g._node.duration) ||
                                                  g._node.duration === 1 / 0) &&
                                              ((g._node.currentTime =
                                                  g._start || 0),
                                              g._node.pause(),
                                              g._node.duration === 1 / 0 &&
                                                  f._clearSound(g._node))),
                                    d || f._emit("stop", g._id));
                            }
                            return f;
                        },
                        mute: function (c, d) {
                            var f = this;
                            if (f._state !== "loaded" || f._playLock)
                                return (
                                    f._queue.push({
                                        event: "mute",
                                        action: function () {
                                            f.mute(c, d);
                                        },
                                    }),
                                    f
                                );
                            if (typeof d > "u")
                                if (typeof c == "boolean") f._muted = c;
                                else return f._muted;
                            for (
                                var p = f._getSoundIds(d), m = 0;
                                m < p.length;
                                m++
                            ) {
                                var g = f._soundById(p[m]);
                                g &&
                                    ((g._muted = c),
                                    g._interval && f._stopFade(g._id),
                                    f._webAudio && g._node
                                        ? g._node.gain.setValueAtTime(
                                              c ? 0 : g._volume,
                                              t.ctx.currentTime
                                          )
                                        : g._node &&
                                          (g._node.muted = t._muted ? !0 : c),
                                    f._emit("mute", g._id));
                            }
                            return f;
                        },
                        volume: function () {
                            var c = this,
                                d = arguments,
                                f,
                                p;
                            if (d.length === 0) return c._volume;
                            if (
                                d.length === 1 ||
                                (d.length === 2 && typeof d[1] > "u")
                            ) {
                                var m = c._getSoundIds(),
                                    g = m.indexOf(d[0]);
                                g >= 0
                                    ? (p = parseInt(d[0], 10))
                                    : (f = parseFloat(d[0]));
                            } else
                                d.length >= 2 &&
                                    ((f = parseFloat(d[0])),
                                    (p = parseInt(d[1], 10)));
                            var _;
                            if (typeof f < "u" && f >= 0 && f <= 1) {
                                if (c._state !== "loaded" || c._playLock)
                                    return (
                                        c._queue.push({
                                            event: "volume",
                                            action: function () {
                                                c.volume.apply(c, d);
                                            },
                                        }),
                                        c
                                    );
                                typeof p > "u" && (c._volume = f),
                                    (p = c._getSoundIds(p));
                                for (var v = 0; v < p.length; v++)
                                    (_ = c._soundById(p[v])),
                                        _ &&
                                            ((_._volume = f),
                                            d[2] || c._stopFade(p[v]),
                                            c._webAudio && _._node && !_._muted
                                                ? _._node.gain.setValueAtTime(
                                                      f,
                                                      t.ctx.currentTime
                                                  )
                                                : _._node &&
                                                  !_._muted &&
                                                  (_._node.volume =
                                                      f * t.volume()),
                                            c._emit("volume", _._id));
                            } else
                                return (
                                    (_ = p ? c._soundById(p) : c._sounds[0]),
                                    _ ? _._volume : 0
                                );
                            return c;
                        },
                        fade: function (c, d, f, p) {
                            var m = this;
                            if (m._state !== "loaded" || m._playLock)
                                return (
                                    m._queue.push({
                                        event: "fade",
                                        action: function () {
                                            m.fade(c, d, f, p);
                                        },
                                    }),
                                    m
                                );
                            (c = Math.min(Math.max(0, parseFloat(c)), 1)),
                                (d = Math.min(Math.max(0, parseFloat(d)), 1)),
                                (f = parseFloat(f)),
                                m.volume(c, p);
                            for (
                                var g = m._getSoundIds(p), _ = 0;
                                _ < g.length;
                                _++
                            ) {
                                var v = m._soundById(g[_]);
                                if (v) {
                                    if (
                                        (p || m._stopFade(g[_]),
                                        m._webAudio && !v._muted)
                                    ) {
                                        var b = t.ctx.currentTime,
                                            y = b + f / 1e3;
                                        (v._volume = c),
                                            v._node.gain.setValueAtTime(c, b),
                                            v._node.gain.linearRampToValueAtTime(
                                                d,
                                                y
                                            );
                                    }
                                    m._startFadeInterval(
                                        v,
                                        c,
                                        d,
                                        f,
                                        g[_],
                                        typeof p > "u"
                                    );
                                }
                            }
                            return m;
                        },
                        _startFadeInterval: function (c, d, f, p, m, g) {
                            var _ = this,
                                v = d,
                                b = f - d,
                                y = Math.abs(b / 0.01),
                                C = Math.max(4, y > 0 ? p / y : p),
                                w = Date.now();
                            (c._fadeTo = f),
                                (c._interval = setInterval(function () {
                                    var A = (Date.now() - w) / p;
                                    (w = Date.now()),
                                        (v += b * A),
                                        (v = Math.round(v * 100) / 100),
                                        b < 0
                                            ? (v = Math.max(f, v))
                                            : (v = Math.min(f, v)),
                                        _._webAudio
                                            ? (c._volume = v)
                                            : _.volume(v, c._id, !0),
                                        g && (_._volume = v),
                                        ((f < d && v <= f) ||
                                            (f > d && v >= f)) &&
                                            (clearInterval(c._interval),
                                            (c._interval = null),
                                            (c._fadeTo = null),
                                            _.volume(f, c._id),
                                            _._emit("fade", c._id));
                                }, C));
                        },
                        _stopFade: function (c) {
                            var d = this,
                                f = d._soundById(c);
                            return (
                                f &&
                                    f._interval &&
                                    (d._webAudio &&
                                        f._node.gain.cancelScheduledValues(
                                            t.ctx.currentTime
                                        ),
                                    clearInterval(f._interval),
                                    (f._interval = null),
                                    d.volume(f._fadeTo, c),
                                    (f._fadeTo = null),
                                    d._emit("fade", c)),
                                d
                            );
                        },
                        loop: function () {
                            var c = this,
                                d = arguments,
                                f,
                                p,
                                m;
                            if (d.length === 0) return c._loop;
                            if (d.length === 1)
                                if (typeof d[0] == "boolean")
                                    (f = d[0]), (c._loop = f);
                                else
                                    return (
                                        (m = c._soundById(parseInt(d[0], 10))),
                                        m ? m._loop : !1
                                    );
                            else
                                d.length === 2 &&
                                    ((f = d[0]), (p = parseInt(d[1], 10)));
                            for (
                                var g = c._getSoundIds(p), _ = 0;
                                _ < g.length;
                                _++
                            )
                                (m = c._soundById(g[_])),
                                    m &&
                                        ((m._loop = f),
                                        c._webAudio &&
                                            m._node &&
                                            m._node.bufferSource &&
                                            ((m._node.bufferSource.loop = f),
                                            f &&
                                                ((m._node.bufferSource.loopStart =
                                                    m._start || 0),
                                                (m._node.bufferSource.loopEnd =
                                                    m._stop),
                                                c.playing(g[_]) &&
                                                    (c.pause(g[_], !0),
                                                    c.play(g[_], !0)))));
                            return c;
                        },
                        rate: function () {
                            var c = this,
                                d = arguments,
                                f,
                                p;
                            if (d.length === 0) p = c._sounds[0]._id;
                            else if (d.length === 1) {
                                var m = c._getSoundIds(),
                                    g = m.indexOf(d[0]);
                                g >= 0
                                    ? (p = parseInt(d[0], 10))
                                    : (f = parseFloat(d[0]));
                            } else
                                d.length === 2 &&
                                    ((f = parseFloat(d[0])),
                                    (p = parseInt(d[1], 10)));
                            var _;
                            if (typeof f == "number") {
                                if (c._state !== "loaded" || c._playLock)
                                    return (
                                        c._queue.push({
                                            event: "rate",
                                            action: function () {
                                                c.rate.apply(c, d);
                                            },
                                        }),
                                        c
                                    );
                                typeof p > "u" && (c._rate = f),
                                    (p = c._getSoundIds(p));
                                for (var v = 0; v < p.length; v++)
                                    if (((_ = c._soundById(p[v])), _)) {
                                        c.playing(p[v]) &&
                                            ((_._rateSeek = c.seek(p[v])),
                                            (_._playStart = c._webAudio
                                                ? t.ctx.currentTime
                                                : _._playStart)),
                                            (_._rate = f),
                                            c._webAudio &&
                                            _._node &&
                                            _._node.bufferSource
                                                ? _._node.bufferSource.playbackRate.setValueAtTime(
                                                      f,
                                                      t.ctx.currentTime
                                                  )
                                                : _._node &&
                                                  (_._node.playbackRate = f);
                                        var b = c.seek(p[v]),
                                            y =
                                                (c._sprite[_._sprite][0] +
                                                    c._sprite[_._sprite][1]) /
                                                    1e3 -
                                                b,
                                            C = (y * 1e3) / Math.abs(_._rate);
                                        (c._endTimers[p[v]] || !_._paused) &&
                                            (c._clearTimer(p[v]),
                                            (c._endTimers[p[v]] = setTimeout(
                                                c._ended.bind(c, _),
                                                C
                                            ))),
                                            c._emit("rate", _._id);
                                    }
                            } else
                                return (
                                    (_ = c._soundById(p)), _ ? _._rate : c._rate
                                );
                            return c;
                        },
                        seek: function () {
                            var c = this,
                                d = arguments,
                                f,
                                p;
                            if (d.length === 0)
                                c._sounds.length && (p = c._sounds[0]._id);
                            else if (d.length === 1) {
                                var m = c._getSoundIds(),
                                    g = m.indexOf(d[0]);
                                g >= 0
                                    ? (p = parseInt(d[0], 10))
                                    : c._sounds.length &&
                                      ((p = c._sounds[0]._id),
                                      (f = parseFloat(d[0])));
                            } else
                                d.length === 2 &&
                                    ((f = parseFloat(d[0])),
                                    (p = parseInt(d[1], 10)));
                            if (typeof p > "u") return 0;
                            if (
                                typeof f == "number" &&
                                (c._state !== "loaded" || c._playLock)
                            )
                                return (
                                    c._queue.push({
                                        event: "seek",
                                        action: function () {
                                            c.seek.apply(c, d);
                                        },
                                    }),
                                    c
                                );
                            var _ = c._soundById(p);
                            if (_)
                                if (typeof f == "number" && f >= 0) {
                                    var v = c.playing(p);
                                    v && c.pause(p, !0),
                                        (_._seek = f),
                                        (_._ended = !1),
                                        c._clearTimer(p),
                                        !c._webAudio &&
                                            _._node &&
                                            !isNaN(_._node.duration) &&
                                            (_._node.currentTime = f);
                                    var b = function () {
                                        v && c.play(p, !0), c._emit("seek", p);
                                    };
                                    if (v && !c._webAudio) {
                                        var y = function () {
                                            c._playLock
                                                ? setTimeout(y, 0)
                                                : b();
                                        };
                                        setTimeout(y, 0);
                                    } else b();
                                } else if (c._webAudio) {
                                    var C = c.playing(p)
                                            ? t.ctx.currentTime - _._playStart
                                            : 0,
                                        w = _._rateSeek
                                            ? _._rateSeek - _._seek
                                            : 0;
                                    return (
                                        _._seek + (w + C * Math.abs(_._rate))
                                    );
                                } else return _._node.currentTime;
                            return c;
                        },
                        playing: function (c) {
                            var d = this;
                            if (typeof c == "number") {
                                var f = d._soundById(c);
                                return f ? !f._paused : !1;
                            }
                            for (var p = 0; p < d._sounds.length; p++)
                                if (!d._sounds[p]._paused) return !0;
                            return !1;
                        },
                        duration: function (c) {
                            var d = this,
                                f = d._duration,
                                p = d._soundById(c);
                            return p && (f = d._sprite[p._sprite][1] / 1e3), f;
                        },
                        state: function () {
                            return this._state;
                        },
                        unload: function () {
                            for (
                                var c = this, d = c._sounds, f = 0;
                                f < d.length;
                                f++
                            )
                                d[f]._paused || c.stop(d[f]._id),
                                    c._webAudio ||
                                        (c._clearSound(d[f]._node),
                                        d[f]._node.removeEventListener(
                                            "error",
                                            d[f]._errorFn,
                                            !1
                                        ),
                                        d[f]._node.removeEventListener(
                                            t._canPlayEvent,
                                            d[f]._loadFn,
                                            !1
                                        ),
                                        d[f]._node.removeEventListener(
                                            "ended",
                                            d[f]._endFn,
                                            !1
                                        ),
                                        t._releaseHtml5Audio(d[f]._node)),
                                    delete d[f]._node,
                                    c._clearTimer(d[f]._id);
                            var p = t._howls.indexOf(c);
                            p >= 0 && t._howls.splice(p, 1);
                            var m = !0;
                            for (f = 0; f < t._howls.length; f++)
                                if (
                                    t._howls[f]._src === c._src ||
                                    c._src.indexOf(t._howls[f]._src) >= 0
                                ) {
                                    m = !1;
                                    break;
                                }
                            return (
                                r && m && delete r[c._src],
                                (t.noAudio = !1),
                                (c._state = "unloaded"),
                                (c._sounds = []),
                                (c = null),
                                null
                            );
                        },
                        on: function (c, d, f, p) {
                            var m = this,
                                g = m["_on" + c];
                            return (
                                typeof d == "function" &&
                                    g.push(
                                        p
                                            ? { id: f, fn: d, once: p }
                                            : { id: f, fn: d }
                                    ),
                                m
                            );
                        },
                        off: function (c, d, f) {
                            var p = this,
                                m = p["_on" + c],
                                g = 0;
                            if (
                                (typeof d == "number" && ((f = d), (d = null)),
                                d || f)
                            )
                                for (g = 0; g < m.length; g++) {
                                    var _ = f === m[g].id;
                                    if ((d === m[g].fn && _) || (!d && _)) {
                                        m.splice(g, 1);
                                        break;
                                    }
                                }
                            else if (c) p["_on" + c] = [];
                            else {
                                var v = Object.keys(p);
                                for (g = 0; g < v.length; g++)
                                    v[g].indexOf("_on") === 0 &&
                                        Array.isArray(p[v[g]]) &&
                                        (p[v[g]] = []);
                            }
                            return p;
                        },
                        once: function (c, d, f) {
                            var p = this;
                            return p.on(c, d, f, 1), p;
                        },
                        _emit: function (c, d, f) {
                            for (
                                var p = this,
                                    m = p["_on" + c],
                                    g = m.length - 1;
                                g >= 0;
                                g--
                            )
                                (!m[g].id || m[g].id === d || c === "load") &&
                                    (setTimeout(
                                        function (_) {
                                            _.call(this, d, f);
                                        }.bind(p, m[g].fn),
                                        0
                                    ),
                                    m[g].once && p.off(c, m[g].fn, m[g].id));
                            return p._loadQueue(c), p;
                        },
                        _loadQueue: function (c) {
                            var d = this;
                            if (d._queue.length > 0) {
                                var f = d._queue[0];
                                f.event === c &&
                                    (d._queue.shift(), d._loadQueue()),
                                    c || f.action();
                            }
                            return d;
                        },
                        _ended: function (c) {
                            var d = this,
                                f = c._sprite;
                            if (
                                !d._webAudio &&
                                c._node &&
                                !c._node.paused &&
                                !c._node.ended &&
                                c._node.currentTime < c._stop
                            )
                                return setTimeout(d._ended.bind(d, c), 100), d;
                            var p = !!(c._loop || d._sprite[f][2]);
                            if (
                                (d._emit("end", c._id),
                                !d._webAudio &&
                                    p &&
                                    d.stop(c._id, !0).play(c._id),
                                d._webAudio && p)
                            ) {
                                d._emit("play", c._id),
                                    (c._seek = c._start || 0),
                                    (c._rateSeek = 0),
                                    (c._playStart = t.ctx.currentTime);
                                var m =
                                    ((c._stop - c._start) * 1e3) /
                                    Math.abs(c._rate);
                                d._endTimers[c._id] = setTimeout(
                                    d._ended.bind(d, c),
                                    m
                                );
                            }
                            return (
                                d._webAudio &&
                                    !p &&
                                    ((c._paused = !0),
                                    (c._ended = !0),
                                    (c._seek = c._start || 0),
                                    (c._rateSeek = 0),
                                    d._clearTimer(c._id),
                                    d._cleanBuffer(c._node),
                                    t._autoSuspend()),
                                !d._webAudio && !p && d.stop(c._id, !0),
                                d
                            );
                        },
                        _clearTimer: function (c) {
                            var d = this;
                            if (d._endTimers[c]) {
                                if (typeof d._endTimers[c] != "function")
                                    clearTimeout(d._endTimers[c]);
                                else {
                                    var f = d._soundById(c);
                                    f &&
                                        f._node &&
                                        f._node.removeEventListener(
                                            "ended",
                                            d._endTimers[c],
                                            !1
                                        );
                                }
                                delete d._endTimers[c];
                            }
                            return d;
                        },
                        _soundById: function (c) {
                            for (var d = this, f = 0; f < d._sounds.length; f++)
                                if (c === d._sounds[f]._id) return d._sounds[f];
                            return null;
                        },
                        _inactiveSound: function () {
                            var c = this;
                            c._drain();
                            for (var d = 0; d < c._sounds.length; d++)
                                if (c._sounds[d]._ended)
                                    return c._sounds[d].reset();
                            return new i(c);
                        },
                        _drain: function () {
                            var c = this,
                                d = c._pool,
                                f = 0,
                                p = 0;
                            if (!(c._sounds.length < d)) {
                                for (p = 0; p < c._sounds.length; p++)
                                    c._sounds[p]._ended && f++;
                                for (p = c._sounds.length - 1; p >= 0; p--) {
                                    if (f <= d) return;
                                    c._sounds[p]._ended &&
                                        (c._webAudio &&
                                            c._sounds[p]._node &&
                                            c._sounds[p]._node.disconnect(0),
                                        c._sounds.splice(p, 1),
                                        f--);
                                }
                            }
                        },
                        _getSoundIds: function (c) {
                            var d = this;
                            if (typeof c > "u") {
                                for (
                                    var f = [], p = 0;
                                    p < d._sounds.length;
                                    p++
                                )
                                    f.push(d._sounds[p]._id);
                                return f;
                            } else return [c];
                        },
                        _refreshBuffer: function (c) {
                            var d = this;
                            return (
                                (c._node.bufferSource =
                                    t.ctx.createBufferSource()),
                                (c._node.bufferSource.buffer = r[d._src]),
                                c._panner
                                    ? c._node.bufferSource.connect(c._panner)
                                    : c._node.bufferSource.connect(c._node),
                                (c._node.bufferSource.loop = c._loop),
                                c._loop &&
                                    ((c._node.bufferSource.loopStart =
                                        c._start || 0),
                                    (c._node.bufferSource.loopEnd =
                                        c._stop || 0)),
                                c._node.bufferSource.playbackRate.setValueAtTime(
                                    c._rate,
                                    t.ctx.currentTime
                                ),
                                d
                            );
                        },
                        _cleanBuffer: function (c) {
                            var d = this,
                                f =
                                    t._navigator &&
                                    t._navigator.vendor.indexOf("Apple") >= 0;
                            if (!c.bufferSource) return d;
                            if (
                                t._scratchBuffer &&
                                c.bufferSource &&
                                ((c.bufferSource.onended = null),
                                c.bufferSource.disconnect(0),
                                f)
                            )
                                try {
                                    c.bufferSource.buffer = t._scratchBuffer;
                                } catch {}
                            return (c.bufferSource = null), d;
                        },
                        _clearSound: function (c) {
                            var d = /MSIE |Trident\//.test(
                                t._navigator && t._navigator.userAgent
                            );
                            d ||
                                (c.src =
                                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                        },
                    };
                    var i = function (c) {
                        (this._parent = c), this.init();
                    };
                    i.prototype = {
                        init: function () {
                            var c = this,
                                d = c._parent;
                            return (
                                (c._muted = d._muted),
                                (c._loop = d._loop),
                                (c._volume = d._volume),
                                (c._rate = d._rate),
                                (c._seek = 0),
                                (c._paused = !0),
                                (c._ended = !0),
                                (c._sprite = "__default"),
                                (c._id = ++t._counter),
                                d._sounds.push(c),
                                c.create(),
                                c
                            );
                        },
                        create: function () {
                            var c = this,
                                d = c._parent,
                                f =
                                    t._muted || c._muted || c._parent._muted
                                        ? 0
                                        : c._volume;
                            return (
                                d._webAudio
                                    ? ((c._node =
                                          typeof t.ctx.createGain > "u"
                                              ? t.ctx.createGainNode()
                                              : t.ctx.createGain()),
                                      c._node.gain.setValueAtTime(
                                          f,
                                          t.ctx.currentTime
                                      ),
                                      (c._node.paused = !0),
                                      c._node.connect(t.masterGain))
                                    : t.noAudio ||
                                      ((c._node = t._obtainHtml5Audio()),
                                      (c._errorFn = c._errorListener.bind(c)),
                                      c._node.addEventListener(
                                          "error",
                                          c._errorFn,
                                          !1
                                      ),
                                      (c._loadFn = c._loadListener.bind(c)),
                                      c._node.addEventListener(
                                          t._canPlayEvent,
                                          c._loadFn,
                                          !1
                                      ),
                                      (c._endFn = c._endListener.bind(c)),
                                      c._node.addEventListener(
                                          "ended",
                                          c._endFn,
                                          !1
                                      ),
                                      (c._node.src = d._src),
                                      (c._node.preload =
                                          d._preload === !0
                                              ? "auto"
                                              : d._preload),
                                      (c._node.volume = f * t.volume()),
                                      c._node.load()),
                                c
                            );
                        },
                        reset: function () {
                            var c = this,
                                d = c._parent;
                            return (
                                (c._muted = d._muted),
                                (c._loop = d._loop),
                                (c._volume = d._volume),
                                (c._rate = d._rate),
                                (c._seek = 0),
                                (c._rateSeek = 0),
                                (c._paused = !0),
                                (c._ended = !0),
                                (c._sprite = "__default"),
                                (c._id = ++t._counter),
                                c
                            );
                        },
                        _errorListener: function () {
                            var c = this;
                            c._parent._emit(
                                "loaderror",
                                c._id,
                                c._node.error ? c._node.error.code : 0
                            ),
                                c._node.removeEventListener(
                                    "error",
                                    c._errorFn,
                                    !1
                                );
                        },
                        _loadListener: function () {
                            var c = this,
                                d = c._parent;
                            (d._duration =
                                Math.ceil(c._node.duration * 10) / 10),
                                Object.keys(d._sprite).length === 0 &&
                                    (d._sprite = {
                                        __default: [0, d._duration * 1e3],
                                    }),
                                d._state !== "loaded" &&
                                    ((d._state = "loaded"),
                                    d._emit("load"),
                                    d._loadQueue()),
                                c._node.removeEventListener(
                                    t._canPlayEvent,
                                    c._loadFn,
                                    !1
                                );
                        },
                        _endListener: function () {
                            var c = this,
                                d = c._parent;
                            d._duration === 1 / 0 &&
                                ((d._duration =
                                    Math.ceil(c._node.duration * 10) / 10),
                                d._sprite.__default[1] === 1 / 0 &&
                                    (d._sprite.__default[1] =
                                        d._duration * 1e3),
                                d._ended(c)),
                                c._node.removeEventListener(
                                    "ended",
                                    c._endFn,
                                    !1
                                );
                        },
                    };
                    var r = {},
                        a = function (c) {
                            var d = c._src;
                            if (r[d]) {
                                (c._duration = r[d].duration), l(c);
                                return;
                            }
                            if (/^data:[^;]+;base64,/.test(d)) {
                                for (
                                    var f = atob(d.split(",")[1]),
                                        p = new Uint8Array(f.length),
                                        m = 0;
                                    m < f.length;
                                    ++m
                                )
                                    p[m] = f.charCodeAt(m);
                                h(p.buffer, c);
                            } else {
                                var g = new XMLHttpRequest();
                                g.open(c._xhr.method, d, !0),
                                    (g.withCredentials =
                                        c._xhr.withCredentials),
                                    (g.responseType = "arraybuffer"),
                                    c._xhr.headers &&
                                        Object.keys(c._xhr.headers).forEach(
                                            function (_) {
                                                g.setRequestHeader(
                                                    _,
                                                    c._xhr.headers[_]
                                                );
                                            }
                                        ),
                                    (g.onload = function () {
                                        var _ = (g.status + "")[0];
                                        if (
                                            _ !== "0" &&
                                            _ !== "2" &&
                                            _ !== "3"
                                        ) {
                                            c._emit(
                                                "loaderror",
                                                null,
                                                "Failed loading audio file with status: " +
                                                    g.status +
                                                    "."
                                            );
                                            return;
                                        }
                                        h(g.response, c);
                                    }),
                                    (g.onerror = function () {
                                        c._webAudio &&
                                            ((c._html5 = !0),
                                            (c._webAudio = !1),
                                            (c._sounds = []),
                                            delete r[d],
                                            c.load());
                                    }),
                                    o(g);
                            }
                        },
                        o = function (c) {
                            try {
                                c.send();
                            } catch {
                                c.onerror();
                            }
                        },
                        h = function (c, d) {
                            var f = function () {
                                    d._emit(
                                        "loaderror",
                                        null,
                                        "Decoding audio data failed."
                                    );
                                },
                                p = function (m) {
                                    m && d._sounds.length > 0
                                        ? ((r[d._src] = m), l(d, m))
                                        : f();
                                };
                            typeof Promise < "u" &&
                            t.ctx.decodeAudioData.length === 1
                                ? t.ctx.decodeAudioData(c).then(p).catch(f)
                                : t.ctx.decodeAudioData(c, p, f);
                        },
                        l = function (c, d) {
                            d && !c._duration && (c._duration = d.duration),
                                Object.keys(c._sprite).length === 0 &&
                                    (c._sprite = {
                                        __default: [0, c._duration * 1e3],
                                    }),
                                c._state !== "loaded" &&
                                    ((c._state = "loaded"),
                                    c._emit("load"),
                                    c._loadQueue());
                        },
                        u = function () {
                            if (t.usingWebAudio) {
                                try {
                                    typeof AudioContext < "u"
                                        ? (t.ctx = new AudioContext())
                                        : typeof webkitAudioContext < "u"
                                        ? (t.ctx = new webkitAudioContext())
                                        : (t.usingWebAudio = !1);
                                } catch {
                                    t.usingWebAudio = !1;
                                }
                                t.ctx || (t.usingWebAudio = !1);
                                var c = /iP(hone|od|ad)/.test(
                                        t._navigator && t._navigator.platform
                                    ),
                                    d =
                                        t._navigator &&
                                        t._navigator.appVersion.match(
                                            /OS (\d+)_(\d+)_?(\d+)?/
                                        ),
                                    f = d ? parseInt(d[1], 10) : null;
                                if (c && f && f < 9) {
                                    var p = /safari/.test(
                                        t._navigator &&
                                            t._navigator.userAgent.toLowerCase()
                                    );
                                    t._navigator &&
                                        !p &&
                                        (t.usingWebAudio = !1);
                                }
                                t.usingWebAudio &&
                                    ((t.masterGain =
                                        typeof t.ctx.createGain > "u"
                                            ? t.ctx.createGainNode()
                                            : t.ctx.createGain()),
                                    t.masterGain.gain.setValueAtTime(
                                        t._muted ? 0 : t._volume,
                                        t.ctx.currentTime
                                    ),
                                    t.masterGain.connect(t.ctx.destination)),
                                    t._setup();
                            }
                        };
                    (s.Howler = t),
                        (s.Howl = n),
                        typeof Ml < "u"
                            ? ((Ml.HowlerGlobal = e),
                              (Ml.Howler = t),
                              (Ml.Howl = n),
                              (Ml.Sound = i))
                            : typeof window < "u" &&
                              ((window.HowlerGlobal = e),
                              (window.Howler = t),
                              (window.Howl = n),
                              (window.Sound = i));
                })();
                /*!
                 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
                 *
                 *  howler.js v2.2.4
                 *  howlerjs.com
                 *
                 *  (c) 2013-2020, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */ (function () {
                    (HowlerGlobal.prototype._pos = [0, 0, 0]),
                        (HowlerGlobal.prototype._orientation = [
                            0, 0, -1, 0, 1, 0,
                        ]),
                        (HowlerGlobal.prototype.stereo = function (t) {
                            var n = this;
                            if (!n.ctx || !n.ctx.listener) return n;
                            for (var i = n._howls.length - 1; i >= 0; i--)
                                n._howls[i].stereo(t);
                            return n;
                        }),
                        (HowlerGlobal.prototype.pos = function (t, n, i) {
                            var r = this;
                            if (!r.ctx || !r.ctx.listener) return r;
                            if (
                                ((n = typeof n != "number" ? r._pos[1] : n),
                                (i = typeof i != "number" ? r._pos[2] : i),
                                typeof t == "number")
                            )
                                (r._pos = [t, n, i]),
                                    typeof r.ctx.listener.positionX < "u"
                                        ? (r.ctx.listener.positionX.setTargetAtTime(
                                              r._pos[0],
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          r.ctx.listener.positionY.setTargetAtTime(
                                              r._pos[1],
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          r.ctx.listener.positionZ.setTargetAtTime(
                                              r._pos[2],
                                              Howler.ctx.currentTime,
                                              0.1
                                          ))
                                        : r.ctx.listener.setPosition(
                                              r._pos[0],
                                              r._pos[1],
                                              r._pos[2]
                                          );
                            else return r._pos;
                            return r;
                        }),
                        (HowlerGlobal.prototype.orientation = function (
                            t,
                            n,
                            i,
                            r,
                            a,
                            o
                        ) {
                            var h = this;
                            if (!h.ctx || !h.ctx.listener) return h;
                            var l = h._orientation;
                            if (
                                ((n = typeof n != "number" ? l[1] : n),
                                (i = typeof i != "number" ? l[2] : i),
                                (r = typeof r != "number" ? l[3] : r),
                                (a = typeof a != "number" ? l[4] : a),
                                (o = typeof o != "number" ? l[5] : o),
                                typeof t == "number")
                            )
                                (h._orientation = [t, n, i, r, a, o]),
                                    typeof h.ctx.listener.forwardX < "u"
                                        ? (h.ctx.listener.forwardX.setTargetAtTime(
                                              t,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          h.ctx.listener.forwardY.setTargetAtTime(
                                              n,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          h.ctx.listener.forwardZ.setTargetAtTime(
                                              i,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          h.ctx.listener.upX.setTargetAtTime(
                                              r,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          h.ctx.listener.upY.setTargetAtTime(
                                              a,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ),
                                          h.ctx.listener.upZ.setTargetAtTime(
                                              o,
                                              Howler.ctx.currentTime,
                                              0.1
                                          ))
                                        : h.ctx.listener.setOrientation(
                                              t,
                                              n,
                                              i,
                                              r,
                                              a,
                                              o
                                          );
                            else return l;
                            return h;
                        }),
                        (Howl.prototype.init = (function (t) {
                            return function (n) {
                                var i = this;
                                return (
                                    (i._orientation = n.orientation || [
                                        1, 0, 0,
                                    ]),
                                    (i._stereo = n.stereo || null),
                                    (i._pos = n.pos || null),
                                    (i._pannerAttr = {
                                        coneInnerAngle:
                                            typeof n.coneInnerAngle < "u"
                                                ? n.coneInnerAngle
                                                : 360,
                                        coneOuterAngle:
                                            typeof n.coneOuterAngle < "u"
                                                ? n.coneOuterAngle
                                                : 360,
                                        coneOuterGain:
                                            typeof n.coneOuterGain < "u"
                                                ? n.coneOuterGain
                                                : 0,
                                        distanceModel:
                                            typeof n.distanceModel < "u"
                                                ? n.distanceModel
                                                : "inverse",
                                        maxDistance:
                                            typeof n.maxDistance < "u"
                                                ? n.maxDistance
                                                : 1e4,
                                        panningModel:
                                            typeof n.panningModel < "u"
                                                ? n.panningModel
                                                : "HRTF",
                                        refDistance:
                                            typeof n.refDistance < "u"
                                                ? n.refDistance
                                                : 1,
                                        rolloffFactor:
                                            typeof n.rolloffFactor < "u"
                                                ? n.rolloffFactor
                                                : 1,
                                    }),
                                    (i._onstereo = n.onstereo
                                        ? [{ fn: n.onstereo }]
                                        : []),
                                    (i._onpos = n.onpos
                                        ? [{ fn: n.onpos }]
                                        : []),
                                    (i._onorientation = n.onorientation
                                        ? [{ fn: n.onorientation }]
                                        : []),
                                    t.call(this, n)
                                );
                            };
                        })(Howl.prototype.init)),
                        (Howl.prototype.stereo = function (t, n) {
                            var i = this;
                            if (!i._webAudio) return i;
                            if (i._state !== "loaded")
                                return (
                                    i._queue.push({
                                        event: "stereo",
                                        action: function () {
                                            i.stereo(t, n);
                                        },
                                    }),
                                    i
                                );
                            var r =
                                typeof Howler.ctx.createStereoPanner > "u"
                                    ? "spatial"
                                    : "stereo";
                            if (typeof n > "u")
                                if (typeof t == "number")
                                    (i._stereo = t), (i._pos = [t, 0, 0]);
                                else return i._stereo;
                            for (
                                var a = i._getSoundIds(n), o = 0;
                                o < a.length;
                                o++
                            ) {
                                var h = i._soundById(a[o]);
                                if (h)
                                    if (typeof t == "number")
                                        (h._stereo = t),
                                            (h._pos = [t, 0, 0]),
                                            h._node &&
                                                ((h._pannerAttr.panningModel =
                                                    "equalpower"),
                                                (!h._panner ||
                                                    !h._panner.pan) &&
                                                    e(h, r),
                                                r === "spatial"
                                                    ? typeof h._panner
                                                          .positionX < "u"
                                                        ? (h._panner.positionX.setValueAtTime(
                                                              t,
                                                              Howler.ctx
                                                                  .currentTime
                                                          ),
                                                          h._panner.positionY.setValueAtTime(
                                                              0,
                                                              Howler.ctx
                                                                  .currentTime
                                                          ),
                                                          h._panner.positionZ.setValueAtTime(
                                                              0,
                                                              Howler.ctx
                                                                  .currentTime
                                                          ))
                                                        : h._panner.setPosition(
                                                              t,
                                                              0,
                                                              0
                                                          )
                                                    : h._panner.pan.setValueAtTime(
                                                          t,
                                                          Howler.ctx.currentTime
                                                      )),
                                            i._emit("stereo", h._id);
                                    else return h._stereo;
                            }
                            return i;
                        }),
                        (Howl.prototype.pos = function (t, n, i, r) {
                            var a = this;
                            if (!a._webAudio) return a;
                            if (a._state !== "loaded")
                                return (
                                    a._queue.push({
                                        event: "pos",
                                        action: function () {
                                            a.pos(t, n, i, r);
                                        },
                                    }),
                                    a
                                );
                            if (
                                ((n = typeof n != "number" ? 0 : n),
                                (i = typeof i != "number" ? -0.5 : i),
                                typeof r > "u")
                            )
                                if (typeof t == "number") a._pos = [t, n, i];
                                else return a._pos;
                            for (
                                var o = a._getSoundIds(r), h = 0;
                                h < o.length;
                                h++
                            ) {
                                var l = a._soundById(o[h]);
                                if (l)
                                    if (typeof t == "number")
                                        (l._pos = [t, n, i]),
                                            l._node &&
                                                ((!l._panner ||
                                                    l._panner.pan) &&
                                                    e(l, "spatial"),
                                                typeof l._panner.positionX < "u"
                                                    ? (l._panner.positionX.setValueAtTime(
                                                          t,
                                                          Howler.ctx.currentTime
                                                      ),
                                                      l._panner.positionY.setValueAtTime(
                                                          n,
                                                          Howler.ctx.currentTime
                                                      ),
                                                      l._panner.positionZ.setValueAtTime(
                                                          i,
                                                          Howler.ctx.currentTime
                                                      ))
                                                    : l._panner.setPosition(
                                                          t,
                                                          n,
                                                          i
                                                      )),
                                            a._emit("pos", l._id);
                                    else return l._pos;
                            }
                            return a;
                        }),
                        (Howl.prototype.orientation = function (t, n, i, r) {
                            var a = this;
                            if (!a._webAudio) return a;
                            if (a._state !== "loaded")
                                return (
                                    a._queue.push({
                                        event: "orientation",
                                        action: function () {
                                            a.orientation(t, n, i, r);
                                        },
                                    }),
                                    a
                                );
                            if (
                                ((n =
                                    typeof n != "number"
                                        ? a._orientation[1]
                                        : n),
                                (i =
                                    typeof i != "number"
                                        ? a._orientation[2]
                                        : i),
                                typeof r > "u")
                            )
                                if (typeof t == "number")
                                    a._orientation = [t, n, i];
                                else return a._orientation;
                            for (
                                var o = a._getSoundIds(r), h = 0;
                                h < o.length;
                                h++
                            ) {
                                var l = a._soundById(o[h]);
                                if (l)
                                    if (typeof t == "number")
                                        (l._orientation = [t, n, i]),
                                            l._node &&
                                                (l._panner ||
                                                    (l._pos ||
                                                        (l._pos = a._pos || [
                                                            0, 0, -0.5,
                                                        ]),
                                                    e(l, "spatial")),
                                                typeof l._panner.orientationX <
                                                "u"
                                                    ? (l._panner.orientationX.setValueAtTime(
                                                          t,
                                                          Howler.ctx.currentTime
                                                      ),
                                                      l._panner.orientationY.setValueAtTime(
                                                          n,
                                                          Howler.ctx.currentTime
                                                      ),
                                                      l._panner.orientationZ.setValueAtTime(
                                                          i,
                                                          Howler.ctx.currentTime
                                                      ))
                                                    : l._panner.setOrientation(
                                                          t,
                                                          n,
                                                          i
                                                      )),
                                            a._emit("orientation", l._id);
                                    else return l._orientation;
                            }
                            return a;
                        }),
                        (Howl.prototype.pannerAttr = function () {
                            var t = this,
                                n = arguments,
                                i,
                                r,
                                a;
                            if (!t._webAudio) return t;
                            if (n.length === 0) return t._pannerAttr;
                            if (n.length === 1)
                                if (typeof n[0] == "object")
                                    (i = n[0]),
                                        typeof r > "u" &&
                                            (i.pannerAttr ||
                                                (i.pannerAttr = {
                                                    coneInnerAngle:
                                                        i.coneInnerAngle,
                                                    coneOuterAngle:
                                                        i.coneOuterAngle,
                                                    coneOuterGain:
                                                        i.coneOuterGain,
                                                    distanceModel:
                                                        i.distanceModel,
                                                    maxDistance: i.maxDistance,
                                                    refDistance: i.refDistance,
                                                    rolloffFactor:
                                                        i.rolloffFactor,
                                                    panningModel:
                                                        i.panningModel,
                                                }),
                                            (t._pannerAttr = {
                                                coneInnerAngle:
                                                    typeof i.pannerAttr
                                                        .coneInnerAngle < "u"
                                                        ? i.pannerAttr
                                                              .coneInnerAngle
                                                        : t._coneInnerAngle,
                                                coneOuterAngle:
                                                    typeof i.pannerAttr
                                                        .coneOuterAngle < "u"
                                                        ? i.pannerAttr
                                                              .coneOuterAngle
                                                        : t._coneOuterAngle,
                                                coneOuterGain:
                                                    typeof i.pannerAttr
                                                        .coneOuterGain < "u"
                                                        ? i.pannerAttr
                                                              .coneOuterGain
                                                        : t._coneOuterGain,
                                                distanceModel:
                                                    typeof i.pannerAttr
                                                        .distanceModel < "u"
                                                        ? i.pannerAttr
                                                              .distanceModel
                                                        : t._distanceModel,
                                                maxDistance:
                                                    typeof i.pannerAttr
                                                        .maxDistance < "u"
                                                        ? i.pannerAttr
                                                              .maxDistance
                                                        : t._maxDistance,
                                                refDistance:
                                                    typeof i.pannerAttr
                                                        .refDistance < "u"
                                                        ? i.pannerAttr
                                                              .refDistance
                                                        : t._refDistance,
                                                rolloffFactor:
                                                    typeof i.pannerAttr
                                                        .rolloffFactor < "u"
                                                        ? i.pannerAttr
                                                              .rolloffFactor
                                                        : t._rolloffFactor,
                                                panningModel:
                                                    typeof i.pannerAttr
                                                        .panningModel < "u"
                                                        ? i.pannerAttr
                                                              .panningModel
                                                        : t._panningModel,
                                            }));
                                else
                                    return (
                                        (a = t._soundById(parseInt(n[0], 10))),
                                        a ? a._pannerAttr : t._pannerAttr
                                    );
                            else
                                n.length === 2 &&
                                    ((i = n[0]), (r = parseInt(n[1], 10)));
                            for (
                                var o = t._getSoundIds(r), h = 0;
                                h < o.length;
                                h++
                            )
                                if (((a = t._soundById(o[h])), a)) {
                                    var l = a._pannerAttr;
                                    l = {
                                        coneInnerAngle:
                                            typeof i.coneInnerAngle < "u"
                                                ? i.coneInnerAngle
                                                : l.coneInnerAngle,
                                        coneOuterAngle:
                                            typeof i.coneOuterAngle < "u"
                                                ? i.coneOuterAngle
                                                : l.coneOuterAngle,
                                        coneOuterGain:
                                            typeof i.coneOuterGain < "u"
                                                ? i.coneOuterGain
                                                : l.coneOuterGain,
                                        distanceModel:
                                            typeof i.distanceModel < "u"
                                                ? i.distanceModel
                                                : l.distanceModel,
                                        maxDistance:
                                            typeof i.maxDistance < "u"
                                                ? i.maxDistance
                                                : l.maxDistance,
                                        refDistance:
                                            typeof i.refDistance < "u"
                                                ? i.refDistance
                                                : l.refDistance,
                                        rolloffFactor:
                                            typeof i.rolloffFactor < "u"
                                                ? i.rolloffFactor
                                                : l.rolloffFactor,
                                        panningModel:
                                            typeof i.panningModel < "u"
                                                ? i.panningModel
                                                : l.panningModel,
                                    };
                                    var u = a._panner;
                                    u ||
                                        (a._pos ||
                                            (a._pos = t._pos || [0, 0, -0.5]),
                                        e(a, "spatial"),
                                        (u = a._panner)),
                                        (u.coneInnerAngle = l.coneInnerAngle),
                                        (u.coneOuterAngle = l.coneOuterAngle),
                                        (u.coneOuterGain = l.coneOuterGain),
                                        (u.distanceModel = l.distanceModel),
                                        (u.maxDistance = l.maxDistance),
                                        (u.refDistance = l.refDistance),
                                        (u.rolloffFactor = l.rolloffFactor),
                                        (u.panningModel = l.panningModel);
                                }
                            return t;
                        }),
                        (Sound.prototype.init = (function (t) {
                            return function () {
                                var n = this,
                                    i = n._parent;
                                (n._orientation = i._orientation),
                                    (n._stereo = i._stereo),
                                    (n._pos = i._pos),
                                    (n._pannerAttr = i._pannerAttr),
                                    t.call(this),
                                    n._stereo
                                        ? i.stereo(n._stereo)
                                        : n._pos &&
                                          i.pos(
                                              n._pos[0],
                                              n._pos[1],
                                              n._pos[2],
                                              n._id
                                          );
                            };
                        })(Sound.prototype.init)),
                        (Sound.prototype.reset = (function (t) {
                            return function () {
                                var n = this,
                                    i = n._parent;
                                return (
                                    (n._orientation = i._orientation),
                                    (n._stereo = i._stereo),
                                    (n._pos = i._pos),
                                    (n._pannerAttr = i._pannerAttr),
                                    n._stereo
                                        ? i.stereo(n._stereo)
                                        : n._pos
                                        ? i.pos(
                                              n._pos[0],
                                              n._pos[1],
                                              n._pos[2],
                                              n._id
                                          )
                                        : n._panner &&
                                          (n._panner.disconnect(0),
                                          (n._panner = void 0),
                                          i._refreshBuffer(n)),
                                    t.call(this)
                                );
                            };
                        })(Sound.prototype.reset));
                    var e = function (t, n) {
                        (n = n || "spatial"),
                            n === "spatial"
                                ? ((t._panner = Howler.ctx.createPanner()),
                                  (t._panner.coneInnerAngle =
                                      t._pannerAttr.coneInnerAngle),
                                  (t._panner.coneOuterAngle =
                                      t._pannerAttr.coneOuterAngle),
                                  (t._panner.coneOuterGain =
                                      t._pannerAttr.coneOuterGain),
                                  (t._panner.distanceModel =
                                      t._pannerAttr.distanceModel),
                                  (t._panner.maxDistance =
                                      t._pannerAttr.maxDistance),
                                  (t._panner.refDistance =
                                      t._pannerAttr.refDistance),
                                  (t._panner.rolloffFactor =
                                      t._pannerAttr.rolloffFactor),
                                  (t._panner.panningModel =
                                      t._pannerAttr.panningModel),
                                  typeof t._panner.positionX < "u"
                                      ? (t._panner.positionX.setValueAtTime(
                                            t._pos[0],
                                            Howler.ctx.currentTime
                                        ),
                                        t._panner.positionY.setValueAtTime(
                                            t._pos[1],
                                            Howler.ctx.currentTime
                                        ),
                                        t._panner.positionZ.setValueAtTime(
                                            t._pos[2],
                                            Howler.ctx.currentTime
                                        ))
                                      : t._panner.setPosition(
                                            t._pos[0],
                                            t._pos[1],
                                            t._pos[2]
                                        ),
                                  typeof t._panner.orientationX < "u"
                                      ? (t._panner.orientationX.setValueAtTime(
                                            t._orientation[0],
                                            Howler.ctx.currentTime
                                        ),
                                        t._panner.orientationY.setValueAtTime(
                                            t._orientation[1],
                                            Howler.ctx.currentTime
                                        ),
                                        t._panner.orientationZ.setValueAtTime(
                                            t._orientation[2],
                                            Howler.ctx.currentTime
                                        ))
                                      : t._panner.setOrientation(
                                            t._orientation[0],
                                            t._orientation[1],
                                            t._orientation[2]
                                        ))
                                : ((t._panner =
                                      Howler.ctx.createStereoPanner()),
                                  t._panner.pan.setValueAtTime(
                                      t._stereo,
                                      Howler.ctx.currentTime
                                  )),
                            t._panner.connect(t._node),
                            t._paused ||
                                t._parent.pause(t._id, !0).play(t._id, !0);
                    };
                })();
            })(Sp)),
        Sp
    );
}
var DV = $V();
function NV(s, e) {
    Ne(e, !0);
    const t = () => U(Eh, "$soundVolume", a),
        n = () => U(Ph, "$musicVolume", a),
        i = () => U(ml, "$betAmountOptions", a),
        r = () => U(Nt, "$betAmount", a),
        [a, o] = tt();
    let h = gt(!1),
        l;
    const u = (g, _, v = 1, b = !1) => {
        const y = l.play(g, _);
        return b || l.volume(v * t(), y), y;
    };
    let c = { baseBgm: 0.5 },
        d,
        f = 0;
    _n(() => {
        $(h) && d && l.volume(c.baseBgm * n(), d);
    }),
        Fs(() => {
            const g = Xi.get("audio");
            l = new DV.Howl({
                ...g,
                onload: () => {
                    Re(h, !0), p();
                },
            });
        });
    const p = () => {
        (d = l.play("md_base_bgm")),
            l.loop(!0, d),
            l.volume(c.baseBgm * n(), d);
    };
    let m = Me(
        () => 0.8 + (i().findIndex((g) => g === r()) / (i().length - 1)) * 1.2
    );
    _n(() => {
        $(h) &&
            De.register({
                betStart: () => {
                    (f = 0), u("shared_click");
                },
                reveal: () => {},
                reelStop: ({ index: g }) => {
                    u(`shared_reel_stop_${Math.min(5, g)}`);
                },
                playButtonClick: () => {
                    u("shared_click");
                },
                increaseBet: () => {
                    const g = u("shared_click");
                    l.rate($(m), g);
                },
                decreaseBet: () => {
                    const g = u("shared_click");
                    l.rate($(m), g);
                },
                realFinalWin: ({ finalWin: g }) => {
                    g > 50
                        ? (u("shared_totalwin_big"), u("shared_totalwin_coins"))
                        : g > 1 &&
                          (u("shared_totalwin"), u("shared_totalwin_coins"));
                },
                pickHit: () => {
                    const g = u(
                        "md_pick_hit",
                        !1,
                        Te.turbo || ye.skip ? 0.08 : 0.2
                    );
                    l.rate(0.8 + 0.3 * Math.random(), g);
                },
                blockBreak: ({ block: g }) => {
                    switch (g) {
                        case "dirt":
                            u("md_dirt_break", !1, 2);
                            break;
                        case "stone":
                            u("md_stone_break", !1, 2);
                            break;
                        case "gold":
                            u("md_gold_break", !1, 2);
                            break;
                        case "ruby":
                            u("md_ruby_break", !1, 2);
                            break;
                        case "diamond":
                            u("md_diamond_break", !1, 2);
                            break;
                        case "obsidian":
                            u("md_obsidian_break", !1, 2);
                            break;
                    }
                    g !== "dirt" && u("md_block_break_win", !1, 0.08);
                },
                chestOpen: ({ multiplier: g }) => {
                    g >= 5 ? u("md_chest_open_big") : u("md_chest_open");
                },
                multMove: () => {
                    u("md_multmove");
                },
                multCombine: () => {
                    u("md_multcombine");
                },
                symbolLand: ({ symbol: g }) => {
                    switch (g.symbol) {
                        case tl.symbol:
                            f++,
                                (f = Math.min(f, 3)),
                                kh(
                                    () =>
                                        u(
                                            `md_bonus_land_${f}`,
                                            !1,
                                            Te.turbo || ye.skip ? 0.4 : 0.6
                                        ),
                                    10
                                );
                            break;
                        case Nk.symbol:
                            break;
                        default:
                            const _ = u(
                                "md_dead_land",
                                !1,
                                Te.turbo || ye.skip ? 0.08 : 0.2
                            );
                            l.rate(0.8 + 0.3 * Math.random(), _);
                            break;
                    }
                },
                symbolWin: ({ symbol: g }) => {
                    g.symbol === Vk.symbol && u("md_tnt_win"),
                        g.symbol === N1.symbol && u("md_pick_upgrade", !1, 0.5),
                        g.symbol === tl.symbol && u("md_bonus_win", !1, 0.5);
                },
                bonusIntro: async ({ scenario: g }) => {
                    (c.baseBgm = 0.1),
                        l.fade(0.5 * n(), 0.1 * n(), 500, d),
                        await Le(300);
                },
                bonusOutro: ({ scenario: g }) => {
                    (c.baseBgm = 0.5), l.fade(0.1 * n(), 0.5 * n(), 1500, d);
                },
            });
    }),
        Ve(),
        o();
}
const VV = {
    en: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "When activated, spins are 5x more likely to trigger a bonus game!",
                },
                BONUS: {
                    DIALOG: "Enter a Bonus game with 4 free spins. Blocks are persistent for the bonus game.",
                },
            },
            GAME_RULES: {
                RULES: `In Minedrop, spin the 5x3 reels at the top to land symbols that drop down and smash through the 5x6 grid of blocks below. Each block you break awards a payout. Break through all blocks in a column to reach the bottom and unlock a treasure chest, multiplying your final win!

The theoretical RTP for Base is 96.00%.
The theoretical RTP for Ante is 96.00%.
The theoretical RTP for Bonus is 96.00%.
The max win is 5,000x the bet.`,
                WAYS_TO_WIN:
                    "Winning combinations are paid from breaking blocks. Different blocks have different durability. Dirt requires 1 hit to break. Stone requires 2 hits to break. Ruby requires 4 hits to break. Gold requires 5 hits to break. Diamond requires 6 hits to break. Obsidian requires 7 hits to break.",
                FEATURES: `Bonus game is a free spins feature awarding 4 free spins. During the free spins, blocks are persistent offering a higher chance of a complete reel being broken to unlock the chests.

Extra Chance is a side bet feature that increases the chance of entering a free spins feature by 5x for 3x the cost of the bet.`,
                GENERAL:
                    "Malfunction voids all pays and plays. A consistent internet connection is required. In the event of a disconnection, reload the game to finish any uncompleted bets. The expected return is calculated over many spins. Movement of reels are not representative of any physical device, and is for illustrative purposes only. TM and  2025 Stake Engine.",
            },
        },
    },
    social: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "When activated, spins are 5x more likely to trigger a bonus game!",
                },
                BONUS: {
                    DIALOG: "Enter a Bonus game with 4 free spins. Blocks are persistent for the bonus game.",
                },
            },
            GAME_RULES: {
                RULES: `In Minedrop, spin the 5x3 reels at the top to land symbols that drop down and smash through the 5x6 grid of blocks below. Each block you break awards a win. Break through all blocks in a column to reach the bottom and unlock a treasure chest, multiplying your final win!

The theoretical RTP for Base is 96.00%.
The theoretical RTP for Ante is 96.00%.
The theoretical RTP for Bonus is 96.00%.
The max win is 5,000x the play.`,
                WAYS_TO_WIN:
                    "Winning combinations are awarded from breaking blocks. Different blocks have different durability. Dirt requires 1 hit to break. Stone requires 2 hits to break. Ruby requires 4 hits to break. Gold requires 5 hits to break. Diamond requires 6 hits to break. Obsidian requires 7 hits to break.",
                FEATURES: `Bonus game is a free spins feature awarding 4 free spins. During the free spins, blocks are persistent offering a higher chance of a complete reel being broken to unlock the chests.

Extra Chance is a side play feature that increases the chance of entering a free spins feature by 5x for 3x the play.`,
                GENERAL:
                    "Malfunction voids all awards and plays. A consistent internet connection is required. In the event of a disconnection, reload the game to finish any uncompleted plays. The expected return is calculated over many spins. Movement of reels are not representative of any physical device, and is for illustrative purposes only. TM and  2025 Stake Engine.",
            },
        },
    },
    ar: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "        5 !",
                },
                BONUS: {
                    DIALOG: "    4  .    .",
                },
            },
            GAME_RULES: {
                RULES: ` **Minedrop**    5x3          5x6 .     .               !

    (RTP)    96.00%.
    (RTP)    96.00%.
    (RTP)   96.00%.
    5000  .`,
                WAYS_TO_WIN:
                    "      .     .     .    .   4  .   5  .   6  .   7  .",
                FEATURES: `       4  .               .

Extra Chance              5   3   .`,
                GENERAL:
                    "     .    .            .         .           . TM   2025 Stake Engine.",
            },
        },
    },
    de: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Wenn aktiviert, haben Spins eine 5x hhere Wahrscheinlichkeit, ein Bonusspiel auszulsen!",
                },
                BONUS: {
                    DIALOG: "Betreten Sie ein Bonusspiel mit 4 Freispielen. Blcke bleiben fr das Bonusspiel bestehen.",
                },
            },
            GAME_RULES: {
                RULES: `In **Minedrop** drehen Sie die 5x3 Walzen oben, um Symbole zu landen, die nach unten fallen und durch das 5x6-Raster von Blcken darunter zerschlagen. Jeder Block, den Sie zerbrechen, vergibt eine Auszahlung. Zerbrechen Sie alle Blcke in einer Spalte, um den Boden zu erreichen und eine Schatztruhe freizuschalten, die Ihren endgltigen Gewinn multipliziert!

Der theoretische RTP fr Basis betrgt 96,00 %.
Der theoretische RTP fr Ante betrgt 96,00 %.
Der theoretische RTP fr Bonus betrgt 96,00 %.
Der maximale Gewinn betrgt das 5.000-fache des Einsatzes.`,
                WAYS_TO_WIN:
                    "Gewinnkombinationen werden durch das Zerbrechen von Blcken ausgezahlt. Verschiedene Blcke haben unterschiedliche Haltbarkeit. Erde erfordert 1 Treffer zum Zerbrechen. Stein erfordert 2 Treffer zum Zerbrechen. Rubin erfordert 4 Treffer zum Zerbrechen. Gold erfordert 5 Treffer zum Zerbrechen. Diamant erfordert 6 Treffer zum Zerbrechen. Obsidian erfordert 7 Treffer zum Zerbrechen.",
                FEATURES: `Das Bonusspiel ist ein Freispiel-Feature, das 4 Freispiele vergibt. Whrend der Freispiele bleiben die Blcke bestehen, was eine hhere Chance bietet, dass eine komplette Walze zerbrochen wird, um die Truhen freizuschalten.

Extra Chance ist ein Nebenwette-Feature, das die Chance, ein Freispiel-Feature zu betreten, um das 5-fache fr das 3-fache der Einsatzkosten erhht.`,
                GENERAL:
                    "Fehlfunktionen machen alle Auszahlungen und Spiele ungltig. Eine konsistente Internetverbindung ist erforderlich. Im Falle einer Trennung laden Sie das Spiel neu, um unvollendete Wetten abzuschlieen. Die erwartete Rendite wird ber viele Drehungen berechnet. Die Bewegung der Walzen stellt kein physisches Gert dar und dient nur zu Illustrationszwecken. TM und  2025 Stake Engine.",
            },
        },
    },
    es: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Al activarse, los giros tienen 5 veces ms probabilidades de activar un juego de bonificacin!",
                },
                BONUS: {
                    DIALOG: "Entra en un juego de bonificacin con 4 giros gratis. Los bloques son persistentes para el juego de bonificacin.",
                },
            },
            GAME_RULES: {
                RULES: `En **Minedrop**, gira los carretes 5x3 en la parte superior para que los smbolos caigan y rompan la cuadrcula de bloques 5x6 de abajo. Cada bloque que rompas otorga un pago. Rompe todos los bloques de una columna para llegar al fondo y desbloquear un cofre del tesoro, multiplicando tu ganancia final!

El RTP terico para el Base es del 96,00 %.
El RTP terico para el Ante es del 96,00 %.
El RTP terico para el Bono es del 96,00 %.
La ganancia mxima es 5.000x la apuesta.`,
                WAYS_TO_WIN:
                    "Las combinaciones ganadoras se pagan al romper bloques. Diferentes bloques tienen diferente durabilidad. La tierra requiere 1 golpe para romperse. La piedra requiere 2 golpes para romperse. El rub requiere 4 golpes para romperse. El oro requiere 5 golpes para romperse. El diamante requiere 6 golpes para romperse. La obsidiana requiere 7 golpes para romperse.",
                FEATURES: `El juego de bonificacin es una funcin de giros gratis que otorga 4 giros gratis. Durante los giros gratis, los bloques son persistentes, lo que ofrece una mayor probabilidad de que se rompa un carrete completo para desbloquear los cofres.

Extra Chance es una funcin de apuesta lateral que aumenta la posibilidad de entrar en una funcin de giros gratis 5 veces por 3x el costo de la apuesta.`,
                GENERAL:
                    "El mal funcionamiento anula todos los pagos y jugadas. Se requiere una conexin a Internet consistente. En caso de desconexin, recargue el juego para finalizar cualquier apuesta incompleta. El retorno esperado se calcula en muchas tiradas. El movimiento de los carretes no es representativo de ningn dispositivo fsico y es solo para fines ilustrativos. TM y  2025 Stake Engine.",
            },
        },
    },
    fi: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Aktivoituna pyrytyksill on 5 kertaa suurempi todennkisyys kynnist bonuspeli!",
                },
                BONUS: {
                    DIALOG: "Siirry bonuspeliin 4 ilmaispyrytyksell. Lohkot ovat pysyvi bonuspelin ajan.",
                },
            },
            GAME_RULES: {
                RULES: `Tervetuloa **Minedrop**-peliin! Pyryt ylreunan 5x3-rullia saadaksesi symboleita, jotka putoavat alas ja murskaavat alla olevan 5x6-lohkoruudukon. Jokainen rikkomasi lohko antaa voiton. Murskaa kaikki lohkot sarakkeessa pstksesi pohjalle ja avataksesi aarteen, joka moninkertaistaa loppuvoittosi!

Teoreettinen palautusprosentti (RTP) peruspeliin on 96.00%.
Teoreettinen palautusprosentti (RTP) Ante-vetoon on 96.00%.
Teoreettinen palautusprosentti (RTP) bonukseen on 96.00%.
Maksimivoitto on 5000x panos.`,
                WAYS_TO_WIN:
                    "Voittavat yhdistelmt maksetaan lohkojen murskaamisesta. Eri lohkoilla on erilainen kestvyys. Multa vaatii 1 osuman. Kivi vaatii 2 osumaa. Rubiini vaatii 4 osumaa. Kulta vaatii 5 osumaa. Timantti vaatii 6 osumaa. Obsidiaani vaatii 7 osumaa.",
                FEATURES: `Bonuspeli on ilmaiskierrosominaisuus, joka antaa 4 ilmaiskierrosta. Ilmaiskierrosten aikana lohkot ovat pysyvi, mik tarjoaa suuremman mahdollisuuden saada kokonainen rulla murskattua ja avata aarteet.

Extra Chance on sivuveto-ominaisuus, joka lis mahdollisuutta pst ilmaiskierrosominaisuuteen 5 kertaa panoksen 3x hinnalla.`,
                GENERAL:
                    "Toimintahiri mitti kaikki maksut ja pelit. Jatkuva internetyhteys vaaditaan. Katkeamisen sattuessa lataa peli uudelleen viimeistellksesi kaikki keskeneriset vedot. Odotettu palautus lasketaan monien pyrytysten perusteella. Rullien liike ei edusta mitn fyysist laitetta ja on tarkoitettu vain havainnollistamistarkoituksiin. TM ja  2025 Stake Engine.",
            },
        },
    },
    fr: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Lorsqu'ils sont activs, les spins ont 5 fois plus de chances de dclencher un jeu bonus !",
                },
                BONUS: {
                    DIALOG: "Entrez dans un jeu Bonus avec 4 tours gratuits. Les blocs sont persistants pour le jeu bonus.",
                },
            },
            GAME_RULES: {
                RULES: `Dans **Minedrop**, faites tourner les rouleaux 5x3 en haut pour faire tomber des symboles qui traversent et brisent la grille de blocs 5x6 en dessous. Chaque bloc que vous brisez attribue un paiement. Brisez tous les blocs d'une colonne pour atteindre le fond et dverrouiller un coffre au trsor, ce qui multiplie votre gain final !

Le RTP thorique pour le mode de base est de 96,00 %.
Le RTP thorique pour Ante est de 96,00 %.
Le RTP thorique pour le Bonus est de 96,00 %.
Le gain maximum est de 5 000x la mise.`,
                WAYS_TO_WIN:
                    "Les combinaisons gagnantes sont payes en brisant des blocs. Diffrents blocs ont une durabilit diffrente. La terre ncessite 1 coup pour tre brise. La pierre ncessite 2 coups pour tre brise. Le rubis ncessite 4 coups pour tre bris. L'or ncessite 5 coups pour tre bris. Le diamant ncessite 6 coups pour tre bris. L'obsidienne ncessite 7 coups pour tre brise.",
                FEATURES: `Le jeu bonus est une fonctionnalit de tours gratuits accordant 4 tours gratuits. Pendant les tours gratuits, les blocs sont persistants, ce qui offre une plus grande chance qu'un rouleau complet soit bris pour dverrouiller les coffres.

Extra Chance est une fonctionnalit de pari secondaire qui augmente la chance d'entrer dans une fonctionnalit de tours gratuits de 5x pour 3x le cot de la mise.`,
                GENERAL:
                    "Un dysfonctionnement annule tous les paiements et jeux. Une connexion Internet stable est requise. En cas de dconnexion, rechargez le jeu pour terminer toutes les mises inacheves. Le retour attendu est calcul sur de nombreux spins. Le mouvement des rouleaux n'est pas reprsentatif d'un appareil physique et est uniquement  des fins d'illustration. TM et  2025 Stake Engine.",
            },
        },
    },
    hi: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "  ,          5    !",
                },
                BONUS: {
                    DIALOG: "4                  ",
                },
            },
            GAME_RULES: {
                RULES: `**Minedrop** ,  5x3           5x6                                 ,        !

    RTP 96.00% 
    RTP 96.00% 
    RTP 96.00% 
    5,000  `,
                WAYS_TO_WIN:
                    "         -   -         1           2           4           5           6           7     ",
                FEATURES: `        4         ,                    

          3x             5x   `,
                GENERAL:
                    "                      ,                                    ,        TM   2025 Stake Engine",
            },
        },
    },
    id: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Ketika diaktifkan, putaran 5x lebih mungkin untuk memicu permainan bonus!",
                },
                BONUS: {
                    DIALOG: "Masuk ke permainan Bonus dengan 4 putaran gratis. Blok-blok bersifat persisten untuk permainan bonus.",
                },
            },
            GAME_RULES: {
                RULES: `Di **Minedrop**, putar gulungan 5x3 di bagian atas untuk mendaratkan simbol yang jatuh dan menghancurkan grid blok 5x6 di bawah. Setiap blok yang Anda hancurkan memberikan pembayaran. Hancurkan semua blok dalam satu kolom untuk mencapai bagian bawah dan membuka peti harta karun, melipatgandakan kemenangan akhir Anda!

RTP teoretis untuk Dasar adalah 96.00%.
RTP teoretis untuk Ante adalah 96.00%.
RTP teoretis untuk Bonus adalah 96.00%.
Kemenangan maksimum adalah 5.000x taruhan.`,
                WAYS_TO_WIN:
                    "Kombinasi pemenang dibayar dari menghancurkan blok. Blok yang berbeda memiliki daya tahan yang berbeda. Tanah membutuhkan 1 pukulan untuk hancur. Batu membutuhkan 2 pukulan untuk hancur. Rubi membutuhkan 4 pukulan untuk hancur. Emas membutuhkan 5 pukulan untuk hancur. Berlian membutuhkan 6 pukulan untuk hancur. Obsidian membutuhkan 7 pukulan untuk hancur.",
                FEATURES: `Permainan bonus adalah fitur putaran gratis yang memberikan 4 putaran gratis. Selama putaran gratis, blok-blok bersifat persisten yang menawarkan peluang lebih tinggi untuk menghancurkan gulungan lengkap guna membuka peti harta karun.

Extra Chance adalah fitur taruhan samping yang meningkatkan peluang memasuki fitur putaran gratis sebanyak 5x dengan biaya taruhan 3x.`,
                GENERAL:
                    "Kerusakan membatalkan semua pembayaran dan permainan. Koneksi internet yang konsisten diperlukan. Jika terjadi pemutusan, muat ulang game untuk menyelesaikan taruhan yang belum selesai. Pengembalian yang diharapkan dihitung berdasarkan banyak putaran. Pergerakan gulungan tidak mewakili perangkat fisik apa pun, dan hanya untuk tujuan ilustrasi. TM dan  2025 Stake Engine.",
            },
        },
    },
    ja: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "5",
                },
                BONUS: {
                    DIALOG: "5",
                },
            },
            GAME_RULES: {
                RULES: `**Minedrop**5x35x6

RTP96.00%
RTP96.00%
RTP96.00%
5,000`,
                WAYS_TO_WIN:
                    "124567",
                FEATURES: `5

35`,
                GENERAL:
                    "TM   2025 Stake Engine",
            },
        },
    },
    ko: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: ",      5 !",
                },
                BONUS: {
                    DIALOG: "4     .     .",
                },
            },
            GAME_RULES: {
                RULES: `**Minedrop**  5x3    5x6     .     .              !

   RTP 96.00%.
  RTP 96.00%.
  RTP 96.00%.
   5,000.`,
                WAYS_TO_WIN:
                    "     .   .    1  .    2  .    4  .    5  .    6  .    7  .",
                FEATURES: `  4      .               .

    3      5    .`,
                GENERAL:
                    "     .    .   ,       .      .      ,    . TM   2025 Stake Engine.",
            },
        },
    },
    pl: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Po aktywacji spiny maj 5 razy wiksz szans na uruchomienie gry bonusowej!",
                },
                BONUS: {
                    DIALOG: "Wejd do gry Bonusowej z 4 darmowymi spinami. Bloki s trwae przez ca gr bonusow.",
                },
            },
            GAME_RULES: {
                RULES: `W **Minedrop** zakr bbnami 5x3 na grze, aby wyldowa symbolami, ktre spadaj i przebijaj si przez siatk blokw 5x6 poniej. Kady rozbity blok przyznaje wypat. Przebij si przez wszystkie bloki w kolumnie, aby dotrze na dno i odblokowa skrzyni skarbw, mnoc swoj ostateczn wygran!

Teoretyczny RTP dla Gry Podstawowej wynosi 96,00%.
Teoretyczny RTP dla Ante wynosi 96,00%.
Teoretyczny RTP dla Bonusu wynosi 96,00%.
Maksymalna wygrana to 5000x stawka.`,
                WAYS_TO_WIN:
                    "Wygrywajce kombinacje s wypacane za rozbijanie blokw. Rne bloki maj rn wytrzymao. Ziemia wymaga 1 uderzenia do rozbicia. Kamie wymaga 2 uderze do rozbicia. Rubin wymaga 4 uderze do rozbicia. Zoto wymaga 5 uderze do rozbicia. Diament wymaga 6 uderze do rozbicia. Obsydian wymaga 7 uderze do rozbicia.",
                FEATURES: `Gra bonusowa to funkcja darmowych spinw, ktra przyznaje 4 darmowych spinw. Podczas darmowych spinw bloki s trwae, co oferuje wiksz szans na rozbicie caej kolumny, aby odblokowa skrzynie.

Extra Chance to funkcja zakadu bocznego, ktra zwiksza szans na wejcie do funkcji darmowych spinw o 5 razy za 3x kosztu zakadu.`,
                GENERAL:
                    "Awaria uniewania wszystkie wypaty i gry. Wymagane jest stae poczenie z Internetem. W przypadku rozczenia, ponownie zaaduj gr, aby zakoczy wszelkie niedokoczone zakady. Oczekiwany zwrot jest obliczany na podstawie wielu obrotw. Ruch bbnw nie jest reprezentatywny dla adnego urzdzenia fizycznego i suy wycznie celom ilustracyjnym. TM i  2025 Stake Engine.",
            },
        },
    },
    pt: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Quando ativados, os spins tm 5x mais probabilidade de acionar um jogo de bnus!",
                },
                BONUS: {
                    DIALOG: "Entre em um jogo de Bnus com 4 rodadas grtis. Os blocos so persistentes para o jogo de bnus.",
                },
            },
            GAME_RULES: {
                RULES: `Em **Minedrop**, gire os rolos 5x3 na parte superior para que os smbolos caiam e esmaguem a grade de blocos 5x6 abaixo. Cada bloco que voc quebrar concede um pagamento. Quebre todos os blocos em uma coluna para chegar ao fundo e desbloquear um ba do tesouro, multiplicando seu ganho final!

O RTP terico para o Base  de 96,00%.
O RTP terico para o Ante  de 96,00%.
O RTP terico para o Bnus  de 96,00%.
O ganho mximo  de 5.000x a aposta.`,
                WAYS_TO_WIN:
                    "As combinaes vencedoras so pagas ao quebrar blocos. Diferentes blocos tm durabilidade diferente. Terra requer 1 acerto para quebrar. Pedra requer 2 acertos para quebrar. Rubi requer 4 acertos para quebrar. Ouro requer 5 acertos para quebrar. Diamante requer 6 acertos para quebrar. Obsidiana requer 7 acertos para quebrar.",
                FEATURES: `O jogo de bnus  um recurso de rodadas grtis que concede 4 rodadas grtis. Durante as rodadas grtis, os blocos so persistentes, oferecendo uma chance maior de um rolo completo ser quebrado para desbloquear os bas.

Extra Chance  um recurso de aposta lateral que aumenta a chance de entrar em um recurso de rodadas grtis em 5x por 3x o custo da aposta.`,
                GENERAL:
                    "Mal funcionamento anula todos os pagamentos e jogadas.  necessria uma conexo de internet consistente. Em caso de desconexo, recarregue o jogo para finalizar quaisquer apostas no concludas. O retorno esperado  calculado em muitas rodadas. O movimento dos rolos no  representativo de nenhum dispositivo fsico e  apenas para fins ilustrativos. TM e  2025 Stake Engine.",
            },
        },
    },
    ru: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "        5 !",
                },
                BONUS: {
                    DIALOG: "     4  .       .",
                },
            },
            GAME_RULES: {
                RULES: ` **Minedrop**   5x3 ,         5x6 .      .      ,        ,    !

 RTP     96,00%.
 RTP  Ante  96,00%.
 RTP    96,00%.
   5000x .`,
                WAYS_TO_WIN:
                    "     .     .   1 ,  .   2 ,  .   4 ,  .   5 ,  .   6 ,  .   7 ,  .",
                FEATURES: `      ,  4  .        ,      ,     ,   .

Extra Chance     ,          5   3x  .`,
                GENERAL:
                    "     .     .     ,     .       .       -        . TM   2025 Stake Engine.",
            },
        },
    },
    tr: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Etkinletirildiinde, dnlerin bonus oyunu tetikleme olasl 5 kat daha fazladr!",
                },
                BONUS: {
                    DIALOG: "4 cretsiz dnle bir Bonus oyununa girin. Bloklar, bonus oyunu iin kalcdr.",
                },
            },
            GAME_RULES: {
                RULES: `**Minedrop**'ta, stteki 5x3 makaralar dndrerek sembollerin dmesini ve alttaki 5x6 blok zgarasn krmasn salayn. Kralnz her blok bir deme verir. Altna ulamak ve bir hazine sandn amak iin bir stundaki tm bloklar krn, bu da son kazancnz arpar!

Temel mod iin teorik RTP %96,00'dr.
Ante iin teorik RTP %96,00'dr.
Bonus iin teorik RTP %96,00'dr.
Maksimum kazan bahsin 5.000 katdr.`,
                WAYS_TO_WIN:
                    "Kazanan kombinasyonlar bloklar krarak denir. Farkl bloklarn farkl dayankllklar vardr. Topran krlmas iin 1 vuru gerekir. Tan krlmas iin 2 vuru gerekir. Yakutun krlmas iin 4 vuru gerekir. Altnn krlmas iin 5 vuru gerekir. Elmasn krlmas iin 6 vuru gerekir. Obsidyenin krlmas iin 7 vuru gerekir.",
                FEATURES: `Bonus oyunu, 4 cretsiz dn veren bir cretsiz dn zelliidir. cretsiz dnler srasnda, bloklar kalcdr ve sandklar amak iin tam bir makarann krlma ans daha yksektir.

Ekstra ans, bahis maliyetinin 3 kat karlnda cretsiz dnler zelliine girme ansn 5 kat artran bir yan bahis zelliidir.`,
                GENERAL:
                    "Arza, tm demeleri ve oyunlar geersiz klar. Srekli bir internet balants gereklidir. Balant kesilmesi durumunda, tamamlanmam bahisleri bitirmek iin oyunu yeniden ykleyin. Beklenen getiri birok dn zerinden hesaplanr. Makaralarn hareketi herhangi bir fiziksel cihaz temsil etmez ve yalnzca aklayc amaldr. TM ve  2025 Stake Engine.",
            },
        },
    },
    vi: {
        translation: {
            BET_MODE_META: {
                ANTE: {
                    DIALOG: "Khi c kch hot, s ln quay c kh nng kch hot tr chi thng gp 5 ln!",
                },
                BONUS: {
                    DIALOG: "Vo tr chi Thng vi 4 lt quay min ph. Cc khi c duy tr trong tr chi thng.",
                },
            },
            GAME_RULES: {
                RULES: `Trong **Minedrop**, quay cc cun 5x3  trn cng  cc biu tng ri xung v ph v li khi 5x6 bn di. Mi khi bn ph v s cp mt khon thanh ton. Ph v tt c cc khi trong mt ct  n y v m kha mt rng kho bu, nhn tin thng cui cng ca bn ln!

RTP l thuyt cho C bn l 96,00%.
RTP l thuyt cho Ante l 96,00%.
RTP l thuyt cho Thng l 96,00%.
S tin thng ti a l 5.000 ln t cc.`,
                WAYS_TO_WIN:
                    "Cc t hp chin thng c tr t vic ph v cc khi. Cc khi khc nhau c  bn khc nhau. t cn 1 ln nh  ph v.  cn 2 ln nh  ph v. Ruby cn 4 ln nh  ph v. Vng cn 5 ln nh  ph v. Kim cng cn 6 ln nh  ph v. Obsidian cn 7 ln nh  ph v.",
                FEATURES: `Tr chi thng l mt tnh nng quay min ph cp 4 lt quay min ph. Trong cc lt quay min ph, cc khi c duy tr, mang li c hi cao hn  ph v mt cun hon chnh  m kha cc rng.

C hi ph l mt tnh nng cc ph gip tng c hi tham gia tnh nng quay min ph ln 5 ln vi chi ph t cc gp 3 ln.`,
                GENERAL:
                    "S c k thut s lm v hiu ha tt c cc khon thanh ton v lt chi. Cn c kt ni internet n nh. Trong trng hp mt kt ni, hy ti li tr chi  hon tt mi cc cha hon thnh. Li nhun d kin c tnh ton da trn nhiu lt quay. Chuyn ng ca cc cun khng i din cho bt k thit b vt l no v ch nhm mc ch minh ha. TM v  2025 Stake Engine.",
            },
        },
    },
    zh: {
        translation: {
            BET_MODE_META: {
                ANTE: { DIALOG: " 5 " },
                BONUS: {
                    DIALOG: " 4 ",
                },
            },
            GAME_RULES: {
                RULES: ` **Minedrop**  5x3  5x6 

 RTP  96.00%
Ante  RTP  96.00%
 RTP  96.00%
 5,000 `,
                WAYS_TO_WIN:
                    " 1  2  4  5  6  7 ",
                FEATURES: ` 4 

 5  3 `,
                GENERAL:
                    "TM   2025 Stake Engine",
            },
        },
    },
};
var UV = X("<!> <!>", 1),
    zV = X("<div><!></div>"),
    YV = X("<!> <!> <!>", 1);
function GV(s, e) {
    Ne(e, !0);
    const t = () => U(gl, "$loaded", a),
        n = () => U(cg, "$paperclipLoaderFinished", a),
        i = () => U(_l, "$startGame", a),
        r = () => U(hg, "$preloaded", a),
        [a, o] = tt();
    let h = gt(!1);
    lc.set($y.betModes),
        Lw.set($y.gameRules),
        Rw.set(VV),
        Fs(async () => {
            PL(), ei.set(De);
        }),
        _n(() => {
            t() && !$(h) && (FV.createBetService(), Re(h, !0));
        });
    const l = (_) => {
            _.target.localName === "canvas" &&
                (ye.skip || De.next({ type: "skip" }));
        },
        u = (_) => {
            _.code === "Space" &&
                !_.repeat &&
                (ye.skip || De.next({ type: "skip" }));
        };
    var c = YV();
    Ip("click", wh, l), Ip("keydown", wh, u);
    var d = me(c);
    TL(d, {
        get assets() {
            return AL;
        },
    });
    var f = N(d, 2);
    OV(f, { version: "1.0.0", gameName: "Minedrop" });
    var p = N(f, 2);
    {
        var m = (_) => {
                var v = UV(),
                    b = me(v);
                NV(b, {});
                var y = N(b, 2);
                _L(y, {}), D(_, v);
            },
            g = (_) => {
                var v = Oe(),
                    b = me(v);
                {
                    var y = (C) => {
                        var w = zV(),
                            A = I(w);
                        CL(A, {}),
                            Vn(
                                3,
                                w,
                                () => Wr,
                                () => ({ duration: 250 })
                            ),
                            D(C, w);
                    };
                    ne(
                        b,
                        (C) => {
                            r() && C(y);
                        },
                        !0
                    );
                }
                D(_, v);
            };
        ne(p, (_) => {
            t() && n() && i() ? _(m) : _(g, !1);
        });
    }
    D(s, c), Ve(), o();
}
TE(GV, { target: document.getElementById("app") });
export {
    Tu as $,
    Lx as A,
    qt as B,
    hn as C,
    rt as D,
    ee as E,
    Sd as F,
    Hr as G,
    Hs as H,
    Gr as I,
    cv as J,
    sl as K,
    uM as L,
    Ce as M,
    xM as N,
    cc as O,
    gn as P,
    Pt as Q,
    Fh as R,
    yM as S,
    Ir as T,
    im as U,
    Lt as V,
    VM as W,
    dv as X,
    Pf as Y,
    fv as Z,
    GT as _,
    ti as a,
    Vt as a0,
    zT as a1,
    ex as a2,
    Ox as a3,
    ae as a4,
    Ge as a5,
    jM as a6,
    jx as a7,
    l3 as a8,
    Hx as a9,
    Zx as aa,
    Jx as ab,
    tC as ac,
    nC as ad,
    ku as ae,
    ru as af,
    fm as ag,
    Zv as ah,
    aC as ai,
    Pv as aj,
    Ev as ak,
    ym as al,
    B5 as am,
    et as an,
    rl as ao,
    uT as ap,
    Uh as aq,
    hC as ar,
    r3 as b,
    $a as c,
    iu as d,
    Ot as e,
    mm as f,
    n3 as g,
    Rg as h,
    Mx as i,
    cx as j,
    cs as k,
    Cx as l,
    bm as m,
    qx as n,
    Kx as o,
    Qx as p,
    eC as q,
    ST as r,
    uc as s,
    we as t,
    cT as u,
    vl as v,
    it as w,
    B3 as x,
    Ms as y,
    Z1 as z,
};
